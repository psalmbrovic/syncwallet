/*!
  * Bootstrap v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!(function (t, e) { typeof exports === "object" && void 0 !== module ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : (t = typeof globalThis !== "undefined" ? globalThis : t || self).bootstrap = e(); }(this, (() => {
  const t = (t) => { let e = t.getAttribute("data-bs-target"); if (!e || e === "#") { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && n !== "#" ? n.trim() : null; } return e; }; const e = (e) => { const n = t(e); return n && document.querySelector(n) ? n : null; }; const n = (e) => { const n = t(e); return n ? document.querySelector(n) : null; }; const r = (t) => { t.dispatchEvent(new Event("transitionend")); }; const i = (t) => !(!t || typeof t !== "object") && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType); const o = (t) => (i(t) ? t.jquery ? t[0] : t : typeof t === "string" && t.length > 0 ? document.querySelector(t) : null); const s = (t, e, n) => { Object.keys(n).forEach((r) => { const o = n[r]; const s = e[r]; const a = s && i(s) ? "element" : (l = s) == null ? `${l}` : {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase(); let l; if (!new RegExp(o).test(a)) throw new TypeError(`${t.toUpperCase()}: Option "${r}" provided type "${a}" but expected type "${o}".`); }); }; const a = (t) => !(!i(t) || t.getClientRects().length === 0) && getComputedStyle(t).getPropertyValue("visibility") === "visible"; const l = (t) => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && t.getAttribute("disabled") !== "false"); const u = (t) => { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode === "function") { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null; } return t instanceof ShadowRoot ? t : t.parentNode ? u(t.parentNode) : null; }; const c = () => {}; const d = (t) => { t.offsetHeight; }; const h = () => { const { jQuery: t } = window; return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null; }; const p = []; const f = () => document.documentElement.dir === "rtl"; const m = (t) => { let e; e = () => { const e = h(); if (e) { const n = t.NAME; const r = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = r, t.jQueryInterface); } }, document.readyState === "loading" ? (p.length || document.addEventListener("DOMContentLoaded", () => { p.forEach((t) => t()); }), p.push(e)) : e(); }; const g = (t) => { typeof t === "function" && t(); }; const v = (t, e, n = !0) => { if (!n) return void g(t); const i = ((t) => { if (!t) return 0; let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t); const r = Number.parseFloat(e); const i = Number.parseFloat(n); return r || i ? (e = e.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(n))) : 0; })(e) + 5; let o = !1; const s = ({ target: n }) => { n === e && (o = !0, e.removeEventListener("transitionend", s), g(t)); }; e.addEventListener("transitionend", s), setTimeout(() => { o || r(e); }, i); }; const y = (t, e, n, r) => { let i = t.indexOf(e); if (i === -1) return t[!n && r ? t.length - 1 : 0]; const o = t.length; return i += n ? 1 : -1, r && (i = (i + o) % o), t[Math.max(0, Math.min(i, o - 1))]; }; const _ = /[^.]*(?=\..*)\.|.*/; const b = /\..*/; const w = /::\d+$/; const x = {}; let S = 1; const k = { mouseenter: "mouseover", mouseleave: "mouseout" }; const C = /^(mouseenter|mouseleave)/i; const E = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function T(t, e) { return e && `${e}::${S++}` || t.uidEvent || S++; } function P(t) { const e = T(t); return t.uidEvent = e, x[e] = x[e] || {}, x[e]; } function O(t, e, n = null) { const r = Object.keys(t); for (let i = 0, o = r.length; i < o; i++) { const o = t[r[i]]; if (o.originalHandler === e && o.delegationSelector === n) return o; } return null; } function A(t, e, n) { const r = typeof e === "string"; const i = r ? n : e; let o = I(t); return E.has(o) || (o = t), [r, i, o]; } function M(t, e, n, r, i) { if (typeof e !== "string" || !t) return; if (n || (n = r, r = null), C.test(e)) { const t = (t) => function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e); }; r ? r = t(r) : n = t(n); } const [o, s, a] = A(e, n, r); const l = P(t); const u = l[a] || (l[a] = {}); const c = O(u, s, o ? n : null); if (c) return void (c.oneOff = c.oneOff && i); const d = T(s, e.replace(_, "")); const h = o ? (function (t, e, n) { return function r(i) { const o = t.querySelectorAll(e); for (let { target: s } = i; s && s !== this; s = s.parentNode) for (let a = o.length; a--;) if (o[a] === s) return i.delegateTarget = s, r.oneOff && j.off(t, i.type, e, n), n.apply(s, [i]); return null; }; }(t, n, r)) : (function (t, e) { return function n(r) { return r.delegateTarget = t, n.oneOff && j.off(t, r.type, e), e.apply(t, [r]); }; }(t, n)); h.delegationSelector = o ? n : null, h.originalHandler = s, h.oneOff = i, h.uidEvent = d, u[d] = h, t.addEventListener(a, h, o); } function L(t, e, n, r, i) { const o = O(e[n], r, i); o && (t.removeEventListener(n, o, Boolean(i)), delete e[n][o.uidEvent]); } function I(t) { return t = t.replace(b, ""), k[t] || t; } const j = {
    on(t, e, n, r) { M(t, e, n, r, !1); }, one(t, e, n, r) { M(t, e, n, r, !0); }, off(t, e, n, r) { if (typeof e !== "string" || !t) return; const [i, o, s] = A(e, n, r); const a = s !== e; const l = P(t); const u = e.startsWith("."); if (void 0 !== o) { if (!l || !l[s]) return; return void L(t, l, s, o, i ? n : null); }u && Object.keys(l).forEach((n) => { !(function (t, e, n, r) { const i = e[n] || {}; Object.keys(i).forEach((o) => { if (o.includes(r)) { const r = i[o]; L(t, e, n, r.originalHandler, r.delegationSelector); } }); }(t, l, n, e.slice(1))); }); const c = l[s] || {}; Object.keys(c).forEach((n) => { const r = n.replace(w, ""); if (!a || e.includes(r)) { const e = c[n]; L(t, l, s, e.originalHandler, e.delegationSelector); } }); }, trigger(t, e, n) { if (typeof e !== "string" || !t) return null; const r = h(); const i = I(e); const o = e !== i; const s = E.has(i); let a; let l = !0; let u = !0; let c = !1; let d = null; return o && r && (a = r.Event(e, n), r(t).trigger(a), l = !a.isPropagationStopped(), u = !a.isImmediatePropagationStopped(), c = a.isDefaultPrevented()), s ? (d = document.createEvent("HTMLEvents"), d.initEvent(i, l, !0)) : d = new CustomEvent(e, { bubbles: l, cancelable: !0 }), void 0 !== n && Object.keys(n).forEach((t) => { Object.defineProperty(d, t, { get: () => n[t] }); }), c && d.preventDefault(), u && t.dispatchEvent(d), d.defaultPrevented && void 0 !== a && a.preventDefault(), d; },
  }; const D = new Map(); const N = { set(t, e, n) { D.has(t) || D.set(t, new Map()); const r = D.get(t); r.has(e) || r.size === 0 ? r.set(e, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(r.keys())[0]}.`); }, get: (t, e) => D.has(t) && D.get(t).get(e) || null, remove(t, e) { if (!D.has(t)) return; const n = D.get(t); n.delete(e), n.size === 0 && D.delete(t); } }; class R {
    constructor(t) { (t = o(t)) && (this._element = t, N.set(this._element, this.constructor.DATA_KEY, this)); }

    dispose() { N.remove(this._element, this.constructor.DATA_KEY), j.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => { this[t] = null; }); }

    _queueCallback(t, e, n = !0) { v(t, e, n); }

    static getInstance(t) { return N.get(o(t), this.DATA_KEY); }

    static getOrCreateInstance(t, e = {}) { return this.getInstance(t) || new this(t, typeof e === "object" ? e : null); }

    static get VERSION() { return "5.1.0"; }

    static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!'); }

    static get DATA_KEY() { return `bs.${this.NAME}`; }

    static get EVENT_KEY() { return `.${this.DATA_KEY}`; }
  } const F = (t, e = "hide") => { const r = `click.dismiss${t.EVENT_KEY}`; const i = t.NAME; j.on(document, r, `[data-bs-dismiss="${i}"]`, (function (r) { if (["A", "AREA"].includes(this.tagName) && r.preventDefault(), l(this)) return; const o = n(this) || this.closest(`.${i}`); t.getOrCreateInstance(o)[e](); })); }; class V extends R {
    static get NAME() { return "alert"; }

    close() { if (j.trigger(this._element, "close.bs.alert").defaultPrevented) return; this._element.classList.remove("show"); const t = this._element.classList.contains("fade"); this._queueCallback(() => this._destroyElement(), this._element, t); }

    _destroyElement() { this._element.remove(), j.trigger(this._element, "closed.bs.alert"), this.dispose(); }

    static jQueryInterface(t) { return this.each((function () { const e = V.getOrCreateInstance(this); if (typeof t === "string") { if (void 0 === e[t] || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); e[t](this); } })); }
  }F(V, "close"), m(V); class z extends R {
    static get NAME() { return "button"; }

    toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")); }

    static jQueryInterface(t) { return this.each((function () { const e = z.getOrCreateInstance(this); t === "toggle" && e[t](); })); }
  } function B(t) { return t === "true" || t !== "false" && (t === Number(t).toString() ? Number(t) : t === "" || t === "null" ? null : t); } function q(t) { return t.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`); }j.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (t) => { t.preventDefault(); const e = t.target.closest('[data-bs-toggle="button"]'); z.getOrCreateInstance(e).toggle(); }), m(z); const H = {
    setDataAttribute(t, e, n) { t.setAttribute(`data-bs-${q(e)}`, n); }, removeDataAttribute(t, e) { t.removeAttribute(`data-bs-${q(e)}`); }, getDataAttributes(t) { if (!t) return {}; const e = {}; return Object.keys(t.dataset).filter((t) => t.startsWith("bs")).forEach((n) => { let r = n.replace(/^bs/, ""); r = r.charAt(0).toLowerCase() + r.slice(1, r.length), e[r] = B(t.dataset[n]); }), e; }, getDataAttribute: (t, e) => B(t.getAttribute(`data-bs-${q(e)}`)), offset(t) { const e = t.getBoundingClientRect(); return { top: e.top + window.pageYOffset, left: e.left + window.pageXOffset }; }, position: (t) => ({ top: t.offsetTop, left: t.offsetLeft }),
  }; const $ = {
    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)), findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t), children: (t, e) => [].concat(...t.children).filter((t) => t.matches(e)), parents(t, e) { const n = []; let r = t.parentNode; for (;r && r.nodeType === Node.ELEMENT_NODE && r.nodeType !== 3;)r.matches(e) && n.push(r), r = r.parentNode; return n; }, prev(t, e) { let n = t.previousElementSibling; for (;n;) { if (n.matches(e)) return [n]; n = n.previousElementSibling; } return []; }, next(t, e) { let n = t.nextElementSibling; for (;n;) { if (n.matches(e)) return [n]; n = n.nextElementSibling; } return []; }, focusableChildren(t) { const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t) => `${t}:not([tabindex^="-"])`).join(", "); return this.find(e, t).filter((t) => !l(t) && a(t)); },
  }; const U = {
    interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0,
  }; const W = {
    interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean",
  }; const G = "next"; const Y = "prev"; const Z = "left"; const K = "right"; const X = { ArrowLeft: K, ArrowRight: Z }; class Q extends R {
    constructor(t, e) { super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = $.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners(); }

    static get Default() { return U; }

    static get NAME() { return "carousel"; }

    next() { this._slide(G); }

    nextWhenVisible() { !document.hidden && a(this._element) && this.next(); }

    prev() { this._slide(Y); }

    pause(t) { t || (this._isPaused = !0), $.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (r(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null; }

    cycle(t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)); }

    to(t) { this._activeElement = $.findOne(".active.carousel-item", this._element); const e = this._getItemIndex(this._activeElement); if (t > this._items.length - 1 || t < 0) return; if (this._isSliding) return void j.one(this._element, "slid.bs.carousel", () => this.to(t)); if (e === t) return this.pause(), void this.cycle(); const n = t > e ? G : Y; this._slide(n, this._items[t]); }

    _getConfig(t) { return t = { ...U, ...H.getDataAttributes(this._element), ...typeof t === "object" ? t : {} }, s("carousel", t, W), t; }

    _handleSwipe() { const t = Math.abs(this.touchDeltaX); if (t <= 40) return; const e = t / this.touchDeltaX; this.touchDeltaX = 0, e && this._slide(e > 0 ? K : Z); }

    _addEventListeners() { this._config.keyboard && j.on(this._element, "keydown.bs.carousel", (t) => this._keydown(t)), this._config.pause === "hover" && (j.on(this._element, "mouseenter.bs.carousel", (t) => this.pause(t)), j.on(this._element, "mouseleave.bs.carousel", (t) => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners(); }

    _addTouchEventListeners() { const t = (t) => { !this._pointerEvent || t.pointerType !== "pen" && t.pointerType !== "touch" ? this._pointerEvent || (this.touchStartX = t.touches[0].clientX) : this.touchStartX = t.clientX; }; const e = (t) => { this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX; }; const n = (t) => { !this._pointerEvent || t.pointerType !== "pen" && t.pointerType !== "touch" || (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((t) => this.cycle(t), 500 + this._config.interval)); }; $.find(".carousel-item img", this._element).forEach((t) => { j.on(t, "dragstart.bs.carousel", (t) => t.preventDefault()); }), this._pointerEvent ? (j.on(this._element, "pointerdown.bs.carousel", (e) => t(e)), j.on(this._element, "pointerup.bs.carousel", (t) => n(t)), this._element.classList.add("pointer-event")) : (j.on(this._element, "touchstart.bs.carousel", (e) => t(e)), j.on(this._element, "touchmove.bs.carousel", (t) => e(t)), j.on(this._element, "touchend.bs.carousel", (t) => n(t))); }

    _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const e = X[t.key]; e && (t.preventDefault(), this._slide(e)); }

    _getItemIndex(t) { return this._items = t && t.parentNode ? $.find(".carousel-item", t.parentNode) : [], this._items.indexOf(t); }

    _getItemByOrder(t, e) { const n = t === G; return y(this._items, e, n, this._config.wrap); }

    _triggerSlideEvent(t, e) {
      const n = this._getItemIndex(t); const r = this._getItemIndex($.findOne(".active.carousel-item", this._element)); return j.trigger(this._element, "slide.bs.carousel", {
        relatedTarget: t, direction: e, from: r, to: n,
      });
    }

    _setActiveIndicatorElement(t) { if (this._indicatorsElement) { const e = $.findOne(".active", this._indicatorsElement); e.classList.remove("active"), e.removeAttribute("aria-current"); const n = $.find("[data-bs-target]", this._indicatorsElement); for (let e = 0; e < n.length; e++) if (Number.parseInt(n[e].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t)) { n[e].classList.add("active"), n[e].setAttribute("aria-current", "true"); break; } } }

    _updateInterval() { const t = this._activeElement || $.findOne(".active.carousel-item", this._element); if (!t) return; const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10); e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval; }

    _slide(t, e) {
      const n = this._directionToOrder(t); const r = $.findOne(".active.carousel-item", this._element); const i = this._getItemIndex(r); const o = e || this._getItemByOrder(n, r); const s = this._getItemIndex(o); const a = Boolean(this._interval); const l = n === G; const u = l ? "carousel-item-start" : "carousel-item-end"; const c = l ? "carousel-item-next" : "carousel-item-prev"; const h = this._orderToDirection(n); if (o && o.classList.contains("active")) return void (this._isSliding = !1); if (this._isSliding) return; if (this._triggerSlideEvent(o, h).defaultPrevented) return; if (!r || !o) return; this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o; const p = () => {
        j.trigger(this._element, "slid.bs.carousel", {
          relatedTarget: o, direction: h, from: i, to: s,
        });
      }; if (this._element.classList.contains("slide")) { o.classList.add(c), d(o), r.classList.add(u), o.classList.add(u); const t = () => { o.classList.remove(u, c), o.classList.add("active"), r.classList.remove("active", c, u), this._isSliding = !1, setTimeout(p, 0); }; this._queueCallback(t, r, !0); } else r.classList.remove("active"), o.classList.add("active"), this._isSliding = !1, p(); a && this.cycle();
    }

    _directionToOrder(t) { return [K, Z].includes(t) ? f() ? t === Z ? Y : G : t === Z ? G : Y : t; }

    _orderToDirection(t) { return [G, Y].includes(t) ? f() ? t === Y ? Z : K : t === Y ? K : Z : t; }

    static carouselInterface(t, e) { const n = Q.getOrCreateInstance(t, e); let { _config: r } = n; typeof e === "object" && (r = { ...r, ...e }); const i = typeof e === "string" ? e : r.slide; if (typeof e === "number")n.to(e); else if (typeof i === "string") { if (void 0 === n[i]) throw new TypeError(`No method named "${i}"`); n[i](); } else r.interval && r.ride && (n.pause(), n.cycle()); }

    static jQueryInterface(t) { return this.each((function () { Q.carouselInterface(this, t); })); }

    static dataApiClickHandler(t) { const e = n(this); if (!e || !e.classList.contains("carousel")) return; const r = { ...H.getDataAttributes(e), ...H.getDataAttributes(this) }; const i = this.getAttribute("data-bs-slide-to"); i && (r.interval = !1), Q.carouselInterface(e, r), i && Q.getInstance(e).to(i), t.preventDefault(); }
  }j.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Q.dataApiClickHandler), j.on(window, "load.bs.carousel.data-api", () => { const t = $.find('[data-bs-ride="carousel"]'); for (let e = 0, n = t.length; e < n; e++)Q.carouselInterface(t[e], Q.getInstance(t[e])); }), m(Q); const J = { toggle: !0, parent: null }; const tt = { toggle: "boolean", parent: "(null|element)" }; class et extends R {
    constructor(t, n) { super(t), this._isTransitioning = !1, this._config = this._getConfig(n), this._triggerArray = []; const r = $.find('[data-bs-toggle="collapse"]'); for (let t = 0, n = r.length; t < n; t++) { const n = r[t]; const i = e(n); const o = $.find(i).filter((t) => t === this._element); i !== null && o.length && (this._selector = i, this._triggerArray.push(n)); } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle(); }

    static get Default() { return J; }

    static get NAME() { return "collapse"; }

    toggle() { this._isShown() ? this.hide() : this.show(); }

    show() { if (this._isTransitioning || this._isShown()) return; let t; let e = []; if (this._config.parent) { const t = $.find(".collapse .collapse", this._config.parent); e = $.find(".show, .collapsing", this._config.parent).filter((e) => !t.includes(e)); } const n = $.findOne(this._selector); if (e.length) { const r = e.find((t) => n !== t); if (t = r ? et.getInstance(r) : null, t && t._isTransitioning) return; } if (j.trigger(this._element, "show.bs.collapse").defaultPrevented) return; e.forEach((e) => { n !== e && et.getOrCreateInstance(e, { toggle: !1 }).hide(), t || N.set(e, "bs.collapse", null); }); const r = this._getDimension(); this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = `scroll${r[0].toUpperCase() + r.slice(1)}`; this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), this._element.style[r] = "", j.trigger(this._element, "shown.bs.collapse"); }, this._element, !0), this._element.style[r] = `${this._element[i]}px`; }

    hide() { if (this._isTransitioning || !this._isShown()) return; if (j.trigger(this._element, "hide.bs.collapse").defaultPrevented) return; const t = this._getDimension(); this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show"); const e = this._triggerArray.length; for (let t = 0; t < e; t++) { const e = this._triggerArray[t]; const r = n(e); r && !this._isShown(r) && this._addAriaAndCollapsedClass([e], !1); } this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(() => { this._isTransitioning = !1, this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), j.trigger(this._element, "hidden.bs.collapse"); }, this._element, !0); }

    _isShown(t = this._element) { return t.classList.contains("show"); }

    _getConfig(t) { return (t = { ...J, ...H.getDataAttributes(this._element), ...t }).toggle = Boolean(t.toggle), t.parent = o(t.parent), s("collapse", t, tt), t; }

    _getDimension() { return this._element.classList.contains("collapse-horizontal") ? "width" : "height"; }

    _initializeChildren() { if (!this._config.parent) return; const t = $.find(".collapse .collapse", this._config.parent); $.find('[data-bs-toggle="collapse"]', this._config.parent).filter((e) => !t.includes(e)).forEach((t) => { const e = n(t); e && this._addAriaAndCollapsedClass([t], this._isShown(e)); }); }

    _addAriaAndCollapsedClass(t, e) { t.length && t.forEach((t) => { e ? t.classList.remove("collapsed") : t.classList.add("collapsed"), t.setAttribute("aria-expanded", e); }); }

    static jQueryInterface(t) { return this.each((function () { const e = {}; typeof t === "string" && /show|hide/.test(t) && (e.toggle = !1); const n = et.getOrCreateInstance(this, e); if (typeof t === "string") { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t](); } })); }
  }j.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function (t) { (t.target.tagName === "A" || t.delegateTarget && t.delegateTarget.tagName === "A") && t.preventDefault(); const n = e(this); $.find(n).forEach((t) => { et.getOrCreateInstance(t, { toggle: !1 }).toggle(); }); })), m(et); const nt = "top"; const rt = "bottom"; const it = "right"; const ot = "left"; const st = [nt, rt, it, ot]; const at = st.reduce(((t, e) => t.concat([`${e}-start`, `${e}-end`])), []); const lt = [].concat(st, ["auto"]).reduce(((t, e) => t.concat([e, `${e}-start`, `${e}-end`])), []); const ut = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function ct(t) { return t ? (t.nodeName || "").toLowerCase() : null; } function dt(t) { if (t == null) return window; if (t.toString() !== "[object Window]") { const e = t.ownerDocument; return e && e.defaultView || window; } return t; } function ht(t) { return t instanceof dt(t).Element || t instanceof Element; } function pt(t) { return t instanceof dt(t).HTMLElement || t instanceof HTMLElement; } function ft(t) { return typeof ShadowRoot !== "undefined" && (t instanceof dt(t).ShadowRoot || t instanceof ShadowRoot); } const mt = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn(t) { const e = t.state; Object.keys(e.elements).forEach(((t) => { const n = e.styles[t] || {}; const r = e.attributes[t] || {}; const i = e.elements[t]; pt(i) && ct(i) && (Object.assign(i.style, n), Object.keys(r).forEach(((t) => { const e = r[t]; !1 === e ? i.removeAttribute(t) : i.setAttribute(t, !0 === e ? "" : e); }))); })); },
    effect(t) {
      const e = t.state; const n = {
        popper: {
          position: e.options.strategy, left: "0", top: "0", margin: "0",
        },
        arrow: { position: "absolute" },
        reference: {},
      }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach(((t) => { const r = e.elements[t]; const i = e.attributes[t] || {}; const o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce(((t, e) => (t[e] = "", t)), {}); pt(r) && ct(r) && (Object.assign(r.style, o), Object.keys(i).forEach(((t) => { r.removeAttribute(t); }))); })); };
    },
    requires: ["computeStyles"],
  }; function gt(t) { return t.split("-")[0]; } const vt = Math.round; function yt(t, e) {
    void 0 === e && (e = !1); const n = t.getBoundingClientRect(); let r = 1; let i = 1; return pt(t) && e && (r = n.width / t.offsetWidth || 1, i = n.height / t.offsetHeight || 1), {
      width: vt(n.width / r), height: vt(n.height / i), top: vt(n.top / i), right: vt(n.right / r), bottom: vt(n.bottom / i), left: vt(n.left / r), x: vt(n.left / r), y: vt(n.top / i),
    };
  } function _t(t) {
    const e = yt(t); let n = t.offsetWidth; let r = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
      x: t.offsetLeft, y: t.offsetTop, width: n, height: r,
    };
  } function bt(t, e) { const n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && ft(n)) { let r = e; do { if (r && t.isSameNode(r)) return !0; r = r.parentNode || r.host; } while (r); } return !1; } function wt(t) { return dt(t).getComputedStyle(t); } function xt(t) { return ["table", "td", "th"].indexOf(ct(t)) >= 0; } function St(t) { return ((ht(t) ? t.ownerDocument : t.document) || window.document).documentElement; } function kt(t) { return ct(t) === "html" ? t : t.assignedSlot || t.parentNode || (ft(t) ? t.host : null) || St(t); } function Ct(t) { return pt(t) && wt(t).position !== "fixed" ? t.offsetParent : null; } function Et(t) { for (var e = dt(t), n = Ct(t); n && xt(n) && wt(n).position === "static";)n = Ct(n); return n && (ct(n) === "html" || ct(n) === "body" && wt(n).position === "static") ? e : n || (function (t) { const e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1; if (navigator.userAgent.indexOf("Trident") !== -1 && pt(t) && wt(t).position === "fixed") return null; for (let n = kt(t); pt(n) && ["html", "body"].indexOf(ct(n)) < 0;) { const r = wt(n); if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || e && r.willChange === "filter" || e && r.filter && r.filter !== "none") return n; n = n.parentNode; } return null; }(t)) || e; } function Tt(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"; } const Pt = Math.max; const Ot = Math.min; const At = Math.round; function Mt(t, e, n) { return Pt(t, Ot(e, n)); } function Lt(t) {
    return {
      top: 0, right: 0, bottom: 0, left: 0, ...t,
    };
  } function It(t, e) { return e.reduce(((e, n) => (e[n] = t, e)), {}); } const jt = {
    name: "arrow", enabled: !0, phase: "main", fn(t) { let e; const n = t.state; const r = t.name; const i = t.options; const o = n.elements.arrow; const s = n.modifiersData.popperOffsets; const a = gt(n.placement); const l = Tt(a); const u = [ot, it].indexOf(a) >= 0 ? "height" : "width"; if (o && s) { const c = (function (t, e) { return Lt(typeof (t = typeof t === "function" ? t({ ...e.rects, placement: e.placement }) : t) !== "number" ? t : It(t, st)); }(i.padding, n)); const d = _t(o); const h = l === "y" ? nt : ot; const p = l === "y" ? rt : it; const f = n.rects.reference[u] + n.rects.reference[l] - s[l] - n.rects.popper[u]; const m = s[l] - n.rects.reference[l]; const g = Et(o); const v = g ? l === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0; const y = f / 2 - m / 2; const _ = c[h]; const b = v - d[u] - c[p]; const w = v / 2 - d[u] / 2 + y; const x = Mt(_, w, b); const S = l; n.modifiersData[r] = ((e = {})[S] = x, e.centerOffset = x - w, e); } }, effect(t) { const e = t.state; const n = t.options.element; let r = void 0 === n ? "[data-popper-arrow]" : n; r != null && (typeof r !== "string" || (r = e.elements.popper.querySelector(r))) && bt(e.elements.popper, r) && (e.elements.arrow = r); }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"],
  }; const Dt = {
    top: "auto", right: "auto", bottom: "auto", left: "auto",
  }; function Nt(t) { let e; const n = t.popper; const r = t.popperRect; const i = t.placement; const o = t.offsets; const s = t.position; const a = t.gpuAcceleration; const l = t.adaptive; const u = t.roundOffsets; const c = !0 === u ? (function (t) { const e = t.x; const n = t.y; const r = window.devicePixelRatio || 1; return { x: At(At(e * r) / r) || 0, y: At(At(n * r) / r) || 0 }; }(o)) : typeof u === "function" ? u(o) : o; const d = c.x; let h = void 0 === d ? 0 : d; const p = c.y; let f = void 0 === p ? 0 : p; const m = o.hasOwnProperty("x"); const g = o.hasOwnProperty("y"); let v = ot; let y = nt; const _ = window; if (l) { let b = Et(n); let w = "clientHeight"; let x = "clientWidth"; b === dt(n) && wt(b = St(n)).position !== "static" && (w = "scrollHeight", x = "scrollWidth"), b = b, i === nt && (y = rt, f -= b[w] - r.height, f *= a ? 1 : -1), i === ot && (v = it, h -= b[x] - r.width, h *= a ? 1 : -1); } let S; const k = { position: s, ...l && Dt }; return a ? ({ ...k, ...((S = {})[y] = g ? "0" : "", S[v] = m ? "0" : "", S.transform = (_.devicePixelRatio || 1) < 2 ? `translate(${h}px, ${f}px)` : `translate3d(${h}px, ${f}px, 0)`, S) }) : ({ ...k, ...((e = {})[y] = g ? `${f}px` : "", e[v] = m ? `${h}px` : "", e.transform = "", e) }); } const Rt = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn(t) {
      const e = t.state; const n = t.options; const r = n.gpuAcceleration; const i = void 0 === r || r; const o = n.adaptive; const s = void 0 === o || o; const a = n.roundOffsets; const l = void 0 === a || a; const u = {
        placement: gt(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i,
      }; e.modifiersData.popperOffsets != null && (e.styles.popper = {
        ...e.styles.popper,
        ...Nt({
          ...u, offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: s, roundOffsets: l,
        }),
      }), e.modifiersData.arrow != null && (e.styles.arrow = {
        ...e.styles.arrow,
        ...Nt({
          ...u, offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l,
        }),
      }), e.attributes.popper = { ...e.attributes.popper, "data-popper-placement": e.placement };
    },
    data: {},
  }; const Ft = { passive: !0 }; const Vt = {
    name: "eventListeners", enabled: !0, phase: "write", fn() {}, effect(t) { const e = t.state; const n = t.instance; const r = t.options; const i = r.scroll; const o = void 0 === i || i; const s = r.resize; const a = void 0 === s || s; const l = dt(e.elements.popper); const u = [].concat(e.scrollParents.reference, e.scrollParents.popper); return o && u.forEach(((t) => { t.addEventListener("scroll", n.update, Ft); })), a && l.addEventListener("resize", n.update, Ft), function () { o && u.forEach(((t) => { t.removeEventListener("scroll", n.update, Ft); })), a && l.removeEventListener("resize", n.update, Ft); }; }, data: {},
  }; const zt = {
    left: "right", right: "left", bottom: "top", top: "bottom",
  }; function Bt(t) { return t.replace(/left|right|bottom|top/g, ((t) => zt[t])); } const qt = { start: "end", end: "start" }; function Ht(t) { return t.replace(/start|end/g, ((t) => qt[t])); } function $t(t) { const e = dt(t); return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset }; } function Ut(t) { return yt(St(t)).left + $t(t).scrollLeft; } function Wt(t) { const e = wt(t); const n = e.overflow; const r = e.overflowX; const i = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + r); } function Gt(t, e) { let n; void 0 === e && (e = []); const r = (function t(e) { return ["html", "body", "#document"].indexOf(ct(e)) >= 0 ? e.ownerDocument.body : pt(e) && Wt(e) ? e : t(kt(e)); }(t)); const i = r === ((n = t.ownerDocument) == null ? void 0 : n.body); const o = dt(r); const s = i ? [o].concat(o.visualViewport || [], Wt(r) ? r : []) : r; const a = e.concat(s); return i ? a : a.concat(Gt(kt(s))); } function Yt(t) {
    return {
      ...t, left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height,
    };
  } function Zt(t, e) {
    return e === "viewport" ? Yt(function (t) {
      const e = dt(t); const n = St(t); const r = e.visualViewport; let i = n.clientWidth; let o = n.clientHeight; let s = 0; let a = 0; return r && (i = r.width, o = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (s = r.offsetLeft, a = r.offsetTop)), {
        width: i, height: o, x: s + Ut(t), y: a,
      };
    }(t)) : pt(e) ? (function (t) { const e = yt(t); return e.top += t.clientTop, e.left += t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e; }(e)) : Yt(function (t) {
      let e; const n = St(t); const r = $t(t); const i = (e = t.ownerDocument) == null ? void 0 : e.body; const o = Pt(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0); const s = Pt(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0); let a = -r.scrollLeft + Ut(t); const l = -r.scrollTop; return wt(i || n).direction === "rtl" && (a += Pt(n.clientWidth, i ? i.clientWidth : 0) - o), {
        width: o, height: s, x: a, y: l,
      };
    }(St(t)));
  } function Kt(t) { return t.split("-")[1]; } function Xt(t) { let e; const n = t.reference; const r = t.element; const i = t.placement; const o = i ? gt(i) : null; const s = i ? Kt(i) : null; const a = n.x + n.width / 2 - r.width / 2; const l = n.y + n.height / 2 - r.height / 2; switch (o) { case nt: e = { x: a, y: n.y - r.height }; break; case rt: e = { x: a, y: n.y + n.height }; break; case it: e = { x: n.x + n.width, y: l }; break; case ot: e = { x: n.x - r.width, y: l }; break; default: e = { x: n.x, y: n.y }; } const u = o ? Tt(o) : null; if (u != null) { const c = u === "y" ? "height" : "width"; switch (s) { case "start": e[u] = e[u] - (n[c] / 2 - r[c] / 2); break; case "end": e[u] = e[u] + (n[c] / 2 - r[c] / 2); } } return e; } function Qt(t, e) {
    void 0 === e && (e = {}); const n = e; const r = n.placement; const i = void 0 === r ? t.placement : r; const o = n.boundary; const s = void 0 === o ? "clippingParents" : o; const a = n.rootBoundary; const l = void 0 === a ? "viewport" : a; const u = n.elementContext; const c = void 0 === u ? "popper" : u; const d = n.altBoundary; const h = void 0 !== d && d; const p = n.padding; const f = void 0 === p ? 0 : p; const m = Lt(typeof f !== "number" ? f : It(f, st)); const g = c === "popper" ? "reference" : "popper"; const v = t.elements.reference; const y = t.rects.popper; const _ = t.elements[h ? g : c]; const b = (function (t, e, n) { const r = e === "clippingParents" ? (function (t) { const e = Gt(kt(t)); const n = ["absolute", "fixed"].indexOf(wt(t).position) >= 0 && pt(t) ? Et(t) : t; return ht(n) ? e.filter(((t) => ht(t) && bt(t, n) && ct(t) !== "body")) : []; }(t)) : [].concat(e); const i = [].concat(r, [n]); const o = i[0]; const s = i.reduce(((e, n) => { const r = Zt(t, n); return e.top = Pt(r.top, e.top), e.right = Ot(r.right, e.right), e.bottom = Ot(r.bottom, e.bottom), e.left = Pt(r.left, e.left), e; }), Zt(t, o)); return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s; }(ht(_) ? _ : _.contextElement || St(t.elements.popper), s, l)); const w = yt(v); const x = Xt({
      reference: w, element: y, strategy: "absolute", placement: i,
    }); const S = Yt({ ...y, ...x }); const k = c === "popper" ? S : w; const C = {
      top: b.top - k.top + m.top, bottom: k.bottom - b.bottom + m.bottom, left: b.left - k.left + m.left, right: k.right - b.right + m.right,
    }; const E = t.modifiersData.offset; if (c === "popper" && E) { const T = E[i]; Object.keys(C).forEach(((t) => { const e = [it, rt].indexOf(t) >= 0 ? 1 : -1; const n = [nt, rt].indexOf(t) >= 0 ? "y" : "x"; C[t] += T[n] * e; })); } return C;
  } const Jt = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn(t) {
      const e = t.state; const n = t.options; const r = t.name; if (!e.modifiersData[r]._skip) {
        for (var i = n.mainAxis, o = void 0 === i || i, s = n.altAxis, a = void 0 === s || s, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.flipVariations, f = void 0 === p || p, m = n.allowedAutoPlacements, g = e.options.placement, v = gt(g), y = l || (v !== g && f ? (function (t) { if (gt(t) === "auto") return []; const e = Bt(t); return [Ht(t), e, Ht(e)]; }(g)) : [Bt(g)]), _ = [g].concat(y).reduce(((t, n) => t.concat(gt(n) === "auto" ? (function (t, e) {
 void 0 === e && (e = {}); const n = e; const r = n.placement; const i = n.boundary; const o = n.rootBoundary; const s = n.padding; const a = n.flipVariations; const l = n.allowedAutoPlacements; const u = void 0 === l ? lt : l; const c = Kt(r); const d = c ? a ? at : at.filter(((t) => Kt(t) === c)) : st; let h = d.filter(((t) => u.indexOf(t) >= 0)); h.length === 0 && (h = d); const p = h.reduce(((e, n) => (e[n] = Qt(t, {
            placement: n, boundary: i, rootBoundary: o, padding: s, 
          })[gt(n)], e)), {}); return Object.keys(p).sort(((t, e) => p[t] - p[e])); 
}(e, {
            placement: n, boundary: c, rootBoundary: d, padding: u, flipVariations: f, allowedAutoPlacements: m,
          })) : n)), []), b = e.rects.reference, w = e.rects.popper, x = new Map(), S = !0, k = _[0], C = 0; C < _.length; C++) {
          const E = _[C]; const T = gt(E); const P = Kt(E) === "start"; const O = [nt, rt].indexOf(T) >= 0; const A = O ? "width" : "height"; const M = Qt(e, {
            placement: E, boundary: c, rootBoundary: d, altBoundary: h, padding: u,
          }); let L = O ? P ? it : ot : P ? rt : nt; b[A] > w[A] && (L = Bt(L)); const I = Bt(L); const j = []; if (o && j.push(M[T] <= 0), a && j.push(M[L] <= 0, M[I] <= 0), j.every(((t) => t))) { k = E, S = !1; break; }x.set(E, j);
        } if (S) for (let D = function (t) { const e = _.find(((e) => { const n = x.get(e); if (n) return n.slice(0, t).every(((t) => t)); })); if (e) return k = e, "break"; }, N = f ? 3 : 1; N > 0 && D(N) !== "break"; N--);e.placement !== k && (e.modifiersData[r]._skip = !0, e.placement = k, e.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: { _skip: !1 },
  }; function te(t, e, n) {
    return void 0 === n && (n = { x: 0, y: 0 }), {
      top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x,
    };
  } function ee(t) { return [nt, it, rt, ot].some(((e) => t[e] >= 0)); } const ne = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn(t) {
      const e = t.state; const n = t.name; const r = e.rects.reference; const i = e.rects.popper; const o = e.modifiersData.preventOverflow; const s = Qt(e, { elementContext: "reference" }); const a = Qt(e, { altBoundary: !0 }); const l = te(s, r); const u = te(a, i, o); const c = ee(l); const d = ee(u); e.modifiersData[n] = {
        referenceClippingOffsets: l, popperEscapeOffsets: u, isReferenceHidden: c, hasPopperEscaped: d,
      }, e.attributes.popper = { ...e.attributes.popper, "data-popper-reference-hidden": c, "data-popper-escaped": d };
    },
  }; const re = {
    name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn(t) { const e = t.state; const n = t.options; const r = t.name; const i = n.offset; const o = void 0 === i ? [0, 0] : i; const s = lt.reduce(((t, n) => (t[n] = (function (t, e, n) { let r = gt(t); let i = [ot, nt].indexOf(r) >= 0 ? -1 : 1; let o = "function" == typeof n ? n({...e,placement:t}) : n; let s = o[0]; let a = o[1]; return s = s || 0, a = (a || 0) * i, [ot, it].indexOf(r) >= 0 ? { x: a, y: s } : { x: s, y: a }; }(n, e.rects, o)), t)), {}); const a = s[e.placement]; const l = a.x; const u = a.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += u), e.modifiersData[r] = s; },
  }; const ie = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn(t) {
      const e = t.state; const n = t.name; e.modifiersData[n] = Xt({
        reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement,
      });
    },
    data: {},
  }; const oe = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn(t) {
      const e = t.state; const n = t.options; const r = t.name; const i = n.mainAxis; const o = void 0 === i || i; const s = n.altAxis; const a = void 0 !== s && s; const l = n.boundary; const u = n.rootBoundary; const c = n.altBoundary; const d = n.padding; const h = n.tether; const p = void 0 === h || h; const f = n.tetherOffset; const m = void 0 === f ? 0 : f; const g = Qt(e, {
        boundary: l, rootBoundary: u, padding: d, altBoundary: c,
      }); const v = gt(e.placement); const y = Kt(e.placement); const _ = !y; const b = Tt(v); const w = b === "x" ? "y" : "x"; const x = e.modifiersData.popperOffsets; const S = e.rects.reference; const k = e.rects.popper; const C = typeof m === "function" ? m({ ...e.rects, placement: e.placement }) : m; const E = { x: 0, y: 0 }; if (x) {
        if (o || a) {
          const T = b === "y" ? nt : ot; const P = b === "y" ? rt : it; const O = b === "y" ? "height" : "width"; const A = x[b]; const M = x[b] + g[T]; const L = x[b] - g[P]; const I = p ? -k[O] / 2 : 0; const j = y === "start" ? S[O] : k[O]; const D = y === "start" ? -k[O] : -S[O]; const N = e.elements.arrow; const R = p && N ? _t(N) : { width: 0, height: 0 }; const F = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
            top: 0, right: 0, bottom: 0, left: 0,
          }; const V = F[T]; const z = F[P]; const B = Mt(0, S[O], R[O]); const q = _ ? S[O] / 2 - I - B - V - C : j - B - V - C; const H = _ ? -S[O] / 2 + I + B + z + C : D + B + z + C; const $ = e.elements.arrow && Et(e.elements.arrow); const U = $ ? b === "y" ? $.clientTop || 0 : $.clientLeft || 0 : 0; const W = e.modifiersData.offset ? e.modifiersData.offset[e.placement][b] : 0; const G = x[b] + q - W - U; const Y = x[b] + H - W; if (o) { const Z = Mt(p ? Ot(M, G) : M, A, p ? Pt(L, Y) : L); x[b] = Z, E[b] = Z - A; } if (a) { const K = b === "x" ? nt : ot; const X = b === "x" ? rt : it; const Q = x[w]; const J = Q + g[K]; const tt = Q - g[X]; const et = Mt(p ? Ot(J, G) : J, Q, p ? Pt(tt, Y) : tt); x[w] = et, E[w] = et - Q; }
        }e.modifiersData[r] = E;
      }
    },
    requiresIfExists: ["offset"],
  }; function se(t, e, n) {
    void 0 === n && (n = !1); let r; let i; const o = pt(e); const s = pt(e) && (function (t) { const e = t.getBoundingClientRect(); const n = e.width / t.offsetWidth || 1; const r = e.height / t.offsetHeight || 1; return n !== 1 || r !== 1; }(e)); const a = St(e); const l = yt(t, s); let u = { scrollLeft: 0, scrollTop: 0 }; let c = { x: 0, y: 0 }; return (o || !o && !n) && ((ct(e) !== "body" || Wt(a)) && (u = (r = e) !== dt(r) && pt(r) ? { scrollLeft: (i = r).scrollLeft, scrollTop: i.scrollTop } : $t(r)), pt(e) ? ((c = yt(e, !0)).x += e.clientLeft, c.y += e.clientTop) : a && (c.x = Ut(a))), {
      x: l.left + u.scrollLeft - c.x, y: l.top + u.scrollTop - c.y, width: l.width, height: l.height,
    };
  } const ae = { placement: "bottom", modifiers: [], strategy: "absolute" }; function le() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some(((t) => !(t && typeof t.getBoundingClientRect === "function"))); } function ue(t) {
    void 0 === t && (t = {}); const e = t; const n = e.defaultModifiers; const r = void 0 === n ? [] : n; const i = e.defaultOptions; const o = void 0 === i ? ae : i; return function (t, e, n) {
      void 0 === n && (n = o); let i; let s; let a = {
        placement: "bottom", orderedModifiers: [], options: { ...ae, ...o }, modifiersData: {}, elements: { reference: t, popper: e }, attributes: {}, styles: {},
      }; let l = []; let u = !1; var c = {
        state: a,
        setOptions(n) {
          d(), a.options = { ...o, ...a.options, ...n }, a.scrollParents = { reference: ht(t) ? Gt(t) : t.contextElement ? Gt(t.contextElement) : [], popper: Gt(e) }; let i; let s; const u = (function (t) {
            const e = (function (t) {
              const e = new Map(); const n = new Set(); const 
            r = []; return t.forEach(((t) => { e.set(t.name, t); })), t.forEach(((t) => { n.has(t.name) || (function t(i) { n.add(i.name), [].concat(i.requires || [], i.requiresIfExists || []).forEach(((r) => { if (!n.has(r)) { const i = e.get(r); i && t(i); } })), r.push(i); }(t)); })), r;
            }(t)); return ut.reduce(((t, n) => t.concat(e.filter(((t) => t.phase === n)))), []);
          }((i = [].concat(r, a.options.modifiers), s = i.reduce(((t, e) => {
            const n = t[e.name]; return t[e.name] = n ? ({
              ...n, ...e, options: { ...n.options, ...e.options }, data: { ...n.data, ...e.data }, 
            }) : e, t;
          }), {}), Object.keys(s).map(((t) => s[t]))))); return a.orderedModifiers = u.filter(((t) => t.enabled)), a.orderedModifiers.forEach(((t) => {
            const e = t.name; const n = t.options; const r = void 0 === n ? {} : n; const i = t.effect; if (typeof i === "function") {
              const o = i({
                state: a, name: e, instance: c, options: r,
              }); l.push(o || (() => {}));
            }
          })), c.update();
        },
        forceUpdate() {
          if (!u) {
            const t = a.elements; const e = t.reference; const n = t.popper; if (le(e, n)) {
              a.rects = { reference: se(e, Et(n), a.options.strategy === "fixed"), popper: _t(n) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(((t) => a.modifiersData[t.name] = { ...t.data })); for (let r = 0; r < a.orderedModifiers.length; r++) {
                if (!0 !== a.reset) {
                  const i = a.orderedModifiers[r]; const o = i.fn; const s = i.options; const l = void 0 === s ? {} : s; const d = i.name; typeof o === "function" && (a = o({
                    state: a, options: l, name: d, instance: c,
                  }) || a);
                } else a.reset = !1, r = -1;
              }
            }
          }
        },
        update: (i = function () { return new Promise(((t) => { c.forceUpdate(), t(a); })); }, function () { return s || (s = new Promise(((t) => { Promise.resolve().then((() => { s = void 0, t(i()); })); }))), s; }),
        destroy() { d(), u = !0; },
      }; if (!le(t, e)) return c; function d() { l.forEach(((t) => t())), l = []; } return c.setOptions(n).then(((t) => { !u && n.onFirstUpdate && n.onFirstUpdate(t); })), c;
    };
  } const ce = ue(); const de = ue({ defaultModifiers: [Vt, ie, Rt, mt] }); const he = ue({ defaultModifiers: [Vt, ie, Rt, mt, re, Jt, oe, jt, ne] }); const pe = Object.freeze({
    __proto__: null, popperGenerator: ue, detectOverflow: Qt, createPopperBase: ce, createPopper: he, createPopperLite: de, top: nt, bottom: rt, right: it, left: ot, auto: "auto", basePlacements: st, start: "start", end: "end", clippingParents: "clippingParents", viewport: "viewport", popper: "popper", reference: "reference", variationPlacements: at, placements: lt, beforeRead: "beforeRead", read: "read", afterRead: "afterRead", beforeMain: "beforeMain", main: "main", afterMain: "afterMain", beforeWrite: "beforeWrite", write: "write", afterWrite: "afterWrite", modifierPhases: ut, applyStyles: mt, arrow: jt, computeStyles: Rt, eventListeners: Vt, flip: Jt, hide: ne, offset: re, popperOffsets: ie, preventOverflow: oe,
  }); const fe = new RegExp("ArrowUp|ArrowDown|Escape"); const me = f() ? "top-end" : "top-start"; const ge = f() ? "top-start" : "top-end"; const ve = f() ? "bottom-end" : "bottom-start"; const ye = f() ? "bottom-start" : "bottom-end"; const _e = f() ? "left-start" : "right-start"; const be = f() ? "right-start" : "left-start"; const we = {
    offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0,
  }; const xe = {
    offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)",
  }; class Se extends R {
    constructor(t, e) { super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(); }

    static get Default() { return we; }

    static get DefaultType() { return xe; }

    static get NAME() { return "dropdown"; }

    toggle() { return this._isShown() ? this.hide() : this.show(); }

    show() { if (l(this._element) || this._isShown(this._menu)) return; const t = { relatedTarget: this._element }; if (j.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) return; const e = Se.getParentFromElement(this._element); this._inNavbar ? H.setDataAttribute(this._menu, "popper", "none") : this._createPopper(e), "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && [].concat(...document.body.children).forEach((t) => j.on(t, "mouseover", c)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add("show"), this._element.classList.add("show"), j.trigger(this._element, "shown.bs.dropdown", t); }

    hide() { if (l(this._element) || !this._isShown(this._menu)) return; const t = { relatedTarget: this._element }; this._completeHide(t); }

    dispose() { this._popper && this._popper.destroy(), super.dispose(); }

    update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update(); }

    _completeHide(t) { j.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t) => j.off(t, "mouseover", c)), this._popper && this._popper.destroy(), this._menu.classList.remove("show"), this._element.classList.remove("show"), this._element.setAttribute("aria-expanded", "false"), H.removeDataAttribute(this._menu, "popper"), j.trigger(this._element, "hidden.bs.dropdown", t)); }

    _getConfig(t) { if (t = { ...this.constructor.Default, ...H.getDataAttributes(this._element), ...t }, s("dropdown", t, this.constructor.DefaultType), typeof t.reference === "object" && !i(t.reference) && typeof t.reference.getBoundingClientRect !== "function") throw new TypeError(`${"dropdown".toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t; }

    _createPopper(t) { if (void 0 === pe) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; this._config.reference === "parent" ? e = t : i(this._config.reference) ? e = o(this._config.reference) : typeof this._config.reference === "object" && (e = this._config.reference); const n = this._getPopperConfig(); const r = n.modifiers.find((t) => t.name === "applyStyles" && !1 === t.enabled); this._popper = he(e, this._menu, n), r && H.setDataAttribute(this._menu, "popper", "static"); }

    _isShown(t = this._element) { return t.classList.contains("show"); }

    _getMenuElement() { return $.next(this._element, ".dropdown-menu")[0]; }

    _getPlacement() { const t = this._element.parentNode; if (t.classList.contains("dropend")) return _e; if (t.classList.contains("dropstart")) return be; const e = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"; return t.classList.contains("dropup") ? e ? ge : me : e ? ye : ve; }

    _detectNavbar() { return this._element.closest(".navbar") !== null; }

    _getOffset() { const { offset: t } = this._config; return typeof t === "string" ? t.split(",").map((t) => Number.parseInt(t, 10)) : typeof t === "function" ? (e) => t(e, this._element) : t; }

    _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return this._config.display === "static" && (t.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...t, ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(t) : this._config.popperConfig }; }

    _selectMenuItem({ key: t, target: e }) { const n = $.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(a); n.length && y(n, e, t === "ArrowDown", !n.includes(e)).focus(); }

    static jQueryInterface(t) { return this.each((function () { const e = Se.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }

    static clearMenus(t) { if (t && (t.button === 2 || t.type === "keyup" && t.key !== "Tab")) return; const e = $.find('[data-bs-toggle="dropdown"]'); for (let n = 0, r = e.length; n < r; n++) { const r = Se.getInstance(e[n]); if (!r || !1 === r._config.autoClose) continue; if (!r._isShown()) continue; const i = { relatedTarget: r._element }; if (t) { const e = t.composedPath(); const n = e.includes(r._menu); if (e.includes(r._element) || r._config.autoClose === "inside" && !n || r._config.autoClose === "outside" && n) continue; if (r._menu.contains(t.target) && (t.type === "keyup" && t.key === "Tab" || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; t.type === "click" && (i.clickEvent = t); }r._completeHide(i); } }

    static getParentFromElement(t) { return n(t) || t.parentNode; }

    static dataApiKeydownHandler(t) { if (/input|textarea/i.test(t.target.tagName) ? t.key === "Space" || t.key !== "Escape" && (t.key !== "ArrowDown" && t.key !== "ArrowUp" || t.target.closest(".dropdown-menu")) : !fe.test(t.key)) return; const e = this.classList.contains("show"); if (!e && t.key === "Escape") return; if (t.preventDefault(), t.stopPropagation(), l(this)) return; const n = this.matches('[data-bs-toggle="dropdown"]') ? this : $.prev(this, '[data-bs-toggle="dropdown"]')[0]; const r = Se.getOrCreateInstance(n); if (t.key !== "Escape") return t.key === "ArrowUp" || t.key === "ArrowDown" ? (e || r.show(), void r._selectMenuItem(t)) : void (e && t.key !== "Space" || Se.clearMenus()); r.hide(); }
  }j.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', Se.dataApiKeydownHandler), j.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", Se.dataApiKeydownHandler), j.on(document, "click.bs.dropdown.data-api", Se.clearMenus), j.on(document, "keyup.bs.dropdown.data-api", Se.clearMenus), j.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function (t) { t.preventDefault(), Se.getOrCreateInstance(this).toggle(); })), m(Se); class ke {
    constructor() { this._element = document.body; }

    getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t); }

    hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", (e) => e + t), this._setElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", (e) => e + t), this._setElementAttributes(".sticky-top", "marginRight", (e) => e - t); }

    _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"; }

    _setElementAttributes(t, e, n) { const r = this.getWidth(); this._applyManipulationCallback(t, (t) => { if (t !== this._element && window.innerWidth > t.clientWidth + r) return; this._saveInitialAttribute(t, e); const i = window.getComputedStyle(t)[e]; t.style[e] = `${n(Number.parseFloat(i))}px`; }); }

    reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"), this._resetElementAttributes(".sticky-top", "marginRight"); }

    _saveInitialAttribute(t, e) { const n = t.style[e]; n && H.setDataAttribute(t, e, n); }

    _resetElementAttributes(t, e) { this._applyManipulationCallback(t, (t) => { const n = H.getDataAttribute(t, e); void 0 === n ? t.style.removeProperty(e) : (H.removeDataAttribute(t, e), t.style[e] = n); }); }

    _applyManipulationCallback(t, e) { i(t) ? e(t) : $.find(t, this._element).forEach(e); }

    isOverflowing() { return this.getWidth() > 0; }
  } const Ce = {
    className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null,
  }; const Ee = {
    className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)",
  }; class Te {
    constructor(t) { this._config = this._getConfig(t), this._isAppended = !1, this._element = null; }

    show(t) { this._config.isVisible ? (this._append(), this._config.isAnimated && d(this._getElement()), this._getElement().classList.add("show"), this._emulateAnimation(() => { g(t); })) : g(t); }

    hide(t) { this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => { this.dispose(), g(t); })) : g(t); }

    _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t; } return this._element; }

    _getConfig(t) { return (t = { ...Ce, ...typeof t === "object" ? t : {} }).rootElement = o(t.rootElement), s("backdrop", t, Ee), t; }

    _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), j.on(this._getElement(), "mousedown.bs.backdrop", () => { g(this._config.clickCallback); }), this._isAppended = !0); }

    dispose() { this._isAppended && (j.off(this._element, "mousedown.bs.backdrop"), this._element.remove(), this._isAppended = !1); }

    _emulateAnimation(t) { v(t, this._getElement(), this._config.isAnimated); }
  } const Pe = { trapElement: null, autofocus: !0 }; const Oe = { trapElement: "element", autofocus: "boolean" }; class Ae {
    constructor(t) { this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null; }

    activate() { const { trapElement: t, autofocus: e } = this._config; this._isActive || (e && t.focus(), j.off(document, ".bs.focustrap"), j.on(document, "focusin.bs.focustrap", (t) => this._handleFocusin(t)), j.on(document, "keydown.tab.bs.focustrap", (t) => this._handleKeydown(t)), this._isActive = !0); }

    deactivate() { this._isActive && (this._isActive = !1, j.off(document, ".bs.focustrap")); }

    _handleFocusin(t) { const { target: e } = t; const { trapElement: n } = this._config; if (e === document || e === n || n.contains(e)) return; const r = $.focusableChildren(n); r.length === 0 ? n.focus() : this._lastTabNavDirection === "backward" ? r[r.length - 1].focus() : r[0].focus(); }

    _handleKeydown(t) { t.key === "Tab" && (this._lastTabNavDirection = t.shiftKey ? "backward" : "forward"); }

    _getConfig(t) { return t = { ...Pe, ...typeof t === "object" ? t : {} }, s("focustrap", t, Oe), t; }
  } const Me = { backdrop: !0, keyboard: !0, focus: !0 }; const Le = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }; class Ie extends R {
    constructor(t, e) { super(t), this._config = this._getConfig(e), this._dialog = $.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ke(); }

    static get Default() { return Me; }

    static get NAME() { return "modal"; }

    toggle(t) { return this._isShown ? this.hide() : this.show(t); }

    show(t) { this._isShown || this._isTransitioning || j.trigger(this._element, "show.bs.modal", { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add("modal-open"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), j.on(this._dialog, "mousedown.dismiss.bs.modal", () => { j.one(this._element, "mouseup.dismiss.bs.modal", (t) => { t.target === this._element && (this._ignoreBackdropClick = !0); }); }), this._showBackdrop(() => this._showElement(t))); }

    hide() { if (!this._isShown || this._isTransitioning) return; if (j.trigger(this._element, "hide.bs.modal").defaultPrevented) return; this._isShown = !1; const t = this._isAnimated(); t && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove("show"), j.off(this._element, "click.dismiss.bs.modal"), j.off(this._dialog, "mousedown.dismiss.bs.modal"), this._queueCallback(() => this._hideModal(), this._element, t); }

    dispose() { [window, this._dialog].forEach((t) => j.off(t, ".bs.modal")), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose(); }

    handleUpdate() { this._adjustDialog(); }

    _initializeBackDrop() { return new Te({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }); }

    _initializeFocusTrap() { return new Ae({ trapElement: this._element }); }

    _getConfig(t) { return t = { ...Me, ...H.getDataAttributes(this._element), ...typeof t === "object" ? t : {} }, s("modal", t, Le), t; }

    _showElement(t) { const e = this._isAnimated(); const n = $.findOne(".modal-body", this._dialog); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), e && d(this._element), this._element.classList.add("show"), this._queueCallback(() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, j.trigger(this._element, "shown.bs.modal", { relatedTarget: t }); }, this._dialog, e); }

    _setEscapeEvent() { this._isShown ? j.on(this._element, "keydown.dismiss.bs.modal", (t) => { this._config.keyboard && t.key === "Escape" ? (t.preventDefault(), this.hide()) : this._config.keyboard || t.key !== "Escape" || this._triggerBackdropTransition(); }) : j.off(this._element, "keydown.dismiss.bs.modal"); }

    _setResizeEvent() { this._isShown ? j.on(window, "resize.bs.modal", () => this._adjustDialog()) : j.off(window, "resize.bs.modal"); }

    _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove("modal-open"), this._resetAdjustments(), this._scrollBar.reset(), j.trigger(this._element, "hidden.bs.modal"); }); }

    _showBackdrop(t) { j.on(this._element, "click.dismiss.bs.modal", (t) => { this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition()); }), this._backdrop.show(t); }

    _isAnimated() { return this._element.classList.contains("fade"); }

    _triggerBackdropTransition() { if (j.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return; const { classList: t, scrollHeight: e, style: n } = this._element; const r = e > document.documentElement.clientHeight; !r && n.overflowY === "hidden" || t.contains("modal-static") || (r || (n.overflowY = "hidden"), t.add("modal-static"), this._queueCallback(() => { t.remove("modal-static"), r || this._queueCallback(() => { n.overflowY = ""; }, this._dialog); }, this._dialog), this._element.focus()); }

    _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight; const e = this._scrollBar.getWidth(); const n = e > 0; (!n && t && !f() || n && !t && f()) && (this._element.style.paddingLeft = `${e}px`), (n && !t && !f() || !n && t && f()) && (this._element.style.paddingRight = `${e}px`); }

    _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = ""; }

    static jQueryInterface(t, e) { return this.each((function () { const n = Ie.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`); n[t](e); } })); }
  }j.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function (t) { const e = n(this); ["A", "AREA"].includes(this.tagName) && t.preventDefault(), j.one(e, "show.bs.modal", (t) => { t.defaultPrevented || j.one(e, "hidden.bs.modal", () => { a(this) && this.focus(); }); }), Ie.getOrCreateInstance(e).toggle(this); })), F(Ie), m(Ie); const je = { backdrop: !0, keyboard: !0, scroll: !1 }; const De = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" }; class Ne extends R {
    constructor(t, e) { super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(); }

    static get NAME() { return "offcanvas"; }

    static get Default() { return je; }

    toggle(t) { return this._isShown ? this.hide() : this.show(t); }

    show(t) { this._isShown || j.trigger(this._element, "show.bs.offcanvas", { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || (new ke()).hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add("show"), this._queueCallback(() => { this._config.scroll || this._focustrap.activate(), j.trigger(this._element, "shown.bs.offcanvas", { relatedTarget: t }); }, this._element, !0)); }

    hide() { this._isShown && (j.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove("show"), this._backdrop.hide(), this._queueCallback(() => { this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || (new ke()).reset(), j.trigger(this._element, "hidden.bs.offcanvas"); }, this._element, !0))); }

    dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose(); }

    _getConfig(t) { return t = { ...je, ...H.getDataAttributes(this._element), ...typeof t === "object" ? t : {} }, s("offcanvas", t, De), t; }

    _initializeBackDrop() {
      return new Te({
        className: "offcanvas-backdrop", isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide(),
      });
    }

    _initializeFocusTrap() { return new Ae({ trapElement: this._element }); }

    _addEventListeners() { j.on(this._element, "keydown.dismiss.bs.offcanvas", (t) => { this._config.keyboard && t.key === "Escape" && this.hide(); }); }

    static jQueryInterface(t) { return this.each((function () { const e = Ne.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === e[t] || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); e[t](this); } })); }
  }j.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', (function (t) { const e = n(this); if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this)) return; j.one(e, "hidden.bs.offcanvas", () => { a(this) && this.focus(); }); const r = $.findOne(".offcanvas.show"); r && r !== e && Ne.getInstance(r).hide(), Ne.getOrCreateInstance(e).toggle(this); })), j.on(window, "load.bs.offcanvas.data-api", () => $.find(".offcanvas.show").forEach((t) => Ne.getOrCreateInstance(t).show())), F(Ne), m(Ne); const Re = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]); const Fe = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i; const Ve = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i; const ze = (t, e) => { const n = t.nodeName.toLowerCase(); if (e.includes(n)) return !Re.has(n) || Boolean(Fe.test(t.nodeValue) || Ve.test(t.nodeValue)); const r = e.filter((t) => t instanceof RegExp); for (let t = 0, e = r.length; t < e; t++) if (r[t].test(n)) return !0; return !1; }; function Be(t, e, n) { if (!t.length) return t; if (n && typeof n === "function") return n(t); const r = (new window.DOMParser()).parseFromString(t, "text/html"); const i = Object.keys(e); const o = [].concat(...r.body.querySelectorAll("*")); for (let t = 0, n = o.length; t < n; t++) { const n = o[t]; const r = n.nodeName.toLowerCase(); if (!i.includes(r)) { n.remove(); continue; } const s = [].concat(...n.attributes); const a = [].concat(e["*"] || [], e[r] || []); s.forEach((t) => { ze(t, a) || n.removeAttribute(t.nodeName); }); } return r.body.innerHTML; } const qe = new Set(["sanitize", "allowList", "sanitizeFn"]); const He = {
    animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)",
  }; const $e = {
    AUTO: "auto", TOP: "top", RIGHT: f() ? "left" : "right", BOTTOM: "bottom", LEFT: f() ? "right" : "left",
  }; const Ue = {
    animation: !0,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: !1,
    selector: !1,
    placement: "top",
    offset: [0, 0],
    container: !1,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    boundary: "clippingParents",
    customClass: "",
    sanitize: !0,
    sanitizeFn: null,
    allowList: {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [],
    },
    popperConfig: null,
  }; const We = {
    HIDE: "hide.bs.tooltip", HIDDEN: "hidden.bs.tooltip", SHOW: "show.bs.tooltip", SHOWN: "shown.bs.tooltip", INSERTED: "inserted.bs.tooltip", CLICK: "click.bs.tooltip", FOCUSIN: "focusin.bs.tooltip", FOCUSOUT: "focusout.bs.tooltip", MOUSEENTER: "mouseenter.bs.tooltip", MOUSELEAVE: "mouseleave.bs.tooltip",
  }; class Ge extends R {
    constructor(t, e) { if (void 0 === pe) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners(); }

    static get Default() { return Ue; }

    static get NAME() { return "tooltip"; }

    static get Event() { return We; }

    static get DefaultType() { return He; }

    enable() { this._isEnabled = !0; }

    disable() { this._isEnabled = !1; }

    toggleEnabled() { this._isEnabled = !this._isEnabled; }

    toggle(t) { if (this._isEnabled) if (t) { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e); } else { if (this.getTipElement().classList.contains("show")) return void this._leave(null, this); this._enter(null, this); } }

    dispose() { clearTimeout(this._timeout), j.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose(); }

    show() { if (this._element.style.display === "none") throw new Error("Please use show on visible elements"); if (!this.isWithContent() || !this._isEnabled) return; const t = j.trigger(this._element, this.constructor.Event.SHOW); const e = u(this._element); const n = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element); if (t.defaultPrevented || !n) return; const r = this.getTipElement(); const i = ((t) => { do { t += Math.floor(1e6 * Math.random()); } while (document.getElementById(t)); return t; })(this.constructor.NAME); r.setAttribute("id", i), this._element.setAttribute("aria-describedby", i), this._config.animation && r.classList.add("fade"); const o = typeof this._config.placement === "function" ? this._config.placement.call(this, r, this._element) : this._config.placement; const s = this._getAttachment(o); this._addAttachmentClass(s); const { container: a } = this._config; N.set(r, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (a.append(r), j.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = he(this._element, r, this._getPopperConfig(s)), r.classList.add("show"); const l = this._resolvePossibleFunction(this._config.customClass); l && r.classList.add(...l.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t) => { j.on(t, "mouseover", c); }); const d = this.tip.classList.contains("fade"); this._queueCallback(() => { const t = this._hoverState; this._hoverState = null, j.trigger(this._element, this.constructor.Event.SHOWN), t === "out" && this._leave(null, this); }, this.tip, d); }

    hide() { if (!this._popper) return; const t = this.getTipElement(); if (j.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return; t.classList.remove("show"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t) => j.off(t, "mouseover", c)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1; const e = this.tip.classList.contains("fade"); this._queueCallback(() => { this._isWithActiveTrigger() || (this._hoverState !== "show" && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), j.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null)); }, this.tip, e), this._hoverState = ""; }

    update() { this._popper !== null && this._popper.update(); }

    isWithContent() { return Boolean(this.getTitle()); }

    getTipElement() { if (this.tip) return this.tip; const t = document.createElement("div"); t.innerHTML = this._config.template; const e = t.children[0]; return this.setContent(e), e.classList.remove("fade", "show"), this.tip = e, this.tip; }

    setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), ".tooltip-inner"); }

    _sanitizeAndSetContent(t, e, n) { const r = $.findOne(n, t); e || !r ? this.setElementContent(r, e) : r.remove(); }

    setElementContent(t, e) { if (t !== null) return i(e) ? (e = o(e), void (this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent)) : void (this._config.html ? (this._config.sanitize && (e = Be(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e); }

    getTitle() { const t = this._element.getAttribute("data-bs-original-title") || this._config.title; return this._resolvePossibleFunction(t); }

    updateAttachment(t) { return t === "right" ? "end" : t === "left" ? "start" : t; }

    _initializeOnDelegatedTarget(t, e) { return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()); }

    _getOffset() { const { offset: t } = this._config; return typeof t === "string" ? t.split(",").map((t) => Number.parseInt(t, 10)) : typeof t === "function" ? (e) => t(e, this._element) : t; }

    _resolvePossibleFunction(t) { return typeof t === "function" ? t.call(this._element) : t; }

    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, {
          name: "onChange", enabled: !0, phase: "afterWrite", fn: (t) => this._handlePopperPlacementChange(t),
        }],
        onFirstUpdate: (t) => { t.options.placement !== t.placement && this._handlePopperPlacementChange(t); },
      }; return { ...e, ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(e) : this._config.popperConfig };
    }

    _addAttachmentClass(t) { this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`); }

    _getAttachment(t) { return $e[t.toUpperCase()]; }

    _setListeners() { this._config.trigger.split(" ").forEach((t) => { if (t === "click")j.on(this._element, this.constructor.Event.CLICK, this._config.selector, (t) => this.toggle(t)); else if (t !== "manual") { const e = t === "hover" ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN; const n = t === "hover" ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT; j.on(this._element, e, this._config.selector, (t) => this._enter(t)), j.on(this._element, n, this._config.selector, (t) => this._leave(t)); } }), this._hideModalHandler = () => { this._element && this.hide(); }, j.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle(); }

    _fixTitle() { const t = this._element.getAttribute("title"); const e = typeof this._element.getAttribute("data-bs-original-title"); (t || e !== "string") && (this._element.setAttribute("data-bs-original-title", t || ""), !t || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t), this._element.setAttribute("title", "")); }

    _enter(t, e) { e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? "focus" : "hover"] = !0), e.getTipElement().classList.contains("show") || e._hoverState === "show" ? e._hoverState = "show" : (clearTimeout(e._timeout), e._hoverState = "show", e._config.delay && e._config.delay.show ? e._timeout = setTimeout(() => { e._hoverState === "show" && e.show(); }, e._config.delay.show) : e.show()); }

    _leave(t, e) { e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? "focus" : "hover"] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = "out", e._config.delay && e._config.delay.hide ? e._timeout = setTimeout(() => { e._hoverState === "out" && e.hide(); }, e._config.delay.hide) : e.hide()); }

    _isWithActiveTrigger() { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1; }

    _getConfig(t) { const e = H.getDataAttributes(this._element); return Object.keys(e).forEach((t) => { qe.has(t) && delete e[t]; }), (t = { ...this.constructor.Default, ...e, ...typeof t === "object" && t ? t : {} }).container = !1 === t.container ? document.body : o(t.container), typeof t.delay === "number" && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title === "number" && (t.title = t.title.toString()), typeof t.content === "number" && (t.content = t.content.toString()), s("tooltip", t, this.constructor.DefaultType), t.sanitize && (t.template = Be(t.template, t.allowList, t.sanitizeFn)), t; }

    _getDelegateConfig() { const t = {}; for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]); return t; }

    _cleanTipClass() { const t = this.getTipElement(); const e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"); const n = t.getAttribute("class").match(e); n !== null && n.length > 0 && n.map((t) => t.trim()).forEach((e) => t.classList.remove(e)); }

    _getBasicClassPrefix() { return "bs-tooltip"; }

    _handlePopperPlacementChange(t) { const { state: e } = t; e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement))); }

    static jQueryInterface(t) { return this.each((function () { const e = Ge.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }m(Ge); const Ye = {
    ...Ge.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  }; const Ze = { ...Ge.DefaultType, content: "(string|element|function)" }; const Ke = {
    HIDE: "hide.bs.popover", HIDDEN: "hidden.bs.popover", SHOW: "show.bs.popover", SHOWN: "shown.bs.popover", INSERTED: "inserted.bs.popover", CLICK: "click.bs.popover", FOCUSIN: "focusin.bs.popover", FOCUSOUT: "focusout.bs.popover", MOUSEENTER: "mouseenter.bs.popover", MOUSELEAVE: "mouseleave.bs.popover",
  }; class Xe extends Ge {
    static get Default() { return Ye; }

    static get NAME() { return "popover"; }

    static get Event() { return Ke; }

    static get DefaultType() { return Ze; }

    isWithContent() { return this.getTitle() || this._getContent(); }

    setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), ".popover-header"), this._sanitizeAndSetContent(t, this._getContent(), ".popover-body"); }

    _getContent() { return this._resolvePossibleFunction(this._config.content); }

    _getBasicClassPrefix() { return "bs-popover"; }

    static jQueryInterface(t) { return this.each((function () { const e = Xe.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }m(Xe); const Qe = { offset: 10, method: "auto", target: "" }; const Je = { offset: "number", method: "string", target: "(string|element)" }; const tn = ".nav-link, .list-group-item, .dropdown-item"; class en extends R {
    constructor(t, e) { super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, j.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process(); }

    static get Default() { return Qe; }

    static get NAME() { return "scrollspy"; }

    refresh() {
      const t = this._scrollElement === this._scrollElement.window ? "offset" : "position"; const n = this._config.method === "auto" ? t : this._config.method; const r = n === "position" ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), $.find(tn, this._config.target).map((t) => { const i = e(t); const o = i ? $.findOne(i) : null; if (o) { const t = o.getBoundingClientRect(); if (t.width || t.height) return [H[n](o).top + r, i]; } return null; }).filter((t) => t).sort((t, e) => t[0] - e[0])
        .forEach((t) => { this._offsets.push(t[0]), this._targets.push(t[1]); });
    }

    dispose() { j.off(this._scrollElement, ".bs.scrollspy"), super.dispose(); }

    _getConfig(t) { return (t = { ...Qe, ...H.getDataAttributes(this._element), ...typeof t === "object" && t ? t : {} }).target = o(t.target) || document.documentElement, s("scrollspy", t, Je), t; }

    _getScrollTop() { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop; }

    _getScrollHeight() { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight); }

    _getOffsetHeight() { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height; }

    _process() { const t = this._getScrollTop() + this._config.offset; const e = this._getScrollHeight(); const n = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), t >= n) { const t = this._targets[this._targets.length - 1]; this._activeTarget !== t && this._activate(t); } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let e = this._offsets.length; e--;) this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e]); } }

    _activate(t) { this._activeTarget = t, this._clear(); const e = tn.split(",").map((e) => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`); const n = $.findOne(e.join(","), this._config.target); n.classList.add("active"), n.classList.contains("dropdown-item") ? $.findOne(".dropdown-toggle", n.closest(".dropdown")).classList.add("active") : $.parents(n, ".nav, .list-group").forEach((t) => { $.prev(t, ".nav-link, .list-group-item").forEach((t) => t.classList.add("active")), $.prev(t, ".nav-item").forEach((t) => { $.children(t, ".nav-link").forEach((t) => t.classList.add("active")); }); }), j.trigger(this._scrollElement, "activate.bs.scrollspy", { relatedTarget: t }); }

    _clear() { $.find(tn, this._config.target).filter((t) => t.classList.contains("active")).forEach((t) => t.classList.remove("active")); }

    static jQueryInterface(t) { return this.each((function () { const e = en.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }j.on(window, "load.bs.scrollspy.data-api", () => { $.find('[data-bs-spy="scroll"]').forEach((t) => new en(t)); }), m(en); class nn extends R {
    static get NAME() { return "tab"; }

    show() { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active")) return; let t; const e = n(this._element); const r = this._element.closest(".nav, .list-group"); if (r) { const e = r.nodeName === "UL" || r.nodeName === "OL" ? ":scope > li > .active" : ".active"; t = $.find(e, r), t = t[t.length - 1]; } const i = t ? j.trigger(t, "hide.bs.tab", { relatedTarget: this._element }) : null; if (j.trigger(this._element, "show.bs.tab", { relatedTarget: t }).defaultPrevented || i !== null && i.defaultPrevented) return; this._activate(this._element, r); const o = () => { j.trigger(t, "hidden.bs.tab", { relatedTarget: this._element }), j.trigger(this._element, "shown.bs.tab", { relatedTarget: t }); }; e ? this._activate(e, e.parentNode, o) : o(); }

    _activate(t, e, n) { const r = (!e || e.nodeName !== "UL" && e.nodeName !== "OL" ? $.children(e, ".active") : $.find(":scope > li > .active", e))[0]; const i = n && r && r.classList.contains("fade"); const o = () => this._transitionComplete(t, r, n); r && i ? (r.classList.remove("show"), this._queueCallback(o, t, !0)) : o(); }

    _transitionComplete(t, e, n) { if (e) { e.classList.remove("active"); const t = $.findOne(":scope > .dropdown-menu .active", e.parentNode); t && t.classList.remove("active"), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1); }t.classList.add("active"), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), d(t), t.classList.contains("fade") && t.classList.add("show"); let r = t.parentNode; if (r && r.nodeName === "LI" && (r = r.parentNode), r && r.classList.contains("dropdown-menu")) { const e = t.closest(".dropdown"); e && $.find(".dropdown-toggle", e).forEach((t) => t.classList.add("active")), t.setAttribute("aria-expanded", !0); }n && n(); }

    static jQueryInterface(t) { return this.each((function () { const e = nn.getOrCreateInstance(this); if (typeof t === "string") { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](); } })); }
  }j.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function (t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this) || nn.getOrCreateInstance(this).show(); })), m(nn); const rn = { animation: "boolean", autohide: "boolean", delay: "number" }; const on = { animation: !0, autohide: !0, delay: 5e3 }; class sn extends R {
    constructor(t, e) { super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(); }

    static get DefaultType() { return rn; }

    static get Default() { return on; }

    static get NAME() { return "toast"; }

    show() { j.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), d(this._element), this._element.classList.add("show"), this._element.classList.add("showing"), this._queueCallback(() => { this._element.classList.remove("showing"), j.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide(); }, this._element, this._config.animation)); }

    hide() { this._element.classList.contains("show") && (j.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add("showing"), this._queueCallback(() => { this._element.classList.add("hide"), this._element.classList.remove("showing"), this._element.classList.remove("show"), j.trigger(this._element, "hidden.bs.toast"); }, this._element, this._config.animation))); }

    dispose() { this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), super.dispose(); }

    _getConfig(t) { return t = { ...on, ...H.getDataAttributes(this._element), ...typeof t === "object" && t ? t : {} }, s("toast", t, this.constructor.DefaultType), t; }

    _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide(); }, this._config.delay))); }

    _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e; } if (e) return void this._clearTimeout(); const n = t.relatedTarget; this._element === n || this._element.contains(n) || this._maybeScheduleHide(); }

    _setListeners() { j.on(this._element, "mouseover.bs.toast", (t) => this._onInteraction(t, !0)), j.on(this._element, "mouseout.bs.toast", (t) => this._onInteraction(t, !1)), j.on(this._element, "focusin.bs.toast", (t) => this._onInteraction(t, !0)), j.on(this._element, "focusout.bs.toast", (t) => this._onInteraction(t, !1)); }

    _clearTimeout() { clearTimeout(this._timeout), this._timeout = null; }

    static jQueryInterface(t) { return this.each((function () { const e = sn.getOrCreateInstance(this, t); if (typeof t === "string") { if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`); e[t](this); } })); }
  } return F(sn), m(sn), {
    Alert: V, Button: z, Carousel: Q, Collapse: et, Dropdown: Se, Modal: Ie, Offcanvas: Ne, Popover: Xe, ScrollSpy: en, Tab: nn, Toast: sn, Tooltip: Ge,
  };
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSHeader = e() : t.HSHeader = e(); }(window, (() => {
  return d = {
    "./src/js/hs-header.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HSHeader; });\n/* harmony import */ var _observers_sticky__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observers/sticky */ \"./src/js/observers/sticky.js\");\n/* harmony import */ var _observers_moment_show_hide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observers/moment-show-hide */ \"./src/js/observers/moment-show-hide.js\");\n/* harmony import */ var _observers_show_hide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observers/show-hide */ \"./src/js/observers/show-hide.js\");\n/* harmony import */ var _observers_hide_section__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observers/hide-section */ \"./src/js/observers/hide-section.js\");\n/* harmony import */ var _observers_has_hidden_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./observers/has-hidden-element */ \"./src/js/observers/has-hidden-element.js\");\n/* harmony import */ var _observers_floating__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./observers/floating */ \"./src/js/observers/floating.js\");\n/* harmony import */ var _observers_without_behavior__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./observers/without-behavior */ \"./src/js/observers/without-behavior.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\r\n* HSHeader Plugin\r\n* @version: 3.0.0 (Mon, 25 Mar 2021)\r\n* @author: HtmlStream\r\n* @event-namespace: .HSHeader\r\n* @license: Htmlstream Libraries (https://htmlstream.com/)\r\n* Copyright 2019 Htmlstream\r\n*/\n// Sticky\n // Moment Show / Hide\n\n // Show / Hide\n\n // Hide Section\n\n // Has Hidden Element\n\n // Floating\n\n // Without Behavior\n\n\n\nvar HSHeader = /*#__PURE__*/function () {\n  function HSHeader(el, config, observers) {\n    _classCallCheck(this, HSHeader);\n\n    this.element = typeof el === \"string\" ? document.querySelector(el) : el;\n    this.config = config;\n    this.observers = observers && Object.prototype.toString.call(observers) === '[object Object]' ? observers : {};\n    this.viewport = 'xs';\n    this.defaults = {\n      fixMoment: 0,\n      fixMomentClasses: null,\n      fixMomentExclude: null,\n      fixEffect: 'slide',\n      breakpoint: 'lg',\n      breakpointsMap: {\n        'md': 768,\n        'sm': 576,\n        'lg': 992,\n        'xl': 1200\n      },\n      effectCompensation: false,\n      effectCompensationStartClass: false,\n      effectCompensationEndClass: false\n    };\n  }\n\n  _createClass(HSHeader, [{\n    key: \"init\",\n    value: function init() {\n      var self = this,\n          element = this.element;\n      var dataSettings = element.hasAttribute('data-hs-header-options') ? JSON.parse(element.getAttribute('data-hs-header-options')) : {};\n      if (!element || element.hasAttribute('HSHeader')) return;\n      this.config = Object.assign({}, this.defaults, dataSettings, this.config);\n\n      this._detectObservers();\n\n      this.fixMediaDifference(this.element);\n      this.checkViewport();\n      onScroll();\n      document.addEventListener('scroll', onScroll);\n      onResize();\n      window.addEventListener('resize', onResize);\n\n      function onScroll() {\n        window.HSHeader = null;\n\n        if (window.pageYOffset < self.config.fixMoment - 100 && self.config.effectCompensation === true) {\n          element.style.top = -window.pageYOffset;\n          element.classList.add(self.config.effectCompensationStartClass);\n          element.classList.remove(self.config.effectCompensationEndClass);\n        } else if (self.config.effectCompensation === true) {\n          element.style.top = 0;\n          element.classList.add(self.config.effectCompensationEndClass);\n          element.classList.remove(self.config.effectCompensationStartClass);\n        }\n\n        if (element.hasAttribute('HSHeader')) {\n          self.notify();\n        }\n\n        element.setAttribute('HSHeader', true);\n      }\n\n      function onResize() {\n        if (self.resizeTimeOutId) clearTimeout(self.resizeTimeOutId);\n        self.resizeTimeOutId = setTimeout(function () {\n          // self.checkViewport()\n          self.update();\n        }, 100);\n      }\n\n      return this.element;\n    }\n  }, {\n    key: \"header\",\n    value: function header(element, config, observers) {\n      if (!element || !element.length) return;\n      this.element = element;\n      this.config = config;\n      this.observers = observers && $.isPlainObject(observers) ? observers : {};\n      this.viewport = 'xs';\n      this.checkViewport();\n    }\n  }, {\n    key: \"_detectObservers\",\n    value: function _detectObservers() {\n      if (!this.element) return;\n      var observers = this.observers = {\n        'xs': [],\n        'sm': [],\n        'md': [],\n        'lg': [],\n        'xl': []\n      };\n      /* ------------------------ xs -------------------------*/\n      // Has Hidden Element\n\n      if (this.element.classList.contains('navbar-has-hidden-element')) {\n        observers['xs'].push(new _observers_has_hidden_element__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.element).init());\n      } // Sticky top\n\n\n      if (this.element.classList.contains('navbar-sticky-top')) {\n        if (this.element.classList.contains('navbar-show-hide')) {\n          observers['xs'].push(new _observers_moment_show_hide__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.element).init());\n        } else if (this.element.classList.contains('navbar-toggle')) {\n          observers['xs'].push(new _observers_hide_section__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.element).init());\n        }\n\n        observers['xs'].push(new _observers_sticky__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.element).init());\n      } // Floating\n\n\n      if (this.element.classList.contains('navbar-floating')) {\n        observers['xs'].push(new _observers_floating__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.element).init());\n      }\n\n      if (this.element.classList.contains('navbar-invulnerable')) {\n        observers['xs'].push(new _observers_without_behavior__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.element).init());\n      } // Abs top & Static\n\n\n      if (this.element.classList.contains('navbar-absolute-top') || this.element.classList.contains('navbar-static')) {\n        if (this.element.classList.contains('navbar-show-hide')) {\n          observers['xs'].push(new _observers_show_hide__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.element, this.config).init());\n        }\n      }\n\n      return observers;\n    }\n  }, {\n    key: \"fixMediaDifference\",\n    value: function fixMediaDifference(element) {\n      if (!element || !element.length || !element.filter(function (el) {\n        return el.closest('[class*=\"navbar-side\"]');\n      }).length) return;\n      var toggleable;\n\n      if (element.classList.contains('navbar-side-left-xl') || element.classList.contains('navbar-side-right-xl')) {\n        toggleable = element.querySelector('.navbar-expand-xl');\n\n        if (toggleable) {\n          toggleable.classList.remove('navbar-expand-xl');\n          toggleable.classList.add('navbar-expand-lg');\n        }\n      } else if (element.classList.contains('navbar-side-left-lg') || element.classList.contains('navbar-side-right-lg')) {\n        toggleable = element.querySelector('.navbar-expand-lg');\n\n        if (toggleable) {\n          toggleable.classList.remove('navbar-expand-lg');\n          toggleable.classList.add('navbar-expand-md');\n        }\n      } else if (element.classList.contains('navbar-side-left-md') || element.classList.contains('navbar-side-right-md')) {\n        toggleable = element.querySelector('.navbar-expand-md');\n\n        if (toggleable) {\n          toggleable.classList.remove('navbar-expand-md');\n          toggleable.classList.add('navbar-expand-sm');\n        }\n      } else if (element.classList.contains('navbar-side-left-sm') || element.classList.contains('navbar-side-right-sm')) {\n        toggleable = element.querySelector('.navbar-expand-sm');\n\n        if (toggleable) {\n          toggleable.classList.remove('navbar-expand-sm');\n          toggleable.classList.add('navbar-expand');\n        }\n      }\n    }\n  }, {\n    key: \"checkViewport\",\n    value: function checkViewport() {\n      if (window.innerWidth > this.config.breakpointsMap['sm'] && this.observers['sm'].length) {\n        this.prevViewport = this.viewport;\n        this.viewport = 'sm';\n\n        if (this.config.fixMoment && window.pageYOffset > this.config.fixMoment) {\n          if (typeof this.config.breakpointsMap['sm'] === 'undefined') {\n            this.element.classList.remove('navbar-scrolled');\n          } else {\n            this.element.classList.add('navbar-scrolled');\n          }\n        }\n\n        return this;\n      }\n\n      if (window.innerWidth > this.config.breakpointsMap['md'] && this.observers['md'].length) {\n        this.prevViewport = this.viewport;\n        this.viewport = 'md';\n\n        if (this.config.fixMoment && window.pageYOffset > this.config.fixMoment) {\n          if (typeof this.config.breakpointsMap['md'] === 'undefined') {\n            this.element.classList.remove('navbar-scrolled');\n          } else {\n            this.element.classList.add('navbar-scrolled');\n          }\n        }\n\n        return this;\n      }\n\n      if (window.innerWidth > this.config.breakpointsMap['lg'] && this.observers['lg'].length) {\n        this.prevViewport = this.viewport;\n        this.viewport = 'lg';\n\n        if (this.config.fixMoment && window.pageYOffset > this.config.fixMoment) {\n          if (typeof this.config.breakpointsMap['lg'] === 'undefined') {\n            this.element.classList.remove('navbar-scrolled');\n          } else {\n            this.element.classList.add('navbar-scrolled');\n          }\n        }\n\n        return this;\n      }\n\n      if (window.innerWidth > this.config.breakpointsMap['xl'] && this.observers['xl'].length) {\n        this.prevViewport = this.viewport;\n        this.viewport = 'xl';\n\n        if (this.config.fixMoment && window.pageYOffset > this.config.fixMoment) {\n          if (typeof this.config.breakpointsMap['xl'] === 'undefined') {\n            this.element.classList.remove('navbar-scrolled');\n          } else {\n            this.element.classList.add('navbar-scrolled');\n          }\n        }\n\n        return this;\n      }\n\n      if (this.prevViewport) this.prevViewport = this.viewport;\n\n      if (this.config.fixMoment && window.pageYOffset > this.config.fixMoment) {\n        if (typeof this.config.breakpointsMap['xs'] === 'undefined') {\n          this.element.classList.remove('navbar-scrolled');\n        } else {\n          this.element.classList.add('navbar-scrolled');\n        }\n      }\n\n      this.viewport = 'xs';\n      return this;\n    }\n  }, {\n    key: \"notify\",\n    value: function notify() {\n      if (this.prevViewport) {\n        this.observers[this.prevViewport].forEach(function (observer) {\n          observer.destroy();\n        });\n        this.prevViewport = null;\n      }\n\n      this.observers[this.viewport].forEach(function (observer) {\n        observer.check();\n      });\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      for (var viewport in this.observers) {\n        this.observers[viewport].forEach(function (observer) {\n          observer.destroy();\n        });\n      }\n\n      this.prevViewport = null;\n      this.observers[this.viewport].forEach(function (observer) {\n        observer.reinit();\n      });\n      return this;\n    }\n  }]);\n\n  return HSHeader;\n}();\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/hs-header.js?");
    },
    "./src/js/observers/abstract.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSAbstractObserver; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar HSAbstractObserver = /*#__PURE__*/function () {\n  function HSAbstractObserver(element) {\n    _classCallCheck(this, HSAbstractObserver);\n\n    this.element = element;\n    this.defaultState = true;\n  }\n\n  _createClass(HSAbstractObserver, [{\n    key: "reinit",\n    value: function reinit() {\n      this.destroy().init().check();\n    }\n  }]);\n\n  return HSAbstractObserver;\n}();\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/abstract.js?');
    },
    "./src/js/observers/floating.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSHeaderFloatingObserver; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ "./src/js/observers/abstract.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HSHeaderFloatingObserver = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderFloatingObserver, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderFloatingObserver);\n\n  function HSHeaderFloatingObserver(element) {\n    var _this;\n\n    _classCallCheck(this, HSHeaderFloatingObserver);\n\n    _this = _super.call(this, element);\n    _this.dataSettings = _this.element.hasAttribute(\'data-hs-header-options\') ? JSON.parse(_this.element.getAttribute(\'data-hs-header-options\')) : {};\n    return _this;\n  }\n\n  _createClass(HSHeaderFloatingObserver, [{\n    key: "init",\n    value: function init() {\n      this.offset = this.element.offsetTop;\n      this.sections = this.element.querySelectorAll(\'.navbar-section\');\n      this.defaultState = true;\n      return this;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.toDefaultState();\n      return this;\n    }\n  }, {\n    key: "check",\n    value: function check() {\n      var docScrolled = window.pageYOffset;\n\n      if (docScrolled > this.offset && this.defaultState) {\n        this.changeState();\n      } else if (docScrolled <= this.offset && !this.defaultState) {\n        this.toDefaultState();\n      }\n\n      return this;\n    }\n  }, {\n    key: "changeState",\n    value: function changeState() {\n      this.element.classList.add(\'navbar-scrolled\');\n      this.element.classList.add(this.dataSettings.fixMomentClasses);\n      this.element.classList.remove(this.dataSettings.fixMomentExclude);\n\n      if (this.sections.length) {\n        this.sections.forEach(function ($section) {\n          var dataSettings = $section.hasAttribute(\'data-hs-navbar-item-options\') ? JSON.parse($section.getAttribute(\'data-hs-navbar-item-options\')) : {};\n          $section.classList.add(dataSettings.fixMomentClasses);\n          $section.classList.remove(dataSettings.fixMomentExclude);\n        });\n      }\n\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }, {\n    key: "toDefaultState",\n    value: function toDefaultState() {\n      this.element.classList.remove(\'navbar-scrolled\');\n      this.element.classList.remove(this.dataSettings.fixMomentClasses);\n      this.element.classList.add(this.dataSettings.fixMomentExclude);\n\n      if (this.sections.length) {\n        this.sections.forEach(function ($section) {\n          var dataSettings = $section.hasAttribute(\'data-hs-navbar-item-options\') ? JSON.parse($section.getAttribute(\'data-hs-navbar-item-options\')) : {};\n          $section.classList.add(dataSettings.fixMomentClasses);\n          $section.classList.remove(dataSettings.fixMomentExclude);\n        });\n      }\n\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }]);\n\n  return HSHeaderFloatingObserver;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/floating.js?');
    },
    "./src/js/observers/has-hidden-element.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSHeaderHasHiddenElement; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ "./src/js/observers/abstract.js");\n/* harmony import */ var _utils_slideUp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/slideUp */ "./src/js/utils/slideUp.js");\n/* harmony import */ var _utils_slideDown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/slideDown */ "./src/js/utils/slideDown.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar HSHeaderHasHiddenElement = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderHasHiddenElement, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderHasHiddenElement);\n\n  function HSHeaderHasHiddenElement(element) {\n    var _this;\n\n    _classCallCheck(this, HSHeaderHasHiddenElement);\n\n    _this = _super.call(this, element);\n    _this.config = {\n      animated: true\n    };\n    _this.dataSettings = _this.element.hasAttribute(\'data-hs-header-options\') ? JSON.parse(_this.element.getAttribute(\'data-hs-header-options\')) : {};\n    return _this;\n  }\n\n  _createClass(HSHeaderHasHiddenElement, [{\n    key: "init",\n    value: function init() {\n      this.offset = isFinite(this.dataSettings.fixMoment) ? this.dataSettings.fixMoment : 5;\n      this.elements = this.element.querySelectorAll(\'.navbar-hidden-element\');\n      this.defaultState = true;\n      return this;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.toDefaultState();\n      return this;\n    }\n  }, {\n    key: "check",\n    value: function check() {\n      if (!this.elements.length) return this;\n      var docScrolled = window.pageYOffset;\n\n      if (docScrolled > this.offset && this.defaultState) {\n        this.changeState();\n      } else if (docScrolled <= this.offset && !this.defaultState) {\n        this.toDefaultState();\n      }\n\n      return this;\n    }\n  }, {\n    key: "changeState",\n    value: function changeState() {\n      if (this.config.animated) {\n        this.elements.forEach(function (item) {\n          Object(_utils_slideUp__WEBPACK_IMPORTED_MODULE_1__["default"])(item);\n        });\n      } else {\n        this.elements.forEach(function (item) {\n          item.style.display = \'none\';\n        });\n      }\n\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }, {\n    key: "toDefaultState",\n    value: function toDefaultState() {\n      if (this.config.animated) {\n        this.elements.forEach(function (item) {\n          Object(_utils_slideDown__WEBPACK_IMPORTED_MODULE_2__["default"])(item);\n        });\n      } else {\n        this.elements.forEach(function (item) {\n          item.style.display = \'block\';\n        });\n      }\n\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }]);\n\n  return HSHeaderHasHiddenElement;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/has-hidden-element.js?');
    },
    "./src/js/observers/hide-section.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSHeaderHideSectionObserver; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ "./src/js/observers/abstract.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HSHeaderHideSectionObserver = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderHideSectionObserver, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderHideSectionObserver);\n\n  function HSHeaderHideSectionObserver(element) {\n    var _this;\n\n    _classCallCheck(this, HSHeaderHideSectionObserver);\n\n    _this = _super.call(this, element);\n    _this.dataSettings = _this.element.hasAttribute(\'data-hs-header-options\') ? JSON.parse(_this.element.getAttribute(\'data-hs-header-options\')) : {};\n    return _this;\n  }\n\n  _createClass(HSHeaderHideSectionObserver, [{\n    key: "init",\n    value: function init() {\n      this.offset = isFinite(this.dataSettings.fixMoment) ? this.dataSettings.fixMoment : 5;\n      this.section = this.element.querySelector(\'.navbar-section-hidden\');\n      this.defaultState = true;\n      this.sectionHeight = this.section ? this.section.offsetHeight : 0;\n      return this;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this.section) {\n        this.element.transition = \'margin-top .5s\';\n        this.element.style.marginTop = 0;\n      }\n\n      return this;\n    }\n  }, {\n    key: "check",\n    value: function check() {\n      if (!this.section) return this;\n      var docScrolled = window.pageYOffset;\n\n      if (docScrolled > this.offset && this.defaultState) {\n        this.changeState();\n      } else if (docScrolled <= this.offset && !this.defaultState) {\n        this.toDefaultState();\n      }\n\n      return this;\n    }\n  }, {\n    key: "changeState",\n    value: function changeState() {\n      var self = this;\n      this.element.transition = \'margin-top .5s\';\n      this.element.style.marginTop = self.sectionHeight * -1 - 1 + \'px\';\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }, {\n    key: "toDefaultState",\n    value: function toDefaultState() {\n      this.element.transition = \'margin-top .5s\';\n      this.element.style.marginTop = 0;\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }]);\n\n  return HSHeaderHideSectionObserver;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/hide-section.js?');
    },
    "./src/js/observers/moment-show-hide.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSHeaderMomentShowHideObserver; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ "./src/js/observers/abstract.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HSHeaderMomentShowHideObserver = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderMomentShowHideObserver, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderMomentShowHideObserver);\n\n  function HSHeaderMomentShowHideObserver(element) {\n    var _this;\n\n    _classCallCheck(this, HSHeaderMomentShowHideObserver);\n\n    _this = _super.call(this, element);\n    _this.dataSettings = _this.element.hasAttribute(\'data-hs-header-options\') ? JSON.parse(_this.element.getAttribute(\'data-hs-header-options\')) : {};\n    return _this;\n  }\n\n  _createClass(HSHeaderMomentShowHideObserver, [{\n    key: "init",\n    value: function init() {\n      this.direction = \'down\';\n      this.delta = 0;\n      this.defaultState = true;\n      this.offset = isFinite(this.dataSettings.fixMoment) && this.dataSettings.fixMoment !== 0 ? this.dataSettings.fixMoment : 5;\n      this.effect = this.dataSettings.fixEffect ? this.dataSettings.fixEffect : \'show-hide\';\n      return this;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.toDefaultState();\n      return this;\n    }\n  }, {\n    key: "checkDirection",\n    value: function checkDirection() {\n      if (window.pageYOffset > this.delta) {\n        this.direction = \'down\';\n      } else {\n        this.direction = \'up\';\n      }\n\n      this.delta = window.pageYOffset;\n      return this;\n    }\n  }, {\n    key: "toDefaultState",\n    value: function toDefaultState() {\n      switch (this.effect) {\n        case \'slide\':\n          this.element.classList.remove(\'navbar-moved-up\');\n          break;\n\n        case \'fade\':\n          this.element.classList.remove(\'navbar-faded\');\n          break;\n\n        default:\n          this.element.classList.remove(\'navbar-invisible\');\n      }\n\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }, {\n    key: "changeState",\n    value: function changeState() {\n      switch (this.effect) {\n        case \'slide\':\n          this.element.classList.add(\'navbar-moved-up\');\n          break;\n\n        case \'fade\':\n          this.element.classList.add(\'navbar-faded\');\n          break;\n\n        default:\n          this.element.classList.add(\'navbar-invisible\');\n      }\n\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }, {\n    key: "check",\n    value: function check() {\n      var docScrolled = window.pageYOffset;\n      this.checkDirection();\n\n      if (docScrolled >= this.offset && this.defaultState && this.direction === \'down\') {\n        this.changeState();\n      } else if (!this.defaultState && this.direction === \'up\') {\n        this.toDefaultState();\n      }\n\n      return this;\n    }\n  }]);\n\n  return HSHeaderMomentShowHideObserver;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/moment-show-hide.js?');
    },
    "./src/js/observers/show-hide.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HSHeaderShowHideObserver; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ \"./src/js/observers/abstract.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HSHeaderShowHideObserver = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderShowHideObserver, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderShowHideObserver);\n\n  function HSHeaderShowHideObserver(element, config) {\n    var _this;\n\n    _classCallCheck(this, HSHeaderShowHideObserver);\n\n    _this = _super.call(this, element, config);\n    _this.dataSettings = _this.element.hasAttribute('data-hs-header-options') ? JSON.parse(_this.element.getAttribute('data-hs-header-options')) : {};\n    _this.config = config;\n    return _this;\n  }\n\n  _createClass(HSHeaderShowHideObserver, [{\n    key: \"init\",\n    value: function init() {\n      if (!this.defaultState && window.pageYOffset > this.offset) return this;\n      this.defaultState = true;\n      this.transitionDuration = parseFloat(getComputedStyle(this.element)['transition-duration'], 10) * 1000;\n      this.offset = isFinite(this.dataSettings.fixMoment) && this.dataSettings.fixMoment > this.element.offsetHeight ? this.dataSettings.fixMoment : this.element.offsetHeight + 100;\n      this.effect = this.dataSettings.fixEffect ? this.dataSettings.fixEffect : 'show-hide';\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (!this.defaultState && window.pageYOffset > this.offset) return this;\n      this.element.classList.remove('navbar-untransitioned');\n\n      this._removeCap();\n\n      return this;\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      if (window.pageYOffset > this.element.offsetHeight && !this.capInserted) {\n        this._insertCap();\n      } else if (window.pageYOffset <= this.element.offsetHeight && this.capInserted) {\n        this._removeCap();\n      }\n\n      if (window.pageYOffset > this.offset && this.defaultState) {\n        this.changeState();\n      } else if (window.pageYOffset <= this.offset && !this.defaultState) {\n        this.toDefaultState();\n      }\n    }\n  }, {\n    key: \"changeState\",\n    value: function changeState() {\n      if (this.config.fixMomentClasses) {\n        var _this$element$classLi;\n\n        (_this$element$classLi = this.element.classList).add.apply(_this$element$classLi, _toConsumableArray(this.config.fixMomentClasses));\n      }\n\n      this.element.classList.remove('navbar-untransitioned');\n      if (this.animationTimeoutId) clearTimeout(this.animationTimeoutId);\n\n      switch (this.effect) {\n        case 'fade':\n          this.element.classList.remove('navbar-faded');\n          break;\n\n        case 'slide':\n          this.element.classList.remove('navbar-moved-up');\n          break;\n\n        default:\n          this.element.classList.remove('navbar-invisible');\n      }\n\n      this.defaultState = !this.defaultState;\n    }\n  }, {\n    key: \"toDefaultState\",\n    value: function toDefaultState() {\n      var self = this;\n\n      if (this.config.fixMomentClasses) {\n        var _this$element$classLi2;\n\n        (_this$element$classLi2 = this.element.classList).remove.apply(_this$element$classLi2, _toConsumableArray(this.config.fixMomentClasses));\n      }\n\n      this.animationTimeoutId = setTimeout(function () {\n        self.element.classList.add('navbar-untransitioned');\n      }, this.transitionDuration);\n\n      switch (this.effect) {\n        case 'fade':\n          this.element.classList.add('navbar-faded');\n          break;\n\n        case 'slide':\n          this.element.classList.add('navbar-moved-up');\n          break;\n\n        default:\n          this.element.classList.add('navbar-invisible');\n      }\n\n      this.defaultState = !this.defaultState;\n    }\n  }, {\n    key: \"_insertCap\",\n    value: function _insertCap() {\n      this.element.classList.add('navbar-scrolled', 'navbar-untransitioned');\n\n      if (this.element.classList.contains('navbar-static')) {\n        document.documentElement.style.paddingTop = this.element.offsetHeight;\n      }\n\n      switch (this.effect) {\n        case 'fade':\n          this.element.classList.add('navbar-faded');\n          break;\n\n        case 'slide':\n          this.element.classList.add('navbar-moved-up');\n          break;\n\n        default:\n          this.element.classList.add('navbar-invisible');\n      }\n\n      this.capInserted = true;\n    }\n  }, {\n    key: \"_removeCap\",\n    value: function _removeCap() {\n      var self = this;\n      this.element.classList.remove('navbar-scrolled');\n\n      if (this.element.classList.contains('navbar-static')) {\n        document.documentElement.style.paddingTop = 0;\n      }\n\n      if (this.removeCapTimeOutId) clearTimeout(this.removeCapTimeOutId);\n      this.removeCapTimeOutId = setTimeout(function () {\n        self.element.classList.remove('navbar-moved-up', 'navbar-faded', 'navbar-invisible');\n      }, 10);\n      this.capInserted = false;\n    }\n  }]);\n\n  return HSHeaderShowHideObserver;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/show-hide.js?");
    },
    "./src/js/observers/sticky.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSHeaderStickObserver; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ "./src/js/observers/abstract.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HSHeaderStickObserver = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderStickObserver, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderStickObserver);\n\n  function HSHeaderStickObserver(element) {\n    _classCallCheck(this, HSHeaderStickObserver);\n\n    return _super.call(this, element);\n  }\n\n  _createClass(HSHeaderStickObserver, [{\n    key: "init",\n    value: function init() {\n      this.defaultState = true;\n      this.offset = this.element.offsetTop;\n      return this;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.toDefaultState();\n      return this;\n    }\n  }, {\n    key: "check",\n    value: function check() {\n      var docScrolled = window.pageYOffset;\n\n      if (docScrolled > this.offset && this.defaultState) {\n        this.changeState();\n      } else if (docScrolled <= this.offset && !this.defaultState) {\n        this.toDefaultState();\n      }\n\n      return this;\n    }\n  }, {\n    key: "changeState",\n    value: function changeState() {\n      this.element.classList.add(\'navbar-scrolled\');\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }, {\n    key: "toDefaultState",\n    value: function toDefaultState() {\n      this.element.classList.remove(\'navbar-scrolled\');\n      this.defaultState = !this.defaultState;\n      return this;\n    }\n  }]);\n\n  return HSHeaderStickObserver;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/sticky.js?');
    },
    "./src/js/observers/without-behavior.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSHeaderWithoutBehaviorObserver; });\n/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract */ "./src/js/observers/abstract.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar HSHeaderWithoutBehaviorObserver = /*#__PURE__*/function (_HSAbstractObserver) {\n  _inherits(HSHeaderWithoutBehaviorObserver, _HSAbstractObserver);\n\n  var _super = _createSuper(HSHeaderWithoutBehaviorObserver);\n\n  function HSHeaderWithoutBehaviorObserver(element) {\n    _classCallCheck(this, HSHeaderWithoutBehaviorObserver);\n\n    return _super.call(this, element);\n  }\n\n  _createClass(HSHeaderWithoutBehaviorObserver, [{\n    key: "init",\n    value: function init() {\n      return this;\n    }\n  }, {\n    key: "check",\n    value: function check() {\n      return this;\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      return this;\n    }\n  }, {\n    key: "changeState",\n    value: function changeState() {\n      return this;\n    }\n  }, {\n    key: "toDefaultState",\n    value: function toDefaultState() {\n      return this;\n    }\n  }]);\n\n  return HSHeaderWithoutBehaviorObserver;\n}(_abstract__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n\n\n//# sourceURL=webpack://HSHeader/./src/js/observers/without-behavior.js?');
    },
    "./src/js/utils/slideDown.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\nvar slideDown = function slideDown(target) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  target.style.removeProperty('display');\n  var display = window.getComputedStyle(target).display;\n  if (display === 'none') display = 'block';\n  target.style.display = display;\n  var height = target.offsetHeight;\n  target.style.overflow = 'hidden';\n  target.style.height = 0;\n  target.style.paddingTop = 0;\n  target.style.paddingBottom = 0;\n  target.style.marginTop = 0;\n  target.style.marginBottom = 0;\n  target.offsetHeight;\n  target.style.boxSizing = 'border-box';\n  target.style.transitionProperty = \"height, margin, padding\";\n  target.style.transitionDuration = duration + 'ms';\n  target.style.height = height + 'px';\n  target.style.removeProperty('padding-top');\n  target.style.removeProperty('padding-bottom');\n  target.style.removeProperty('margin-top');\n  target.style.removeProperty('margin-bottom');\n  window.setTimeout(function () {\n    target.style.removeProperty('height');\n    target.style.removeProperty('overflow');\n    target.style.removeProperty('transition-duration');\n    target.style.removeProperty('transition-property');\n  }, duration);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (slideDown);\n\n//# sourceURL=webpack://HSHeader/./src/js/utils/slideDown.js?");
    },
    "./src/js/utils/slideUp.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\nvar slideUp = function slideUp(target) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  target.style.transitionProperty = 'height, margin, padding';\n  target.style.transitionDuration = duration + 'ms';\n  target.style.boxSizing = 'border-box';\n  target.style.height = target.offsetHeight + 'px';\n  target.offsetHeight;\n  target.style.overflow = 'hidden';\n  target.style.height = 0;\n  target.style.paddingTop = 0;\n  target.style.paddingBottom = 0;\n  target.style.marginTop = 0;\n  target.style.marginBottom = 0;\n  window.setTimeout(function () {\n    target.style.display = 'none';\n    target.style.removeProperty('height');\n    target.style.removeProperty('padding-top');\n    target.style.removeProperty('padding-bottom');\n    target.style.removeProperty('margin-top');\n    target.style.removeProperty('margin-bottom');\n    target.style.removeProperty('overflow');\n    target.style.removeProperty('transition-duration');\n    target.style.removeProperty('transition-property'); //alert(\"!\");\n  }, duration);\n  return target;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (slideUp);\n\n//# sourceURL=webpack://HSHeader/./src/js/utils/slideUp.js?");
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-header.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSMegaMenu = e() : t.HSMegaMenu = e(); }(window, (() => {
  return d = {
    "./src/js/hs-mega-menu.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSMegaMenu; });\n/* harmony import */ var _methods_object_assign_deep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/object-assign-deep */ "./src/js/methods/object-assign-deep.js");\n/* harmony import */ var _methods_object_assign_deep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_methods_object_assign_deep__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _methods_get_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/get-type */ "./src/js/methods/get-type.js");\n/* harmony import */ var _methods_smart_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods/smart-position */ "./src/js/methods/smart-position.js");\n/* harmony import */ var _methods_desktop_css_animation_enable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods/desktop-css-animation-enable */ "./src/js/methods/desktop-css-animation-enable.js");\n/* harmony import */ var _methods_desktop_mouseenter_event_listener__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./methods/desktop-mouseenter-event-listener */ "./src/js/methods/desktop-mouseenter-event-listener.js");\n/* harmony import */ var _methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./methods/desktop-mouseleave-event-listener */ "./src/js/methods/desktop-mouseleave-event-listener.js");\n/* harmony import */ var _methods_desktop_click_event_listener__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./methods/desktop-click-event-listener */ "./src/js/methods/desktop-click-event-listener.js");\n/* harmony import */ var _methods_mobile_click_event_listener__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./methods/mobile-click-event-listener */ "./src/js/methods/mobile-click-event-listener.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSMegaMenu Plugin\n* @version: 2.0.1 (Sun, 1 Nov 2021)\n* @author: HtmlStream\n* @event-namespace: .HSMegaMenu\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\n\n\n\n\n\n\n\n\nvar dataAttributeName = \'data-hs-mega-menu-options\';\nvar defaults = {\n  eventType: \'hover\',\n  direction: \'horizontal\',\n  breakpoint: \'lg\',\n  rtl: false,\n  isMenuOpened: false,\n  sideBarRatio: 1 / 4,\n  pageContainer: document.getElementsByTagName(\'body\'),\n  mobileSpeed: 400,\n  duration: 300,\n  delay: 0,\n  itemOptions: {\n    megaMenuTimeOut: null,\n    desktop: {\n      animation: \'animated\',\n      animationIn: \'slideInUp\',\n      animationOut: false,\n      position: null,\n      maxWidth: null\n    }\n  },\n  classMap: {\n    rtl: \'.hs-rtl\',\n    reversed: \'.hs-reversed\',\n    initialized: \'.hs-menu-initialized\',\n    mobileState: \'.hs-mobile-state\',\n    invoker: \'.hs-mega-menu-invoker\',\n    subMenu: \'.hs-sub-menu\',\n    hasSubMenu: \'.hs-has-sub-menu\',\n    hasSubMenuActive: \'.hs-sub-menu-opened\',\n    megaMenu: \'.hs-mega-menu\',\n    hasMegaMenu: \'.hs-has-mega-menu\',\n    hasMegaMenuActive: \'.hs-mega-menu-opened\'\n  }\n};\n\nvar HSMegaMenu = /*#__PURE__*/function () {\n  function HSMegaMenu(el, options, id) {\n    _classCallCheck(this, HSMegaMenu);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSMegaMenu, [{\n    key: "_init",\n    value: function _init() {\n      var _this = this;\n\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        _options.state = null; // Resolution list\n\n        resolutionsList = {\n          xs: 0,\n          sm: 576,\n          md: 768,\n          lg: 992,\n          xl: 1200\n        }; // Keycodes\n\n        ESC_KEYCODE = 27;\n        TAB_KEYCODE = 9;\n        ENTER_KEYCODE = 13;\n        SPACE_KEYCODE = 32;\n        ARROW_UP_KEYCODE = 38;\n        ARROW_DOWN_KEYCODE = 40;\n        ARROW_RIGHT_KEYCODE = 39;\n        ARROW_LEFT_KEYCODE = 37; // Prevent scroll\n\n        var preventScroll = function preventScroll(keycode) {\n          return function (e) {\n            if (e.which === keycode) {\n              e.preventDefault();\n            }\n          };\n        }; // Get Item Settings\n\n\n        var getItemSettings = function getItemSettings($el) {\n          if (!$el) return false;\n          var dataSettings = $el.hasAttribute(\'data-hs-mega-menu-item-options\') ? JSON.parse($el.getAttribute(\'data-hs-mega-menu-item-options\')) : {},\n              itemSettings = _options.itemOptions;\n          itemSettings = Object.assign({}, itemSettings, dataSettings);\n\n          itemSettings.activeItemClass = function () {\n            return Object(_methods_get_type__WEBPACK_IMPORTED_MODULE_1__["default"])($el, _options) === \'mega-menu\' ? _options.classMap.hasMegaMenuActive : _options.classMap.hasSubMenuActive;\n          };\n\n          return itemSettings;\n        };\n\n        var stateDetection = function stateDetection() {\n          if (window.innerWidth < resolutionsList[_options.breakpoint]) {\n            _this.state = \'mobile\';\n          } else {\n            _this.state = \'desktop\';\n          }\n        };\n\n        stateDetection(); // State Detection\n\n        window.addEventListener(\'resize\', function () {\n          stateDetection();\n        }); // Set RTL\n\n        if (_options.rtl) {\n          _$el.addClass(_options.classMap.rtl.slice(1));\n        } // Init Menu Items\n\n\n        _$el.querySelectorAll("".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)).forEach(function (el) {\n          _this.MegaMenuItem(el, el.querySelector(_options.classMap[Object(_methods_get_type__WEBPACK_IMPORTED_MODULE_1__["default"])(el, _options) === \'mega-menu\' ? \'megaMenu\' : \'subMenu\']), _options);\n        }); // Add Initialized Classes\n\n\n        _$el.classList.add("".concat(_options.classMap.initialized.slice(1)), "hs-menu-".concat(_options.direction)); // *****\n        // Start: ACCESSIBILITY\n        // *****\n\n\n        myPreventScrollSpace = preventScroll(SPACE_KEYCODE);\n        myPreventScrollDown = preventScroll(ARROW_DOWN_KEYCODE);\n        myPreventScrollUp = preventScroll(ARROW_UP_KEYCODE);\n        var $items = void 0,\n            index = void 0,\n            state = null;\n        document.addEventListener(\'keyup\', function () {\n          window.removeEventListener(\'keydown\', myPreventScrollSpace, false);\n          window.removeEventListener(\'keydown\', myPreventScrollUp, false);\n          window.removeEventListener(\'keydown\', myPreventScrollDown, false);\n        });\n        document.addEventListener(\'keyup\', function (e) {\n          if (!e.target.closest("".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu))) return false; //\n          // Start: PREVENT SCROLL\n          //\n\n          e.preventDefault();\n          e.stopPropagation();\n          window.addEventListener(\'keydown\', myPreventScrollSpace, false);\n          window.addEventListener(\'keydown\', myPreventScrollUp, false);\n          window.addEventListener(\'keydown\', myPreventScrollDown, false); //\n          // End: PREVENT SCROLL\n          //\n          //\n          // Start: ELEMENT DETECTION\n          //\n\n          if (e.target.classList.contains(_options.classMap.invoker.slice(1)) && !e.target.closest(["".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu)])) {\n            // console.log(\'Top level\');\n            if (state !== \'topLevel\') {\n              state = \'topLevel\';\n            }\n\n            $items = [].slice.call(e.target.parentNode.parentNode.querySelectorAll(_options.classMap.invoker)).filter(function (item) {\n              if (!item.closest(["".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu)])) {\n                return item.offsetParent !== null;\n              }\n            });\n          } else if (e.target.closest(["".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu)]) && e.target.parentNode.querySelector("".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu))) {\n            // console.log(\'Has submenu and not top level\');\n            if (state !== \'hasSubmenu\') {\n              state = \'hasSubmenu\';\n            }\n\n            $items = [].slice.call(e.target.parentNode.parentNode.querySelectorAll(_options.classMap.invoker)).filter(function (item) {\n              return item.offsetParent !== null;\n            });\n          } else {\n            // console.log(\'Just element\');\n            if (state !== \'simple\') {\n              state = \'simple\';\n            }\n\n            $items = [].slice.call(e.target.closest(["".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu)]).querySelectorAll(\'a, button\')).filter(function (item) {\n              return item.offsetParent !== null;\n            });\n          } //\n          // End: ELEMENT DETECTION\n          //\n\n\n          index = $items.indexOf(e.target); //\n          // Start: TOP LEVEL\n          //\n          // Left\n\n          if (state === \'topLevel\' && e.which === ARROW_LEFT_KEYCODE && index > 0) {\n            index--;\n          } // Right\n\n\n          if (state === \'topLevel\' && e.which === ARROW_RIGHT_KEYCODE && index < $items.length - 1) {\n            index++;\n          } // Open Sub\n\n\n          if (state === \'topLevel\' && (e.which === ARROW_DOWN_KEYCODE || e.which === SPACE_KEYCODE || e.which === ENTER_KEYCODE)) {\n            if (!e.target.parentNode.querySelector(["".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)])) {\n              Object(_methods_desktop_mouseenter_event_listener__WEBPACK_IMPORTED_MODULE_4__["default"])(e.target.parentNode, e.target.parentNode.querySelector(["".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu)]), _options, getItemSettings(e.target.parentNode))();\n            } else if (e.target.parentNode.querySelector(["".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)])) {\n              e.target.parentNode.querySelector(["".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)]).querySelectorAll(\'a\')[0].focus();\n              return;\n            }\n          } // Close Siblings\n\n\n          if (state === \'topLevel\' && (e.which === TAB_KEYCODE || e.which === ARROW_RIGHT_KEYCODE || e.which === ARROW_LEFT_KEYCODE) && e.target.closest("".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)).parentNode.querySelector("".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn))) {\n            Object(_methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__["default"])(e.target.closest("".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)), e.target.closest("".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)).parentNode.querySelector("".concat(_options.classMap.hasMegaMenuActive, " > ").concat(_options.classMap.megaMenu, ", ").concat(_options.classMap.hasSubMenuActive, " > ").concat(_options.classMap.subMenu)), _options, getItemSettings(e.target.closest("".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu))))();\n          } //\n          // End: TOP LEVEL\n          //\n          //\n          // Start: HAS SUB-MENU BUT NOT TOP LEVEL\n          //\n          // Up\n\n\n          if (state === \'hasSubmenu\' && e.which === ARROW_UP_KEYCODE && index > 0) {\n            index--;\n          } // Down\n\n\n          if (state === \'hasSubmenu\' && e.which === ARROW_DOWN_KEYCODE && index < $items.length - 1) {\n            index++;\n          } // Open Sub\n\n\n          if (state === \'hasSubmenu\' && (e.which === ARROW_LEFT_KEYCODE || e.which === ARROW_RIGHT_KEYCODE || e.which === SPACE_KEYCODE || e.which === ENTER_KEYCODE)) {\n            if (!e.target.parentNode.querySelector(["".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)])) {\n              Object(_methods_desktop_mouseenter_event_listener__WEBPACK_IMPORTED_MODULE_4__["default"])(e.target.parentNode, e.target.parentNode.querySelector(["".concat(_options.classMap.subMenu, ", ").concat(_options.classMap.megaMenu)]), _options, getItemSettings(e.target.parentNode))();\n            } else if (e.target.parentNode.querySelector(["".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)])) {\n              e.target.parentNode.querySelector(["".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)]).querySelectorAll(\'a\')[0].focus();\n              return;\n            }\n          } // Close Siblings\n\n\n          if (state === \'hasSubmenu\' && (e.which === TAB_KEYCODE || e.which === ARROW_DOWN_KEYCODE || e.which === ARROW_UP_KEYCODE) && e.target.closest(["".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)]).parentNode.querySelectorAll("".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)).length) {\n            Object(_methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__["default"])(e.target.closest(["".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)]), e.target.closest(["".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)]).parentNode.querySelector("".concat(_options.classMap.hasMegaMenuActive, " > ").concat(_options.classMap.megaMenu, ", ").concat(_options.classMap.hasSubMenuActive, " > ").concat(_options.classMap.subMenu)), _options, getItemSettings(e.target.closest(["".concat(_options.classMap.hasMegaMenu, ", ").concat(_options.classMap.hasSubMenu)])))();\n          } //\n          // End: HAS SUB-MENU BUT NOT TOP LEVEL\n          //\n          //\n          // Start: SIMPLE\n          //\n          // Left, Up\n\n\n          if (state === \'simple\' && e.which === ARROW_UP_KEYCODE && index > 0) {\n            index--;\n          } // Right, Down\n\n\n          if (state === \'simple\' && e.which === ARROW_DOWN_KEYCODE && index < $items.length - 1) {\n            index++;\n          } // Close Siblings\n\n\n          if (state === \'simple\' && (e.which === ARROW_RIGHT_KEYCODE || e.which === ARROW_LEFT_KEYCODE) && e.target.closest(_options.classMap.hasSubMenu).parentNode.querySelector(_options.classMap.subMenu)) {\n            e.target.closest(_options.classMap.hasSubMenu).querySelector(_options.classMap.invoker).focus();\n            Object(_methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__["default"])(e.target.closest(_options.classMap.hasSubMenu), e.target.closest(_options.classMap.hasSubMenu).parentNode.querySelector("".concat(_options.classMap.hasSubMenuActive, " > ").concat(_options.classMap.subMenu)), _options, getItemSettings(e.target.closest(_options.classMap.hasSubMenu)))();\n            return;\n          } //\n          // End: SIMPLE\n          //\n          // Close Self\n\n\n          if (e.which === ESC_KEYCODE && _this.state === \'desktop\' && document.querySelector("".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn))) {\n            Object(_methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__["default"])(document.querySelector("".concat(_options.classMap.hasMegaMenuActive, ", ").concat(_options.classMap.hasSubMenuActive)), document.querySelector("".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)), _options, getItemSettings(document.querySelector("".concat(_options.classMap.hasMegaMenuActive, ", ").concat(_options.classMap.hasSubMenuActive))))();\n            return;\n          } // Reset index\n\n\n          if (index < 0) {\n            index = 0;\n          }\n\n          $items[index].focus();\n        });\n        document.addEventListener(\'keyup\', function (e) {\n          // Close All\n          if (e.which === TAB_KEYCODE && document.querySelector("".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn))) {\n            Object(_methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__["default"])(document.querySelector("".concat(_options.classMap.hasMegaMenuActive, ", ").concat(_options.classMap.hasSubMenuActive)), document.querySelector("".concat(_options.classMap.megaMenu, ".").concat(_options.itemOptions.desktop.animationIn, ", ").concat(_options.classMap.subMenu, ".").concat(_options.itemOptions.desktop.animationIn)), _options, getItemSettings(document.querySelector("".concat(_options.classMap.hasMegaMenuActive, ", ").concat(_options.classMap.hasSubMenuActive))))();\n          }\n        }); // *****\n        // End: ACCESSIBILITY\n        // *****\n\n        that.collection[i].$initializedEl = _options;\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var resolutionsList;\n        var ESC_KEYCODE, TAB_KEYCODE, ENTER_KEYCODE, SPACE_KEYCODE, ARROW_UP_KEYCODE, ARROW_DOWN_KEYCODE, ARROW_RIGHT_KEYCODE, ARROW_LEFT_KEYCODE;\n        var myPreventScrollSpace, myPreventScrollDown, myPreventScrollUp;\n\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "MegaMenuItem",\n    value: function MegaMenuItem(el, menu, params) {\n      var context = this,\n          settings = params,\n          itemDataSettings = el.hasAttribute(\'data-hs-mega-menu-item-options\') ? JSON.parse(el.getAttribute(\'data-hs-mega-menu-item-options\')) : {},\n          $el = el,\n          $menu = menu;\n      var itemSettings = {\n        eventType: itemDataSettings.eventType ? itemDataSettings.eventType : settings.eventType,\n        megaMenuTimeOut: null,\n        desktop: {\n          animation: \'animated\',\n          animationIn: \'slideInUp\',\n          animationOut: false,\n          position: null,\n          maxWidth: null\n        }\n      };\n      itemSettings = _methods_object_assign_deep__WEBPACK_IMPORTED_MODULE_0___default()({}, settings, itemSettings, itemDataSettings);\n\n      itemSettings.activeItemClass = function () {\n        return Object(_methods_get_type__WEBPACK_IMPORTED_MODULE_1__["default"])($el, itemSettings) === \'mega-menu\' ? itemSettings.classMap.hasMegaMenuActive : itemSettings.classMap.hasSubMenuActive;\n      }; // Set Menu Breakpoint Class\n\n\n      $menu.classList.add(Object(_methods_get_type__WEBPACK_IMPORTED_MODULE_1__["default"])($el, itemSettings) === \'mega-menu\' ? "hs-mega-menu-desktop-".concat(itemSettings.breakpoint) : "hs-sub-menu-desktop-".concat(itemSettings.breakpoint)); // Listeners\n\n      var myDesktopCSSAnimationEnable = Object(_methods_desktop_css_animation_enable__WEBPACK_IMPORTED_MODULE_3__["default"])($menu, itemSettings),\n          myDesktopMouseEnterEventListener = Object(_methods_desktop_mouseenter_event_listener__WEBPACK_IMPORTED_MODULE_4__["default"])($el, $menu, settings, itemSettings),\n          myDesktopMouseLeaveEventListener = Object(_methods_desktop_mouseleave_event_listener__WEBPACK_IMPORTED_MODULE_5__["default"])($el, $menu, settings, itemSettings),\n          myDesktopClickEventListener = Object(_methods_desktop_click_event_listener__WEBPACK_IMPORTED_MODULE_6__["default"])($el, $menu, settings, itemSettings),\n          myMobileClickEventListener = Object(_methods_mobile_click_event_listener__WEBPACK_IMPORTED_MODULE_7__["default"])($el, $menu, settings, itemSettings);\n\n      var mobileListeners = function mobileListeners() {\n        // Remove Desktop Listeners\n        $menu.removeEventListener(\'animationend\', myDesktopCSSAnimationEnable, false);\n        $menu.removeEventListener(\'webkitAnimationEnd\', myDesktopCSSAnimationEnable, false);\n        $el.removeEventListener(\'mouseenter\', myDesktopMouseEnterEventListener, false);\n        $el.removeEventListener(\'mouseleave\', myDesktopMouseLeaveEventListener, false); // $el.children(settings.classMap.invoker)[0].removeEventListener(\'focus\', myDesktopMouseEnterEventListener, false);\n\n        $el.querySelector(itemSettings.classMap.invoker).removeEventListener(\'click\', myDesktopClickEventListener, false); // Add Mobile Listeners\n\n        $el.querySelector(itemSettings.classMap.invoker).addEventListener(\'click\', myMobileClickEventListener, false);\n      },\n          desktopListeners = function desktopListeners() {\n        // Remove Mobile Listeners\n        $el.querySelector(itemSettings.classMap.invoker).removeEventListener(\'click\', myMobileClickEventListener, false); // Add Desktop Listeners\n\n        $menu.addEventListener(\'animationend\', myDesktopCSSAnimationEnable, false);\n        $menu.addEventListener(\'webkitAnimationEnd\', myDesktopCSSAnimationEnable, false);\n\n        if (itemSettings.eventType === \'hover\') {\n          $el.addEventListener(\'mouseenter\', myDesktopMouseEnterEventListener, false);\n          $el.addEventListener(\'mouseleave\', myDesktopMouseLeaveEventListener, false);\n        }\n\n        if (itemSettings.eventType === \'click\') {\n          $el.querySelector(itemSettings.classMap.invoker).addEventListener(\'click\', myDesktopClickEventListener, false);\n        }\n      };\n\n      if (itemSettings.desktop.maxWidth) {\n        $menu.style.maxWidth = itemSettings.desktop.maxWidth;\n      }\n\n      if (itemSettings.desktop.position) {\n        $menu.classList.add("hs-position-".concat(itemSettings.desktop.position));\n      } // Document Events\n\n\n      document.addEventListener(\'click\', function (e) {\n        if (!e.target.closest([itemSettings.classMap.subMenu, itemSettings.classMap.megaMenu, itemSettings.classMap.invoker]) && context.state === \'desktop\') {\n          $el.classList.remove(itemSettings.activeItemClass().slice(1));\n          $menu.classList.remove(itemSettings.desktop.animationIn);\n\n          if (itemSettings.animationOut) {\n            $menu.classList.add(itemSettings.desktop.animationOut);\n          } else {\n            $menu.style.display = \'none\';\n          }\n        }\n      }); // Resize and Scroll Events\n\n      window.addEventListener(\'resize\', function () {\n        if (context.state === \'desktop\') {\n          Object(_methods_smart_position__WEBPACK_IMPORTED_MODULE_2__["default"])($menu, itemSettings);\n        }\n      });\n\n      var resizeDetection = function resizeDetection() {\n        if (context.state === \'mobile\') {\n          $menu.classList.remove(itemSettings.desktop.animation);\n          $menu.style.animationDuration = \'\';\n          mobileListeners();\n        } else if (context.state === \'desktop\') {\n          $menu.classList.add(itemSettings.desktop.animation);\n          $menu.style.animationDuration = "".concat(itemSettings.duration, "ms");\n          desktopListeners();\n        }\n      };\n\n      resizeDetection(); // State Detection\n\n      window.addEventListener(\'resize\', function () {\n        resizeDetection();\n      });\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: _methods_object_assign_deep__WEBPACK_IMPORTED_MODULE_0___default()({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItems",\n    value: function getItems() {\n      var that = this;\n      var newCollection = [];\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        newCollection.push(that.collection[i].$initializedEl);\n      }\n\n      return newCollection;\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(ind) {\n      return this.collection[ind].$initializedEl;\n    }\n  }]);\n\n  return HSMegaMenu;\n}();\n\n\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/hs-mega-menu.js?');
    },
    "./src/js/methods/desktop-click-event-listener.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return desktopClickEventListener; });\n/* harmony import */ var _get_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-type */ "./src/js/methods/get-type.js");\n/* harmony import */ var _smart_position__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./smart-position */ "./src/js/methods/smart-position.js");\n/* harmony import */ var _desktop_show__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./desktop-show */ "./src/js/methods/desktop-show.js");\n/* harmony import */ var _desktop_hide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./desktop-hide */ "./src/js/methods/desktop-hide.js");\n\n\n\n\nfunction desktopClickEventListener(el, menu, params, itemParams) {\n  return function () {\n    var $siblingInvokers = menu.closest("".concat(params.classMap.hasMegaMenu, ", ").concat(params.classMap.hasSubMenu)).parentNode.querySelectorAll("".concat(params.classMap.hasMegaMenu).concat(params.classMap.hasMegaMenuActive, ", ").concat(params.classMap.hasSubMenu).concat(params.classMap.hasSubMenuActive));\n\n    if ($siblingInvokers.length) {\n      $siblingInvokers.forEach(function ($el) {\n        var $menu = $el.querySelector("".concat(params.classMap.megaMenu, ", ").concat(params.classMap.subMenu)),\n            itemDataSettings = $el.hasAttribute(\'data-hs-mega-menu-item-options\') ? JSON.parse($el.getAttribute(\'data-hs-mega-menu-item-options\')) : {};\n        var itemSettings = {\n          desktop: {\n            animation: \'animated\',\n            animationIn: \'slideInUp\',\n            animationOut: \'fadeOut\',\n            position: null\n          }\n        };\n        itemSettings = Object.assign({}, itemSettings, itemDataSettings);\n\n        itemSettings.activeItemClass = function () {\n          return Object(_get_type__WEBPACK_IMPORTED_MODULE_0__["default"])($el, params) === \'mega-menu\' ? params.classMap.hasMegaMenuActive : params.classMap.hasSubMenuActive;\n        };\n\n        $el.classList.remove(itemSettings.activeItemClass().slice(1));\n        Object(_desktop_hide__WEBPACK_IMPORTED_MODULE_3__["default"])($el, $menu, params, itemSettings);\n      });\n    }\n\n    if (menu.previousElementSibling.classList.contains(\'show\')) {\n      el.classList.add(itemParams.activeItemClass().slice(1));\n      Object(_desktop_show__WEBPACK_IMPORTED_MODULE_2__["default"])(el, menu, params, itemParams);\n      Object(_smart_position__WEBPACK_IMPORTED_MODULE_1__["default"])(menu, params);\n    }\n  };\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/desktop-click-event-listener.js?');
    },
    "./src/js/methods/desktop-css-animation-enable.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return desktopCSSAnimationEnable; });\nfunction desktopCSSAnimationEnable(menu, itemParams) {\n  return function (e) {\n    if (menu.classList.contains(itemParams.desktop.animationOut)) {\n      menu.classList.remove(itemParams.desktop.animationOut);\n      menu.style.display = 'none';\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n  };\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/desktop-css-animation-enable.js?");
    },
    "./src/js/methods/desktop-hide.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return desktopHide; });\nfunction desktopHide(el, menu, params, itemParams) {\n  if (!menu) {\n    return this;\n  }\n\n  if (itemParams.desktop.animationOut) {\n    menu.classList.remove(itemParams.desktop.animationIn);\n    menu.classList.add(itemParams.desktop.animationOut);\n    menu.style.display = 'none';\n  } else {\n    menu.classList.remove(itemParams.desktop.animationIn);\n    menu.style.display = 'none';\n  }\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/desktop-hide.js?");
    },
    "./src/js/methods/desktop-mouseenter-event-listener.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return desktopMouseEnterEventListener; });\n/* harmony import */ var _smart_position__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./smart-position */ "./src/js/methods/smart-position.js");\n/* harmony import */ var _desktop_show__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./desktop-show */ "./src/js/methods/desktop-show.js");\n/* harmony import */ var _get_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-type */ "./src/js/methods/get-type.js");\n/* harmony import */ var _desktop_hide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./desktop-hide */ "./src/js/methods/desktop-hide.js");\n\n\n\n\nfunction desktopMouseEnterEventListener(el, menu, params, itemParams) {\n  return function () {\n    if (itemParams.megaMenuTimeOut) {\n      clearTimeout(itemParams.megaMenuTimeOut);\n    }\n\n    var $siblingInvokers = menu.closest("".concat(params.classMap.hasMegaMenu, ", ").concat(params.classMap.hasSubMenu)).parentNode.querySelectorAll("".concat(params.classMap.hasMegaMenu).concat(params.classMap.hasMegaMenuActive, ", ").concat(params.classMap.hasSubMenu).concat(params.classMap.hasSubMenuActive));\n\n    if ($siblingInvokers.length) {\n      $siblingInvokers.forEach(function ($el) {\n        var $menu = $el.querySelector("".concat(params.classMap.megaMenu, ", ").concat(params.classMap.subMenu)),\n            itemDataSettings = $el.hasAttribute(\'data-hs-mega-menu-item-options\') ? JSON.parse($el.getAttribute(\'data-hs-mega-menu-item-options\')) : {};\n        var itemSettings = {\n          desktop: {\n            animation: \'animated\',\n            animationIn: \'slideInUp\',\n            animationOut: \'fadeOut\',\n            position: null\n          }\n        };\n        itemSettings = Object.assign({}, itemSettings, itemDataSettings);\n\n        itemSettings.activeItemClass = function () {\n          return Object(_get_type__WEBPACK_IMPORTED_MODULE_2__["default"])($el, params) === \'mega-menu\' ? params.classMap.hasMegaMenuActive : params.classMap.hasSubMenuActive;\n        };\n\n        $el.classList.remove(itemSettings.activeItemClass().slice(1));\n        Object(_desktop_hide__WEBPACK_IMPORTED_MODULE_3__["default"])($el, $menu, params, itemSettings);\n      });\n    }\n\n    el.classList.add(itemParams.activeItemClass().slice(1));\n    Object(_desktop_show__WEBPACK_IMPORTED_MODULE_1__["default"])(el, menu, params, itemParams);\n    Object(_smart_position__WEBPACK_IMPORTED_MODULE_0__["default"])(menu, params);\n  };\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/desktop-mouseenter-event-listener.js?');
    },
    "./src/js/methods/desktop-mouseleave-event-listener.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return desktopMouseLeaveEventListener; });\n/* harmony import */ var _desktop_hide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./desktop-hide */ "./src/js/methods/desktop-hide.js");\n\nfunction desktopMouseLeaveEventListener(el, menu, params, itemParams) {\n  return function () {\n    itemParams.megaMenuTimeOut = setTimeout(function () {\n      el.classList.remove(itemParams.activeItemClass().slice(1));\n      Object(_desktop_hide__WEBPACK_IMPORTED_MODULE_0__["default"])(el, menu, params, itemParams);\n    }, params.delay);\n  };\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/desktop-mouseleave-event-listener.js?');
    },
    "./src/js/methods/desktop-show.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return desktopShow; });\nfunction desktopShow(el, menu, params, itemParams) {\n  menu.classList.remove(itemParams.desktop.animationOut);\n  menu.style.display = 'block';\n  menu.classList.add(itemParams.desktop.animationIn);\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/desktop-show.js?");
    },
    "./src/js/methods/get-type.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getType; });\nfunction getType(el, params) {\n  if (!el) {\n    return false;\n  }\n\n  return el.classList.contains(params.classMap.hasSubMenu.slice(1)) ? 'sub-menu' : el.classList.contains(params.classMap.hasMegaMenu.slice(1)) ? 'mega-menu' : null;\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/get-type.js?");
    },
    "./src/js/methods/mobile-click-event-listener.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mobileClickEventListener; });\n/* harmony import */ var _get_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-type */ "./src/js/methods/get-type.js");\n/* harmony import */ var _mobile_show__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mobile-show */ "./src/js/methods/mobile-show.js");\n/* harmony import */ var _mobile_hide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mobile-hide */ "./src/js/methods/mobile-hide.js");\n\n\n\nfunction mobileClickEventListener(el, menu, params, itemParams) {\n  return function () {\n    var $siblingInvokers = menu.closest("".concat(params.classMap.hasMegaMenu, ", ").concat(params.classMap.hasSubMenu)).parentNode.querySelectorAll("".concat(params.classMap.hasMegaMenu).concat(params.classMap.hasMegaMenuActive, ", ").concat(params.classMap.hasSubMenu).concat(params.classMap.hasSubMenuActive));\n\n    if ($siblingInvokers.length) {\n      $siblingInvokers.forEach(function ($el) {\n        var $menu = $el.querySelector("".concat(params.classMap.megaMenu, ", ").concat(params.classMap.subMenu)),\n            itemSettings = {};\n\n        itemSettings.activeItemClass = function () {\n          return Object(_get_type__WEBPACK_IMPORTED_MODULE_0__["default"])($el, params) === \'mega-menu\' ? params.classMap.hasMegaMenuActive : params.classMap.hasSubMenuActive;\n        };\n\n        Object(_mobile_hide__WEBPACK_IMPORTED_MODULE_2__["default"])($el, $menu, params, itemSettings);\n      });\n    }\n\n    if (menu.offsetParent === null) {\n      Object(_mobile_show__WEBPACK_IMPORTED_MODULE_1__["default"])(el, menu, params, itemParams);\n    } else {\n      Object(_mobile_hide__WEBPACK_IMPORTED_MODULE_2__["default"])(el, menu, params, itemParams);\n    }\n  };\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/mobile-click-event-listener.js?');
    },
    "./src/js/methods/mobile-hide.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mobileHide; });\n/* harmony import */ var _slideUp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slideUp */ "./src/js/methods/slideUp.js");\n\nfunction mobileHide(el, menu, params, itemParams) {\n  if (!menu) {\n    return this;\n  }\n\n  el.classList.remove(itemParams.activeItemClass().slice(1));\n  Object(_slideUp__WEBPACK_IMPORTED_MODULE_0__["default"])(menu, params.mobileSpeed);\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/mobile-hide.js?');
    },
    "./src/js/methods/mobile-show.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mobileShow; });\n/* harmony import */ var _slideDown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slideDown */ "./src/js/methods/slideDown.js");\n\nfunction mobileShow(el, menu, params, itemParams) {\n  if (!menu) {\n    return this;\n  }\n\n  el.classList.add(itemParams.activeItemClass().slice(1));\n  Object(_slideDown__WEBPACK_IMPORTED_MODULE_0__["default"])(menu, params.mobileSpeed);\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/mobile-show.js?');
    },
    "./src/js/methods/object-assign-deep.js": function (module, exports, __webpack_require__) {
      eval("\n/*\n * OBJECT ASSIGN DEEP\n * Allows deep cloning of plain objects that contain primitives, nested plain objects, or nested plain arrays.\n */\n\n/*\n * A unified way of returning a string that describes the type of the given variable.\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction getTypeOf(input) {\n  if (input === null) {\n    return 'null';\n  } else if (typeof input === 'undefined') {\n    return 'undefined';\n  } else if (_typeof(input) === 'object') {\n    return Array.isArray(input) ? 'array' : 'object';\n  }\n\n  return _typeof(input);\n}\n/*\n * Branching logic which calls the correct function to clone the given value base on its type.\n */\n\n\nfunction cloneValue(value) {\n  // The value is an object so lets clone it.\n  if (getTypeOf(value) === 'object') {\n    return quickCloneObject(value);\n  } // The value is an array so lets clone it.\n  else if (getTypeOf(value) === 'array') {\n    return quickCloneArray(value);\n  } // Any other value can just be copied.\n\n\n  return value;\n}\n/*\n * Enumerates the given array and returns a new array, with each of its values cloned (i.e. references broken).\n */\n\n\nfunction quickCloneArray(input) {\n  return input.map(cloneValue);\n}\n/*\n * Enumerates the properties of the given object (ignoring the prototype chain) and returns a new object, with each of\n * its values cloned (i.e. references broken).\n */\n\n\nfunction quickCloneObject(input) {\n  var output = {};\n\n  for (var key in input) {\n    if (!Object.prototype.hasOwnProperty.call(input, key)) {\n      continue;\n    }\n\n    output[key] = cloneValue(input[key]);\n  }\n\n  return output;\n}\n/*\n * Does the actual deep merging.\n */\n\n\nfunction executeDeepMerge(target) {\n  var _objects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  var _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var options = {\n    arrayBehaviour: _options.arrayBehaviour || 'replace' // Can be \"merge\" or \"replace\".\n\n  }; // Ensure we have actual objects for each.\n\n  var objects = _objects.map(function (object) {\n    return object || {};\n  });\n\n  var output = target || {}; // Enumerate the objects and their keys.\n\n  for (var oindex = 0; oindex < objects.length; oindex++) {\n    var object = objects[oindex];\n    var keys = Object.keys(object);\n\n    for (var kindex = 0; kindex < keys.length; kindex++) {\n      var key = keys[kindex];\n      var value = object[key];\n      var type = getTypeOf(value);\n      var existingValueType = getTypeOf(output[key]);\n\n      if (type === 'object') {\n        if (existingValueType !== 'undefined') {\n          var existingValue = existingValueType === 'object' ? output[key] : {};\n          output[key] = executeDeepMerge({}, [existingValue, quickCloneObject(value)], options);\n        } else {\n          output[key] = quickCloneObject(value);\n        }\n      } else if (type === 'array') {\n        if (existingValueType === 'array') {\n          var newValue = quickCloneArray(value);\n          output[key] = options.arrayBehaviour === 'merge' ? output[key].concat(newValue) : newValue;\n        } else {\n          output[key] = quickCloneArray(value);\n        }\n      } else {\n        output[key] = value;\n      }\n    }\n  }\n\n  return output;\n}\n/*\n * Merge all the supplied objects into the target object, breaking all references, including those of nested objects\n * and arrays, and even objects nested inside arrays. The first parameter is not mutated unlike Object.assign().\n * Properties in later objects will always overwrite.\n */\n\n\nmodule.exports = function objectAssignDeep(target) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  return executeDeepMerge(target, objects);\n};\n/*\n * Same as objectAssignDeep() except it doesn't mutate the target object and returns an entirely new object.\n */\n\n\nmodule.exports.noMutate = function objectAssignDeepInto() {\n  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    objects[_key2] = arguments[_key2];\n  }\n\n  return executeDeepMerge({}, objects);\n};\n/*\n * Allows an options object to be passed in to customise the behaviour of the function.\n */\n\n\nmodule.exports.withOptions = function objectAssignDeepInto(target, objects, options) {\n  return executeDeepMerge(target, objects, options);\n};\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/object-assign-deep.js?");
    },
    "./src/js/methods/offset.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (function (el) {\n  if (!el) return false;\n  var rect = el.getBoundingClientRect();\n  return {\n    top: rect.top - window.scrollY,\n    left: rect.left - window.scrollX\n  };\n});\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/offset.js?');
    },
    "./src/js/methods/slideDown.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\nvar slideDown = function slideDown(target) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  target.style.removeProperty('display');\n  var display = window.getComputedStyle(target).display;\n  if (display === 'none') display = 'block';\n  target.style.display = display;\n  var height = target.offsetHeight;\n  target.style.overflow = 'hidden';\n  target.style.height = 0;\n  target.style.paddingTop = 0;\n  target.style.paddingBottom = 0;\n  target.style.marginTop = 0;\n  target.style.marginBottom = 0;\n  target.offsetHeight;\n  target.style.boxSizing = 'border-box';\n  target.style.transitionProperty = \"height, margin, padding\";\n  target.style.transitionDuration = duration + 'ms';\n  target.style.height = height + 'px';\n  target.style.removeProperty('padding-top');\n  target.style.removeProperty('padding-bottom');\n  target.style.removeProperty('margin-top');\n  target.style.removeProperty('margin-bottom');\n  window.setTimeout(function () {\n    target.style.removeProperty('height');\n    target.style.removeProperty('overflow');\n    target.style.removeProperty('transition-duration');\n    target.style.removeProperty('transition-property');\n  }, duration);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (slideDown);\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/slideDown.js?");
    },
    "./src/js/methods/slideUp.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\nvar slideUp = function slideUp(target) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n  target.style.transitionProperty = 'height, margin, padding';\n  target.style.transitionDuration = duration + 'ms';\n  target.style.boxSizing = 'border-box';\n  target.style.height = target.offsetHeight + 'px';\n  target.offsetHeight;\n  target.style.overflow = 'hidden';\n  target.style.height = 0;\n  target.style.paddingTop = 0;\n  target.style.paddingBottom = 0;\n  target.style.marginTop = 0;\n  target.style.marginBottom = 0;\n  window.setTimeout(function () {\n    target.style.display = 'none';\n    target.style.removeProperty('height');\n    target.style.removeProperty('padding-top');\n    target.style.removeProperty('padding-bottom');\n    target.style.removeProperty('margin-top');\n    target.style.removeProperty('margin-bottom');\n    target.style.removeProperty('overflow');\n    target.style.removeProperty('transition-duration');\n    target.style.removeProperty('transition-property'); //alert(\"!\");\n  }, duration);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (slideUp);\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/slideUp.js?");
    },
    "./src/js/methods/smart-position.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return smartPosition; });\n/* harmony import */ var _offset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./offset */ "./src/js/methods/offset.js");\n\nfunction smartPosition(el, params) {\n  if (!el) return;\n\n  if (!params.rtl) {\n    if (Object(_offset__WEBPACK_IMPORTED_MODULE_0__["default"])(el).left + el.offsetWidth > window.innerWidth) {\n      el.classList.add(params.classMap.reversed.slice(1));\n    }\n  } else {\n    if (Object(_offset__WEBPACK_IMPORTED_MODULE_0__["default"])(el).left < 0) {\n      el.classList.add(params.classMap.reversed.slice(1));\n    }\n  }\n}\n\n//# sourceURL=webpack://HSMegaMenu/./src/js/methods/smart-position.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-mega-menu.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSShowAnimation = e() : t.HSShowAnimation = e(); }(window, (() => {
  return d = {
    "./src/js/hs-show-animation.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSShowAnimation; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/js/utils.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSShowAnimation Plugin\n* @version: 3.0.0 (Sat, 20 Nov 2021)\n* @author: HtmlStream\n* @event-namespace: .HSShowAnimation\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\n\nvar dataAttributeName = \'data-hs-show-animation-options\';\nvar defaults = {\n  groupName: null,\n  targetSelector: null,\n  siblingSelector: null,\n  eventType: \'click\',\n  classMap: {\n    active: \'active\'\n  },\n  animationType: \'simple\',\n  animationInit: \'animated\',\n  animationIn: null,\n  duration: null,\n  afterShow: function afterShow() {}\n};\n\nvar HSShowAnimation = /*#__PURE__*/function () {\n  function HSShowAnimation(el, options, id) {\n    _classCallCheck(this, HSShowAnimation);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSShowAnimation, [{\n    key: "_init",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        that.prepareObject(_$el, _options);\n\n        _$el.addEventListener(_options.eventType, function (e) {\n          e.preventDefault();\n\n          if (_$el.classList.contains(_options.classMap.active)) {\n            return;\n          }\n\n          that.activeClassChange(_options);\n\n          if (_options.animationType === \'css-animation\') {\n            that.cssAnimation(_options);\n          } else {\n            that.simpleAnimation(_options);\n          }\n        });\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "prepareObject",\n    value: function prepareObject($el, settings) {\n      var $targetSelector = document.querySelector(settings.targetSelector),\n          $siblingSelector = document.querySelector(settings.siblingSelector);\n      $el.setAttribute(\'data-hs-show-animation-link-group\', settings.groupName);\n\n      if (settings.duration) {\n        $targetSelector.style.animationDuration = "".concat(settings.duration, "ms");\n      }\n\n      $targetSelector.setAttribute(\'data-hs-show-animation-target-group\', settings.groupName);\n\n      if ($siblingSelector) {\n        $siblingSelector.setAttribute(\'data-hs-show-animation-target-group\', settings.groupName);\n      }\n    }\n  }, {\n    key: "activeClassChange",\n    value: function activeClassChange(settings) {\n      var $targets = document.querySelectorAll("[data-hs-show-animation-link-group=\\"".concat(settings.groupName, "\\"]"));\n\n      if ($targets.length) {\n        $targets.forEach(function ($item) {\n          return $item.classList.remove(settings.classMap.active);\n        });\n      }\n    }\n  }, {\n    key: "simpleAnimation",\n    value: function simpleAnimation(settings) {\n      var $targets = document.querySelectorAll("[data-hs-show-animation-target-group=\\"".concat(settings.groupName, "\\"]")),\n          $targetSelector = document.querySelector(settings.targetSelector);\n\n      if ($targets.length) {\n        $targets.forEach(function ($item) {\n          $item.style.display = \'none\';\n          $item.style.opacity = 0;\n        });\n      }\n\n      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["fadeIn"])($targetSelector, 400);\n      settings.afterShow();\n    }\n  }, {\n    key: "cssAnimation",\n    value: function cssAnimation(settings) {\n      var $targets = document.querySelectorAll("[data-hs-show-animation-target-group=\\"".concat(settings.groupName, "\\"]")),\n          $targetSelector = document.querySelector(settings.targetSelector);\n\n      if ($targets.length) {\n        $targets.forEach(function ($item) {\n          $item.style.display = \'none\';\n          $item.style.opacity = 0;\n          $item.classList.remove(settings.animationInit, settings.animationIn);\n        });\n      }\n\n      $targetSelector.style.display = \'block\';\n      settings.afterShow();\n      setTimeout(function () {\n        $targetSelector.style.opacity = 1;\n        $targetSelector.classList.add(settings.animationInit, settings.animationIn);\n      }, 50);\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSShowAnimation;\n}();\n\n\n\n//# sourceURL=webpack://HSShowAnimation/./src/js/hs-show-animation.js?');
    },
    "./src/js/utils.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeIn\", function() { return fadeIn; });\nfunction fadeIn(el, time) {\n  if (!el || el.offsetParent !== null) return el;\n  el.style.opacity = 0;\n  el.style.display = 'block';\n  var last = +new Date();\n\n  var tick = function tick() {\n    el.style.opacity = +el.style.opacity + (new Date() - last) / time;\n    last = +new Date();\n\n    if (+el.style.opacity < 1) {\n      window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);\n    }\n  };\n\n  tick();\n}\n\n//# sourceURL=webpack://HSShowAnimation/./src/js/utils.js?");
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-show-animation.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSGoTo = e() : t.HSGoTo = e(); }(window, (() => {
  return d = {
    "./src/js/hs-go-to.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSGoTo; });\n/* harmony import */ var _utils_scrollTo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/scrollTo */ "./src/utils/scrollTo.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar dataAttributeName = \'data-hs-go-to-options\';\nvar defaults = {\n  pageContainerSelector: \'html, body\',\n  targetSelector: null,\n  compensationSelector: null,\n  animationInit: \'animated\',\n  animationIn: \'fadeInUp\',\n  animationOut: \'fadeOutDown\',\n  duration: 800,\n  offsetTop: 0,\n  position: {\n    init: null,\n    hide: null,\n    show: null\n  },\n  isReferencedToOtherPage: null,\n  preventEventClass: \'hs-go-to-prevent-event\'\n};\n\nvar HSGoTo = /*#__PURE__*/function () {\n  function HSGoTo(el, options, id) {\n    _classCallCheck(this, HSGoTo);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSGoTo, [{\n    key: "_init",\n    value: function _init() {\n      var _this = this;\n\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n\n        var _compensationSelector = document.querySelector(_options.compensationSelector),\n            _targetSelector = document.querySelector(_options.targetSelector),\n            _pageContainerSelector = document.querySelector(_options.pageContainerSelector);\n\n        _options.targetOffsetTop = function () {\n          if (_compensationSelector) {\n            return _targetSelector ? _targetSelector.offsetTop - _compensationSelector.innerHeight : 0;\n          } else {\n            return _targetSelector ? _targetSelector.offsetTop : 0;\n          }\n        };\n\n        _this.prepareObject(_$el, _options); // Set Position\n\n\n        if (_options.position) {\n          _this.setPosition(_$el, _options);\n        } // Click Events\n\n\n        _$el.addEventListener(\'click\', function (e) {\n          return _this.clickEvents(_$el, _options, {\n            _pageContainerSelector: _pageContainerSelector,\n            _compensationSelector: _compensationSelector,\n            _targetSelector: _targetSelector\n          });\n        }); // Scroll Events\n\n\n        if (_options.animationIn && _options.animationOut) {\n          document.addEventListener(\'scroll\', function (e) {\n            return _this.scrollEvents(_$el, _options);\n          });\n        }\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "prepareObject",\n    value: function prepareObject($el, settings) {\n      if (settings.animationIn && settings.animationOut) {\n        if (navigator.userAgent.match(\'MSIE 10.0\')) {\n          document.html.classList.add(\'ie10\');\n        }\n\n        $el.classList.add(settings.animationInit, settings.animationOut, settings.preventEventClass);\n      }\n    }\n  }, {\n    key: "setPosition",\n    value: function setPosition($el, settings) {\n      for (var style in settings.position.init) {\n        $el.style.setProperty(style, settings.position.init[style]);\n      }\n    }\n  }, {\n    key: "clickEvents",\n    value: function clickEvents($el, settings, _ref) {\n      var _pageContainerSelector = _ref._pageContainerSelector;\n\n      if (!settings.isReferencedToOtherPage) {\n        if (event) {\n          event.preventDefault();\n        }\n\n        Object(_utils_scrollTo__WEBPACK_IMPORTED_MODULE_0__["default"])({\n          to: settings.targetOffsetTop(),\n          el: _pageContainerSelector\n        }, settings.duration);\n      }\n    }\n  }, {\n    key: "scrollEvents",\n    value: function scrollEvents($el, settings) {\n      $el.style.visibility = \'\';\n\n      if (window.scrollY >= settings.offsetTop) {\n        if (settings.position.show) {\n          for (var style in settings.position.show) {\n            $el.style.setProperty(style, settings.position.show[style]);\n          }\n        }\n\n        $el.classList.remove(settings.animationOut);\n        $el.classList.add(settings.animationIn);\n      } else {\n        if (settings.position.show) {\n          for (var _style in settings.position.show) {\n            $el.style.setProperty(_style, settings.position.show[_style]);\n          }\n        }\n\n        $el.classList.remove(settings.animationIn);\n        $el.classList.add(settings.animationOut);\n      }\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSGoTo;\n}();\n\n\n\n//# sourceURL=webpack://HSGoTo/./src/js/hs-go-to.js?');
    },
    "./src/utils/scrollTo.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return scrollTo; });\nMath.easeInOutQuad = function (t, b, c, d) {\n  t /= d / 2;\n  if (t < 1) return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n};\n/*\n  scrollTo(element.scrollTop || 200, 400)\n*/\n\n\nfunction scrollTo(_ref, duration) {\n  var el = _ref.el,\n      to = _ref.to;\n  var element = el;\n  var start = element && element.scrollTop || window.pageYOffset,\n      change = to - start,\n      increment = 20;\n  var currentTime = 0;\n\n  var animateScroll = function animateScroll() {\n    currentTime += increment;\n    var val = Math.easeInOutQuad(currentTime, start, change, duration);\n    el.scrollTop = val;\n\n    if (currentTime < duration) {\n      window.setTimeout(animateScroll, increment);\n    }\n  };\n\n  animateScroll();\n}\n\n//# sourceURL=webpack://HSGoTo/./src/utils/scrollTo.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-go-to.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && void 0 !== module ? e(exports) : typeof define === "function" && define.amd ? define(["exports"], e) : e((t = typeof globalThis !== "undefined" ? globalThis : t || self).IMask = {}); }(this, ((t) => {
  const e = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {}; const n = function (t) { return t && t.Math == Math && t; }; const r = n(typeof globalThis === "object" && globalThis) || n(typeof window === "object" && window) || n(typeof self === "object" && self) || n(typeof e === "object" && e) || (function () { return this; }()) || Function("return this")(); const i = {}; const o = function (t) { try { return !!t(); } catch (t) { return !0; } }; const s = !o((() => Object.defineProperty({}, 1, { get() { return 7; } })[1] != 7)); const a = {}; const l = {}.propertyIsEnumerable; const u = Object.getOwnPropertyDescriptor; const c = u && !l.call({ 1: 2 }, 1); a.f = c ? function (t) { const e = u(this, t); return !!e && e.enumerable; } : l; const d = function (t, e) {
    return {
      enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e,
    };
  }; const h = {}.toString; const p = "".split; const f = o((() => !Object("z").propertyIsEnumerable(0))) ? function (t) { return (function (t) { return h.call(t).slice(8, -1); }(t)) == "String" ? p.call(t, "") : Object(t); } : Object; const m = function (t) { if (t == null) throw TypeError(`Can't call method on ${t}`); return t; }; const g = f; const v = m; const y = function (t) { return g(v(t)); }; const _ = function (t) { return typeof t === "object" ? t !== null : typeof t === "function"; }; const b = _; const w = function (t, e) { if (!b(t)) return t; let n; let r; if (e && typeof (n = t.toString) === "function" && !b(r = n.call(t))) return r; if (typeof (n = t.valueOf) === "function" && !b(r = n.call(t))) return r; if (!e && typeof (n = t.toString) === "function" && !b(r = n.call(t))) return r; throw TypeError("Can't convert object to primitive value"); }; const x = m; const S = function (t) { return Object(x(t)); }; const k = S; const C = {}.hasOwnProperty; const E = Object.hasOwn || function (t, e) { return C.call(k(t), e); }; const T = _; const P = r.document; const O = T(P) && T(P.createElement); const A = !s && !o((() => Object.defineProperty((function (t) { return O ? P.createElement(t) : {}; }("div")), "a", { get() { return 7; } }).a != 7)); const M = s; const L = a; const I = d; const j = y; const D = w; const N = E; const R = A; const F = Object.getOwnPropertyDescriptor; i.f = M ? F : function (t, e) { if (t = j(t), e = D(e, !0), R) try { return F(t, e); } catch (t) {} if (N(t, e)) return I(!L.f.call(t, e), t[e]); }; const V = {}; const z = _; const B = function (t) { if (!z(t)) throw TypeError(`${String(t)} is not an object`); return t; }; const q = s; const H = A; const $ = B; const U = w; const W = Object.defineProperty; V.f = q ? W : function (t, e, n) { if ($(t), e = U(e, !0), $(n), H) try { return W(t, e, n); } catch (t) {} if ("get" in n || "set" in n) throw TypeError("Accessors not supported"); return "value" in n && (t[e] = n.value), t; }; const G = V; const Y = d; const Z = s ? function (t, e, n) { return G.f(t, e, Y(1, n)); } : function (t, e, n) { return t[e] = n, t; }; const K = { exports: {} }; const X = r; const Q = Z; const J = function (t, e) { try { Q(X, t, e); } catch (n) { X[t] = e; } return e; }; const tt = J; const et = "__core-js_shared__"; const nt = r[et] || tt(et, {}); const rt = nt; const it = Function.toString; typeof rt.inspectSource !== "function" && (rt.inspectSource = function (t) { return it.call(t); }); const ot = rt.inspectSource; const st = ot; const at = r.WeakMap; const lt = typeof at === "function" && /native code/.test(st(at)); const ut = { exports: {} }; const ct = nt; (ut.exports = function (t, e) { return ct[t] || (ct[t] = void 0 !== e ? e : {}); })("versions", []).push({ version: "3.15.2", mode: "global", copyright: " 2021 Denis Pushkarev (zloirock.ru)" }); let dt; let ht; let pt; let ft = 0; const mt = Math.random(); const gt = ut.exports; const vt = gt("keys"); const yt = {}; const _t = lt; const bt = _; const wt = Z; const xt = E; const St = nt; const kt = yt; const Ct = "Object already initialized"; const Et = r.WeakMap; if (_t || St.state) { const Tt = St.state || (St.state = new Et()); const Pt = Tt.get; const Ot = Tt.has; const At = Tt.set; dt = function (t, e) { if (Ot.call(Tt, t)) throw new TypeError(Ct); return e.facade = t, At.call(Tt, t, e), e; }, ht = function (t) { return Pt.call(Tt, t) || {}; }, pt = function (t) { return Ot.call(Tt, t); }; } else { const Mt = (function (t) { return vt[t] || (vt[t] = (function (t) { return `Symbol(${String(void 0 === t ? "" : t)})_${(++ft + mt).toString(36)}`; }(t))); }("state")); kt[Mt] = !0, dt = function (t, e) { if (xt(t, Mt)) throw new TypeError(Ct); return e.facade = t, wt(t, Mt, e), e; }, ht = function (t) { return xt(t, Mt) ? t[Mt] : {}; }, pt = function (t) { return xt(t, Mt); }; } const Lt = {
    set: dt, get: ht, has: pt, enforce(t) { return pt(t) ? ht(t) : dt(t, {}); }, getterFor(t) { return function (e) { let n; if (!bt(e) || (n = ht(e)).type !== t) throw TypeError(`Incompatible receiver, ${t} required`); return n; }; },
  }; const It = r; const jt = Z; const Dt = E; const Nt = J; const Rt = ot; const Ft = Lt.get; const Vt = Lt.enforce; const zt = String(String).split("String"); (K.exports = function (t, e, n, r) { let i; const o = !!r && !!r.unsafe; let s = !!r && !!r.enumerable; const a = !!r && !!r.noTargetGet; typeof n === "function" && (typeof e !== "string" || Dt(n, "name") || jt(n, "name", e), (i = Vt(n)).source || (i.source = zt.join(typeof e === "string" ? e : ""))), t !== It ? (o ? !a && t[e] && (s = !0) : delete t[e], s ? t[e] = n : jt(t, e, n)) : s ? t[e] = n : Nt(e, n); })(Function.prototype, "toString", (function () { return typeof this === "function" && Ft(this).source || Rt(this); })); const Bt = r; const qt = r; const Ht = function (t) { return typeof t === "function" ? t : void 0; }; const $t = function (t, e) { return arguments.length < 2 ? Ht(Bt[t]) || Ht(qt[t]) : Bt[t] && Bt[t][e] || qt[t] && qt[t][e]; }; const Ut = {}; const Wt = Math.ceil; const Gt = Math.floor; const Yt = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? Gt : Wt)(t); }; const Zt = Yt; const Kt = Math.min; const Xt = function (t) { return t > 0 ? Kt(Zt(t), 9007199254740991) : 0; }; const Qt = Yt; const Jt = Math.max; const te = Math.min; const ee = y; const ne = Xt; const re = function (t) { return function (e, n, r) { let i; const o = ee(e); const s = ne(o.length); let a = (function (t, e) { const n = Qt(t); return n < 0 ? Jt(n + e, 0) : te(n, e); }(r, s)); if (t && n != n) { for (;s > a;) if ((i = o[a++]) != i) return !0; } else for (;s > a; a++) if ((t || a in o) && o[a] === n) return t || a || 0; return !t && -1; }; }; const ie = { includes: re(!0), indexOf: re(!1) }; const oe = E; const se = y; const ae = ie.indexOf; const le = yt; const ue = function (t, e) { let n; const r = se(t); let i = 0; const o = []; for (n in r)!oe(le, n) && oe(r, n) && o.push(n); for (;e.length > i;)oe(r, n = e[i++]) && (~ae(o, n) || o.push(n)); return o; }; const ce = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]; const de = ue; const he = ce.concat("length", "prototype"); Ut.f = Object.getOwnPropertyNames || function (t) { return de(t, he); }; const pe = {}; pe.f = Object.getOwnPropertySymbols; const fe = Ut; const me = pe; const ge = B; const ve = $t("Reflect", "ownKeys") || function (t) { const e = fe.f(ge(t)); const n = me.f; return n ? e.concat(n(t)) : e; }; const ye = E; const _e = ve; const be = i; const we = V; const xe = o; const Se = /#|\.prototype\./; const ke = function (t, e) { const n = Ee[Ce(t)]; return n == Pe || n != Te && (typeof e === "function" ? xe(e) : !!e); }; var Ce = ke.normalize = function (t) { return String(t).replace(Se, ".").toLowerCase(); }; var Ee = ke.data = {}; var Te = ke.NATIVE = "N"; var Pe = ke.POLYFILL = "P"; const Oe = ke; const Ae = r; const Me = i.f; const Le = Z; const Ie = K.exports; const je = J; const De = function (t, e) { for (let n = _e(e), r = we.f, i = be.f, o = 0; o < n.length; o++) { const s = n[o]; ye(t, s) || r(t, s, i(e, s)); } }; const Ne = Oe; const Re = function (t, e) { let n; let r; let i; let o; let s; const a = t.target; const l = t.global; const u = t.stat; if (n = l ? Ae : u ? Ae[a] || je(a, {}) : (Ae[a] || {}).prototype) for (r in e) { if (o = e[r], i = t.noTargetGet ? (s = Me(n, r)) && s.value : n[r], !Ne(l ? r : a + (u ? "." : "#") + r, t.forced) && void 0 !== i) { if (typeof o === typeof i) continue; De(o, i); }(t.sham || i && i.sham) && Le(o, "sham", !0), Ie(n, r, o, t); } }; const Fe = ue; const Ve = ce; const ze = Object.keys || function (t) { return Fe(t, Ve); }; const Be = s; const qe = o; const He = ze; const $e = pe; const Ue = a; const We = S; const Ge = f; const Ye = Object.assign; const Ze = Object.defineProperty; const Ke = !Ye || qe((() => { if (Be && ({ b: 1, ...Ye(Ze({}, "a", { enumerable: !0, get() { Ze(this, "b", { value: 3, enumerable: !1 }); } }), { b: 2 }) }).b !== 1) return !0; const t = {}; const e = {}; const n = Symbol(); const r = "abcdefghijklmnopqrst"; return t[n] = 7, r.split("").forEach(((t) => { e[t] = t; })), ({ ...t })[n] != 7 || He({ ...e }).join("") != r; })) ? function (t, e) { for (var n = We(t), r = arguments.length, i = 1, o = $e.f, s = Ue.f; r > i;) for (var a, l = Ge(arguments[i++]), u = o ? He(l).concat(o(l)) : He(l), c = u.length, d = 0; c > d;)a = u[d++], Be && !s.call(l, a) || (n[a] = l[a]); return n; } : Ye; Re({ target: "Object", stat: !0, forced: Object.assign !== Ke }, { assign: Ke }); const Xe = Yt; const Qe = m; const Je = function (t) { let e = String(Qe(this)); let n = ""; let r = Xe(t); if (r < 0 || r == 1 / 0) throw RangeError("Wrong number of repetitions"); for (;r > 0; (r >>>= 1) && (e += e))1 & r && (n += e); return n; }; Re({ target: "String", proto: !0 }, { repeat: Je }); const tn = Xt; const en = Je; const nn = m; const rn = Math.ceil; const on = function (t) { return function (e, n, r) { let i; let o; const s = String(nn(e)); const a = s.length; const l = void 0 === r ? " " : String(r); const u = tn(n); return u <= a || l == "" ? s : (i = u - a, (o = en.call(l, rn(i / l.length))).length > i && (o = o.slice(0, i)), t ? s + o : o + s); }; }; const sn = { start: on(!1), end: on(!0) }; const an = $t("navigator", "userAgent") || ""; const ln = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(an); const un = sn.start; Re({ target: "String", proto: !0, forced: ln }, { padStart(t) { return un(this, t, arguments.length > 1 ? arguments[1] : void 0); } }); const cn = sn.end; function dn(t) { return (dn = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; })(t); } function hn(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function pn(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } function fn(t, e, n) { return e && pn(t.prototype, e), n && pn(t, n), t; } function mn(t, e) { if (typeof e !== "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && (function (t, e) { (Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); }(t, e)); } function gn(t) { return (gn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } function vn(t, e) { if (t == null) return {}; let n; let r; const i = (function (t, e) { if (t == null) return {}; let n; let r; const i = {}; const o = Object.keys(t); for (r = 0; r < o.length; r++)n = o[r], e.indexOf(n) >= 0 || (i[n] = t[n]); return i; }(t, e)); if (Object.getOwnPropertySymbols) { const o = Object.getOwnPropertySymbols(t); for (r = 0; r < o.length; r++)n = o[r], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n]); } return i; } function yn(t, e) { return !e || typeof e !== "object" && typeof e !== "function" ? (function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; }(t)) : e; } function _n(t) { const e = (function () { if (typeof Reflect === "undefined" || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (() => {}))), !0; } catch (t) { return !1; } }()); return function () { let n; const r = gn(t); if (e) { const i = gn(this).constructor; n = Reflect.construct(r, arguments, i); } else n = r.apply(this, arguments); return yn(this, n); }; } function bn(t, e) { for (;!Object.prototype.hasOwnProperty.call(t, e) && (t = gn(t)) !== null;);return t; } function wn(t, e, n) { return (wn = typeof Reflect !== "undefined" && Reflect.get ? Reflect.get : function (t, e, n) { const r = bn(t, e); if (r) { const i = Object.getOwnPropertyDescriptor(r, e); return i.get ? i.get.call(n) : i.value; } })(t, e, n || t); } function xn(t, e, n, r) {
    return (xn = typeof Reflect !== "undefined" && Reflect.set ? Reflect.set : function (t, e, n, r) {
      let i; const o = bn(t, e); if (o) { if ((i = Object.getOwnPropertyDescriptor(o, e)).set) return i.set.call(r, n), !0; if (!i.writable) return !1; } if (i = Object.getOwnPropertyDescriptor(r, e)) { if (!i.writable) return !1; i.value = n, Object.defineProperty(r, e, i); } else {
        !(function (t, e, n) {
          e in t ? Object.defineProperty(t, e, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }) : t[e] = n;
        }(r, e, n));
      } return !0;
    })(t, e, n, r);
  } function Sn(t, e, n, r, i) { if (!xn(t, e, n, r || t) && i) throw new Error("failed to set property"); return n; } function kn(t, e) { return (function (t) { if (Array.isArray(t)) return t; }(t)) || (function (t, e) { let n = t == null ? null : typeof Symbol !== "undefined" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { let r; let i; const o = []; let s = !0; let a = !1; try { for (n = n.call(t); !(s = (r = n.next()).done) && (o.push(r.value), !e || o.length !== e); s = !0); } catch (t) { a = !0, i = t; } finally { try { s || n.return == null || n.return(); } finally { if (a) throw i; } } return o; } }(t, e)) || (function (t, e) { if (t) { if (typeof t === "string") return Cn(t, e); let n = Object.prototype.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Cn(t, e) : void 0; } }(t, e)) || (function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }()); } function Cn(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r; } function En(t) { return typeof t === "string" || t instanceof String; }Re({ target: "String", proto: !0, forced: ln }, { padEnd(t) { return cn(this, t, arguments.length > 1 ? arguments[1] : void 0); } }), Re({ global: !0 }, { globalThis: r }); const Tn = "NONE"; const Pn = "LEFT"; const On = "FORCE_LEFT"; const An = "RIGHT"; const Mn = "FORCE_RIGHT"; function Ln(t) { switch (t) { case Pn: return On; case An: return Mn; default: return t; } } function In(t) { return t.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1"); } const jn = (function () { function t(e, n, r, i) { for (hn(this, t), this.value = e, this.cursorPos = n, this.oldValue = r, this.oldSelection = i; this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);)--this.oldSelection.start; } return fn(t, [{ key: "startChangePos", get() { return Math.min(this.cursorPos, this.oldSelection.start); } }, { key: "insertedCount", get() { return this.cursorPos - this.startChangePos; } }, { key: "inserted", get() { return this.value.substr(this.startChangePos, this.insertedCount); } }, { key: "removedCount", get() { return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0); } }, { key: "removed", get() { return this.oldValue.substr(this.startChangePos, this.removedCount); } }, { key: "head", get() { return this.value.substring(0, this.startChangePos); } }, { key: "tail", get() { return this.value.substring(this.startChangePos + this.insertedCount); } }, { key: "removeDirection", get() { return !this.removedCount || this.insertedCount ? Tn : this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? An : Pn; } }]), t; }()); const Dn = (function () {
    function t(e) {
      hn(this, t), Object.assign(this, {
        inserted: "", rawInserted: "", skip: !1, tailShift: 0,
      }, e);
    } return fn(t, [{ key: "aggregate", value(t) { return this.rawInserted += t.rawInserted, this.skip = this.skip || t.skip, this.inserted += t.inserted, this.tailShift += t.tailShift, this; } }, { key: "offset", get() { return this.tailShift + this.inserted.length; } }]), t;
  }()); const Nn = (function () { function t() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const r = arguments.length > 2 ? arguments[2] : void 0; hn(this, t), this.value = e, this.from = n, this.stop = r; } return fn(t, [{ key: "toString", value() { return this.value; } }, { key: "extend", value(t) { this.value += String(t); } }, { key: "appendTo", value(t) { return t.append(this.toString(), { tail: !0 }).aggregate(t._appendPlaceholder()); } }, { key: "state", get() { return { value: this.value, from: this.from, stop: this.stop }; }, set(t) { Object.assign(this, t); } }, { key: "shiftBefore", value(t) { if (this.from >= t || !this.value.length) return ""; const e = this.value[0]; return this.value = this.value.slice(1), e; } }]), t; }()); function Rn(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return new Rn.InputMask(t, e); } const Fn = (function () {
    function t(e) { hn(this, t), this._value = "", this._update({ ...t.DEFAULTS, ...e }), this.isInitialized = !0; } return fn(t, [{ key: "updateOptions", value(t) { Object.keys(t).length && this.withValueRefresh(this._update.bind(this, t)); } }, { key: "_update", value(t) { Object.assign(this, t); } }, { key: "state", get() { return { _value: this.value }; }, set(t) { this._value = t._value; } }, { key: "reset", value() { this._value = ""; } }, { key: "value", get() { return this._value; }, set(t) { this.resolve(t); } }, { key: "resolve", value(t) { return this.reset(), this.append(t, { input: !0 }, ""), this.doCommit(), this.value; } }, { key: "unmaskedValue", get() { return this.value; }, set(t) { this.reset(), this.append(t, {}, ""), this.doCommit(); } }, { key: "typedValue", get() { return this.doParse(this.value); }, set(t) { this.value = this.doFormat(t); } }, { key: "rawInputValue", get() { return this.extractInput(0, this.value.length, { raw: !0 }); }, set(t) { this.reset(), this.append(t, { raw: !0 }, ""), this.doCommit(); } }, { key: "isComplete", get() { return !0; } }, { key: "nearestInputPos", value(t, e) { return t; } }, { key: "extractInput", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return this.value.slice(t, e); } }, { key: "extractTail", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return new Nn(this.extractInput(t, e), t); } }, { key: "appendTail", value(t) { return En(t) && (t = new Nn(String(t))), t.appendTo(this); } }, { key: "_appendCharRaw", value(t) { return t ? (this._value += t, new Dn({ inserted: t, rawInserted: t })) : new Dn(); } }, { key: "_appendChar", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = arguments.length > 2 ? arguments[2] : void 0; const r = this.state; let i = this._appendCharRaw(this.doPrepare(t, e), e); if (i.inserted) { let o; let s = !1 !== this.doValidate(e); if (s && n != null) { const a = this.state; this.overwrite && (o = n.state, n.shiftBefore(this.value.length)); const l = this.appendTail(n); (s = l.rawInserted === n.toString()) && l.inserted && (this.state = a); }s || (i = new Dn(), this.state = r, n && o && (n.state = o)); } return i; } }, { key: "_appendPlaceholder", value() { return new Dn(); } }, {
      key: "append",
      value(t, e, n) {
        if (!En(t)) throw new Error("value should be string"); const r = new Dn(); const
          i = En(n) ? new Nn(String(n)) : n; e && e.tail && (e._beforeTailState = this.state); for (let o = 0; o < t.length; ++o)r.aggregate(this._appendChar(t[o], e, i)); return i != null && (r.tailShift += this.appendTail(i).tailShift), r;
      },
    }, { key: "remove", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return this._value = this.value.slice(0, t) + this.value.slice(e), new Dn(); } }, { key: "withValueRefresh", value(t) { if (this._refreshing || !this.isInitialized) return t(); this._refreshing = !0; const e = this.rawInputValue; const n = this.value; const r = t(); return this.rawInputValue = e, this.value && this.value !== n && n.indexOf(this.value) === 0 && this.append(n.slice(this.value.length), {}, ""), delete this._refreshing, r; } }, { key: "runIsolated", value(t) { if (this._isolated || !this.isInitialized) return t(this); this._isolated = !0; const e = this.state; const n = t(this); return this.state = e, delete this._isolated, n; } }, { key: "doPrepare", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return this.prepare ? this.prepare(t, this, e) : t; } }, { key: "doValidate", value(t) { return (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t)); } }, { key: "doCommit", value() { this.commit && this.commit(this.value, this); } }, { key: "doFormat", value(t) { return this.format ? this.format(t, this) : t; } }, { key: "doParse", value(t) { return this.parse ? this.parse(t, this) : t; } }, { key: "splice", value(t, e, n, r) { const i = t + e; const o = this.extractTail(i); const s = this.nearestInputPos(t, r); return new Dn({ tailShift: s - t }).aggregate(this.remove(s)).aggregate(this.append(n, { input: !0 }, o)); } }]), t;
  }()); function Vn(t) { if (t == null) throw new Error("mask property should be defined"); return t instanceof RegExp ? Rn.MaskedRegExp : En(t) ? Rn.MaskedPattern : t instanceof Date || t === Date ? Rn.MaskedDate : t instanceof Number || typeof t === "number" || t === Number ? Rn.MaskedNumber : Array.isArray(t) || t === Array ? Rn.MaskedDynamic : Rn.Masked && t.prototype instanceof Rn.Masked ? t : t instanceof Function ? Rn.MaskedFunction : t instanceof Rn.Masked ? t.constructor : (console.warn("Mask not found for mask", t), Rn.Masked); } function zn(t) { if (Rn.Masked && t instanceof Rn.Masked) return t; const e = (t = { ...t }).mask; if (Rn.Masked && e instanceof Rn.Masked) return e; const n = Vn(e); if (!n) throw new Error("Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask."); return new n(t); }Fn.DEFAULTS = { format(t) { return t; }, parse(t) { return t; } }, Rn.Masked = Fn, Rn.createMask = zn; const Bn = ["mask"]; const qn = { 0: /\d/, a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, "*": /./ }; const Hn = (function () { function t(e) { hn(this, t); const n = e.mask; const r = vn(e, Bn); this.masked = zn({ mask: n }), Object.assign(this, r); } return fn(t, [{ key: "reset", value() { this._isFilled = !1, this.masked.reset(); } }, { key: "remove", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; return t === 0 && e >= 1 ? (this._isFilled = !1, this.masked.remove(t, e)) : new Dn(); } }, { key: "value", get() { return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : ""); } }, { key: "unmaskedValue", get() { return this.masked.unmaskedValue; } }, { key: "isComplete", get() { return Boolean(this.masked.value) || this.isOptional; } }, { key: "_appendChar", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this._isFilled) return new Dn(); const n = this.masked.state; const r = this.masked._appendChar(t, e); return r.inserted && !1 === this.doValidate(e) && (r.inserted = r.rawInserted = "", this.masked.state = n), r.inserted || this.isOptional || this.lazy || e.input || (r.inserted = this.placeholderChar), r.skip = !r.inserted && !this.isOptional, this._isFilled = Boolean(r.inserted), r; } }, { key: "append", value() { let t; return (t = this.masked).append.apply(t, arguments); } }, { key: "_appendPlaceholder", value() { const t = new Dn(); return this._isFilled || this.isOptional || (this._isFilled = !0, t.inserted = this.placeholderChar), t; } }, { key: "extractTail", value() { let t; return (t = this.masked).extractTail.apply(t, arguments); } }, { key: "appendTail", value() { let t; return (t = this.masked).appendTail.apply(t, arguments); } }, { key: "extractInput", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = arguments.length > 2 ? arguments[2] : void 0; return this.masked.extractInput(t, e, n); } }, { key: "nearestInputPos", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Tn; const n = 0; const r = this.value.length; const i = Math.min(Math.max(t, n), r); switch (e) { case Pn: case On: return this.isComplete ? i : n; case An: case Mn: return this.isComplete ? i : r; case Tn: default: return i; } } }, { key: "doValidate", value() { let t; let e; return (t = this.masked).doValidate.apply(t, arguments) && (!this.parent || (e = this.parent).doValidate.apply(e, arguments)); } }, { key: "doCommit", value() { this.masked.doCommit(); } }, { key: "state", get() { return { masked: this.masked.state, _isFilled: this._isFilled }; }, set(t) { this.masked.state = t.masked, this._isFilled = t._isFilled; } }]), t; }()); const $n = (function () { function t(e) { hn(this, t), Object.assign(this, e), this._value = ""; } return fn(t, [{ key: "value", get() { return this._value; } }, { key: "unmaskedValue", get() { return this.isUnmasking ? this.value : ""; } }, { key: "reset", value() { this._isRawInput = !1, this._value = ""; } }, { key: "remove", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length; return this._value = this._value.slice(0, t) + this._value.slice(e), this._value || (this._isRawInput = !1), new Dn(); } }, { key: "nearestInputPos", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Tn; const n = 0; const r = this._value.length; switch (e) { case Pn: case On: return n; case Tn: case An: case Mn: default: return r; } } }, { key: "extractInput", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return n.raw && this._isRawInput && this._value.slice(t, e) || ""; } }, { key: "isComplete", get() { return !0; } }, { key: "_appendChar", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = new Dn(); if (this._value) return n; const r = this.char === t[0]; const i = r && (this.isUnmasking || e.input || e.raw) && !e.tail; return i && (n.rawInserted = this.char), this._value = n.inserted = this.char, this._isRawInput = i && (e.raw || e.input), n; } }, { key: "_appendPlaceholder", value() { const t = new Dn(); return this._value || (this._value = t.inserted = this.char), t; } }, { key: "extractTail", value() { return arguments.length > 1 && void 0 !== arguments[1] || this.value.length, new Nn(""); } }, { key: "appendTail", value(t) { return En(t) && (t = new Nn(String(t))), t.appendTo(this); } }, { key: "append", value(t, e, n) { const r = this._appendChar(t, e); return n != null && (r.tailShift += this.appendTail(n).tailShift), r; } }, { key: "doCommit", value() {} }, { key: "state", get() { return { _value: this._value, _isRawInput: this._isRawInput }; }, set(t) { Object.assign(this, t); } }]), t; }()); const Un = ["chunks"]; const Wn = (function () {
    function t() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; hn(this, t), this.chunks = e, this.from = n; } return fn(t, [{ key: "toString", value() { return this.chunks.map(String).join(""); } }, { key: "extend", value(e) { if (String(e)) { En(e) && (e = new Nn(String(e))); const n = this.chunks[this.chunks.length - 1]; const r = n && (n.stop === e.stop || e.stop == null) && e.from === n.from + n.toString().length; if (e instanceof Nn)r ? n.extend(e.toString()) : this.chunks.push(e); else if (e instanceof t) { if (e.stop == null) for (var i; e.chunks.length && e.chunks[0].stop == null;)(i = e.chunks.shift()).from += e.from, this.extend(i); e.toString() && (e.stop = e.blockIndex, this.chunks.push(e)); } } } }, { key: "appendTo", value(e) { if (!(e instanceof Rn.MaskedPattern)) return new Nn(this.toString()).appendTo(e); for (var n = new Dn(), r = 0; r < this.chunks.length && !n.skip; ++r) { const i = this.chunks[r]; const o = e._mapPosToBlock(e.value.length); const s = i.stop; let a = void 0; if (s != null && (!o || o.index <= s) && ((i instanceof t || e._stops.indexOf(s) >= 0) && n.aggregate(e._appendPlaceholder(s)), a = i instanceof t && e._blocks[s]), a) { const l = a.appendTail(i); l.skip = !1, n.aggregate(l), e._value += l.inserted; const u = i.toString().slice(l.rawInserted.length); u && n.aggregate(e.append(u, { tail: !0 })); } else n.aggregate(e.append(i.toString(), { tail: !0 })); } return n; } }, {
      key: "state",
      get() {
        return {
          chunks: this.chunks.map(((t) => t.state)), from: this.from, stop: this.stop, blockIndex: this.blockIndex,
        };
      },
      set(e) { const n = e.chunks; const r = vn(e, Un); Object.assign(this, r), this.chunks = n.map(((e) => { const n = "chunks" in e ? new t() : new Nn(); return n.state = e, n; })); },
    }, { key: "shiftBefore", value(t) { if (this.from >= t || !this.chunks.length) return ""; for (let e = t - this.from, n = 0; n < this.chunks.length;) { const r = this.chunks[n]; const i = r.shiftBefore(e); if (r.toString()) { if (!i) break; ++n; } else this.chunks.splice(n, 1); if (i) return i; } return ""; } }]), t;
  }()); const Gn = (function (t) { mn(n, t); const e = _n(n); function n() { return hn(this, n), e.apply(this, arguments); } return fn(n, [{ key: "_update", value(t) { t.mask && (t.validate = function (e) { return e.search(t.mask) >= 0; }), wn(gn(n.prototype), "_update", this).call(this, t); } }]), n; }(Fn)); Rn.MaskedRegExp = Gn; const Yn = ["_blocks"]; const Zn = (function (t) {
    mn(n, t); const e = _n(n); function n() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return hn(this, n), t.definitions = { ...qn, ...t.definitions }, e.call(this, { ...n.DEFAULTS, ...t }); } return fn(n, [{ key: "_update", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t.definitions = { ...this.definitions, ...t.definitions }, wn(gn(n.prototype), "_update", this).call(this, t), this._rebuildMask(); } }, {
      key: "_rebuildMask",
      value() {
        const t = this; const e = this.definitions; this._blocks = [], this._stops = [], this._maskedBlocks = {}; const r = this.mask; if (r && e) {
          for (var i = !1, o = !1, s = 0; s < r.length; ++s) {
 if (!this.blocks || (function () { let e = r.slice(s); let n = Object.keys(t.blocks).filter(((t) => e.indexOf(t)===0)); n.sort(((t, e) => e.length - t.length)); let i = n[0]; if (i) { let o = zn({ parent: t, lazy: t.lazy, placeholderChar: t.placeholderChar, overwrite: t.overwrite, ...t.blocks[i] }); return o && (t._blocks.push(o), t._maskedBlocks[i] || (t._maskedBlocks[i] = []), t._maskedBlocks[i].push(t._blocks.length - 1)), s += i.length - 1, "continue"; } }()) !== "continue") {
            let a = r[s]; let l = a in e; if (a !== n.STOP_CHAR) { if (a !== "{" && a !== "}") {if (a !== "[" && a !== "]") { if (a === n.ESCAPE_CHAR) { if (++s, !(a = r[s])) break; l = !1; } let u = l ? new Hn({
 parent: this, lazy: this.lazy, placeholderChar: this.placeholderChar, mask: e[a], isOptional: o 
}) : new $n({ char: a, isUnmasking: i }); this._blocks.push(u); } else o = !o;} else i = !i; } else this._stops.push(this._blocks.length);
          } 
} 
}
      },
    }, { key: "state", get() { return { ...wn(gn(n.prototype), "state", this), _blocks: this._blocks.map(((t) => t.state)) }; }, set(t) { const e = t._blocks; const r = vn(t, Yn); this._blocks.forEach(((t, n) => t.state = e[n])), Sn(gn(n.prototype), "state", r, this, !0); } }, { key: "reset", value() { wn(gn(n.prototype), "reset", this).call(this), this._blocks.forEach(((t) => t.reset())); } }, { key: "isComplete", get() { return this._blocks.every(((t) => t.isComplete)); } }, { key: "doCommit", value() { this._blocks.forEach(((t) => t.doCommit())), wn(gn(n.prototype), "doCommit", this).call(this); } }, { key: "unmaskedValue", get() { return this._blocks.reduce(((t, e) => t + e.unmaskedValue), ""); }, set(t) { Sn(gn(n.prototype), "unmaskedValue", t, this, !0); } }, { key: "value", get() { return this._blocks.reduce(((t, e) => t + e.value), ""); }, set(t) { Sn(gn(n.prototype), "value", t, this, !0); } }, { key: "appendTail", value(t) { return wn(gn(n.prototype), "appendTail", this).call(this, t).aggregate(this._appendPlaceholder()); } }, { key: "_appendCharRaw", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = this._mapPosToBlock(this.value.length); const r = new Dn(); if (!n) return r; for (let i = n.index; ;++i) { const o = this._blocks[i]; if (!o) break; const s = o._appendChar(t, e); const a = s.skip; if (r.aggregate(s), a || s.rawInserted) break; } return r; } }, { key: "extractTail", value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const r = new Wn(); return e === n || this._forEachBlocksInRange(e, n, ((e, n, i, o) => { const s = e.extractTail(i, o); s.stop = t._findStopBefore(n), s.from = t._blockStartPos(n), s instanceof Wn && (s.blockIndex = n), r.extend(s); })), r; } }, { key: "extractInput", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (t === e) return ""; let r = ""; return this._forEachBlocksInRange(t, e, ((t, e, i, o) => { r += t.extractInput(i, o, n); })), r; } }, { key: "_findStopBefore", value(t) { for (var e, n = 0; n < this._stops.length; ++n) { const r = this._stops[n]; if (!(r <= t)) break; e = r; } return e; } }, { key: "_appendPlaceholder", value(t) { const e = this; const n = new Dn(); if (this.lazy && t == null) return n; const r = this._mapPosToBlock(this.value.length); if (!r) return n; const i = r.index; const o = t != null ? t : this._blocks.length; return this._blocks.slice(i, o).forEach(((r) => { if (!r.lazy || t != null) { const i = r._blocks != null ? [r._blocks.length] : []; const o = r._appendPlaceholder.apply(r, i); e._value += o.inserted, n.aggregate(o); } })), n; } }, { key: "_mapPosToBlock", value(t) { for (let e = "", n = 0; n < this._blocks.length; ++n) { const r = this._blocks[n]; const i = e.length; if (t <= (e += r.value).length) return { index: n, offset: t - i }; } } }, { key: "_blockStartPos", value(t) { return this._blocks.slice(0, t).reduce(((t, e) => t + e.value.length), 0); } }, { key: "_forEachBlocksInRange", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = arguments.length > 2 ? arguments[2] : void 0; const r = this._mapPosToBlock(t); if (r) { const i = this._mapPosToBlock(e); const o = i && r.index === i.index; const s = r.offset; const a = i && o ? i.offset : this._blocks[r.index].value.length; if (n(this._blocks[r.index], r.index, s, a), i && !o) { for (let l = r.index + 1; l < i.index; ++l)n(this._blocks[l], l, 0, this._blocks[l].value.length); n(this._blocks[i.index], i.index, 0, i.offset); } } } }, { key: "remove", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const r = wn(gn(n.prototype), "remove", this).call(this, t, e); return this._forEachBlocksInRange(t, e, ((t, e, n, i) => { r.aggregate(t.remove(n, i)); })), r; } }, { key: "nearestInputPos", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Tn; const n = this._mapPosToBlock(t) || { index: 0, offset: 0 }; const r = n.offset; const i = n.index; const o = this._blocks[i]; if (!o) return t; let s = r; s !== 0 && s < o.value.length && (s = o.nearestInputPos(r, Ln(e))); const a = s === o.value.length; const l = s === 0; if (!l && !a) return this._blockStartPos(i) + s; const u = a ? i + 1 : i; if (e === Tn) { if (u > 0) { const c = u - 1; const d = this._blocks[c]; const h = d.nearestInputPos(0, Tn); if (!d.value.length || h !== d.value.length) return this._blockStartPos(u); } for (let p = u, f = p; f < this._blocks.length; ++f) { const m = this._blocks[f]; const g = m.nearestInputPos(0, Tn); if (!m.value.length || g !== m.value.length) return this._blockStartPos(f) + g; } for (let v = u - 1; v >= 0; --v) { const y = this._blocks[v]; const _ = y.nearestInputPos(0, Tn); if (!y.value.length || _ !== y.value.length) return this._blockStartPos(v) + y.value.length; } return t; } if (e === Pn || e === On) { for (var b, w = u; w < this._blocks.length; ++w) if (this._blocks[w].value) { b = w; break; } if (b != null) { const x = this._blocks[b]; const S = x.nearestInputPos(0, An); if (S === 0 && x.unmaskedValue.length) return this._blockStartPos(b) + S; } for (var k, C = -1, E = u - 1; E >= 0; --E) { const T = this._blocks[E]; const P = T.nearestInputPos(T.value.length, On); if (T.value && P === 0 || (k = E), P !== 0) { if (P !== T.value.length) return this._blockStartPos(E) + P; C = E; break; } } if (e === Pn) for (let O = C + 1; O <= Math.min(u, this._blocks.length - 1); ++O) { const A = this._blocks[O]; const M = A.nearestInputPos(0, Tn); const L = this._blockStartPos(O) + M; if (L > t) break; if (M !== A.value.length) return L; } if (C >= 0) return this._blockStartPos(C) + this._blocks[C].value.length; if (e === On || this.lazy && !this.extractInput() && !Kn(this._blocks[u])) return 0; if (k != null) return this._blockStartPos(k); for (let I = u; I < this._blocks.length; ++I) { const j = this._blocks[I]; const D = j.nearestInputPos(0, Tn); if (!j.value.length || D !== j.value.length) return this._blockStartPos(I) + D; } return 0; } if (e === An || e === Mn) { for (var N, R, F = u; F < this._blocks.length; ++F) { const V = this._blocks[F]; const z = V.nearestInputPos(0, Tn); if (z !== V.value.length) { R = this._blockStartPos(F) + z, N = F; break; } } if (N != null && R != null) { for (let B = N; B < this._blocks.length; ++B) { const q = this._blocks[B]; const H = q.nearestInputPos(0, Mn); if (H !== q.value.length) return this._blockStartPos(B) + H; } return e === Mn ? this.value.length : R; } for (let $ = Math.min(u, this._blocks.length - 1); $ >= 0; --$) { const U = this._blocks[$]; const W = U.nearestInputPos(U.value.length, Pn); if (W !== 0) { const G = this._blockStartPos($) + W; if (G >= t) return G; break; } } } return t; } }, { key: "maskedBlock", value(t) { return this.maskedBlocks(t)[0]; } }, { key: "maskedBlocks", value(t) { const e = this; const n = this._maskedBlocks[t]; return n ? n.map(((t) => e._blocks[t])) : []; } }]), n;
  }(Fn)); function Kn(t) { if (!t) return !1; const e = t.value; return !e || t.nearestInputPos(0, Tn) !== e.length; }Zn.DEFAULTS = { lazy: !0, placeholderChar: "_" }, Zn.STOP_CHAR = "`", Zn.ESCAPE_CHAR = "\\", Zn.InputDefinition = Hn, Zn.FixedDefinition = $n, Rn.MaskedPattern = Zn; const Xn = (function (t) { mn(n, t); const e = _n(n); function n() { return hn(this, n), e.apply(this, arguments); } return fn(n, [{ key: "_matchFrom", get() { return this.maxLength - String(this.from).length; } }, { key: "_update", value(t) { t = { to: this.to || 0, from: this.from || 0, ...t }; let e = String(t.to).length; t.maxLength != null && (e = Math.max(e, t.maxLength)), t.maxLength = e; for (var r = String(t.from).padStart(e, "0"), i = String(t.to).padStart(e, "0"), o = 0; o < i.length && i[o] === r[o];)++o; t.mask = i.slice(0, o).replace(/0/g, "\\0") + "0".repeat(e - o), wn(gn(n.prototype), "_update", this).call(this, t); } }, { key: "isComplete", get() { return wn(gn(n.prototype), "isComplete", this) && Boolean(this.value); } }, { key: "boundaries", value(t) { let e = ""; let n = ""; const r = kn(t.match(/^(\D*)(\d*)(\D*)/) || [], 3); const i = r[1]; const o = r[2]; return o && (e = "0".repeat(i.length) + o, n = "9".repeat(i.length) + o), [e = e.padEnd(this.maxLength, "0"), n = n.padEnd(this.maxLength, "9")]; } }, { key: "doPrepare", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (t = wn(gn(n.prototype), "doPrepare", this).call(this, t, e).replace(/\D/g, ""), !this.autofix) return t; for (var r = String(this.from).padStart(this.maxLength, "0"), i = String(this.to).padStart(this.maxLength, "0"), o = this.value, s = "", a = 0; a < t.length; ++a) { const l = o + s + t[a]; const u = this.boundaries(l); const c = kn(u, 2); const d = c[0]; const h = c[1]; Number(h) < this.from ? s += r[l.length - 1] : Number(d) > this.to ? s += i[l.length - 1] : s += t[a]; } return s; } }, { key: "doValidate", value() { let t; const e = this.value; const r = e.search(/[^0]/); if (r === -1 && e.length <= this._matchFrom) return !0; for (var i = this.boundaries(e), o = kn(i, 2), s = o[0], a = o[1], l = arguments.length, u = new Array(l), c = 0; c < l; c++)u[c] = arguments[c]; return this.from <= Number(a) && Number(s) <= this.to && (t = wn(gn(n.prototype), "doValidate", this)).call.apply(t, [this].concat(u)); } }]), n; }(Zn)); Rn.MaskedRange = Xn; const Qn = (function (t) { mn(n, t); const e = _n(n); function n(t) { return hn(this, n), e.call(this, { ...n.DEFAULTS, ...t }); } return fn(n, [{ key: "_update", value(t) { t.mask === Date && delete t.mask, t.pattern && (t.mask = t.pattern); const e = t.blocks; t.blocks = { ...n.GET_DEFAULT_BLOCKS() }, t.min && (t.blocks.Y.from = t.min.getFullYear()), t.max && (t.blocks.Y.to = t.max.getFullYear()), t.min && t.max && t.blocks.Y.from === t.blocks.Y.to && (t.blocks.m.from = t.min.getMonth() + 1, t.blocks.m.to = t.max.getMonth() + 1, t.blocks.m.from === t.blocks.m.to && (t.blocks.d.from = t.min.getDate(), t.blocks.d.to = t.max.getDate())), Object.assign(t.blocks, e), Object.keys(t.blocks).forEach(((e) => { const n = t.blocks[e]; "autofix" in n || (n.autofix = t.autofix); })), wn(gn(n.prototype), "_update", this).call(this, t); } }, { key: "doValidate", value() { for (var t, e = this.date, r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return (t = wn(gn(n.prototype), "doValidate", this)).call.apply(t, [this].concat(i)) && (!this.isComplete || this.isDateExist(this.value) && e != null && (this.min == null || this.min <= e) && (this.max == null || e <= this.max)); } }, { key: "isDateExist", value(t) { return this.format(this.parse(t, this), this).indexOf(t) >= 0; } }, { key: "date", get() { return this.typedValue; }, set(t) { this.typedValue = t; } }, { key: "typedValue", get() { return this.isComplete ? wn(gn(n.prototype), "typedValue", this) : null; }, set(t) { Sn(gn(n.prototype), "typedValue", t, this, !0); } }]), n; }(Zn)); Qn.DEFAULTS = { pattern: "d{.}`m{.}`Y", format(t) { return [String(t.getDate()).padStart(2, "0"), String(t.getMonth() + 1).padStart(2, "0"), t.getFullYear()].join("."); }, parse(t) { const e = kn(t.split("."), 3); const n = e[0]; const r = e[1]; const i = e[2]; return new Date(i, r - 1, n); } }, Qn.GET_DEFAULT_BLOCKS = function () {
    return {
      d: {
        mask: Xn, from: 1, to: 31, maxLength: 2,
      },
      m: {
        mask: Xn, from: 1, to: 12, maxLength: 2,
      },
      Y: { mask: Xn, from: 1900, to: 9999 },
    };
  }, Rn.MaskedDate = Qn; const Jn = (function () { function t() { hn(this, t); } return fn(t, [{ key: "selectionStart", get() { let t; try { t = this._unsafeSelectionStart; } catch (t) {} return t != null ? t : this.value.length; } }, { key: "selectionEnd", get() { let t; try { t = this._unsafeSelectionEnd; } catch (t) {} return t != null ? t : this.value.length; } }, { key: "select", value(t, e) { if (t != null && e != null && (t !== this.selectionStart || e !== this.selectionEnd)) try { this._unsafeSelect(t, e); } catch (t) {} } }, { key: "_unsafeSelect", value(t, e) {} }, { key: "isActive", get() { return !1; } }, { key: "bindEvents", value(t) {} }, { key: "unbindEvents", value() {} }]), t; }()); Rn.MaskElement = Jn; const tr = (function (t) { mn(n, t); const e = _n(n); function n(t) { let r; return hn(this, n), (r = e.call(this)).input = t, r._handlers = {}, r; } return fn(n, [{ key: "rootElement", get() { return this.input.getRootNode ? this.input.getRootNode() : document; } }, { key: "isActive", get() { return this.input === this.rootElement.activeElement; } }, { key: "_unsafeSelectionStart", get() { return this.input.selectionStart; } }, { key: "_unsafeSelectionEnd", get() { return this.input.selectionEnd; } }, { key: "_unsafeSelect", value(t, e) { this.input.setSelectionRange(t, e); } }, { key: "value", get() { return this.input.value; }, set(t) { this.input.value = t; } }, { key: "bindEvents", value(t) { const e = this; Object.keys(t).forEach(((r) => e._toggleEventHandler(n.EVENTS_MAP[r], t[r]))); } }, { key: "unbindEvents", value() { const t = this; Object.keys(this._handlers).forEach(((e) => t._toggleEventHandler(e))); } }, { key: "_toggleEventHandler", value(t, e) { this._handlers[t] && (this.input.removeEventListener(t, this._handlers[t]), delete this._handlers[t]), e && (this.input.addEventListener(t, e), this._handlers[t] = e); } }]), n; }(Jn)); tr.EVENTS_MAP = {
    selectionChange: "keydown", input: "input", drop: "drop", click: "click", focus: "focus", commit: "blur",
  }, Rn.HTMLMaskElement = tr; const er = (function (t) { mn(n, t); const e = _n(n); function n() { return hn(this, n), e.apply(this, arguments); } return fn(n, [{ key: "_unsafeSelectionStart", get() { const t = this.rootElement; const e = t.getSelection && t.getSelection(); return e && e.anchorOffset; } }, { key: "_unsafeSelectionEnd", get() { const t = this.rootElement; const e = t.getSelection && t.getSelection(); return e && this._unsafeSelectionStart + String(e).length; } }, { key: "_unsafeSelect", value(t, e) { if (this.rootElement.createRange) { const n = this.rootElement.createRange(); n.setStart(this.input.firstChild || this.input, t), n.setEnd(this.input.lastChild || this.input, e); const r = this.rootElement; const i = r.getSelection && r.getSelection(); i && (i.removeAllRanges(), i.addRange(n)); } } }, { key: "value", get() { return this.input.textContent; }, set(t) { this.input.textContent = t; } }]), n; }(tr)); Rn.HTMLContenteditableMaskElement = er; const nr = ["mask"]; const rr = (function () {
    function t(e, n) { hn(this, t), this.el = e instanceof Jn ? e : e.isContentEditable && e.tagName !== "INPUT" && e.tagName !== "TEXTAREA" ? new er(e) : new tr(e), this.masked = zn(n), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange(); } return fn(t, [{ key: "mask", get() { return this.masked.mask; }, set(t) { if (!this.maskEquals(t)) if (t instanceof Rn.Masked || this.masked.constructor !== Vn(t)) { const e = zn({ mask: t }); e.unmaskedValue = this.masked.unmaskedValue, this.masked = e; } else this.masked.updateOptions({ mask: t }); } }, { key: "maskEquals", value(t) { return t == null || t === this.masked.mask || t === Date && this.masked instanceof Qn; } }, { key: "value", get() { return this._value; }, set(t) { this.masked.value = t, this.updateControl(), this.alignCursor(); } }, { key: "unmaskedValue", get() { return this._unmaskedValue; }, set(t) { this.masked.unmaskedValue = t, this.updateControl(), this.alignCursor(); } }, { key: "typedValue", get() { return this.masked.typedValue; }, set(t) { this.masked.typedValue = t, this.updateControl(), this.alignCursor(); } }, {
      key: "_bindEvents",
      value() {
        this.el.bindEvents({
          selectionChange: this._saveSelection, input: this._onInput, drop: this._onDrop, click: this._onClick, focus: this._onFocus, commit: this._onChange,
        });
      },
    }, { key: "_unbindEvents", value() { this.el && this.el.unbindEvents(); } }, { key: "_fireEvent", value(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; const i = this._listeners[t]; i && i.forEach(((t) => t.apply(void 0, n))); } }, { key: "selectionStart", get() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart; } }, { key: "cursorPos", get() { return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd; }, set(t) { this.el && this.el.isActive && (this.el.select(t, t), this._saveSelection()); } }, { key: "_saveSelection", value() { this.value !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = { start: this.selectionStart, end: this.cursorPos }; } }, { key: "updateValue", value() { this.masked.value = this.el.value, this._value = this.masked.value; } }, { key: "updateControl", value() { const t = this.masked.unmaskedValue; const e = this.masked.value; const n = this.unmaskedValue !== t || this.value !== e; this._unmaskedValue = t, this._value = e, this.el.value !== e && (this.el.value = e), n && this._fireChangeEvents(); } }, { key: "updateOptions", value(t) { const e = t.mask; const n = vn(t, nr); const r = !this.maskEquals(e); const i = !(function t(e, n) { if (n === e) return !0; let r; const i = Array.isArray(n); const o = Array.isArray(e); if (i && o) { if (n.length != e.length) return !1; for (r = 0; r < n.length; r++) if (!t(n[r], e[r])) return !1; return !0; } if (i != o) return !1; if (n && e && dn(n) === "object" && dn(e) === "object") { const s = n instanceof Date; const a = e instanceof Date; if (s && a) return n.getTime() == e.getTime(); if (s != a) return !1; const l = n instanceof RegExp; const u = e instanceof RegExp; if (l && u) return n.toString() == e.toString(); if (l != u) return !1; const c = Object.keys(n); for (r = 0; r < c.length; r++) if (!Object.prototype.hasOwnProperty.call(e, c[r])) return !1; for (r = 0; r < c.length; r++) if (!t(e[c[r]], n[c[r]])) return !1; return !0; } return !(!n || !e || typeof n !== "function" || typeof e !== "function") && n.toString() === e.toString(); }(this.masked, n)); r && (this.mask = e), i && this.masked.updateOptions(n), (r || i) && this.updateControl(); } }, { key: "updateCursor", value(t) { t != null && (this.cursorPos = t, this._delayUpdateCursor(t)); } }, { key: "_delayUpdateCursor", value(t) { const e = this; this._abortUpdateCursor(), this._changingCursorPos = t, this._cursorChanging = setTimeout((() => { e.el && (e.cursorPos = e._changingCursorPos, e._abortUpdateCursor()); }), 10); } }, { key: "_fireChangeEvents", value() { this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent); } }, { key: "_abortUpdateCursor", value() { this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging); } }, { key: "alignCursor", value() { this.cursorPos = this.masked.nearestInputPos(this.cursorPos, Pn); } }, { key: "alignCursorFriendly", value() { this.selectionStart === this.cursorPos && this.alignCursor(); } }, { key: "on", value(t, e) { return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this; } }, { key: "off", value(t, e) { if (!this._listeners[t]) return this; if (!e) return delete this._listeners[t], this; const n = this._listeners[t].indexOf(e); return n >= 0 && this._listeners[t].splice(n, 1), this; } }, { key: "_onInput", value(t) { if (this._inputEvent = t, this._abortUpdateCursor(), !this._selection) return this.updateValue(); const e = new jn(this.el.value, this.cursorPos, this.value, this._selection); const n = this.masked.rawInputValue; const r = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection).offset; const i = n === this.masked.rawInputValue ? e.removeDirection : Tn; const o = this.masked.nearestInputPos(e.startChangePos + r, i); this.updateControl(), this.updateCursor(o), delete this._inputEvent; } }, { key: "_onChange", value() { this.value !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection(); } }, { key: "_onDrop", value(t) { t.preventDefault(), t.stopPropagation(); } }, { key: "_onFocus", value(t) { this.alignCursorFriendly(); } }, { key: "_onClick", value(t) { this.alignCursorFriendly(); } }, { key: "destroy", value() { this._unbindEvents(), this._listeners.length = 0, delete this.el; } }]), t;
  }()); Rn.InputMask = rr; const ir = (function (t) { mn(n, t); const e = _n(n); function n() { return hn(this, n), e.apply(this, arguments); } return fn(n, [{ key: "_update", value(t) { t.enum && (t.mask = "*".repeat(t.enum[0].length)), wn(gn(n.prototype), "_update", this).call(this, t); } }, { key: "doValidate", value() { for (var t, e = this, r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return this.enum.some(((t) => t.indexOf(e.unmaskedValue) >= 0)) && (t = wn(gn(n.prototype), "doValidate", this)).call.apply(t, [this].concat(i)); } }]), n; }(Zn)); Rn.MaskedEnum = ir; const or = (function (t) { mn(n, t); const e = _n(n); function n(t) { return hn(this, n), e.call(this, { ...n.DEFAULTS, ...t }); } return fn(n, [{ key: "_update", value(t) { wn(gn(n.prototype), "_update", this).call(this, t), this._updateRegExps(); } }, { key: "_updateRegExps", value() { const t = `^${this.allowNegative ? "[+|\\-]?" : ""}`; const e = `${this.scale ? `(${In(this.radix)}\\d{0,${this.scale}})?` : ""}$`; this._numberRegExpInput = new RegExp(`${t}(0|([1-9]+\\d*))?${e}`), this._numberRegExp = new RegExp(`${t}\\d*${e}`), this._mapToRadixRegExp = new RegExp(`[${this.mapToRadix.map(In).join("")}]`, "g"), this._thousandsSeparatorRegExp = new RegExp(In(this.thousandsSeparator), "g"); } }, { key: "_removeThousandsSeparators", value(t) { return t.replace(this._thousandsSeparatorRegExp, ""); } }, { key: "_insertThousandsSeparators", value(t) { const e = t.split(this.radix); return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), e.join(this.radix); } }, { key: "doPrepare", value(t) { for (var e, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)i[o - 1] = arguments[o]; return (e = wn(gn(n.prototype), "doPrepare", this)).call.apply(e, [this, this._removeThousandsSeparators(t.replace(this._mapToRadixRegExp, this.radix))].concat(i)); } }, { key: "_separatorsCount", value(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = 0, r = 0; r < t; ++r) this._value.indexOf(this.thousandsSeparator, r) === r && (++n, e && (t += this.thousandsSeparator.length)); return n; } }, { key: "_separatorsCountFromSlice", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._value; return this._separatorsCount(this._removeThousandsSeparators(t).length, !0); } }, { key: "extractInput", value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const r = arguments.length > 2 ? arguments[2] : void 0; const i = this._adjustRangeWithSeparators(t, e); const o = kn(i, 2); return t = o[0], e = o[1], this._removeThousandsSeparators(wn(gn(n.prototype), "extractInput", this).call(this, t, e, r)); } }, { key: "_appendCharRaw", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.thousandsSeparator) return wn(gn(n.prototype), "_appendCharRaw", this).call(this, t, e); const r = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value; const i = this._separatorsCountFromSlice(r); this._value = this._removeThousandsSeparators(this.value); const o = wn(gn(n.prototype), "_appendCharRaw", this).call(this, t, e); this._value = this._insertThousandsSeparators(this._value); const s = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value; const a = this._separatorsCountFromSlice(s); return o.tailShift += (a - i) * this.thousandsSeparator.length, o.skip = !o.rawInserted && t === this.thousandsSeparator, o; } }, { key: "_findSeparatorAround", value(t) { if (this.thousandsSeparator) { const e = t - this.thousandsSeparator.length + 1; const n = this.value.indexOf(this.thousandsSeparator, e); if (n <= t) return n; } return -1; } }, { key: "_adjustRangeWithSeparators", value(t, e) { const n = this._findSeparatorAround(t); n >= 0 && (t = n); const r = this._findSeparatorAround(e); return r >= 0 && (e = r + this.thousandsSeparator.length), [t, e]; } }, { key: "remove", value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length; const n = this._adjustRangeWithSeparators(t, e); const r = kn(n, 2); t = r[0], e = r[1]; const i = this.value.slice(0, t); const o = this.value.slice(e); const s = this._separatorsCount(i.length); this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(i + o)); const a = this._separatorsCountFromSlice(i); return new Dn({ tailShift: (a - s) * this.thousandsSeparator.length }); } }, { key: "nearestInputPos", value(t, e) { if (!this.thousandsSeparator) return t; switch (e) { case Tn: case Pn: case On: var n = this._findSeparatorAround(t - 1); if (n >= 0) { const r = n + this.thousandsSeparator.length; if (t < r || this.value.length <= r || e === On) return n; } break; case An: case Mn: var i = this._findSeparatorAround(t); if (i >= 0) return i + this.thousandsSeparator.length; } return t; } }, { key: "doValidate", value(t) { let e = (t.input ? this._numberRegExpInput : this._numberRegExp).test(this._removeThousandsSeparators(this.value)); if (e) { const r = this.number; e = e && !isNaN(r) && (this.min == null || this.min >= 0 || this.min <= this.number) && (this.max == null || this.max <= 0 || this.number <= this.max); } return e && wn(gn(n.prototype), "doValidate", this).call(this, t); } }, { key: "doCommit", value() { if (this.value) { const t = this.number; let e = t; this.min != null && (e = Math.max(e, this.min)), this.max != null && (e = Math.min(e, this.max)), e !== t && (this.unmaskedValue = String(e)); let r = this.value; this.normalizeZeros && (r = this._normalizeZeros(r)), this.padFractionalZeros && (r = this._padFractionalZeros(r)), this._value = r; }wn(gn(n.prototype), "doCommit", this).call(this); } }, { key: "_normalizeZeros", value(t) { const e = this._removeThousandsSeparators(t).split(this.radix); return e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, ((t, e, n, r) => e + r)), t.length && !/\d$/.test(e[0]) && (e[0] += "0"), e.length > 1 && (e[1] = e[1].replace(/0*$/, ""), e[1].length || (e.length = 1)), this._insertThousandsSeparators(e.join(this.radix)); } }, { key: "_padFractionalZeros", value(t) { if (!t) return t; const e = t.split(this.radix); return e.length < 2 && e.push(""), e[1] = e[1].padEnd(this.scale, "0"), e.join(this.radix); } }, { key: "unmaskedValue", get() { return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, "."); }, set(t) { Sn(gn(n.prototype), "unmaskedValue", t.replace(".", this.radix), this, !0); } }, { key: "typedValue", get() { return Number(this.unmaskedValue); }, set(t) { Sn(gn(n.prototype), "unmaskedValue", String(t), this, !0); } }, { key: "number", get() { return this.typedValue; }, set(t) { this.typedValue = t; } }, { key: "allowNegative", get() { return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0; } }]), n; }(Fn)); or.DEFAULTS = {
    radix: ",", thousandsSeparator: "", mapToRadix: ["."], scale: 2, signed: !1, normalizeZeros: !0, padFractionalZeros: !1,
  }, Rn.MaskedNumber = or; const sr = (function (t) { mn(n, t); const e = _n(n); function n() { return hn(this, n), e.apply(this, arguments); } return fn(n, [{ key: "_update", value(t) { t.mask && (t.validate = t.mask), wn(gn(n.prototype), "_update", this).call(this, t); } }]), n; }(Fn)); Rn.MaskedFunction = sr; const ar = ["compiledMasks", "currentMaskRef", "currentMask"]; const lr = (function (t) {
    mn(n, t); const e = _n(n); function n(t) { let r; return hn(this, n), (r = e.call(this, { ...n.DEFAULTS, ...t })).currentMask = null, r; } return fn(n, [{ key: "_update", value(t) { wn(gn(n.prototype), "_update", this).call(this, t), "mask" in t && (this.compiledMasks = Array.isArray(t.mask) ? t.mask.map(((t) => zn(t))) : []); } }, { key: "_appendCharRaw", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = this._applyDispatch(t, e); return this.currentMask && n.aggregate(this.currentMask._appendChar(t, e)), n; } }, { key: "_applyDispatch", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = e.tail && e._beforeTailState != null ? e._beforeTailState._value : this.value; const r = this.rawInputValue; const i = e.tail && e._beforeTailState != null ? e._beforeTailState._rawInputValue : r; const o = r.slice(i.length); const s = this.currentMask; const a = new Dn(); const l = s && s.state; if (this.currentMask = this.doDispatch(t, { ...e }), this.currentMask) if (this.currentMask !== s) { if (this.currentMask.reset(), i) { const u = this.currentMask.append(i, { raw: !0 }); a.tailShift = u.inserted.length - n.length; }o && (a.tailShift += this.currentMask.append(o, { raw: !0, tail: !0 }).tailShift); } else this.currentMask.state = l; return a; } }, { key: "_appendPlaceholder", value() { const t = this._applyDispatch.apply(this, arguments); return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t; } }, { key: "doDispatch", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return this.dispatch(t, this, e); } }, { key: "doValidate", value() { for (var t, e, r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return (t = wn(gn(n.prototype), "doValidate", this)).call.apply(t, [this].concat(i)) && (!this.currentMask || (e = this.currentMask).doValidate.apply(e, i)); } }, { key: "reset", value() { this.currentMask && this.currentMask.reset(), this.compiledMasks.forEach(((t) => t.reset())); } }, { key: "value", get() { return this.currentMask ? this.currentMask.value : ""; }, set(t) { Sn(gn(n.prototype), "value", t, this, !0); } }, { key: "unmaskedValue", get() { return this.currentMask ? this.currentMask.unmaskedValue : ""; }, set(t) { Sn(gn(n.prototype), "unmaskedValue", t, this, !0); } }, { key: "typedValue", get() { return this.currentMask ? this.currentMask.typedValue : ""; }, set(t) { let e = String(t); this.currentMask && (this.currentMask.typedValue = t, e = this.currentMask.unmaskedValue), this.unmaskedValue = e; } }, { key: "isComplete", get() { return !!this.currentMask && this.currentMask.isComplete; } }, { key: "remove", value() { let t; const e = new Dn(); return this.currentMask && e.aggregate((t = this.currentMask).remove.apply(t, arguments)).aggregate(this._applyDispatch()), e; } }, {
      key: "state",
      get() {
        return {
          ...wn(gn(n.prototype), "state", this), _rawInputValue: this.rawInputValue, compiledMasks: this.compiledMasks.map(((t) => t.state)), currentMaskRef: this.currentMask, currentMask: this.currentMask && this.currentMask.state,
        };
      },
      set(t) { const e = t.compiledMasks; const r = t.currentMaskRef; const i = t.currentMask; const o = vn(t, ar); this.compiledMasks.forEach(((t, n) => t.state = e[n])), r != null && (this.currentMask = r, this.currentMask.state = i), Sn(gn(n.prototype), "state", o, this, !0); },
    }, { key: "extractInput", value() { let t; return this.currentMask ? (t = this.currentMask).extractInput.apply(t, arguments) : ""; } }, { key: "extractTail", value() { for (var t, e, r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return this.currentMask ? (t = this.currentMask).extractTail.apply(t, i) : (e = wn(gn(n.prototype), "extractTail", this)).call.apply(e, [this].concat(i)); } }, { key: "doCommit", value() { this.currentMask && this.currentMask.doCommit(), wn(gn(n.prototype), "doCommit", this).call(this); } }, { key: "nearestInputPos", value() { for (var t, e, r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return this.currentMask ? (t = this.currentMask).nearestInputPos.apply(t, i) : (e = wn(gn(n.prototype), "nearestInputPos", this)).call.apply(e, [this].concat(i)); } }, { key: "overwrite", get() { return this.currentMask ? this.currentMask.overwrite : wn(gn(n.prototype), "overwrite", this); }, set(t) { console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings'); } }]), n;
  }(Fn)); lr.DEFAULTS = { dispatch(t, e, n) { if (e.compiledMasks.length) { const r = e.rawInputValue; const i = e.compiledMasks.map(((e, i) => (e.reset(), e.append(r, { raw: !0 }), e.append(t, n), { weight: e.rawInputValue.length, index: i }))); return i.sort(((t, e) => e.weight - t.weight)), e.compiledMasks[i[0].index]; } } }, Rn.MaskedDynamic = lr; const ur = { MASKED: "value", UNMASKED: "unmaskedValue", TYPED: "typedValue" }; function cr(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ur.MASKED; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ur.MASKED; const r = zn(t); return function (t) { return r.runIsolated(((r) => (r[e] = t, r[n]))); }; } function dr(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return cr.apply(void 0, n)(t); }Rn.PIPE_TYPE = ur, Rn.createPipe = cr, Rn.pipe = dr; try { globalThis.IMask = Rn; } catch (t) {}t.HTMLContenteditableMaskElement = er, t.HTMLMaskElement = tr, t.InputMask = rr, t.MaskElement = Jn, t.Masked = Fn, t.MaskedDate = Qn, t.MaskedDynamic = lr, t.MaskedEnum = ir, t.MaskedFunction = sr, t.MaskedNumber = or, t.MaskedPattern = Zn, t.MaskedRange = Xn, t.MaskedRegExp = Gn, t.PIPE_TYPE = ur, t.createMask = zn, t.createPipe = cr, t.default = Rn, t.pipe = dr, Object.defineProperty(t, "__esModule", { value: !0 });
}))), (function (t, e) { typeof exports === "object" && void 0 !== module ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : (t = typeof globalThis !== "undefined" ? globalThis : t || self).TomSelect = e(); }(this, (() => {
  function t(t, e) { t.split(/\s+/).forEach((t) => { e(t); }); } class e {
    constructor() { this._events = void 0, this._events = {}; }

    on(e, n) { t(e, (t) => { this._events[t] = this._events[t] || [], this._events[t].push(n); }); }

    off(e, n) { const r = arguments.length; r !== 0 ? t(e, (t) => { if (r === 1) return delete this._events[t]; t in this._events != 0 && this._events[t].splice(this._events[t].indexOf(n), 1); }) : this._events = {}; }

    trigger(e, ...n) { const r = this; t(e, (t) => { if (t in r._events != 0) for (const e of r._events[t])e.apply(r, n); }); }
  } const n = [[67, 67], [160, 160], [192, 438], [452, 652], [961, 961], [1019, 1019], [1083, 1083], [1281, 1289], [1984, 1984], [5095, 5095], [7429, 7441], [7545, 7549], [7680, 7935], [8580, 8580], [9398, 9449], [11360, 11391], [42792, 42793], [42802, 42851], [42873, 42897], [42912, 42922], [64256, 64260], [65313, 65338], [65345, 65370]]; const r = (t) => t.normalize("NFD").replace(/[\u0300-\u036F]/g, "").normalize("NFKD").toLowerCase(); let i = null; const o = (t) => {
    i === null && (i = (() => {
      const t = {
        l: "l", n: "n", : "ae", : "o", a: "a", dz: "dz",
      }; const e = {}; return n.forEach((n) => { for (let r = n[0]; r <= n[1]; r++) { const n = String.fromCharCode(r); let i = n.normalize("NFD").replace(/[\u0300-\u036F]/g, "").normalize("NFKD"); i != n && (i = i.toLowerCase(), i in t && (i = t[i]), i in e || (e[i] = i + i.toUpperCase()), e[i] += n); } }), e;
    })()); for (const e in i)i.hasOwnProperty(e) && (t = t.replace(new RegExp(e, "g"), `[${i[e]}]`)); return t;
  }; const s = (t, e) => { if (t) return t[e]; }; const a = (t, e) => { if (t) { for (var n, r = e.split("."); (n = r.shift()) && (t = t[n]););return t; } }; const l = (t, e, n) => { let r; let i; return t ? (i = (t += "").search(e.regex)) === -1 ? 0 : (r = e.string.length / t.length, i === 0 && (r += 0.5), r * n) : 0; }; const u = (t) => (`${t}`).replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"); const c = (t, e) => { const n = t[e]; n && !Array.isArray(n) && (t[e] = [n]); }; const d = (t, e) => { if (Array.isArray(t))t.forEach(e); else for (const n in t)t.hasOwnProperty(n) && e(t[n], n); }; const h = (t, e) => (typeof t === "number" && typeof e === "number" ? t > e ? 1 : t < e ? -1 : 0 : (t = r(`${t}`).toLowerCase()) > (e = r(`${e}`).toLowerCase()) ? 1 : e > t ? -1 : 0); class p {
    constructor(t, e) { this.items = void 0, this.settings = void 0, this.items = t, this.settings = e || { diacritics: !0 }; }

    tokenize(t, e, n) { if (!t || !t.length) return []; const r = []; const i = t.split(/\s+/); let s; return n && (s = new RegExp(`^(${Object.keys(n).map(u).join("|")}):(.*)$`)), i.forEach((t) => { let n; let i = null; let a = null; s && (n = t.match(s)) && (i = n[1], t = n[2]), t.length > 0 && (a = u(t), this.settings.diacritics && (a = o(a)), e && (a = `\\b${a}`)), r.push({ string: t, regex: a ? new RegExp(a, "i") : null, field: i }); }), r; }

    getScoreFunction(t, e) { const n = this.prepareSearch(t, e); return this._getScoreFunction(n); }

    _getScoreFunction(t) { const e = t.tokens; const n = e.length; if (!n) return function () { return 0; }; const r = t.options.fields; const i = t.weights; const o = r.length; const s = t.getAttrFn; if (!o) return function () { return 1; }; const a = o === 1 ? function (t, e) { const n = r[0].field; return l(s(e, n), t, i[n]); } : function (t, e) { let n = 0; if (t.field) { const r = s(e, t.field); !t.regex && r ? n += 1 / o : n += l(r, t, 1); } else d(i, (r, i) => { n += l(s(e, i), t, r); }); return n / o; }; return n === 1 ? function (t) { return a(e[0], t); } : t.options.conjunction === "and" ? function (t) { for (var r, i = 0, o = 0; i < n; i++) { if ((r = a(e[i], t)) <= 0) return 0; o += r; } return o / n; } : function (t) { let r = 0; return d(e, (e) => { r += a(e, t); }), r / n; }; }

    getSortFunction(t, e) { const n = this.prepareSearch(t, e); return this._getSortFunction(n); }

    _getSortFunction(t) { let e; let n; let r; const i = this; const o = t.options; const s = !t.query && o.sort_empty ? o.sort_empty : o.sort; const a = []; const l = []; const u = function (e, n) { return e === "$score" ? n.score : t.getAttrFn(i.items[n.id], e); }; if (s) for (e = 0, n = s.length; e < n; e++)(t.query || s[e].field !== "$score") && a.push(s[e]); if (t.query) { for (r = !0, e = 0, n = a.length; e < n; e++) if (a[e].field === "$score") { r = !1; break; }r && a.unshift({ field: "$score", direction: "desc" }); } else for (e = 0, n = a.length; e < n; e++) if (a[e].field === "$score") { a.splice(e, 1); break; } for (e = 0, n = a.length; e < n; e++)l.push(a[e].direction === "desc" ? -1 : 1); const c = a.length; if (c) { if (c === 1) { const t = a[0].field; const e = l[0]; return function (n, r) { return e * h(u(t, n), u(t, r)); }; } return function (t, e) { let n; let r; let i; for (n = 0; n < c; n++) if (i = a[n].field, r = l[n] * h(u(i, t), u(i, e))) return r; return 0; }; } return null; }

    prepareSearch(t, e) {
      const n = {}; const i = { ...e }; if (c(i, "sort"), c(i, "sort_empty"), i.fields) { c(i, "fields"); const t = []; i.fields.forEach((e) => { typeof e === "string" && (e = { field: e, weight: 1 }), t.push(e), n[e.field] = "weight" in e ? e.weight : 1; }), i.fields = t; } return {
        options: i, query: t = r(`${t}`).toLowerCase().trim(), tokens: this.tokenize(t, i.respect_word_boundaries, n), total: 0, items: [], weights: n, getAttrFn: i.nesting ? a : s,
      };
    }

    search(t, e) { let n; let r; const i = this; r = this.prepareSearch(t, e), e = r.options, t = r.query; const o = e.score || i._getScoreFunction(r); t.length ? d(i.items, (t, i) => { n = o(t), (!1 === e.filter || n > 0) && r.items.push({ score: n, id: i }); }) : d(i.items, (t, e) => { r.items.push({ score: 1, id: e }); }); const s = i._getSortFunction(r); return s && r.items.sort(s), r.total = r.items.length, typeof e.limit === "number" && (r.items = r.items.slice(0, e.limit)), r; }
  } const f = (t) => { if (t.jquery) return t[0]; if (t instanceof HTMLElement) return t; if (t.indexOf("<") > -1) { const e = document.createElement("div"); return e.innerHTML = t.trim(), e.firstChild; } return document.querySelector(t); }; const m = (t, e) => { const n = document.createEvent("HTMLEvents"); n.initEvent(e, !0, !1), t.dispatchEvent(n); }; const g = (t, e) => { Object.assign(t.style, e); }; const v = (t, ...e) => { const n = _(e); (t = b(t)).map((t) => { n.map((e) => { t.classList.add(e); }); }); }; const y = (t, ...e) => { const n = _(e); (t = b(t)).map((t) => { n.map((e) => { t.classList.remove(e); }); }); }; const _ = (t) => { let e = []; for (let n of t) typeof n === "string" && (n = n.trim().split(/[\11\12\14\15\40]/)), Array.isArray(n) && (e = e.concat(n)); return e.filter(Boolean); }; const b = (t) => (Array.isArray(t) || (t = [t]), t); const w = (t, e, n) => { if (!n || n.contains(t)) for (;t && t.matches;) { if (t.matches(e)) return t; t = t.parentNode; } }; const x = (t, e = 0) => (e > 0 ? t[t.length - 1] : t[0]); const S = (t, e) => { if (!t) return -1; e = e || t.nodeName; for (var n = 0; t = t.previousElementSibling;)t.matches(e) && n++; return n; }; const k = (t, e) => { for (const n in e) { const r = e[n]; r == null ? t.removeAttribute(n) : t.setAttribute(n, `${r}`); } }; const C = (t, e) => { t.parentNode && t.parentNode.replaceChild(e, t); }; const E = (t, e) => { if (e === null) return; if (typeof e === "string") { if (!e.length) return; e = new RegExp(e, "i"); } const n = (t) => (t.nodeType === 3 ? ((t) => { const n = t.data.match(e); if (n && t.data.length > 0) { const r = document.createElement("span"); r.className = "highlight"; const i = t.splitText(n.index); i.splitText(n[0].length); const o = i.cloneNode(!0); return r.appendChild(o), C(i, r), 1; } return 0; })(t) : (((t) => { if (t.nodeType === 1 && t.childNodes && !/(script|style)/i.test(t.tagName) && (t.className !== "highlight" || t.tagName !== "SPAN")) for (let e = 0; e < t.childNodes.length; ++e)e += n(t.childNodes[e]); })(t), 0)); n(t); }; const T = typeof navigator !== "undefined" && /Mac/.test(navigator.userAgent) ? "metaKey" : "ctrlKey"; const P = {
    options: [], optgroups: [], plugins: [], delimiter: ",", splitOn: null, persist: !0, diacritics: !0, create: null, createOnBlur: !1, createFilter: null, highlight: !0, openOnFocus: !0, shouldOpen: null, maxOptions: 50, maxItems: null, hideSelected: null, duplicates: !1, addPrecedence: !1, selectOnTab: !1, preload: null, allowEmptyOption: !1, closeAfterSelect: !1, loadThrottle: 300, loadingClass: "loading", dataAttr: null, optgroupField: "optgroup", valueField: "value", labelField: "text", disabledField: "disabled", optgroupLabelField: "label", optgroupValueField: "value", lockOptgroupOrder: !1, sortField: "$order", searchField: ["text"], searchConjunction: "and", mode: null, wrapperClass: "ts-control", inputClass: "ts-input", dropdownClass: "ts-dropdown", dropdownContentClass: "ts-dropdown-content", itemClass: "item", optionClass: "option", dropdownParent: null, controlInput: null, copyClassesToDropdown: !0, placeholder: null, hidePlaceholder: null, shouldLoad(t) { return t.length > 0; }, render: {},
  }; const O = (t) => (t == null ? null : A(t)); const A = (t) => (typeof t === "boolean" ? t ? "1" : "0" : `${t}`); const M = (t) => (`${t}`).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"); const L = (t, e) => { let n; return function (r, i) { const o = this; n && (o.loading = Math.max(o.loading - 1, 0), clearTimeout(n)), n = setTimeout((() => { n = null, o.loadedSearches[r] = !0, t.call(o, r, i); }), e); }; }; const I = (t, e, n) => { let r; const i = t.trigger; const o = {}; for (r in t.trigger = function () { const n = arguments[0]; if (e.indexOf(n) === -1) return i.apply(t, arguments); o[n] = arguments; }, n.apply(t, []), t.trigger = i, o)i.apply(t, o[r]); }; const j = (t, e = !1) => { t && (t.preventDefault(), e && t.stopPropagation()); }; const D = (t, e, n, r) => { t.addEventListener(e, n, r); }; const N = (t, e) => !!e && !!e[t] && (e.altKey ? 1 : 0) + (e.ctrlKey ? 1 : 0) + (e.shiftKey ? 1 : 0) + (e.metaKey ? 1 : 0) == 1; const R = (t, e) => t.getAttribute("id") || (t.setAttribute("id", e), e); const F = (t) => t.replace(/[\\"']/g, "\\$&"); const V = (t, e) => { e && t.append(e); }; function z(t, e) {
    const n = { ...P, ...e }; const r = n.dataAttr; const i = n.labelField; const o = n.valueField; const s = n.disabledField; const a = n.optgroupField; const l = n.optgroupLabelField; const u = n.optgroupValueField; const c = t.tagName.toLowerCase(); let d = t.getAttribute("placeholder") || t.getAttribute("data-placeholder"); if (!d && !n.allowEmptyOption) { const e = t.querySelector('option[value=""]'); e && (d = e.textContent); } const h = {
      placeholder: d, options: [], optgroups: [], items: [], maxItems: null,
    }; return c === "select" ? (() => { let e; const c = h.options; const d = {}; let p = 1; const f = (t) => { let e = { ...t.dataset }; const n = r && e[r]; return typeof n === "string" && n.length && (e = Object.assign(e, JSON.parse(n))), e; }; const m = (t, e) => { const r = O(t.value); if (r != null && (r || n.allowEmptyOption)) { if (d.hasOwnProperty(r)) { if (e) { const l = d[r][a]; l ? Array.isArray(l) ? l.push(e) : d[r][a] = [l, e] : d[r][a] = e; } } else { const u = f(t); u[i] = u[i] || t.textContent, u[o] = u[o] || r, u[s] = u[s] || t.disabled, u[a] = u[a] || e, u.$option = t, d[r] = u, c.push(u); }t.selected && h.items.push(r); } }; const g = (t) => { let e; let n; (n = f(t))[l] = n[l] || t.getAttribute("label") || "", n[u] = n[u] || p++, n[s] = n[s] || t.disabled, h.optgroups.push(n), e = n[u]; for (const n of t.children)m(n, e); }; h.maxItems = t.hasAttribute("multiple") ? null : 1; for (const n of t.children)(e = n.tagName.toLowerCase()) === "optgroup" ? g(n) : e === "option" && m(n); })() : (() => { const e = t.getAttribute(r); if (e) { h.options = JSON.parse(e); for (const t of h.options)h.items.push(t[o]); } else { const s = t.value.trim() || ""; if (!n.allowEmptyOption && !s.length) return; const e = s.split(n.delimiter); for (const t of e) { const e = {}; e[i] = t, e[o] = t, h.options.push(e); }h.items = e; } })(), ({ ...P, ...h, ...e });
  } let B = 0; class q extends (function (t) {
    return t.plugins = {}, class extends t {
      constructor(...t) {
        super(...t), this.plugins = {
          names: [], settings: {}, requested: {}, loaded: {},
        };
      }

      static define(e, n) { t.plugins[e] = { name: e, fn: n }; }

      initializePlugins(t) { let e; let n; const r = this; const i = []; if (Array.isArray(t))t.forEach((t) => { typeof t === "string" ? i.push(t) : (r.plugins.settings[t.name] = t.options, i.push(t.name)); }); else if (t) for (e in t)t.hasOwnProperty(e) && (r.plugins.settings[e] = t[e], i.push(e)); for (;n = i.shift();)r.require(n); }

      loadPlugin(e) { const n = this; const r = n.plugins; const i = t.plugins[e]; if (!t.plugins.hasOwnProperty(e)) throw new Error(`Unable to find "${e}" plugin`); r.requested[e] = !0, r.loaded[e] = i.fn.apply(n, [n.plugins.settings[e] || {}]), r.names.push(e); }

      require(t) { const e = this; const n = e.plugins; if (!e.plugins.loaded.hasOwnProperty(t)) { if (n.requested[t]) throw new Error(`Plugin has circular dependency ("${t}")`); e.loadPlugin(t); } return n.loaded[t]; }
    };
  }(e)) {
    constructor(t, e) {
      let n; super(), this.control_input = void 0, this.wrapper = void 0, this.dropdown = void 0, this.control = void 0, this.dropdown_content = void 0, this.order = 0, this.settings = void 0, this.input = void 0, this.tabIndex = void 0, this.is_select_tag = void 0, this.rtl = void 0, this.inputId = void 0, this._destroy = void 0, this.sifter = void 0, this.tab_key = !1, this.isOpen = !1, this.isDisabled = !1, this.isRequired = void 0, this.isInvalid = !1, this.isLocked = !1, this.isFocused = !1, this.isInputHidden = !1, this.isSetup = !1, this.ignoreFocus = !1, this.hasOptions = !1, this.currentResults = void 0, this.lastValue = "", this.caretPos = 0, this.loading = 0, this.loadedSearches = {}, this.activeOption = null, this.activeItems = [], this.optgroups = {}, this.options = {}, this.userOptions = {}, this.items = [], this.renderCache = { item: {}, option: {} }, B++; let r = f(t); const i = this; if (r.tomselect) throw new Error("Tom Select already initialized on this element"); r.tomselect = this, n = (window.getComputedStyle && window.getComputedStyle(r, null)).getPropertyValue("direction"), this.settings = z(r, e), this.input = r, this.tabIndex = r.tabIndex || 0, this.is_select_tag = r.tagName.toLowerCase() === "select", this.rtl = /rtl/i.test(n), this.inputId = R(r, `tomselect-${B}`), this.isRequired = r.required, this.sifter = new p(this.options, { diacritics: this.settings.diacritics }), this.setupOptions(this.settings.options, this.settings.optgroups), delete this.settings.optgroups, delete this.settings.options, this.settings.mode = this.settings.mode || (this.settings.maxItems === 1 ? "single" : "multi"), typeof this.settings.hideSelected !== "boolean" && (this.settings.hideSelected = this.settings.mode === "multi"), typeof this.settings.hidePlaceholder !== "boolean" && (this.settings.hidePlaceholder = this.settings.mode !== "multi"); let o; let s; let a; let l; let c; let d; let h; let m; let g; let y = this.settings.createFilter; typeof y !== "function" && (typeof y === "string" && (y = new RegExp(y)), y instanceof RegExp ? this.settings.createFilter = (t) => y.test(t) : this.settings.createFilter = () => !0), this.initializePlugins(this.settings.plugins), this.setupCallbacks(), this.setupTemplates(), e = i.settings, r = i.input; const _ = { passive: !0 }; const b = `${i.inputId}-ts-dropdown`; if (d = i.settings.mode, h = r.getAttribute("class") || "", o = f("<div>"), v(o, e.wrapperClass, h, d), s = f('<div class="items">'), v(s, e.inputClass), V(o, s), l = i._render("dropdown"), v(l, e.dropdownClass, d), c = f(`<div role="listbox" id="${b}" tabindex="-1">`), v(c, e.dropdownContentClass), V(l, c), f(e.dropdownParent || o).appendChild(l), e.controlInput)a = f(e.controlInput); else { a = f('<input type="text" autocomplete="off" size="1" />'); for (const t of ["autocorrect", "autocapitalize", "autocomplete"])r.getAttribute(t) && k(a, { [t]: r.getAttribute(t) }); }e.controlInput || (a.tabIndex = r.disabled ? -1 : i.tabIndex, s.appendChild(a)), k(a, {
        role: "combobox", haspopup: "listbox", "aria-expanded": "false", "aria-controls": b,
      }), g = R(a, `${i.inputId}-tomselected`); const x = `label[for='${((t) => t.replace(/['"\\]/g, "\\$&"))(i.inputId)}']`; const S = document.querySelector(x); if (S) { k(S, { for: g }); const t = R(S, `${i.inputId}-ts-label`); k(c, { "aria-labelledby": t }); }i.settings.copyClassesToDropdown && v(l, h), o.style.width = r.style.width, i.plugins.names.length && (m = `plugin-${i.plugins.names.join(" plugin-")}`, v([o, l], m)), (e.maxItems === null || e.maxItems > 1) && i.is_select_tag && k(r, { multiple: "multiple" }), i.settings.placeholder && k(a, { placeholder: e.placeholder }), !i.settings.splitOn && i.settings.delimiter && (i.settings.splitOn = new RegExp(`\\s*${u(i.settings.delimiter)}+\\s*`)), this.settings.load && this.settings.loadThrottle && (this.settings.load = L(this.settings.load, this.settings.loadThrottle)), this.control = s, this.control_input = a, this.wrapper = o, this.dropdown = l, this.dropdown_content = c, i.control_input.type = r.type, D(l, "click", (t) => { const e = w(t.target, "[data-selectable]"); e && (i.onOptionSelect(t, e), j(t, !0)); }), D(s, "click", (t) => { const e = w(t.target, `.${i.settings.itemClass}`, s); e && i.onItemSelect(t, e) ? j(t, !0) : a.value == "" && (i.onClick(), j(t, !0)); }), D(a, "mousedown", (t) => { a.value !== "" && t.stopPropagation(); }), D(a, "keydown", (t) => i.onKeyDown(t)), D(a, "keyup", (t) => i.onKeyUp(t)), D(a, "keypress", (t) => i.onKeyPress(t)), D(a, "resize", () => i.positionDropdown(), _), D(a, "blur", () => i.onBlur()), D(a, "focus", (t) => i.onFocus(t)), D(a, "paste", (t) => i.onPaste(t)); const C = (t) => { const e = t.composedPath()[0]; if (!o.contains(e) && !l.contains(e)) return i.isFocused && i.blur(), void i.inputState(); j(t, !0); }; const E = () => { i.isOpen && i.positionDropdown(); }; D(document, "mousedown", C), D(window, "sroll", E, _), D(window, "resize", E, _), this._destroy = () => { document.removeEventListener("mousedown", C), window.removeEventListener("sroll", E), window.removeEventListener("resize", E); }, this.revertSettings = { innerHTML: r.innerHTML, tabIndex: r.tabIndex }, r.tabIndex = -1, k(r, { hidden: "hidden" }), r.insertAdjacentElement("afterend", i.wrapper), i.setValue(e.items), e.items = [], D(r, "invalid", (t) => { j(t), i.isInvalid || (i.isInvalid = !0, i.refreshState()); }), i.updateOriginalInput(), i.refreshItems(), i.close(!1), i.inputState(), i.isSetup = !0, r.disabled && i.disable(), i.on("change", this.onChange), v(r, "tomselected"), i.trigger("initialize"), !0 === e.preload && i.load(""), i.setup();
    }

    setup() {}

    setupOptions(t = [], e = []) { for (const e of t) this.registerOption(e); for (const t of e) this.registerOptionGroup(t); }

    setupTemplates() {
      const t = this; const e = t.settings.labelField; const n = t.settings.optgroupLabelField; const r = {
        optgroup: (t) => { const e = document.createElement("div"); return e.className = "optgroup", e.appendChild(t.options), e; }, optgroup_header: (t, e) => `<div class="optgroup-header">${e(t[n])}</div>`, option: (t, n) => `<div>${n(t[e])}</div>`, item: (t, n) => `<div>${n(t[e])}</div>`, option_create: (t, e) => `<div class="create">Add <strong>${e(t.input)}</strong>&hellip;</div>`, no_results: () => '<div class="no-results">No results found</div>', loading: () => '<div class="spinner"></div>', not_loading: () => {}, dropdown: () => "<div></div>",
      }; t.settings.render = { ...r, ...t.settings.render };
    }

    setupCallbacks() {
      let t; let e; const n = {
        initialize: "onInitialize", change: "onChange", item_add: "onItemAdd", item_remove: "onItemRemove", item_select: "onItemSelect", clear: "onClear", option_add: "onOptionAdd", option_remove: "onOptionRemove", option_clear: "onOptionClear", optgroup_add: "onOptionGroupAdd", optgroup_remove: "onOptionGroupRemove", optgroup_clear: "onOptionGroupClear", dropdown_open: "onDropdownOpen", dropdown_close: "onDropdownClose", type: "onType", load: "onLoad", focus: "onFocus", blur: "onBlur",
      }; for (t in n)(e = this.settings[n[t]]) && this.on(t, e);
    }

    onClick() { const t = this; if (t.activeItems.length > 0) return t.clearActiveItems(), void t.focus(); t.isFocused && t.isOpen ? t.blur() : t.focus(); }

    onMouseDown() {}

    onChange() { m(this.input, "input"), m(this.input, "change"); }

    onPaste(t) { const e = this; e.isFull() || e.isInputHidden || e.isLocked ? j(t) : e.settings.splitOn && setTimeout(() => { const t = e.inputValue(); if (t.match(e.settings.splitOn)) { const n = t.trim().split(e.settings.splitOn); for (const t of n)e.createItem(t); } }, 0); }

    onKeyPress(t) { const e = this; if (!e.isLocked) { const n = String.fromCharCode(t.keyCode || t.which); return e.settings.create && e.settings.mode === "multi" && n === e.settings.delimiter ? (e.createItem(), void j(t)) : void 0; }j(t); }

    onKeyDown(t) { const e = this; if (e.isLocked)t.keyCode !== 9 && j(t); else { switch (t.keyCode) { case 65: if (N(T, t)) return void e.selectAll(); break; case 27: return e.isOpen && (j(t, !0), e.close()), void e.clearActiveItems(); case 40: if (!e.isOpen && e.hasOptions)e.open(); else if (e.activeOption) { const t = e.getAdjacent(e.activeOption, 1); t && e.setActiveOption(t); } return void j(t); case 38: if (e.activeOption) { const t = e.getAdjacent(e.activeOption, -1); t && e.setActiveOption(t); } return void j(t); case 13: return void (e.isOpen && e.activeOption ? (e.onOptionSelect(t, e.activeOption), j(t)) : e.settings.create && e.createItem() && j(t)); case 37: return void e.advanceSelection(-1, t); case 39: return void e.advanceSelection(1, t); case 9: return void (e.settings.selectOnTab && (e.isOpen && e.activeOption && (e.tab_key = !0, e.onOptionSelect(t, e.activeOption), j(t), e.tab_key = !1), e.settings.create && e.createItem() && j(t))); case 8: case 46: return void e.deleteSelection(t); }e.isInputHidden && !N(T, t) && j(t); } }

    onKeyUp(t) { const e = this; if (e.isLocked)j(t); else { const n = e.inputValue(); e.lastValue !== n && (e.lastValue = n, e.settings.shouldLoad.call(e, n) && e.load(n), e.refreshOptions(), e.trigger("type", n)); } }

    onFocus(t) { const e = this; const n = e.isFocused; if (e.isDisabled) return e.blur(), void j(t); e.ignoreFocus || (e.isFocused = !0, e.settings.preload === "focus" && e.load(""), n || e.trigger("focus"), e.activeItems.length || (e.showInput(), e.refreshOptions(!!e.settings.openOnFocus)), e.refreshState()); }

    onBlur() { const t = this; if (t.isFocused) { t.isFocused = !1, t.ignoreFocus = !1; const e = () => { t.close(), t.setActiveItem(), t.setCaret(t.items.length), t.trigger("blur"); }; t.settings.create && t.settings.createOnBlur ? t.createItem(null, !1, e) : e(); } }

    onOptionSelect(t, e) { let n; const r = this; e && (e.parentElement && e.parentElement.matches("[data-disabled]") || (e.classList.contains("create") ? r.createItem(null, !0, () => { r.settings.closeAfterSelect && r.close(); }) : void 0 !== (n = e.dataset.value) && (r.lastQuery = null, r.addItem(n), r.settings.closeAfterSelect && r.close(), !r.settings.hideSelected && t.type && /click/.test(t.type) && r.setActiveOption(e)))); }

    onItemSelect(t, e) { const n = this; return !n.isLocked && n.settings.mode === "multi" && (j(t), n.setActiveItem(e, t), !0); }

    canLoad(t) { return !!this.settings.load && !this.loadedSearches.hasOwnProperty(t); }

    load(t) { const e = this; if (!e.canLoad(t)) return; v(e.wrapper, e.settings.loadingClass), e.loading++; const n = e.loadCallback.bind(e); e.settings.load.call(e, t, n); }

    loadCallback(t, e) { const n = this; n.loading = Math.max(n.loading - 1, 0), n.lastQuery = null, n.clearActiveOption(), n.setupOptions(t, e), n.refreshOptions(n.isFocused && !n.isInputHidden), n.loading || y(n.wrapper, n.settings.loadingClass), n.trigger("load", t, e); }

    setTextboxValue(t = "") { const e = this.control_input; e.value !== t && (e.value = t, m(e, "update"), this.lastValue = t); }

    getValue() { return this.is_select_tag && this.input.hasAttribute("multiple") ? this.items : this.items.join(this.settings.delimiter); }

    setValue(t, e) { I(this, e ? [] : ["change"], () => { this.clear(e), this.addItems(t, e); }); }

    setMaxItems(t) { t === 0 && (t = null), this.settings.maxItems = t, this.refreshState(); }

    setActiveItem(t, e) { let n; let r; let i; let o; let s; let a; const l = this; if (l.settings.mode !== "single") { if (!t) return l.clearActiveItems(), void (l.isFocused && l.showInput()); if ((n = e && e.type.toLowerCase()) === "click" && N("shiftKey", e) && l.activeItems.length) { for (a = l.getLastActive(), (i = Array.prototype.indexOf.call(l.control.children, a)) > (o = Array.prototype.indexOf.call(l.control.children, t)) && (s = i, i = o, o = s), r = i; r <= o; r++)t = l.control.children[r], l.activeItems.indexOf(t) === -1 && l.setActiveItemClass(t); j(e); } else n === "click" && N(T, e) || n === "keydown" && N("shiftKey", e) ? t.classList.contains("active") ? l.removeActiveItem(t) : l.setActiveItemClass(t) : (l.clearActiveItems(), l.setActiveItemClass(t)); l.hideInput(), l.isFocused || l.focus(); } }

    setActiveItemClass(t) { const e = this; const n = e.control.querySelector(".last-active"); n && y(n, "last-active"), v(t, "active last-active"), e.trigger("item_select", t), e.activeItems.indexOf(t) == -1 && e.activeItems.push(t); }

    removeActiveItem(t) { const e = this.activeItems.indexOf(t); this.activeItems.splice(e, 1), y(t, "active"); }

    clearActiveItems() { y(this.activeItems, "active"), this.activeItems = []; }

    setActiveOption(t) { t !== this.activeOption && (this.clearActiveOption(), t && (this.activeOption = t, k(this.control_input, { "aria-activedescendant": t.getAttribute("id") }), k(t, { "aria-selected": "true" }), v(t, "active"), this.scrollToOption(t))); }

    scrollToOption(t, e) { if (!t) return; const n = this.dropdown_content; const r = n.clientHeight; const i = n.scrollTop || 0; const o = t.offsetHeight; const s = t.getBoundingClientRect().top - n.getBoundingClientRect().top + i; s + o > r + i ? this.scroll(s - r + o, e) : s < i && this.scroll(s, e); }

    scroll(t, e) { const n = this.dropdown_content; e && (n.style.scrollBehavior = e), n.scrollTop = t, n.style.scrollBehavior = ""; }

    clearActiveOption() { this.activeOption && (y(this.activeOption, "active"), k(this.activeOption, { "aria-selected": null })), this.activeOption = null, k(this.control_input, { "aria-activedescendant": null }); }

    selectAll() { this.settings.mode !== "single" && (this.activeItems = this.controlChildren(), this.activeItems.length && (v(this.activeItems, "active"), this.hideInput(), this.close()), this.focus()); }

    inputState() { const t = this; t.settings.controlInput || (t.activeItems.length > 0 || !t.isFocused && this.settings.hidePlaceholder && t.items.length > 0 ? (t.setTextboxValue(), t.isInputHidden = !0, v(t.wrapper, "input-hidden")) : (t.isInputHidden = !1, y(t.wrapper, "input-hidden"))); }

    hideInput() { this.inputState(); }

    showInput() { this.inputState(); }

    inputValue() { return this.control_input.value.trim(); }

    focus() { const t = this; t.isDisabled || (t.ignoreFocus = !0, t.control_input.focus(), setTimeout(() => { t.ignoreFocus = !1, t.onFocus(); }, 0)); }

    blur() { this.control_input.blur(), this.onBlur(); }

    getScoreFunction(t) { return this.sifter.getScoreFunction(t, this.getSearchOptions()); }

    getSearchOptions() {
      const t = this.settings; let e = t.sortField; return typeof t.sortField === "string" && (e = [{ field: t.sortField }]), {
        fields: t.searchField, conjunction: t.searchConjunction, sort: e, nesting: t.nesting,
      };
    }

    search(t) { let e; let n; let r; const i = this; const o = this.getSearchOptions(); if (i.settings.score && typeof (r = i.settings.score.call(i, t)) !== "function") throw new Error('Tom Select "score" setting must be a function that returns a function'); if (t !== i.lastQuery ? (i.lastQuery = t, n = i.sifter.search(t, Object.assign(o, { score: r })), i.currentResults = n) : n = { ...i.currentResults }, i.settings.hideSelected) for (e = n.items.length - 1; e >= 0; e--) { const t = O(n.items[e].id); t && i.items.indexOf(t) !== -1 && n.items.splice(e, 1); } return n; }

    refreshOptions(t = !0) { let e; let n; let r; let i; let o; let s; let a; let l; let u; let c; let d; const h = {}; const p = []; let f; const m = this; const g = m.inputValue(); const v = m.search(g); let _ = m.activeOption; let b = m.settings.shouldOpen || !1; const w = m.dropdown_content; for (_ && (u = _.dataset.value, c = _.closest("[data-group]")), i = v.items.length, typeof m.settings.maxOptions === "number" && (i = Math.min(i, m.settings.maxOptions)), i > 0 && (b = !0), e = 0; e < i; e++) { const t = m.options[v.items[e].id]; const i = A(t[m.settings.valueField]); let a = m.getOption(i); for (a || (a = m._render("option", t)), m.settings.hideSelected || a.classList.toggle("selected", m.items.includes(i)), o = t[m.settings.optgroupField] || "", n = 0, r = (s = Array.isArray(o) ? o : [o]) && s.length; n < r; n++)o = s[n], m.optgroups.hasOwnProperty(o) || (o = ""), h.hasOwnProperty(o) || (h[o] = document.createDocumentFragment(), p.push(o)), n > 0 && (a = a.cloneNode(!0), k(a, { id: `${t.$id}-clone-${n}`, "aria-selected": null }), a.classList.add("ts-cloned"), y(a, "active")), u == i && c && c.dataset.group === o && (_ = a), h[o].appendChild(a); } for (o of (this.settings.lockOptgroupOrder && p.sort((t, e) => (m.optgroups[t] && m.optgroups[t].$order || 0) - (m.optgroups[e] && m.optgroups[e].$order || 0)), a = document.createDocumentFragment(), p)) if (m.optgroups.hasOwnProperty(o) && h[o].children.length) { const t = document.createDocumentFragment(); const e = m.render("optgroup_header", m.optgroups[o]); V(t, e), V(t, h[o]); const n = m.render("optgroup", { group: m.optgroups[o], options: t }); V(a, n); } else V(a, h[o]); if (w.innerHTML = "", V(w, a), m.settings.highlight && (f = w.querySelectorAll("span.highlight"), Array.prototype.forEach.call(f, ((t) => { const e = t.parentNode; e.replaceChild(t.firstChild, t), e.normalize(); })), v.query.length && v.tokens.length)) for (const t of v.tokens)E(w, t.regex); const x = (t) => { const e = m.render(t, { input: g }); return e && (b = !0, w.insertBefore(e, w.firstChild)), e; }; if (m.settings.shouldLoad.call(m, g) ? m.loading ? x("loading") : v.items.length === 0 && x("no_results") : x("not_loading"), (l = m.canCreate(g)) && (d = x("option_create")), m.hasOptions = v.items.length > 0 || l, b) { if (v.items.length > 0) { if (!w.contains(_) && m.settings.mode === "single" && m.items.length && (_ = m.getOption(m.items[0])), !w.contains(_)) { let t = 0; d && !m.settings.addPrecedence && (t = 1), _ = m.selectable()[t]; } } else d && (_ = d); t && !m.isOpen && (m.open(), m.scrollToOption(_, "auto")), m.setActiveOption(_); } else m.clearActiveOption(), t && m.isOpen && m.close(!1); }

    selectable() { return this.dropdown_content.querySelectorAll("[data-selectable]"); }

    addOption(t) { let e; const n = this; if (Array.isArray(t)) for (const e of t)n.addOption(e); else (e = n.registerOption(t)) && (n.userOptions[e] = !0, n.lastQuery = null, n.trigger("option_add", e, t)); }

    registerOption(t) { const e = O(t[this.settings.valueField]); return e !== null && !this.options.hasOwnProperty(e) && (t.$order = t.$order || ++this.order, t.$id = `${this.inputId}-opt-${t.$order}`, this.options[e] = t, e); }

    registerOptionGroup(t) { const e = O(t[this.settings.optgroupValueField]); return e !== null && (t.$order = t.$order || ++this.order, this.optgroups[e] = t, e); }

    addOptionGroup(t, e) { let n; e[this.settings.optgroupValueField] = t, (n = this.registerOptionGroup(e)) && this.trigger("optgroup_add", n, e); }

    removeOptionGroup(t) { this.optgroups.hasOwnProperty(t) && (delete this.optgroups[t], this.clearCache(), this.trigger("optgroup_remove", t)); }

    clearOptionGroups() { this.optgroups = {}, this.clearCache(), this.trigger("optgroup_clear"); }

    updateOption(t, e) { const n = this; let r; let i; const o = O(t); if (o === null) return; const s = O(e[n.settings.valueField]); const a = n.getOption(o); const l = n.getItem(o); if (n.options.hasOwnProperty(o)) { if (typeof s !== "string") throw new Error("Value must be set in option data"); if (e.$order = e.$order || n.options[o].$order, delete n.options[o], n.uncacheValue(s), n.uncacheValue(o, !1), n.options[s] = e, a) { if (n.dropdown_content.contains(a)) { const t = n._render("option", e); C(a, t), n.activeOption === a && n.setActiveOption(t); }a.remove(); }l && ((i = n.items.indexOf(o)) !== -1 && n.items.splice(i, 1, s), r = n._render("item", e), l.classList.contains("active") && v(r, "active"), C(l, r)), n.lastQuery = null; } }

    removeOption(t, e) { const n = this; t = A(t), n.uncacheValue(t), delete n.userOptions[t], delete n.options[t], n.lastQuery = null, n.trigger("option_remove", t), n.removeItem(t, e); }

    clearOptions() { this.loadedSearches = {}, this.userOptions = {}, this.clearCache(); const t = {}; for (const e in this.options) this.options.hasOwnProperty(e) && this.items.indexOf(e) >= 0 && (t[e] = this.options[e]); this.options = this.sifter.items = t, this.lastQuery = null, this.trigger("option_clear"); }

    uncacheValue(t, e = !0) { const n = this; const r = n.renderCache.item; const i = n.renderCache.option; if (r && delete r[t], i && delete i[t], e) { const e = n.getOption(t); e && e.remove(); } }

    getOption(t) { const e = O(t); return this.rendered("option", e); }

    getAdjacent(t, e, n = "option") { let r; if (!t) return null; r = n == "item" ? this.controlChildren() : this.dropdown_content.querySelectorAll("[data-selectable]"); for (let n = 0; n < r.length; n++) if (r[n] == t) return e > 0 ? r[n + 1] : r[n - 1]; return null; }

    getItem(t) { if (typeof t === "object") return t; const e = O(t); return e ? this.control.querySelector(`[data-value="${F(e)}"]`) : null; }

    addItems(t, e) { const n = this; let r = Array.isArray(t) ? t : [t]; for (let t = 0, i = (r = r.filter((t) => n.items.indexOf(t) === -1)).length; t < i; t++)n.isPending = t < i - 1, n.addItem(r[t], e); }

    addItem(t, e) { I(this, e ? [] : ["change"], () => { let n; let r; const i = this; const o = i.settings.mode; const s = O(t); if ((!s || i.items.indexOf(s) === -1 || (o === "single" && i.close(), o !== "single" && i.settings.duplicates)) && s !== null && i.options.hasOwnProperty(s) && (o === "single" && i.clear(e), o !== "multi" || !i.isFull())) { if (n = i._render("item", i.options[s]), i.control.contains(n) && (n = n.cloneNode(!0)), r = i.isFull(), i.items.splice(i.caretPos, 0, s), i.insertAtCaret(n), i.isSetup) { const t = i.selectable(); if (!i.isPending && i.settings.hideSelected) { const t = i.getOption(s); const e = i.getAdjacent(t, 1); e && i.setActiveOption(e); }i.isPending || i.refreshOptions(i.isFocused && o !== "single"), !t.length || i.isFull() ? i.close() : i.isPending || i.positionDropdown(), i.trigger("item_add", s, n), i.isPending || i.updateOriginalInput({ silent: e }); }(!i.isPending || !r && i.isFull()) && i.refreshState(); } }); }

    removeItem(t = null, e) { const n = this; if (!(t = n.getItem(t))) return; let r; let i; const o = t.dataset.value; r = S(t), t.remove(), t.classList.contains("active") && (i = n.activeItems.indexOf(t), n.activeItems.splice(i, 1), y(t, "active")), n.items.splice(r, 1), n.lastQuery = null, !n.settings.persist && n.userOptions.hasOwnProperty(o) && n.removeOption(o, e), r < n.caretPos && n.setCaret(n.caretPos - 1), n.updateOriginalInput({ silent: e }), n.refreshState(), n.positionDropdown(), n.trigger("item_remove", o, t); }

    createItem(t = null, e = !0, n = (() => {})) { let r; const i = this; const o = i.caretPos; if (t = t || i.inputValue(), !i.canCreate(t)) return n(), !1; i.lock(); let s = !1; const a = (t) => { if (i.unlock(), !t || typeof t !== "object") return n(); const r = O(t[i.settings.valueField]); if (typeof r !== "string") return n(); i.setTextboxValue(), i.addOption(t), i.setCaret(o), i.addItem(r), i.refreshOptions(e && i.settings.mode !== "single"), n(t), s = !0; }; return r = typeof i.settings.create === "function" ? i.settings.create.call(this, t, a) : { [i.settings.labelField]: t, [i.settings.valueField]: t }, s || a(r), !0; }

    refreshItems() { const t = this; t.lastQuery = null, t.isSetup && t.addItems(t.items), t.updateOriginalInput(), t.refreshState(); }

    refreshState() { const t = this; t.refreshValidityState(); const e = t.isFull(); const n = t.isLocked; t.wrapper.classList.toggle("rtl", t.rtl); let r; const i = t.control.classList; i.toggle("focus", t.isFocused), i.toggle("disabled", t.isDisabled), i.toggle("required", t.isRequired), i.toggle("invalid", t.isInvalid), i.toggle("locked", n), i.toggle("full", e), i.toggle("not-full", !e), i.toggle("input-active", t.isFocused && !t.isInputHidden), i.toggle("dropdown-active", t.isOpen), i.toggle("has-options", (r = t.options, Object.keys(r).length === 0)), i.toggle("has-items", t.items.length > 0); }

    refreshValidityState() { const t = this; if (t.input.checkValidity) { this.isRequired && (t.input.required = !0); const e = !t.input.checkValidity(); t.isInvalid = e, t.control_input.required = e, this.isRequired && (t.input.required = !e); } }

    isFull() { return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems; }

    updateOriginalInput(t = {}) { const e = this; let n; let r; let i; let o; if (e.is_select_tag) { const t = []; function s(n, r, i) { return n || (n = f(`<option value="${M(r)}">${M(i)}</option>`)), e.input.prepend(n), t.push(n), k(n, { selected: "true" }), n.selected = !0, n; } if (e.input.querySelectorAll("option[selected]").forEach((t) => { k(t, { selected: null }), t.selected = !1; }), e.items.length != 0 || e.settings.mode != "single" || e.isRequired) for (n = e.items.length - 1; n >= 0; n--)r = e.items[n], o = (i = e.options[r])[e.settings.labelField] || "", t.includes(i.$option) ? s(e.input.querySelector(`option[value="${F(r)}"]:not([selected])`), r, o) : i.$option = s(i.$option, r, o); else s(e.input.querySelector('option[value=""]'), "", ""); } else e.input.value = e.getValue(); e.isSetup && (t.silent || e.trigger("change", e.getValue())); }

    open() { const t = this; t.isLocked || t.isOpen || t.settings.mode === "multi" && t.isFull() || (t.isOpen = !0, k(t.control_input, { "aria-expanded": "true" }), t.refreshState(), g(t.dropdown, { visibility: "hidden", display: "block" }), t.positionDropdown(), g(t.dropdown, { visibility: "visible", display: "block" }), t.focus(), t.trigger("dropdown_open", t.dropdown)); }

    close(t = !0) { const e = this; const n = e.isOpen; t && (e.setTextboxValue(), e.settings.mode === "single" && e.items.length && (e.hideInput(), e.tab_key || e.blur())), e.isOpen = !1, k(e.control_input, { "aria-expanded": "false" }), g(e.dropdown, { display: "none" }), e.settings.hideSelected && e.clearActiveOption(), e.refreshState(), n && e.trigger("dropdown_close", e.dropdown); }

    positionDropdown() { if (this.settings.dropdownParent === "body") { const t = this.control; const e = t.getBoundingClientRect(); const n = t.offsetHeight + e.top + window.scrollY; const r = e.left + window.scrollX; g(this.dropdown, { width: `${e.width}px`, top: `${n}px`, left: `${r}px` }); } }

    clear(t) { const e = this; if (e.items.length) { const n = e.controlChildren(); for (const t of n)t.remove(); e.items = [], e.lastQuery = null, e.setCaret(0), e.clearActiveItems(), e.updateOriginalInput({ silent: t }), e.refreshState(), e.showInput(), e.trigger("clear"); } }

    insertAtCaret(t) { const e = this; const n = Math.min(e.caretPos, e.items.length); const r = e.control; n === 0 ? r.insertBefore(t, r.firstChild) : r.insertBefore(t, r.children[n]), e.setCaret(n + 1); }

    deleteSelection(t) { let e; let n; let r; let i; let o; const s = this; e = t && t.keyCode === 8 ? -1 : 1, n = { start: (o = s.control_input).selectionStart || 0, length: (o.selectionEnd || 0) - (o.selectionStart || 0) }; const a = []; if (s.activeItems.length) { i = x(s.activeItems, e), r = S(i), e > 0 && r++; for (const t of s.activeItems)a.push(t); } else if ((s.isFocused || s.settings.mode === "single") && s.items.length) { const t = s.controlChildren(); e < 0 && n.start === 0 && n.length === 0 ? a.push(t[s.caretPos - 1]) : e > 0 && n.start === s.inputValue().length && a.push(t[s.caretPos]); } const l = a.map((t) => t.dataset.value); if (!l.length || typeof s.settings.onDelete === "function" && !1 === s.settings.onDelete.call(s, l, t)) return !1; for (j(t, !0), void 0 !== r && s.setCaret(r); a.length;)s.removeItem(a.pop()); return s.showInput(), s.positionDropdown(), s.refreshOptions(!1), !0; }

    advanceSelection(t, e) { let n; let r; let i; const o = this; o.rtl && (t *= -1), o.inputValue().length || (N(T, e) || N("shiftKey", e) ? (i = (r = o.getLastActive(t)) ? r.classList.contains("active") ? o.getAdjacent(r, t, "item") : r : t > 0 ? o.control_input.nextElementSibling : o.control_input.previousElementSibling) && (i.classList.contains("active") && o.removeActiveItem(r), o.setActiveItemClass(i)) : o.isFocused && !o.activeItems.length ? o.setCaret(o.caretPos + t) : (r = o.getLastActive(t)) && (n = S(r), o.setCaret(t > 0 ? n + 1 : n), o.setActiveItem())); }

    getLastActive(t) { const e = this.control.querySelector(".last-active"); if (e) return e; const n = this.control.querySelectorAll(".active"); return n ? x(n, t) : void 0; }

    setCaret(t) { const e = this; e.settings.mode === "single" || e.settings.controlInput ? t = e.items.length : (t = Math.max(0, Math.min(e.items.length, t))) == e.caretPos || e.isPending || e.controlChildren().forEach((n, r) => { r < t ? e.control_input.insertAdjacentElement("beforebegin", n) : e.control.appendChild(n); }), e.caretPos = t; }

    controlChildren() { return Array.from(this.control.getElementsByClassName(this.settings.itemClass)); }

    lock() { this.close(), this.isLocked = !0, this.refreshState(); }

    unlock() { this.isLocked = !1, this.refreshState(); }

    disable() { const t = this; t.input.disabled = !0, t.control_input.disabled = !0, t.control_input.tabIndex = -1, t.isDisabled = !0, t.lock(); }

    enable() { const t = this; t.input.disabled = !1, t.control_input.disabled = !1, t.control_input.tabIndex = t.tabIndex, t.isDisabled = !1, t.unlock(); }

    destroy() { const t = this; const e = t.revertSettings; t.trigger("destroy"), t.off(), t.wrapper.remove(), t.dropdown.remove(), t.input.innerHTML = e.innerHTML, t.input.tabIndex = e.tabIndex, y(t.input, "tomselected"), k(t.input, { hidden: null }), t.input.required = this.isRequired, t._destroy(), delete t.input.tomselect; }

    render(t, e) { return typeof this.settings.render[t] !== "function" ? null : this._render(t, e); }

    _render(t, e) { let n; let r; let i = ""; const o = this; return (t === "option" || t === "item") && (i = A(e[o.settings.valueField]), r = o.rendered(t, i)) || (r = o.settings.render[t].call(this, e, M)) == null || (r = f(r), t === "option" || t === "option_create" ? e[o.settings.disabledField] ? k(r, { "aria-disabled": "true" }) : k(r, { "data-selectable": "" }) : t === "optgroup" && (n = e.group[o.settings.optgroupValueField], k(r, { "data-group": n }), e.group[o.settings.disabledField] && k(r, { "data-disabled": "" })), t !== "option" && t !== "item" || (k(r, { "data-value": i }), t === "item" ? v(r, o.settings.itemClass) : (v(r, o.settings.optionClass), k(r, { role: "option", id: e.$id })), o.renderCache[t][i] = r)), r; }

    rendered(t, e) { return e !== null && this.renderCache[t].hasOwnProperty(e) ? this.renderCache[t][e] : null; }

    clearCache(t) { const e = this; for (const t in e.options) { const n = e.getOption(t); n && n.remove(); } void 0 === t ? e.renderCache = { item: {}, option: {} } : e.renderCache[t] = {}; }

    canCreate(t) { return this.settings.create && t.length > 0 && this.settings.createFilter.call(this, t); }

    hook(t, e, n) { const r = this; const i = r[e]; r[e] = function () { let e; let o; return t === "after" && (e = i.apply(r, arguments)), o = n.apply(r, arguments), t === "instead" ? o : (t === "before" && (e = i.apply(r, arguments)), e); }; }
  } return q.define("change_listener", (function () { const t = this; const e = (e) => e.join(t.settings.delimiter); D(t.input, "change", () => { const n = z(t.input, { delimiter: t.settings.delimiter }); e(t.items) != e(n.items) && (t.setupOptions(n.options, n.optgroups), t.setValue(n.items)); }); })), q.define("checkbox_options", (function () { const t = this; const e = t.onOptionSelect; t.settings.hideSelected = !1; const n = function (t) { setTimeout(() => { const e = t.querySelector("input"); t.classList.contains("selected") ? e.checked = !0 : e.checked = !1; }, 1); }; t.hook("after", "setupTemplates", () => { const e = t.settings.render.option; t.settings.render.option = (n, r) => { const i = f(e.call(t, n, r)); const o = document.createElement("input"); o.addEventListener("click", ((t) => { j(t); })), o.type = "checkbox"; const s = O(n[t.settings.valueField]); return s && t.items.indexOf(s) > -1 && (o.checked = !0), i.prepend(o), i; }; }), t.on("item_remove", (e) => { const r = t.getOption(e); r && (r.classList.remove("selected"), n(r)); }), t.hook("instead", "onOptionSelect", (r, i) => { if (i.classList.contains("selected")) return i.classList.remove("selected"), t.removeItem(i.dataset.value), t.refreshOptions(), void j(r, !0); e.call(t, r, i), n(i); }); })), q.define("clear_button", (function (t) {
    const e = this; const n = {
      className: "clear-button", title: "Clear All", html: (t) => `<div class="${t.className}" title="${t.title}">&times;</div>`, ...t,
    }; e.on("initialize", () => { const t = f(n.html(n)); t.addEventListener("click", (t) => { e.clear(), t.preventDefault(), t.stopPropagation(); }), e.control.appendChild(t); });
  })), q.define("drag_drop", (function () {
    const t = this; if (!$.fn.sortable) throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".'); if (t.settings.mode === "multi") {
      const e = t.lock; const n = t.unlock; t.hook("instead", "lock", () => { const n = $(t.control).data("sortable"); return n && n.disable(), e.call(t); }), t.hook("instead", "unlock", () => { const e = $(t.control).data("sortable"); return e && e.enable(), n.call(t); }), t.on("initialize", () => {
        var e = $(t.control).sortable({
          items: "[data-value]", forcePlaceholderSize: !0, disabled: t.isLocked, start: (t, n) => { n.placeholder.css("width", n.helper.css("width")), e.css({ overflow: "visible" }); }, stop: () => { e.css({ overflow: "hidden" }); const n = []; e.children("[data-value]").each((function () { this.dataset.value && n.push(this.dataset.value); })), t.setValue(n); },
        });
      });
    }
  })), q.define("dropdown_header", (function (t) {
    const e = this; const n = {
      title: "Untitled", headerClass: "dropdown-header", titleRowClass: "dropdown-header-title", labelClass: "dropdown-header-label", closeClass: "dropdown-header-close", html: (t) => `<div class="${t.headerClass}"><div class="${t.titleRowClass}"><span class="${t.labelClass}">${t.title}</span><a class="${t.closeClass}">&times;</a></div></div>`, ...t,
    }; e.on("initialize", () => { const t = f(n.html(n)); const r = t.querySelector(`.${n.closeClass}`); r && r.addEventListener("click", (t) => { j(t, !0), e.close(); }), e.dropdown.insertBefore(t, e.dropdown.firstChild); });
  })), q.define("dropdown_input", (function () { const t = this; let e = t.settings.controlInput || '<input type="text" autocomplete="off" class="dropdown-input" />'; e = f(e), t.settings.placeholder && k(e, { placeholder: t.settings.placeholder }), t.settings.controlInput = e, t.settings.shouldOpen = !0, t.on("initialize", () => { D(t.wrapper, "focus", (e) => { t.onFocus(e); }); const n = () => { k(t.wrapper, { tabindex: t.input.disabled ? "-1" : t.tabIndex }); }; t.on("dropdown_close", n), t.on("dropdown_open", () => k(t.wrapper, { tabindex: "-1" })), n(), D(t.wrapper, "keypress", (e) => { if (!t.control.contains(e.target) && !t.dropdown.contains(e.target)) switch (e.keyCode) { case 13: return void t.onClick(); } }); const r = f('<div class="dropdown-input-wrap">'); r.appendChild(e), t.dropdown.insertBefore(r, t.dropdown.firstChild); }); })), q.define("input_autogrow", (function () { const t = this; t.on("initialize", () => { const e = document.createElement("span"); const n = t.control_input; e.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ", t.wrapper.appendChild(e); for (const t of ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"])e.style[t] = n.style[t]; const r = () => { t.items.length > 0 ? (e.textContent = n.value, n.style.width = `${e.clientWidth}px`) : n.style.width = ""; }; r(), t.on("update item_add item_remove", r), D(n, "input", r), D(n, "keyup", r), D(n, "blur", r), D(n, "update", r); }); })), q.define("no_backspace_delete", (function () { const t = this; const e = t.deleteSelection; this.hook("instead", "deleteSelection", (n) => !!t.activeItems.length && e.call(t, n)); })), q.define("no_active_items", (function () { this.hook("instead", "setActiveItem", () => {}), this.hook("instead", "selectAll", () => {}); })), q.define("optgroup_columns", (function () { const t = this; const e = t.onKeyDown; t.hook("instead", "onKeyDown", (n) => { let r; let i; let o; let s; if (!t.isOpen || n.keyCode !== 37 && n.keyCode !== 39) return e.call(t, n); s = w(t.activeOption, "[data-group]"), r = S(t.activeOption, "[data-selectable]"), s && (s = n.keyCode === 37 ? s.previousSibling : s.nextSibling) && (i = (o = s.querySelectorAll("[data-selectable]"))[Math.min(o.length - 1, r)]) && t.setActiveOption(i); }); })), q.define("remove_button", (function (t) {
    const e = {
      label: "&times;", title: "Remove", className: "remove", append: !0, ...t,
    }; const n = this; if (e.append) { const r = `<a href="javascript:void(0)" class="${e.className}" tabindex="-1" title="${M(e.title)}">${e.label}</a>`; n.hook("after", "setupTemplates", () => { const t = n.settings.render.item; n.settings.render.item = (e, i) => { const o = f(t.call(n, e, i)); const s = f(r); return o.appendChild(s), D(s, "mousedown", (t) => { j(t, !0); }), D(s, "click", (t) => { if (j(t, !0), !n.isLocked) { const e = o.dataset.value; n.removeItem(e), n.refreshOptions(!1); } }), o; }; }); }
  })), q.define("restore_on_backspace", (function (t) { const e = this; const n = { text: (t) => t[e.settings.labelField], ...t }; e.on("item_remove", ((t) => { if (e.control_input.value.trim() === "") { const r = e.options[t]; r && e.setTextboxValue(n.text.call(e, r)); } })); })), q.define("virtual_scroll", (function () { const t = this; const e = t.canLoad; const n = t.clearActiveOption; const r = t.loadCallback; let i; let o = {}; let s = !1; if (!t.settings.firstUrl) throw "virtual_scroll plugin requires a firstUrl() method"; function a(e) { return !(typeof t.settings.maxOptions === "number" && i.children.length >= t.settings.maxOptions || !(e in o) || !o[e]); }t.settings.sortField = [{ field: "$order" }, { field: "$score" }], t.setNextUrl = function (t, e) { o[t] = e; }, t.getUrl = function (e) { if (e in o) { const t = o[e]; return o[e] = !1, t; } return o = {}, t.settings.firstUrl(e); }, t.hook("instead", "clearActiveOption", () => { if (!s) return n.call(t); }), t.hook("instead", "canLoad", (n) => (n in o ? a(n) : e.call(t, n))), t.hook("instead", "loadCallback", (e, n) => { s || t.clearOptions(), r.call(t, e, n), s = !1; }), t.hook("after", "refreshOptions", () => { const e = t.lastValue; let n; a(e) ? (n = t.render("loading_more", { query: e })) && n.setAttribute("data-selectable", "") : e in o && !i.querySelector(".no-results") && (n = t.render("no_more_results", { query: e })), n && (v(n, t.settings.optionClass), i.append(n)); }), t.on("initialize", () => { i = t.dropdown_content, t.settings.render = { loading_more() { return '<div class="loading-more-results">Loading more results ... </div>'; }, no_more_results() { return '<div class="no-more-results">No more results</div>'; }, ...t.settings.render }, i.addEventListener("scroll", (() => { i.clientHeight / (i.scrollHeight - i.scrollTop) < 0.95 || a(t.lastValue) && (s || (s = !0, t.load.call(t, t.lastValue))); })); }); })), q;
}))); const tomSelect = function (t, e) { return new TomSelect(t, e); }; let module; !(function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSToggleState = e() : t.HSToggleState = e(); }(window, (() => (function (t) { const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const i in t)n.d(r, i, ((e) => t[e]).bind(null, i)); return r; }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return n.d(e, "a", e), e; }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.p = "", n(n.s = "./src/js/hs-toggle-state.js"); }({
  "./src/js/hs-toggle-state.js":
  /*! ***********************************!*\
  !*** ./src/js/hs-toggle-state.js ***!
  \********************************** */
  /*! exports provided: default */function (t, e, n) {
    function r(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } }n.r(e), n.d(e, "default", (() => o));
    /*
* HSToggleState Plugin
* @version: 3.0.1 (Sun, 01 Aug 2021)
* @author: HtmlStream
* @event-namespace: .HSToggleState
* @license: Htmlstream Libraries (https://htmlstream.com/)
* Copyright 2021 Htmlstream
*/
    const i = { targetSelector: null, slaveSelector: null, classMap: { toggle: "toggled" } }; var o = (function () { function t(e, n, r) { let i; !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.collection = [], i = e instanceof HTMLElement ? [e] : e instanceof Object ? e : document.querySelectorAll(e); for (let o = 0; o < i.length; o += 1) this.addToCollection(i[o], n, r || i[o].id); return !!this.collection.length && (this._init(), this); } let e; let n; return e = t, (n = [{ key: "_init", value() { for (var t = this, e = function (e) { let n; let r = void 0; if (t.collection[e].hasOwnProperty("$initializedEl")) return "continue"; r = t.collection[e].$el, n = t.collection[e].options, t.prepareObject(r, n); const i = document.querySelector(n.slaveSelector); r.addEventListener("click", (() => { r.classList.toggle(n.classMap.toggle), n.slaveSelector && (r.classList.contains(n.classMap.toggle) ? i.classList.add(n.classMap.toggle) : i.classList.remove(n.classMap.toggle)), t.checkState(r, n); })), i && i.addEventListener("click", (() => { document.querySelector('[data-hs-toggle-state-slave="'.concat(n.slaveSelector, '"]')).classList.remove(n.classMap.toggle); })), t.collection[e].$initializedEl = n; }, n = 0; n < t.collection.length; n += 1)e(n); } }, { key: "prepareObject", value(t, e) { t.setAttribute("data-hs-toggle-state-slave", e.slaveSelector); } }, { key: "checkState", value(t, e) { const n = Array.from(document.querySelectorAll(e.targetSelector)); t.classList.contains(e.classMap.toggle) ? n.forEach(((t) => t.checked = !0)) : n.forEach(((t) => t.checked = !1)); } }, { key: "addToCollection", value(t, e, n) { this.collection.push({ $el: t, id: n || null, options: { ...i, ...(t.hasAttribute("data-hs-toggle-state-options") ? JSON.parse(t.getAttribute("data-hs-toggle-state-options")) : {}), ...e } }); } }, { key: "getItem", value(t) { return typeof t === "number" ? this.collection[t].$initializedEl : this.collection.find(((e) => e.id === t)).$initializedEl; } }]) && r(e.prototype, n), t; }());
  },
})).default))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HsNavScroller = e() : t.HsNavScroller = e(); }(window, (() => {
  return d = {
    "./node_modules/velocity-animate/velocity.js": function (module, exports, __webpack_require__) { eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! VelocityJS.org (1.5.2). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */\r\n\r\n/*************************\r\n Velocity jQuery Shim\r\n *************************/\r\n\r\n/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */\r\n\r\n/* This file contains the jQuery functions that Velocity relies on, thereby removing Velocity\'s dependency on a full copy of jQuery, and allowing it to work in any environment. */\r\n/* These shimmed functions are only used if jQuery isn\'t present. If both this shim and jQuery are loaded, Velocity defaults to jQuery proper. */\r\n/* Browser support: Using this shim instead of jQuery proper removes support for IE8. */\r\n\r\n(function(window) {\r\n\t"use strict";\r\n\t/***************\r\n\t Setup\r\n\t ***************/\r\n\r\n\t/* If jQuery is already loaded, there\'s no point in loading this shim. */\r\n\tif (window.jQuery) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t/* jQuery base. */\r\n\tvar $ = function(selector, context) {\r\n\t\treturn new $.fn.init(selector, context);\r\n\t};\r\n\r\n\t/********************\r\n\t Private Methods\r\n\t ********************/\r\n\r\n\t/* jQuery */\r\n\t$.isWindow = function(obj) {\r\n\t\t/* jshint eqeqeq: false */\r\n\t\treturn obj && obj === obj.window;\r\n\t};\r\n\r\n\t/* jQuery */\r\n\t$.type = function(obj) {\r\n\t\tif (!obj) {\r\n\t\t\treturn obj + "";\r\n\t\t}\r\n\r\n\t\treturn typeof obj === "object" || typeof obj === "function" ?\r\n\t\t\t\tclass2type[toString.call(obj)] || "object" :\r\n\t\t\t\ttypeof obj;\r\n\t};\r\n\r\n\t/* jQuery */\r\n\t$.isArray = Array.isArray || function(obj) {\r\n\t\treturn $.type(obj) === "array";\r\n\t};\r\n\r\n\t/* jQuery */\r\n\tfunction isArraylike(obj) {\r\n\t\tvar length = obj.length,\r\n\t\t\t\ttype = $.type(obj);\r\n\r\n\t\tif (type === "function" || $.isWindow(obj)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (obj.nodeType === 1 && length) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;\r\n\t}\r\n\r\n\t/***************\r\n\t $ Methods\r\n\t ***************/\r\n\r\n\t/* jQuery: Support removed for IE<9. */\r\n\t$.isPlainObject = function(obj) {\r\n\t\tvar key;\r\n\r\n\t\tif (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tif (obj.constructor &&\r\n\t\t\t\t\t!hasOwn.call(obj, "constructor") &&\r\n\t\t\t\t\t!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (key in obj) {\r\n\t\t}\r\n\r\n\t\treturn key === undefined || hasOwn.call(obj, key);\r\n\t};\r\n\r\n\t/* jQuery */\r\n\t$.each = function(obj, callback, args) {\r\n\t\tvar value,\r\n\t\t\t\ti = 0,\r\n\t\t\t\tlength = obj.length,\r\n\t\t\t\tisArray = isArraylike(obj);\r\n\r\n\t\tif (args) {\r\n\t\t\tif (isArray) {\r\n\t\t\t\tfor (; i < length; i++) {\r\n\t\t\t\t\tvalue = callback.apply(obj[i], args);\r\n\r\n\t\t\t\t\tif (value === false) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i in obj) {\r\n\t\t\t\t\tif (!obj.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = callback.apply(obj[i], args);\r\n\r\n\t\t\t\t\tif (value === false) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tif (isArray) {\r\n\t\t\t\tfor (; i < length; i++) {\r\n\t\t\t\t\tvalue = callback.call(obj[i], i, obj[i]);\r\n\r\n\t\t\t\t\tif (value === false) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (i in obj) {\r\n\t\t\t\t\tif (!obj.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = callback.call(obj[i], i, obj[i]);\r\n\r\n\t\t\t\t\tif (value === false) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn obj;\r\n\t};\r\n\r\n\t/* Custom */\r\n\t$.data = function(node, key, value) {\r\n\t\t/* $.getData() */\r\n\t\tif (value === undefined) {\r\n\t\t\tvar getId = node[$.expando],\r\n\t\t\t\t\tstore = getId && cache[getId];\r\n\r\n\t\t\tif (key === undefined) {\r\n\t\t\t\treturn store;\r\n\t\t\t} else if (store) {\r\n\t\t\t\tif (key in store) {\r\n\t\t\t\t\treturn store[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/* $.setData() */\r\n\t\t} else if (key !== undefined) {\r\n\t\t\tvar setId = node[$.expando] || (node[$.expando] = ++$.uuid);\r\n\r\n\t\t\tcache[setId] = cache[setId] || {};\r\n\t\t\tcache[setId][key] = value;\r\n\r\n\t\t\treturn value;\r\n\t\t}\r\n\t};\r\n\r\n\t/* Custom */\r\n\t$.removeData = function(node, keys) {\r\n\t\tvar id = node[$.expando],\r\n\t\t\t\tstore = id && cache[id];\r\n\r\n\t\tif (store) {\r\n\t\t\t// Cleanup the entire store if no keys are provided.\r\n\t\t\tif (!keys) {\r\n\t\t\t\tdelete cache[id];\r\n\t\t\t} else {\r\n\t\t\t\t$.each(keys, function(_, key) {\r\n\t\t\t\t\tdelete store[key];\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/* jQuery */\r\n\t$.extend = function() {\r\n\t\tvar src, copyIsArray, copy, name, options, clone,\r\n\t\t\t\ttarget = arguments[0] || {},\r\n\t\t\t\ti = 1,\r\n\t\t\t\tlength = arguments.length,\r\n\t\t\t\tdeep = false;\r\n\r\n\t\tif (typeof target === "boolean") {\r\n\t\t\tdeep = target;\r\n\r\n\t\t\ttarget = arguments[i] || {};\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tif (typeof target !== "object" && $.type(target) !== "function") {\r\n\t\t\ttarget = {};\r\n\t\t}\r\n\r\n\t\tif (i === length) {\r\n\t\t\ttarget = this;\r\n\t\t\ti--;\r\n\t\t}\r\n\r\n\t\tfor (; i < length; i++) {\r\n\t\t\tif ((options = arguments[i])) {\r\n\t\t\t\tfor (name in options) {\r\n\t\t\t\t\tif (!options.hasOwnProperty(name)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsrc = target[name];\r\n\t\t\t\t\tcopy = options[name];\r\n\r\n\t\t\t\t\tif (target === copy) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {\r\n\t\t\t\t\t\tif (copyIsArray) {\r\n\t\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\t\tclone = src && $.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tclone = src && $.isPlainObject(src) ? src : {};\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttarget[name] = $.extend(deep, clone, copy);\r\n\r\n\t\t\t\t\t} else if (copy !== undefined) {\r\n\t\t\t\t\t\ttarget[name] = copy;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t};\r\n\r\n\t/* jQuery 1.4.3 */\r\n\t$.queue = function(elem, type, data) {\r\n\t\tfunction $makeArray(arr, results) {\r\n\t\t\tvar ret = results || [];\r\n\r\n\t\t\tif (arr) {\r\n\t\t\t\tif (isArraylike(Object(arr))) {\r\n\t\t\t\t\t/* $.merge */\r\n\t\t\t\t\t(function(first, second) {\r\n\t\t\t\t\t\tvar len = +second.length,\r\n\t\t\t\t\t\t\t\tj = 0,\r\n\t\t\t\t\t\t\t\ti = first.length;\r\n\r\n\t\t\t\t\t\twhile (j < len) {\r\n\t\t\t\t\t\t\tfirst[i++] = second[j++];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (len !== len) {\r\n\t\t\t\t\t\t\twhile (second[j] !== undefined) {\r\n\t\t\t\t\t\t\t\tfirst[i++] = second[j++];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfirst.length = i;\r\n\r\n\t\t\t\t\t\treturn first;\r\n\t\t\t\t\t})(ret, typeof arr === "string" ? [arr] : arr);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t[].push.call(ret, arr);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t\tif (!elem) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttype = (type || "fx") + "queue";\r\n\r\n\t\tvar q = $.data(elem, type);\r\n\r\n\t\tif (!data) {\r\n\t\t\treturn q || [];\r\n\t\t}\r\n\r\n\t\tif (!q || $.isArray(data)) {\r\n\t\t\tq = $.data(elem, type, $makeArray(data));\r\n\t\t} else {\r\n\t\t\tq.push(data);\r\n\t\t}\r\n\r\n\t\treturn q;\r\n\t};\r\n\r\n\t/* jQuery 1.4.3 */\r\n\t$.dequeue = function(elems, type) {\r\n\t\t/* Custom: Embed element iteration. */\r\n\t\t$.each(elems.nodeType ? [elems] : elems, function(i, elem) {\r\n\t\t\ttype = type || "fx";\r\n\r\n\t\t\tvar queue = $.queue(elem, type),\r\n\t\t\t\t\tfn = queue.shift();\r\n\r\n\t\t\tif (fn === "inprogress") {\r\n\t\t\t\tfn = queue.shift();\r\n\t\t\t}\r\n\r\n\t\t\tif (fn) {\r\n\t\t\t\tif (type === "fx") {\r\n\t\t\t\t\tqueue.unshift("inprogress");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfn.call(elem, function() {\r\n\t\t\t\t\t$.dequeue(elem, type);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\t/******************\r\n\t $.fn Methods\r\n\t ******************/\r\n\r\n\t/* jQuery */\r\n\t$.fn = $.prototype = {\r\n\t\tinit: function(selector) {\r\n\t\t\t/* Just return the element wrapped inside an array; don\'t proceed with the actual jQuery node wrapping process. */\r\n\t\t\tif (selector.nodeType) {\r\n\t\t\t\tthis[0] = selector;\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error("Not a DOM node.");\r\n\t\t\t}\r\n\t\t},\r\n\t\toffset: function() {\r\n\t\t\t/* jQuery altered code: Dropped disconnected DOM node checking. */\r\n\t\t\tvar box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {top: 0, left: 0};\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttop: box.top + (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),\r\n\t\t\t\tleft: box.left + (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)\r\n\t\t\t};\r\n\t\t},\r\n\t\tposition: function() {\r\n\t\t\t/* jQuery */\r\n\t\t\tfunction offsetParentFn(elem) {\r\n\t\t\t\tvar offsetParent = elem.offsetParent;\r\n\r\n\t\t\t\twhile (offsetParent && (offsetParent.nodeName.toLowerCase() !== "html" && offsetParent.style && offsetParent.style.position.toLowerCase() === "static")) {\r\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn offsetParent || document;\r\n\t\t\t}\r\n\r\n\t\t\t/* Zepto */\r\n\t\t\tvar elem = this[0],\r\n\t\t\t\t\toffsetParent = offsetParentFn(elem),\r\n\t\t\t\t\toffset = this.offset(),\r\n\t\t\t\t\tparentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? {top: 0, left: 0} : $(offsetParent).offset();\r\n\r\n\t\t\toffset.top -= parseFloat(elem.style.marginTop) || 0;\r\n\t\t\toffset.left -= parseFloat(elem.style.marginLeft) || 0;\r\n\r\n\t\t\tif (offsetParent.style) {\r\n\t\t\t\tparentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0;\r\n\t\t\t\tparentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0;\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttop: offset.top - parentOffset.top,\r\n\t\t\t\tleft: offset.left - parentOffset.left\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\t/**********************\r\n\t Private Variables\r\n\t **********************/\r\n\r\n\t/* For $.data() */\r\n\tvar cache = {};\r\n\t$.expando = "velocity" + (new Date().getTime());\r\n\t$.uuid = 0;\r\n\r\n\t/* For $.queue() */\r\n\tvar class2type = {},\r\n\t\t\thasOwn = class2type.hasOwnProperty,\r\n\t\t\ttoString = class2type.toString;\r\n\r\n\tvar types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");\r\n\tfor (var i = 0; i < types.length; i++) {\r\n\t\tclass2type["[object " + types[i] + "]"] = types[i].toLowerCase();\r\n\t}\r\n\r\n\t/* Makes $(node) possible, without having to call init. */\r\n\t$.fn.init.prototype = $.fn;\r\n\r\n\t/* Globalize Velocity onto the window, and assign its Utilities property. */\r\n\twindow.Velocity = {Utilities: $};\r\n})(window);\r\n\r\n/******************\r\n Velocity.js\r\n ******************/\r\n\r\n(function(factory) {\r\n\t"use strict";\r\n\t/* CommonJS module. */\r\n\tif ( true && typeof module.exports === "object") {\r\n\t\tmodule.exports = factory();\r\n\t\t/* AMD module. */\r\n\t} else if (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\t/* Browser globals. */\r\n\t} else {}\r\n}(function() {\r\n\t"use strict";\r\n\treturn function(global, window, document, undefined) {\r\n\r\n\t\t/***************\r\n\t\t Summary\r\n\t\t ***************/\r\n\r\n\t\t/*\r\n\t\t - CSS: CSS stack that works independently from the rest of Velocity.\r\n\t\t - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.\r\n\t\t - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call\'s options.\r\n\t\t - Queueing: The logic that runs once the call has reached its point of execution in the element\'s $.queue() stack.\r\n\t\t Most logic is placed here to avoid risking it becoming stale (if the element\'s properties have changed).\r\n\t\t - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.\r\n\t\t - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.\r\n\t\t - completeCall(): Handles the cleanup process for each Velocity call.\r\n\t\t */\r\n\r\n\t\t/*********************\r\n\t\t Helper Functions\r\n\t\t *********************/\r\n\r\n\t\t/* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */\r\n\t\tvar IE = (function() {\r\n\t\t\tif (document.documentMode) {\r\n\t\t\t\treturn document.documentMode;\r\n\t\t\t} else {\r\n\t\t\t\tfor (var i = 7; i > 4; i--) {\r\n\t\t\t\t\tvar div = document.createElement("div");\r\n\r\n\t\t\t\t\tdiv.innerHTML = "\x3c!--[if IE " + i + "]><span></span><![endif]--\x3e";\r\n\r\n\t\t\t\t\tif (div.getElementsByTagName("span").length) {\r\n\t\t\t\t\t\tdiv = null;\r\n\r\n\t\t\t\t\t\treturn i;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\t\t})();\r\n\r\n\t\t/* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */\r\n\t\tvar rAFShim = (function() {\r\n\t\t\tvar timeLast = 0;\r\n\r\n\t\t\treturn window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {\r\n\t\t\t\tvar timeCurrent = (new Date()).getTime(),\r\n\t\t\t\t\t\ttimeDelta;\r\n\r\n\t\t\t\t/* Dynamically set delay on a per-tick basis to match 60fps. */\r\n\t\t\t\t/* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */\r\n\t\t\t\ttimeDelta = Math.max(0, 16 - (timeCurrent - timeLast));\r\n\t\t\t\ttimeLast = timeCurrent + timeDelta;\r\n\r\n\t\t\t\treturn setTimeout(function() {\r\n\t\t\t\t\tcallback(timeCurrent + timeDelta);\r\n\t\t\t\t}, timeDelta);\r\n\t\t\t};\r\n\t\t})();\r\n\r\n\t\tvar performance = (function() {\r\n\t\t\tvar perf = window.performance || {};\r\n\r\n\t\t\tif (typeof perf.now !== "function") {\r\n\t\t\t\tvar nowOffset = perf.timing && perf.timing.navigationStart ? perf.timing.navigationStart : (new Date()).getTime();\r\n\r\n\t\t\t\tperf.now = function() {\r\n\t\t\t\t\treturn (new Date()).getTime() - nowOffset;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn perf;\r\n\t\t})();\r\n\r\n\t\t/* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */\r\n\t\tfunction compactSparseArray(array) {\r\n\t\t\tvar index = -1,\r\n\t\t\t\t\tlength = array ? array.length : 0,\r\n\t\t\t\t\tresult = [];\r\n\r\n\t\t\twhile (++index < length) {\r\n\t\t\t\tvar value = array[index];\r\n\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tresult.push(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Shim for "fixing" IE\'s lack of support (IE < 9) for applying slice\r\n\t\t * on host objects like NamedNodeMap, NodeList, and HTMLCollection\r\n\t\t * (technically, since host objects have been implementation-dependent,\r\n\t\t * at least before ES2015, IE hasn\'t needed to work this way).\r\n\t\t * Also works on strings, fixes IE < 9 to allow an explicit undefined\r\n\t\t * for the 2nd argument (as in Firefox), and prevents errors when\r\n\t\t * called on other DOM objects.\r\n\t\t */\r\n\t\tvar _slice = (function() {\r\n\t\t\tvar slice = Array.prototype.slice;\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// Can\'t be used with DOM elements in IE < 9\r\n\t\t\t\tslice.call(document.documentElement);\r\n\t\t\t\treturn slice;\r\n\t\t\t} catch (e) { // Fails in IE < 9\r\n\r\n\t\t\t\t// This will work for genuine arrays, array-like objects, \r\n\t\t\t\t// NamedNodeMap (attributes, entities, notations),\r\n\t\t\t\t// NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),\r\n\t\t\t\t// and will not fail on other DOM objects (as do DOM elements in IE < 9)\r\n\t\t\t\treturn function(begin, end) {\r\n\t\t\t\t\tvar len = this.length;\r\n\r\n\t\t\t\t\tif (typeof begin !== "number") {\r\n\t\t\t\t\t\tbegin = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// IE < 9 gets unhappy with an undefined end argument\r\n\t\t\t\t\tif (typeof end !== "number") {\r\n\t\t\t\t\t\tend = len;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// For native Array objects, we use the native slice function\r\n\t\t\t\t\tif (this.slice) {\r\n\t\t\t\t\t\treturn slice.call(this, begin, end);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// For array like object we handle it ourselves.\r\n\t\t\t\t\tvar i,\r\n\t\t\t\t\t\t\tcloned = [],\r\n\t\t\t\t\t\t\t// Handle negative value for "begin"\r\n\t\t\t\t\t\t\tstart = (begin >= 0) ? begin : Math.max(0, len + begin),\r\n\t\t\t\t\t\t\t// Handle negative value for "end"\r\n\t\t\t\t\t\t\tupTo = end < 0 ? len + end : Math.min(end, len),\r\n\t\t\t\t\t\t\t// Actual expected size of the slice\r\n\t\t\t\t\t\t\tsize = upTo - start;\r\n\r\n\t\t\t\t\tif (size > 0) {\r\n\t\t\t\t\t\tcloned = new Array(size);\r\n\t\t\t\t\t\tif (this.charAt) {\r\n\t\t\t\t\t\t\tfor (i = 0; i < size; i++) {\r\n\t\t\t\t\t\t\t\tcloned[i] = this.charAt(start + i);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (i = 0; i < size; i++) {\r\n\t\t\t\t\t\t\t\tcloned[i] = this[start + i];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn cloned;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t})();\r\n\r\n\t\t/* .indexOf doesn\'t exist in IE<9 */\r\n\t\tvar _inArray = (function() {\r\n\t\t\tif (Array.prototype.includes) {\r\n\t\t\t\treturn function(arr, val) {\r\n\t\t\t\t\treturn arr.includes(val);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (Array.prototype.indexOf) {\r\n\t\t\t\treturn function(arr, val) {\r\n\t\t\t\t\treturn arr.indexOf(val) >= 0;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn function(arr, val) {\r\n\t\t\t\tfor (var i = 0; i < arr.length; i++) {\r\n\t\t\t\t\tif (arr[i] === val) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\tfunction sanitizeElements(elements) {\r\n\t\t\t/* Unwrap jQuery/Zepto objects. */\r\n\t\t\tif (Type.isWrapped(elements)) {\r\n\t\t\t\telements = _slice.call(elements);\r\n\t\t\t\t/* Wrap a single element in an array so that $.each() can iterate with the element instead of its node\'s children. */\r\n\t\t\t} else if (Type.isNode(elements)) {\r\n\t\t\t\telements = [elements];\r\n\t\t\t}\r\n\r\n\t\t\treturn elements;\r\n\t\t}\r\n\r\n\t\tvar Type = {\r\n\t\t\tisNumber: function(variable) {\r\n\t\t\t\treturn (typeof variable === "number");\r\n\t\t\t},\r\n\t\t\tisString: function(variable) {\r\n\t\t\t\treturn (typeof variable === "string");\r\n\t\t\t},\r\n\t\t\tisArray: Array.isArray || function(variable) {\r\n\t\t\t\treturn Object.prototype.toString.call(variable) === "[object Array]";\r\n\t\t\t},\r\n\t\t\tisFunction: function(variable) {\r\n\t\t\t\treturn Object.prototype.toString.call(variable) === "[object Function]";\r\n\t\t\t},\r\n\t\t\tisNode: function(variable) {\r\n\t\t\t\treturn variable && variable.nodeType;\r\n\t\t\t},\r\n\t\t\t/* Determine if variable is an array-like wrapped jQuery, Zepto or similar element, or even a NodeList etc. */\r\n\t\t\t/* NOTE: HTMLFormElements also have a length. */\r\n\t\t\tisWrapped: function(variable) {\r\n\t\t\t\treturn variable\r\n\t\t\t\t\t\t&& variable !== window\r\n\t\t\t\t\t\t&& Type.isNumber(variable.length)\r\n\t\t\t\t\t\t&& !Type.isString(variable)\r\n\t\t\t\t\t\t&& !Type.isFunction(variable)\r\n\t\t\t\t\t\t&& !Type.isNode(variable)\r\n\t\t\t\t\t\t&& (variable.length === 0 || Type.isNode(variable[0]));\r\n\t\t\t},\r\n\t\t\tisSVG: function(variable) {\r\n\t\t\t\treturn window.SVGElement && (variable instanceof window.SVGElement);\r\n\t\t\t},\r\n\t\t\tisEmptyObject: function(variable) {\r\n\t\t\t\tfor (var name in variable) {\r\n\t\t\t\t\tif (variable.hasOwnProperty(name)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/*****************\r\n\t\t Dependencies\r\n\t\t *****************/\r\n\r\n\t\tvar $,\r\n\t\t\t\tisJQuery = false;\r\n\r\n\t\tif (global.fn && global.fn.jquery) {\r\n\t\t\t$ = global;\r\n\t\t\tisJQuery = true;\r\n\t\t} else {\r\n\t\t\t$ = window.Velocity.Utilities;\r\n\t\t}\r\n\r\n\t\tif (IE <= 8 && !isJQuery) {\r\n\t\t\tthrow new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");\r\n\t\t} else if (IE <= 7) {\r\n\t\t\t/* Revert to jQuery\'s $.animate(), and lose Velocity\'s extra features. */\r\n\t\t\tjQuery.fn.velocity = jQuery.fn.animate;\r\n\r\n\t\t\t/* Now that $.fn.velocity is aliased, abort this Velocity declaration. */\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/*****************\r\n\t\t Constants\r\n\t\t *****************/\r\n\r\n\t\tvar DURATION_DEFAULT = 400,\r\n\t\t\t\tEASING_DEFAULT = "swing";\r\n\r\n\t\t/*************\r\n\t\t State\r\n\t\t *************/\r\n\r\n\t\tvar Velocity = {\r\n\t\t\t/* Container for page-wide Velocity state data. */\r\n\t\t\tState: {\r\n\t\t\t\t/* Detect mobile devices to determine if mobileHA should be turned on. */\r\n\t\t\t\tisMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent),\r\n\t\t\t\t/* The mobileHA option\'s behavior changes on older Android devices (Gingerbread, versions 2.3.3-2.3.7). */\r\n\t\t\t\tisAndroid: /Android/i.test(window.navigator.userAgent),\r\n\t\t\t\tisGingerbread: /Android 2\\.3\\.[3-7]/i.test(window.navigator.userAgent),\r\n\t\t\t\tisChrome: window.chrome,\r\n\t\t\t\tisFirefox: /Firefox/i.test(window.navigator.userAgent),\r\n\t\t\t\t/* Create a cached element for re-use when checking for CSS property prefixes. */\r\n\t\t\t\tprefixElement: document.createElement("div"),\r\n\t\t\t\t/* Cache every prefix match to avoid repeating lookups. */\r\n\t\t\t\tprefixMatches: {},\r\n\t\t\t\t/* Cache the anchor used for animating window scrolling. */\r\n\t\t\t\tscrollAnchor: null,\r\n\t\t\t\t/* Cache the browser-specific property names associated with the scroll anchor. */\r\n\t\t\t\tscrollPropertyLeft: null,\r\n\t\t\t\tscrollPropertyTop: null,\r\n\t\t\t\t/* Keep track of whether our RAF tick is running. */\r\n\t\t\t\tisTicking: false,\r\n\t\t\t\t/* Container for every in-progress call to Velocity. */\r\n\t\t\t\tcalls: [],\r\n\t\t\t\tdelayedElements: {\r\n\t\t\t\t\tcount: 0\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t/* Velocity\'s custom CSS stack. Made global for unit testing. */\r\n\t\t\tCSS: {/* Defined below. */},\r\n\t\t\t/* A shim of the jQuery utility functions used by Velocity -- provided by Velocity\'s optional jQuery shim. */\r\n\t\t\tUtilities: $,\r\n\t\t\t/* Container for the user\'s custom animation redirects that are referenced by name in place of the properties map argument. */\r\n\t\t\tRedirects: {/* Manually registered by the user. */},\r\n\t\t\tEasings: {/* Defined below. */},\r\n\t\t\t/* Attempt to use ES6 Promises by default. Users can override this with a third-party promises library. */\r\n\t\t\tPromise: window.Promise,\r\n\t\t\t/* Velocity option defaults, which can be overriden by the user. */\r\n\t\t\tdefaults: {\r\n\t\t\t\tqueue: "",\r\n\t\t\t\tduration: DURATION_DEFAULT,\r\n\t\t\t\teasing: EASING_DEFAULT,\r\n\t\t\t\tbegin: undefined,\r\n\t\t\t\tcomplete: undefined,\r\n\t\t\t\tprogress: undefined,\r\n\t\t\t\tdisplay: undefined,\r\n\t\t\t\tvisibility: undefined,\r\n\t\t\t\tloop: false,\r\n\t\t\t\tdelay: false,\r\n\t\t\t\tmobileHA: true,\r\n\t\t\t\t/* Advanced: Set to false to prevent property values from being cached between consecutive Velocity-initiated chain calls. */\r\n\t\t\t\t_cacheValues: true,\r\n\t\t\t\t/* Advanced: Set to false if the promise should always resolve on empty element lists. */\r\n\t\t\t\tpromiseRejectEmpty: true\r\n\t\t\t},\r\n\t\t\t/* A design goal of Velocity is to cache data wherever possible in order to avoid DOM requerying. Accordingly, each element has a data cache. */\r\n\t\t\tinit: function(element) {\r\n\t\t\t\t$.data(element, "velocity", {\r\n\t\t\t\t\t/* Store whether this is an SVG element, since its properties are retrieved and updated differently than standard HTML elements. */\r\n\t\t\t\t\tisSVG: Type.isSVG(element),\r\n\t\t\t\t\t/* Keep track of whether the element is currently being animated by Velocity.\r\n\t\t\t\t\t This is used to ensure that property values are not transferred between non-consecutive (stale) calls. */\r\n\t\t\t\t\tisAnimating: false,\r\n\t\t\t\t\t/* A reference to the element\'s live computedStyle object. Learn more here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */\r\n\t\t\t\t\tcomputedStyle: null,\r\n\t\t\t\t\t/* Tween data is cached for each animation on the element so that data can be passed across calls --\r\n\t\t\t\t\t in particular, end values are used as subsequent start values in consecutive Velocity calls. */\r\n\t\t\t\t\ttweensContainer: null,\r\n\t\t\t\t\t/* The full root property values of each CSS hook being animated on this element are cached so that:\r\n\t\t\t\t\t 1) Concurrently-animating hooks sharing the same root can have their root values\' merged into one while tweening.\r\n\t\t\t\t\t 2) Post-hook-injection root values can be transferred over to consecutively chained Velocity calls as starting root values. */\r\n\t\t\t\t\trootPropertyValueCache: {},\r\n\t\t\t\t\t/* A cache for transform updates, which must be manually flushed via CSS.flushTransformCache(). */\r\n\t\t\t\t\ttransformCache: {}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\t/* A parallel to jQuery\'s $.css(), used for getting/setting Velocity\'s hooked CSS properties. */\r\n\t\t\thook: null, /* Defined below. */\r\n\t\t\t/* Velocity-wide animation time remapping for testing purposes. */\r\n\t\t\tmock: false,\r\n\t\t\tversion: {major: 1, minor: 5, patch: 2},\r\n\t\t\t/* Set to 1 or 2 (most verbose) to output debug info to console. */\r\n\t\t\tdebug: false,\r\n\t\t\t/* Use rAF high resolution timestamp when available */\r\n\t\t\ttimestamp: true,\r\n\t\t\t/* Pause all animations */\r\n\t\t\tpauseAll: function(queueName) {\r\n\t\t\t\tvar currentTime = (new Date()).getTime();\r\n\r\n\t\t\t\t$.each(Velocity.State.calls, function(i, activeCall) {\r\n\r\n\t\t\t\t\tif (activeCall) {\r\n\r\n\t\t\t\t\t\t/* If we have a queueName and this call is not on that queue, skip */\r\n\t\t\t\t\t\tif (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Set call to paused */\r\n\t\t\t\t\t\tactiveCall[5] = {\r\n\t\t\t\t\t\t\tresume: false\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t/* Pause timers on any currently delayed calls */\r\n\t\t\t\t$.each(Velocity.State.delayedElements, function(k, element) {\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpauseDelayOnElement(element, currentTime);\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\t/* Resume all animations */\r\n\t\t\tresumeAll: function(queueName) {\r\n\t\t\t\tvar currentTime = (new Date()).getTime();\r\n\r\n\t\t\t\t$.each(Velocity.State.calls, function(i, activeCall) {\r\n\r\n\t\t\t\t\tif (activeCall) {\r\n\r\n\t\t\t\t\t\t/* If we have a queueName and this call is not on that queue, skip */\r\n\t\t\t\t\t\tif (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Set call to resumed if it was paused */\r\n\t\t\t\t\t\tif (activeCall[5]) {\r\n\t\t\t\t\t\t\tactiveCall[5].resume = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\t/* Resume timers on any currently delayed calls */\r\n\t\t\t\t$.each(Velocity.State.delayedElements, function(k, element) {\r\n\t\t\t\t\tif (!element) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresumeDelayOnElement(element, currentTime);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/* Retrieve the appropriate scroll anchor and property name for the browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY */\r\n\t\tif (window.pageYOffset !== undefined) {\r\n\t\t\tVelocity.State.scrollAnchor = window;\r\n\t\t\tVelocity.State.scrollPropertyLeft = "pageXOffset";\r\n\t\t\tVelocity.State.scrollPropertyTop = "pageYOffset";\r\n\t\t} else {\r\n\t\t\tVelocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;\r\n\t\t\tVelocity.State.scrollPropertyLeft = "scrollLeft";\r\n\t\t\tVelocity.State.scrollPropertyTop = "scrollTop";\r\n\t\t}\r\n\r\n\t\t/* Shorthand alias for jQuery\'s $.data() utility. */\r\n\t\tfunction Data(element) {\r\n\t\t\t/* Hardcode a reference to the plugin name. */\r\n\t\t\tvar response = $.data(element, "velocity");\r\n\r\n\t\t\t/* jQuery <=1.4.2 returns null instead of undefined when no match is found. We normalize this behavior. */\r\n\t\t\treturn response === null ? undefined : response;\r\n\t\t}\r\n\r\n\t\t/**************\r\n\t\t Delay Timer\r\n\t\t **************/\r\n\r\n\t\tfunction pauseDelayOnElement(element, currentTime) {\r\n\t\t\t/* Check for any delay timers, and pause the set timeouts (while preserving time data)\r\n\t\t\t to be resumed when the "resume" command is issued */\r\n\t\t\tvar data = Data(element);\r\n\t\t\tif (data && data.delayTimer && !data.delayPaused) {\r\n\t\t\t\tdata.delayRemaining = data.delay - currentTime + data.delayBegin;\r\n\t\t\t\tdata.delayPaused = true;\r\n\t\t\t\tclearTimeout(data.delayTimer.setTimeout);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction resumeDelayOnElement(element, currentTime) {\r\n\t\t\t/* Check for any paused timers and resume */\r\n\t\t\tvar data = Data(element);\r\n\t\t\tif (data && data.delayTimer && data.delayPaused) {\r\n\t\t\t\t/* If the element was mid-delay, re initiate the timeout with the remaining delay */\r\n\t\t\t\tdata.delayPaused = false;\r\n\t\t\t\tdata.delayTimer.setTimeout = setTimeout(data.delayTimer.next, data.delayRemaining);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\t/**************\r\n\t\t Easing\r\n\t\t **************/\r\n\r\n\t\t/* Step easing generator. */\r\n\t\tfunction generateStep(steps) {\r\n\t\t\treturn function(p) {\r\n\t\t\t\treturn Math.round(p * steps) * (1 / steps);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t/* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\r\n\t\tfunction generateBezier(mX1, mY1, mX2, mY2) {\r\n\t\t\tvar NEWTON_ITERATIONS = 4,\r\n\t\t\t\t\tNEWTON_MIN_SLOPE = 0.001,\r\n\t\t\t\t\tSUBDIVISION_PRECISION = 0.0000001,\r\n\t\t\t\t\tSUBDIVISION_MAX_ITERATIONS = 10,\r\n\t\t\t\t\tkSplineTableSize = 11,\r\n\t\t\t\t\tkSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\r\n\t\t\t\t\tfloat32ArraySupported = "Float32Array" in window;\r\n\r\n\t\t\t/* Must contain four arguments. */\r\n\t\t\tif (arguments.length !== 4) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t/* Arguments must be numbers. */\r\n\t\t\tfor (var i = 0; i < 4; ++i) {\r\n\t\t\t\tif (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* X values must be in the [0, 1] range. */\r\n\t\t\tmX1 = Math.min(mX1, 1);\r\n\t\t\tmX2 = Math.min(mX2, 1);\r\n\t\t\tmX1 = Math.max(mX1, 0);\r\n\t\t\tmX2 = Math.max(mX2, 0);\r\n\r\n\t\t\tvar mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\r\n\r\n\t\t\tfunction A(aA1, aA2) {\r\n\t\t\t\treturn 1.0 - 3.0 * aA2 + 3.0 * aA1;\r\n\t\t\t}\r\n\t\t\tfunction B(aA1, aA2) {\r\n\t\t\t\treturn 3.0 * aA2 - 6.0 * aA1;\r\n\t\t\t}\r\n\t\t\tfunction C(aA1) {\r\n\t\t\t\treturn 3.0 * aA1;\r\n\t\t\t}\r\n\r\n\t\t\tfunction calcBezier(aT, aA1, aA2) {\r\n\t\t\t\treturn ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\r\n\t\t\t}\r\n\r\n\t\t\tfunction getSlope(aT, aA1, aA2) {\r\n\t\t\t\treturn 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\r\n\t\t\t}\r\n\r\n\t\t\tfunction newtonRaphsonIterate(aX, aGuessT) {\r\n\t\t\t\tfor (var i = 0; i < NEWTON_ITERATIONS; ++i) {\r\n\t\t\t\t\tvar currentSlope = getSlope(aGuessT, mX1, mX2);\r\n\r\n\t\t\t\t\tif (currentSlope === 0.0) {\r\n\t\t\t\t\t\treturn aGuessT;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar currentX = calcBezier(aGuessT, mX1, mX2) - aX;\r\n\t\t\t\t\taGuessT -= currentX / currentSlope;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn aGuessT;\r\n\t\t\t}\r\n\r\n\t\t\tfunction calcSampleValues() {\r\n\t\t\t\tfor (var i = 0; i < kSplineTableSize; ++i) {\r\n\t\t\t\t\tmSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction binarySubdivide(aX, aA, aB) {\r\n\t\t\t\tvar currentX, currentT, i = 0;\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tcurrentT = aA + (aB - aA) / 2.0;\r\n\t\t\t\t\tcurrentX = calcBezier(currentT, mX1, mX2) - aX;\r\n\t\t\t\t\tif (currentX > 0.0) {\r\n\t\t\t\t\t\taB = currentT;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\taA = currentT;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\r\n\r\n\t\t\t\treturn currentT;\r\n\t\t\t}\r\n\r\n\t\t\tfunction getTForX(aX) {\r\n\t\t\t\tvar intervalStart = 0.0,\r\n\t\t\t\t\t\tcurrentSample = 1,\r\n\t\t\t\t\t\tlastSample = kSplineTableSize - 1;\r\n\r\n\t\t\t\tfor (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\r\n\t\t\t\t\tintervalStart += kSampleStepSize;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t--currentSample;\r\n\r\n\t\t\t\tvar dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\r\n\t\t\t\t\t\tguessForT = intervalStart + dist * kSampleStepSize,\r\n\t\t\t\t\t\tinitialSlope = getSlope(guessForT, mX1, mX2);\r\n\r\n\t\t\t\tif (initialSlope >= NEWTON_MIN_SLOPE) {\r\n\t\t\t\t\treturn newtonRaphsonIterate(aX, guessForT);\r\n\t\t\t\t} else if (initialSlope === 0.0) {\r\n\t\t\t\t\treturn guessForT;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar _precomputed = false;\r\n\r\n\t\t\tfunction precompute() {\r\n\t\t\t\t_precomputed = true;\r\n\t\t\t\tif (mX1 !== mY1 || mX2 !== mY2) {\r\n\t\t\t\t\tcalcSampleValues();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar f = function(aX) {\r\n\t\t\t\tif (!_precomputed) {\r\n\t\t\t\t\tprecompute();\r\n\t\t\t\t}\r\n\t\t\t\tif (mX1 === mY1 && mX2 === mY2) {\r\n\t\t\t\t\treturn aX;\r\n\t\t\t\t}\r\n\t\t\t\tif (aX === 0) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t\tif (aX === 1) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn calcBezier(getTForX(aX), mY1, mY2);\r\n\t\t\t};\r\n\r\n\t\t\tf.getControlPoints = function() {\r\n\t\t\t\treturn [{x: mX1, y: mY1}, {x: mX2, y: mY2}];\r\n\t\t\t};\r\n\r\n\t\t\tvar str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";\r\n\t\t\tf.toString = function() {\r\n\t\t\t\treturn str;\r\n\t\t\t};\r\n\r\n\t\t\treturn f;\r\n\t\t}\r\n\r\n\t\t/* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\r\n\t\t/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\r\n\t\t then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\r\n\t\tvar generateSpringRK4 = (function() {\r\n\t\t\tfunction springAccelerationForState(state) {\r\n\t\t\t\treturn (-state.tension * state.x) - (state.friction * state.v);\r\n\t\t\t}\r\n\r\n\t\t\tfunction springEvaluateStateWithDerivative(initialState, dt, derivative) {\r\n\t\t\t\tvar state = {\r\n\t\t\t\t\tx: initialState.x + derivative.dx * dt,\r\n\t\t\t\t\tv: initialState.v + derivative.dv * dt,\r\n\t\t\t\t\ttension: initialState.tension,\r\n\t\t\t\t\tfriction: initialState.friction\r\n\t\t\t\t};\r\n\r\n\t\t\t\treturn {dx: state.v, dv: springAccelerationForState(state)};\r\n\t\t\t}\r\n\r\n\t\t\tfunction springIntegrateState(state, dt) {\r\n\t\t\t\tvar a = {\r\n\t\t\t\t\tdx: state.v,\r\n\t\t\t\t\tdv: springAccelerationForState(state)\r\n\t\t\t\t},\r\n\t\t\t\t\t\tb = springEvaluateStateWithDerivative(state, dt * 0.5, a),\r\n\t\t\t\t\t\tc = springEvaluateStateWithDerivative(state, dt * 0.5, b),\r\n\t\t\t\t\t\td = springEvaluateStateWithDerivative(state, dt, c),\r\n\t\t\t\t\t\tdxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\r\n\t\t\t\t\t\tdvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\r\n\r\n\t\t\t\tstate.x = state.x + dxdt * dt;\r\n\t\t\t\tstate.v = state.v + dvdt * dt;\r\n\r\n\t\t\t\treturn state;\r\n\t\t\t}\r\n\r\n\t\t\treturn function springRK4Factory(tension, friction, duration) {\r\n\r\n\t\t\t\tvar initState = {\r\n\t\t\t\t\tx: -1,\r\n\t\t\t\t\tv: 0,\r\n\t\t\t\t\ttension: null,\r\n\t\t\t\t\tfriction: null\r\n\t\t\t\t},\r\n\t\t\t\t\t\tpath = [0],\r\n\t\t\t\t\t\ttime_lapsed = 0,\r\n\t\t\t\t\t\ttolerance = 1 / 10000,\r\n\t\t\t\t\t\tDT = 16 / 1000,\r\n\t\t\t\t\t\thave_duration, dt, last_state;\r\n\r\n\t\t\t\ttension = parseFloat(tension) || 500;\r\n\t\t\t\tfriction = parseFloat(friction) || 20;\r\n\t\t\t\tduration = duration || null;\r\n\r\n\t\t\t\tinitState.tension = tension;\r\n\t\t\t\tinitState.friction = friction;\r\n\r\n\t\t\t\thave_duration = duration !== null;\r\n\r\n\t\t\t\t/* Calculate the actual time it takes for this animation to complete with the provided conditions. */\r\n\t\t\t\tif (have_duration) {\r\n\t\t\t\t\t/* Run the simulation without a duration. */\r\n\t\t\t\t\ttime_lapsed = springRK4Factory(tension, friction);\r\n\t\t\t\t\t/* Compute the adjusted time delta. */\r\n\t\t\t\t\tdt = time_lapsed / duration * DT;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdt = DT;\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\t/* Next/step function .*/\r\n\t\t\t\t\tlast_state = springIntegrateState(last_state || initState, dt);\r\n\t\t\t\t\t/* Store the position. */\r\n\t\t\t\t\tpath.push(1 + last_state.x);\r\n\t\t\t\t\ttime_lapsed += 16;\r\n\t\t\t\t\t/* If the change threshold is reached, break. */\r\n\t\t\t\t\tif (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\r\n\t\t\t\t computed path and returns a snapshot of the position according to a given percentComplete. */\r\n\t\t\t\treturn !have_duration ? time_lapsed : function(percentComplete) {\r\n\t\t\t\t\treturn path[ (percentComplete * (path.length - 1)) | 0 ];\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t}());\r\n\r\n\t\t/* jQuery easings. */\r\n\t\tVelocity.Easings = {\r\n\t\t\tlinear: function(p) {\r\n\t\t\t\treturn p;\r\n\t\t\t},\r\n\t\t\tswing: function(p) {\r\n\t\t\t\treturn 0.5 - Math.cos(p * Math.PI) / 2;\r\n\t\t\t},\r\n\t\t\t/* Bonus "spring" easing, which is a less exaggerated version of easeInOutElastic. */\r\n\t\t\tspring: function(p) {\r\n\t\t\t\treturn 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6));\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/* CSS3 and Robert Penner easings. */\r\n\t\t$.each(\r\n\t\t\t\t[\r\n\t\t\t\t\t["ease", [0.25, 0.1, 0.25, 1.0]],\r\n\t\t\t\t\t["ease-in", [0.42, 0.0, 1.00, 1.0]],\r\n\t\t\t\t\t["ease-out", [0.00, 0.0, 0.58, 1.0]],\r\n\t\t\t\t\t["ease-in-out", [0.42, 0.0, 0.58, 1.0]],\r\n\t\t\t\t\t["easeInSine", [0.47, 0, 0.745, 0.715]],\r\n\t\t\t\t\t["easeOutSine", [0.39, 0.575, 0.565, 1]],\r\n\t\t\t\t\t["easeInOutSine", [0.445, 0.05, 0.55, 0.95]],\r\n\t\t\t\t\t["easeInQuad", [0.55, 0.085, 0.68, 0.53]],\r\n\t\t\t\t\t["easeOutQuad", [0.25, 0.46, 0.45, 0.94]],\r\n\t\t\t\t\t["easeInOutQuad", [0.455, 0.03, 0.515, 0.955]],\r\n\t\t\t\t\t["easeInCubic", [0.55, 0.055, 0.675, 0.19]],\r\n\t\t\t\t\t["easeOutCubic", [0.215, 0.61, 0.355, 1]],\r\n\t\t\t\t\t["easeInOutCubic", [0.645, 0.045, 0.355, 1]],\r\n\t\t\t\t\t["easeInQuart", [0.895, 0.03, 0.685, 0.22]],\r\n\t\t\t\t\t["easeOutQuart", [0.165, 0.84, 0.44, 1]],\r\n\t\t\t\t\t["easeInOutQuart", [0.77, 0, 0.175, 1]],\r\n\t\t\t\t\t["easeInQuint", [0.755, 0.05, 0.855, 0.06]],\r\n\t\t\t\t\t["easeOutQuint", [0.23, 1, 0.32, 1]],\r\n\t\t\t\t\t["easeInOutQuint", [0.86, 0, 0.07, 1]],\r\n\t\t\t\t\t["easeInExpo", [0.95, 0.05, 0.795, 0.035]],\r\n\t\t\t\t\t["easeOutExpo", [0.19, 1, 0.22, 1]],\r\n\t\t\t\t\t["easeInOutExpo", [1, 0, 0, 1]],\r\n\t\t\t\t\t["easeInCirc", [0.6, 0.04, 0.98, 0.335]],\r\n\t\t\t\t\t["easeOutCirc", [0.075, 0.82, 0.165, 1]],\r\n\t\t\t\t\t["easeInOutCirc", [0.785, 0.135, 0.15, 0.86]]\r\n\t\t\t\t], function(i, easingArray) {\r\n\t\t\tVelocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);\r\n\t\t});\r\n\r\n\t\t/* Determine the appropriate easing type given an easing input. */\r\n\t\tfunction getEasing(value, duration) {\r\n\t\t\tvar easing = value;\r\n\r\n\t\t\t/* The easing option can either be a string that references a pre-registered easing,\r\n\t\t\t or it can be a two-/four-item array of integers to be converted into a bezier/spring function. */\r\n\t\t\tif (Type.isString(value)) {\r\n\t\t\t\t/* Ensure that the easing has been assigned to jQuery\'s Velocity.Easings object. */\r\n\t\t\t\tif (!Velocity.Easings[value]) {\r\n\t\t\t\t\teasing = false;\r\n\t\t\t\t}\r\n\t\t\t} else if (Type.isArray(value) && value.length === 1) {\r\n\t\t\t\teasing = generateStep.apply(null, value);\r\n\t\t\t} else if (Type.isArray(value) && value.length === 2) {\r\n\t\t\t\t/* springRK4 must be passed the animation\'s duration. */\r\n\t\t\t\t/* Note: If the springRK4 array contains non-numbers, generateSpringRK4() returns an easing\r\n\t\t\t\t function generated with default tension and friction values. */\r\n\t\t\t\teasing = generateSpringRK4.apply(null, value.concat([duration]));\r\n\t\t\t} else if (Type.isArray(value) && value.length === 4) {\r\n\t\t\t\t/* Note: If the bezier array contains non-numbers, generateBezier() returns false. */\r\n\t\t\t\teasing = generateBezier.apply(null, value);\r\n\t\t\t} else {\r\n\t\t\t\teasing = false;\r\n\t\t\t}\r\n\r\n\t\t\t/* Revert to the Velocity-wide default easing type, or fall back to "swing" (which is also jQuery\'s default)\r\n\t\t\t if the Velocity-wide default has been incorrectly modified. */\r\n\t\t\tif (easing === false) {\r\n\t\t\t\tif (Velocity.Easings[Velocity.defaults.easing]) {\r\n\t\t\t\t\teasing = Velocity.defaults.easing;\r\n\t\t\t\t} else {\r\n\t\t\t\t\teasing = EASING_DEFAULT;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn easing;\r\n\t\t}\r\n\r\n\t\t/*****************\r\n\t\t CSS Stack\r\n\t\t *****************/\r\n\r\n\t\t/* The CSS object is a highly condensed and performant CSS stack that fully replaces jQuery\'s.\r\n\t\t It handles the validation, getting, and setting of both standard CSS properties and CSS property hooks. */\r\n\t\t/* Note: A "CSS" shorthand is aliased so that our code is easier to read. */\r\n\t\tvar CSS = Velocity.CSS = {\r\n\t\t\t/*************\r\n\t\t\t RegEx\r\n\t\t\t *************/\r\n\r\n\t\t\tRegEx: {\r\n\t\t\t\tisHex: /^#([A-f\\d]{3}){1,2}$/i,\r\n\t\t\t\t/* Unwrap a property value\'s surrounding text, e.g. "rgba(4, 3, 2, 1)" ==> "4, 3, 2, 1" and "rect(4px 3px 2px 1px)" ==> "4px 3px 2px 1px". */\r\n\t\t\t\tvalueUnwrap: /^[A-z]+\\((.*)\\)$/i,\r\n\t\t\t\twrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,\r\n\t\t\t\t/* Split a multi-value property into an array of subvalues, e.g. "rgba(4, 3, 2, 1) 4px 3px 2px 1px" ==> [ "rgba(4, 3, 2, 1)", "4px", "3px", "2px", "1px" ]. */\r\n\t\t\t\tvalueSplit: /([A-z]+\\(.+\\))|(([A-z0-9#-.]+?)(?=\\s|$))/ig\r\n\t\t\t},\r\n\t\t\t/************\r\n\t\t\t Lists\r\n\t\t\t ************/\r\n\r\n\t\t\tLists: {\r\n\t\t\t\tcolors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"],\r\n\t\t\t\ttransformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"],\r\n\t\t\t\ttransforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"],\r\n\t\t\t\tunits: [\r\n\t\t\t\t\t"%", // relative\r\n\t\t\t\t\t"em", "ex", "ch", "rem", // font relative\r\n\t\t\t\t\t"vw", "vh", "vmin", "vmax", // viewport relative\r\n\t\t\t\t\t"cm", "mm", "Q", "in", "pc", "pt", "px", // absolute lengths\r\n\t\t\t\t\t"deg", "grad", "rad", "turn", // angles\r\n\t\t\t\t\t"s", "ms" // time\r\n\t\t\t\t],\r\n\t\t\t\tcolorNames: {\r\n\t\t\t\t\t"aliceblue": "240,248,255",\r\n\t\t\t\t\t"antiquewhite": "250,235,215",\r\n\t\t\t\t\t"aquamarine": "127,255,212",\r\n\t\t\t\t\t"aqua": "0,255,255",\r\n\t\t\t\t\t"azure": "240,255,255",\r\n\t\t\t\t\t"beige": "245,245,220",\r\n\t\t\t\t\t"bisque": "255,228,196",\r\n\t\t\t\t\t"black": "0,0,0",\r\n\t\t\t\t\t"blanchedalmond": "255,235,205",\r\n\t\t\t\t\t"blueviolet": "138,43,226",\r\n\t\t\t\t\t"blue": "0,0,255",\r\n\t\t\t\t\t"brown": "165,42,42",\r\n\t\t\t\t\t"burlywood": "222,184,135",\r\n\t\t\t\t\t"cadetblue": "95,158,160",\r\n\t\t\t\t\t"chartreuse": "127,255,0",\r\n\t\t\t\t\t"chocolate": "210,105,30",\r\n\t\t\t\t\t"coral": "255,127,80",\r\n\t\t\t\t\t"cornflowerblue": "100,149,237",\r\n\t\t\t\t\t"cornsilk": "255,248,220",\r\n\t\t\t\t\t"crimson": "220,20,60",\r\n\t\t\t\t\t"cyan": "0,255,255",\r\n\t\t\t\t\t"darkblue": "0,0,139",\r\n\t\t\t\t\t"darkcyan": "0,139,139",\r\n\t\t\t\t\t"darkgoldenrod": "184,134,11",\r\n\t\t\t\t\t"darkgray": "169,169,169",\r\n\t\t\t\t\t"darkgrey": "169,169,169",\r\n\t\t\t\t\t"darkgreen": "0,100,0",\r\n\t\t\t\t\t"darkkhaki": "189,183,107",\r\n\t\t\t\t\t"darkmagenta": "139,0,139",\r\n\t\t\t\t\t"darkolivegreen": "85,107,47",\r\n\t\t\t\t\t"darkorange": "255,140,0",\r\n\t\t\t\t\t"darkorchid": "153,50,204",\r\n\t\t\t\t\t"darkred": "139,0,0",\r\n\t\t\t\t\t"darksalmon": "233,150,122",\r\n\t\t\t\t\t"darkseagreen": "143,188,143",\r\n\t\t\t\t\t"darkslateblue": "72,61,139",\r\n\t\t\t\t\t"darkslategray": "47,79,79",\r\n\t\t\t\t\t"darkturquoise": "0,206,209",\r\n\t\t\t\t\t"darkviolet": "148,0,211",\r\n\t\t\t\t\t"deeppink": "255,20,147",\r\n\t\t\t\t\t"deepskyblue": "0,191,255",\r\n\t\t\t\t\t"dimgray": "105,105,105",\r\n\t\t\t\t\t"dimgrey": "105,105,105",\r\n\t\t\t\t\t"dodgerblue": "30,144,255",\r\n\t\t\t\t\t"firebrick": "178,34,34",\r\n\t\t\t\t\t"floralwhite": "255,250,240",\r\n\t\t\t\t\t"forestgreen": "34,139,34",\r\n\t\t\t\t\t"fuchsia": "255,0,255",\r\n\t\t\t\t\t"gainsboro": "220,220,220",\r\n\t\t\t\t\t"ghostwhite": "248,248,255",\r\n\t\t\t\t\t"gold": "255,215,0",\r\n\t\t\t\t\t"goldenrod": "218,165,32",\r\n\t\t\t\t\t"gray": "128,128,128",\r\n\t\t\t\t\t"grey": "128,128,128",\r\n\t\t\t\t\t"greenyellow": "173,255,47",\r\n\t\t\t\t\t"green": "0,128,0",\r\n\t\t\t\t\t"honeydew": "240,255,240",\r\n\t\t\t\t\t"hotpink": "255,105,180",\r\n\t\t\t\t\t"indianred": "205,92,92",\r\n\t\t\t\t\t"indigo": "75,0,130",\r\n\t\t\t\t\t"ivory": "255,255,240",\r\n\t\t\t\t\t"khaki": "240,230,140",\r\n\t\t\t\t\t"lavenderblush": "255,240,245",\r\n\t\t\t\t\t"lavender": "230,230,250",\r\n\t\t\t\t\t"lawngreen": "124,252,0",\r\n\t\t\t\t\t"lemonchiffon": "255,250,205",\r\n\t\t\t\t\t"lightblue": "173,216,230",\r\n\t\t\t\t\t"lightcoral": "240,128,128",\r\n\t\t\t\t\t"lightcyan": "224,255,255",\r\n\t\t\t\t\t"lightgoldenrodyellow": "250,250,210",\r\n\t\t\t\t\t"lightgray": "211,211,211",\r\n\t\t\t\t\t"lightgrey": "211,211,211",\r\n\t\t\t\t\t"lightgreen": "144,238,144",\r\n\t\t\t\t\t"lightpink": "255,182,193",\r\n\t\t\t\t\t"lightsalmon": "255,160,122",\r\n\t\t\t\t\t"lightseagreen": "32,178,170",\r\n\t\t\t\t\t"lightskyblue": "135,206,250",\r\n\t\t\t\t\t"lightslategray": "119,136,153",\r\n\t\t\t\t\t"lightsteelblue": "176,196,222",\r\n\t\t\t\t\t"lightyellow": "255,255,224",\r\n\t\t\t\t\t"limegreen": "50,205,50",\r\n\t\t\t\t\t"lime": "0,255,0",\r\n\t\t\t\t\t"linen": "250,240,230",\r\n\t\t\t\t\t"magenta": "255,0,255",\r\n\t\t\t\t\t"maroon": "128,0,0",\r\n\t\t\t\t\t"mediumaquamarine": "102,205,170",\r\n\t\t\t\t\t"mediumblue": "0,0,205",\r\n\t\t\t\t\t"mediumorchid": "186,85,211",\r\n\t\t\t\t\t"mediumpurple": "147,112,219",\r\n\t\t\t\t\t"mediumseagreen": "60,179,113",\r\n\t\t\t\t\t"mediumslateblue": "123,104,238",\r\n\t\t\t\t\t"mediumspringgreen": "0,250,154",\r\n\t\t\t\t\t"mediumturquoise": "72,209,204",\r\n\t\t\t\t\t"mediumvioletred": "199,21,133",\r\n\t\t\t\t\t"midnightblue": "25,25,112",\r\n\t\t\t\t\t"mintcream": "245,255,250",\r\n\t\t\t\t\t"mistyrose": "255,228,225",\r\n\t\t\t\t\t"moccasin": "255,228,181",\r\n\t\t\t\t\t"navajowhite": "255,222,173",\r\n\t\t\t\t\t"navy": "0,0,128",\r\n\t\t\t\t\t"oldlace": "253,245,230",\r\n\t\t\t\t\t"olivedrab": "107,142,35",\r\n\t\t\t\t\t"olive": "128,128,0",\r\n\t\t\t\t\t"orangered": "255,69,0",\r\n\t\t\t\t\t"orange": "255,165,0",\r\n\t\t\t\t\t"orchid": "218,112,214",\r\n\t\t\t\t\t"palegoldenrod": "238,232,170",\r\n\t\t\t\t\t"palegreen": "152,251,152",\r\n\t\t\t\t\t"paleturquoise": "175,238,238",\r\n\t\t\t\t\t"palevioletred": "219,112,147",\r\n\t\t\t\t\t"papayawhip": "255,239,213",\r\n\t\t\t\t\t"peachpuff": "255,218,185",\r\n\t\t\t\t\t"peru": "205,133,63",\r\n\t\t\t\t\t"pink": "255,192,203",\r\n\t\t\t\t\t"plum": "221,160,221",\r\n\t\t\t\t\t"powderblue": "176,224,230",\r\n\t\t\t\t\t"purple": "128,0,128",\r\n\t\t\t\t\t"red": "255,0,0",\r\n\t\t\t\t\t"rosybrown": "188,143,143",\r\n\t\t\t\t\t"royalblue": "65,105,225",\r\n\t\t\t\t\t"saddlebrown": "139,69,19",\r\n\t\t\t\t\t"salmon": "250,128,114",\r\n\t\t\t\t\t"sandybrown": "244,164,96",\r\n\t\t\t\t\t"seagreen": "46,139,87",\r\n\t\t\t\t\t"seashell": "255,245,238",\r\n\t\t\t\t\t"sienna": "160,82,45",\r\n\t\t\t\t\t"silver": "192,192,192",\r\n\t\t\t\t\t"skyblue": "135,206,235",\r\n\t\t\t\t\t"slateblue": "106,90,205",\r\n\t\t\t\t\t"slategray": "112,128,144",\r\n\t\t\t\t\t"snow": "255,250,250",\r\n\t\t\t\t\t"springgreen": "0,255,127",\r\n\t\t\t\t\t"steelblue": "70,130,180",\r\n\t\t\t\t\t"tan": "210,180,140",\r\n\t\t\t\t\t"teal": "0,128,128",\r\n\t\t\t\t\t"thistle": "216,191,216",\r\n\t\t\t\t\t"tomato": "255,99,71",\r\n\t\t\t\t\t"turquoise": "64,224,208",\r\n\t\t\t\t\t"violet": "238,130,238",\r\n\t\t\t\t\t"wheat": "245,222,179",\r\n\t\t\t\t\t"whitesmoke": "245,245,245",\r\n\t\t\t\t\t"white": "255,255,255",\r\n\t\t\t\t\t"yellowgreen": "154,205,50",\r\n\t\t\t\t\t"yellow": "255,255,0"\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t/************\r\n\t\t\t Hooks\r\n\t\t\t ************/\r\n\r\n\t\t\t/* Hooks allow a subproperty (e.g. "boxShadowBlur") of a compound-value CSS property\r\n\t\t\t (e.g. "boxShadow: X Y Blur Spread Color") to be animated as if it were a discrete property. */\r\n\t\t\t/* Note: Beyond enabling fine-grained property animation, hooking is necessary since Velocity only\r\n\t\t\t tweens properties with single numeric values; unlike CSS transitions, Velocity does not interpolate compound-values. */\r\n\t\t\tHooks: {\r\n\t\t\t\t/********************\r\n\t\t\t\t Registration\r\n\t\t\t\t ********************/\r\n\r\n\t\t\t\t/* Templates are a concise way of indicating which subproperties must be individually registered for each compound-value CSS property. */\r\n\t\t\t\t/* Each template consists of the compound-value\'s base name, its constituent subproperty names, and those subproperties\' default values. */\r\n\t\t\t\ttemplates: {\r\n\t\t\t\t\t"textShadow": ["Color X Y Blur", "black 0px 0px 0px"],\r\n\t\t\t\t\t"boxShadow": ["Color X Y Blur Spread", "black 0px 0px 0px 0px"],\r\n\t\t\t\t\t"clip": ["Top Right Bottom Left", "0px 0px 0px 0px"],\r\n\t\t\t\t\t"backgroundPosition": ["X Y", "0% 0%"],\r\n\t\t\t\t\t"transformOrigin": ["X Y Z", "50% 50% 0px"],\r\n\t\t\t\t\t"perspectiveOrigin": ["X Y", "50% 50%"]\r\n\t\t\t\t},\r\n\t\t\t\t/* A "registered" hook is one that has been converted from its template form into a live,\r\n\t\t\t\t tweenable property. It contains data to associate it with its root property. */\r\n\t\t\t\tregistered: {\r\n\t\t\t\t\t/* Note: A registered hook looks like this ==> textShadowBlur: [ "textShadow", 3 ],\r\n\t\t\t\t\t which consists of the subproperty\'s name, the associated root property\'s name,\r\n\t\t\t\t\t and the subproperty\'s position in the root\'s value. */\r\n\t\t\t\t},\r\n\t\t\t\t/* Convert the templates into individual hooks then append them to the registered object above. */\r\n\t\t\t\tregister: function() {\r\n\t\t\t\t\t/* Color hooks registration: Colors are defaulted to white -- as opposed to black -- since colors that are\r\n\t\t\t\t\t currently set to "transparent" default to their respective template below when color-animated,\r\n\t\t\t\t\t and white is typically a closer match to transparent than black is. An exception is made for text ("color"),\r\n\t\t\t\t\t which is almost always set closer to black than white. */\r\n\t\t\t\t\tfor (var i = 0; i < CSS.Lists.colors.length; i++) {\r\n\t\t\t\t\t\tvar rgbComponents = (CSS.Lists.colors[i] === "color") ? "0 0 0 1" : "255 255 255 1";\r\n\t\t\t\t\t\tCSS.Hooks.templates[CSS.Lists.colors[i]] = ["Red Green Blue Alpha", rgbComponents];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar rootProperty,\r\n\t\t\t\t\t\t\thookTemplate,\r\n\t\t\t\t\t\t\thookNames;\r\n\r\n\t\t\t\t\t/* In IE, color values inside compound-value properties are positioned at the end the value instead of at the beginning.\r\n\t\t\t\t\t Thus, we re-arrange the templates accordingly. */\r\n\t\t\t\t\tif (IE) {\r\n\t\t\t\t\t\tfor (rootProperty in CSS.Hooks.templates) {\r\n\t\t\t\t\t\t\tif (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\thookTemplate = CSS.Hooks.templates[rootProperty];\r\n\t\t\t\t\t\t\thookNames = hookTemplate[0].split(" ");\r\n\r\n\t\t\t\t\t\t\tvar defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);\r\n\r\n\t\t\t\t\t\t\tif (hookNames[0] === "Color") {\r\n\t\t\t\t\t\t\t\t/* Reposition both the hook\'s name and its default value to the end of their respective strings. */\r\n\t\t\t\t\t\t\t\thookNames.push(hookNames.shift());\r\n\t\t\t\t\t\t\t\tdefaultValues.push(defaultValues.shift());\r\n\r\n\t\t\t\t\t\t\t\t/* Replace the existing template for the hook\'s root property. */\r\n\t\t\t\t\t\t\t\tCSS.Hooks.templates[rootProperty] = [hookNames.join(" "), defaultValues.join(" ")];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Hook registration. */\r\n\t\t\t\t\tfor (rootProperty in CSS.Hooks.templates) {\r\n\t\t\t\t\t\tif (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\thookTemplate = CSS.Hooks.templates[rootProperty];\r\n\t\t\t\t\t\thookNames = hookTemplate[0].split(" ");\r\n\r\n\t\t\t\t\t\tfor (var j in hookNames) {\r\n\t\t\t\t\t\t\tif (!hookNames.hasOwnProperty(j)) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar fullHookName = rootProperty + hookNames[j],\r\n\t\t\t\t\t\t\t\t\thookPosition = j;\r\n\r\n\t\t\t\t\t\t\t/* For each hook, register its full name (e.g. textShadowBlur) with its root property (e.g. textShadow)\r\n\t\t\t\t\t\t\t and the hook\'s position in its template\'s default value string. */\r\n\t\t\t\t\t\t\tCSS.Hooks.registered[fullHookName] = [rootProperty, hookPosition];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t/*****************************\r\n\t\t\t\t Injection and Extraction\r\n\t\t\t\t *****************************/\r\n\r\n\t\t\t\t/* Look up the root property associated with the hook (e.g. return "textShadow" for "textShadowBlur"). */\r\n\t\t\t\t/* Since a hook cannot be set directly (the browser won\'t recognize it), style updating for hooks is routed through the hook\'s root property. */\r\n\t\t\t\tgetRoot: function(property) {\r\n\t\t\t\t\tvar hookData = CSS.Hooks.registered[property];\r\n\r\n\t\t\t\t\tif (hookData) {\r\n\t\t\t\t\t\treturn hookData[0];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* If there was no hook match, return the property name untouched. */\r\n\t\t\t\t\t\treturn property;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tgetUnit: function(str, start) {\r\n\t\t\t\t\tvar unit = (str.substr(start || 0, 5).match(/^[a-z%]+/) || [])[0] || "";\r\n\r\n\t\t\t\t\tif (unit && _inArray(CSS.Lists.units, unit)) {\r\n\t\t\t\t\t\treturn unit;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn "";\r\n\t\t\t\t},\r\n\t\t\t\tfixColors: function(str) {\r\n\t\t\t\t\treturn str.replace(/(rgba?\\(\\s*)?(\\b[a-z]+\\b)/g, function($0, $1, $2) {\r\n\t\t\t\t\t\tif (CSS.Lists.colorNames.hasOwnProperty($2)) {\r\n\t\t\t\t\t\t\treturn ($1 ? $1 : "rgba(") + CSS.Lists.colorNames[$2] + ($1 ? "" : ",1)");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn $1 + $2;\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\t/* Convert any rootPropertyValue, null or otherwise, into a space-delimited list of hook values so that\r\n\t\t\t\t the targeted hook can be injected or extracted at its standard position. */\r\n\t\t\t\tcleanRootPropertyValue: function(rootProperty, rootPropertyValue) {\r\n\t\t\t\t\t/* If the rootPropertyValue is wrapped with "rgb()", "clip()", etc., remove the wrapping to normalize the value before manipulation. */\r\n\t\t\t\t\tif (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {\r\n\t\t\t\t\t\trootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* If rootPropertyValue is a CSS null-value (from which there\'s inherently no hook value to extract),\r\n\t\t\t\t\t default to the root\'s default value as defined in CSS.Hooks.templates. */\r\n\t\t\t\t\t/* Note: CSS null-values include "none", "auto", and "transparent". They must be converted into their\r\n\t\t\t\t\t zero-values (e.g. textShadow: "none" ==> textShadow: "0px 0px 0px black") for hook manipulation to proceed. */\r\n\t\t\t\t\tif (CSS.Values.isCSSNullValue(rootPropertyValue)) {\r\n\t\t\t\t\t\trootPropertyValue = CSS.Hooks.templates[rootProperty][1];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn rootPropertyValue;\r\n\t\t\t\t},\r\n\t\t\t\t/* Extracted the hook\'s value from its root property\'s value. This is used to get the starting value of an animating hook. */\r\n\t\t\t\textractValue: function(fullHookName, rootPropertyValue) {\r\n\t\t\t\t\tvar hookData = CSS.Hooks.registered[fullHookName];\r\n\r\n\t\t\t\t\tif (hookData) {\r\n\t\t\t\t\t\tvar hookRoot = hookData[0],\r\n\t\t\t\t\t\t\t\thookPosition = hookData[1];\r\n\r\n\t\t\t\t\t\trootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);\r\n\r\n\t\t\t\t\t\t/* Split rootPropertyValue into its constituent hook values then grab the desired hook at its standard position. */\r\n\t\t\t\t\t\treturn rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* If the provided fullHookName isn\'t a registered hook, return the rootPropertyValue that was passed in. */\r\n\t\t\t\t\t\treturn rootPropertyValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t/* Inject the hook\'s value into its root property\'s value. This is used to piece back together the root property\r\n\t\t\t\t once Velocity has updated one of its individually hooked values through tweening. */\r\n\t\t\t\tinjectValue: function(fullHookName, hookValue, rootPropertyValue) {\r\n\t\t\t\t\tvar hookData = CSS.Hooks.registered[fullHookName];\r\n\r\n\t\t\t\t\tif (hookData) {\r\n\t\t\t\t\t\tvar hookRoot = hookData[0],\r\n\t\t\t\t\t\t\t\thookPosition = hookData[1],\r\n\t\t\t\t\t\t\t\trootPropertyValueParts,\r\n\t\t\t\t\t\t\t\trootPropertyValueUpdated;\r\n\r\n\t\t\t\t\t\trootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);\r\n\r\n\t\t\t\t\t\t/* Split rootPropertyValue into its individual hook values, replace the targeted value with hookValue,\r\n\t\t\t\t\t\t then reconstruct the rootPropertyValue string. */\r\n\t\t\t\t\t\trootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);\r\n\t\t\t\t\t\trootPropertyValueParts[hookPosition] = hookValue;\r\n\t\t\t\t\t\trootPropertyValueUpdated = rootPropertyValueParts.join(" ");\r\n\r\n\t\t\t\t\t\treturn rootPropertyValueUpdated;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* If the provided fullHookName isn\'t a registered hook, return the rootPropertyValue that was passed in. */\r\n\t\t\t\t\t\treturn rootPropertyValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t/*******************\r\n\t\t\t Normalizations\r\n\t\t\t *******************/\r\n\r\n\t\t\t/* Normalizations standardize CSS property manipulation by pollyfilling browser-specific implementations (e.g. opacity)\r\n\t\t\t and reformatting special properties (e.g. clip, rgba) to look like standard ones. */\r\n\t\t\tNormalizations: {\r\n\t\t\t\t/* Normalizations are passed a normalization target (either the property\'s name, its extracted value, or its injected value),\r\n\t\t\t\t the targeted element (which may need to be queried), and the targeted property value. */\r\n\t\t\t\tregistered: {\r\n\t\t\t\t\tclip: function(type, element, propertyValue) {\r\n\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\treturn "clip";\r\n\t\t\t\t\t\t\t\t/* Clip needs to be unwrapped and stripped of its commas during extraction. */\r\n\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\tvar extracted;\r\n\r\n\t\t\t\t\t\t\t\t/* If Velocity also extracted this value, skip extraction. */\r\n\t\t\t\t\t\t\t\tif (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {\r\n\t\t\t\t\t\t\t\t\textracted = propertyValue;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t/* Remove the "rect()" wrapper. */\r\n\t\t\t\t\t\t\t\t\textracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);\r\n\r\n\t\t\t\t\t\t\t\t\t/* Strip off commas. */\r\n\t\t\t\t\t\t\t\t\textracted = extracted ? extracted[1].replace(/,(\\s+)?/g, " ") : propertyValue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treturn extracted;\r\n\t\t\t\t\t\t\t\t/* Clip needs to be re-wrapped during injection. */\r\n\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\treturn "rect(" + propertyValue + ")";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tblur: function(type, element, propertyValue) {\r\n\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\treturn Velocity.State.isFirefox ? "filter" : "-webkit-filter";\r\n\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\tvar extracted = parseFloat(propertyValue);\r\n\r\n\t\t\t\t\t\t\t\t/* If extracted is NaN, meaning the value isn\'t already extracted. */\r\n\t\t\t\t\t\t\t\tif (!(extracted || extracted === 0)) {\r\n\t\t\t\t\t\t\t\t\tvar blurComponent = propertyValue.toString().match(/blur\\(([0-9]+[A-z]+)\\)/i);\r\n\r\n\t\t\t\t\t\t\t\t\t/* If the filter string had a blur component, return just the blur value and unit type. */\r\n\t\t\t\t\t\t\t\t\tif (blurComponent) {\r\n\t\t\t\t\t\t\t\t\t\textracted = blurComponent[1];\r\n\t\t\t\t\t\t\t\t\t\t/* If the component doesn\'t exist, default blur to 0. */\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\textracted = 0;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treturn extracted;\r\n\t\t\t\t\t\t\t\t/* Blur needs to be re-wrapped during injection. */\r\n\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\t/* For the blur effect to be fully de-applied, it needs to be set to "none" instead of 0. */\r\n\t\t\t\t\t\t\t\tif (!parseFloat(propertyValue)) {\r\n\t\t\t\t\t\t\t\t\treturn "none";\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn "blur(" + propertyValue + ")";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\t/* <=IE8 do not support the standard opacity property. They use filter:alpha(opacity=INT) instead. */\r\n\t\t\t\t\topacity: function(type, element, propertyValue) {\r\n\t\t\t\t\t\tif (IE <= 8) {\r\n\t\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\t\treturn "filter";\r\n\t\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\t\t/* <=IE8 return a "filter" value of "alpha(opacity=\\d{1,3})".\r\n\t\t\t\t\t\t\t\t\t Extract the value and convert it to a decimal value to match the standard CSS opacity property\'s formatting. */\r\n\t\t\t\t\t\t\t\t\tvar extracted = propertyValue.toString().match(/alpha\\(opacity=(.*)\\)/i);\r\n\r\n\t\t\t\t\t\t\t\t\tif (extracted) {\r\n\t\t\t\t\t\t\t\t\t\t/* Convert to decimal value. */\r\n\t\t\t\t\t\t\t\t\t\tpropertyValue = extracted[1] / 100;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t/* When extracting opacity, default to 1 since a null value means opacity hasn\'t been set. */\r\n\t\t\t\t\t\t\t\t\t\tpropertyValue = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\treturn propertyValue;\r\n\t\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\t\t/* Opacified elements are required to have their zoom property set to a non-zero value. */\r\n\t\t\t\t\t\t\t\t\telement.style.zoom = 1;\r\n\r\n\t\t\t\t\t\t\t\t\t/* Setting the filter property on elements with certain font property combinations can result in a\r\n\t\t\t\t\t\t\t\t\t highly unappealing ultra-bolding effect. There\'s no way to remedy this throughout a tween, but dropping the\r\n\t\t\t\t\t\t\t\t\t value altogether (when opacity hits 1) at leasts ensures that the glitch is gone post-tweening. */\r\n\t\t\t\t\t\t\t\t\tif (parseFloat(propertyValue) >= 1) {\r\n\t\t\t\t\t\t\t\t\t\treturn "";\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t/* As per the filter property\'s spec, convert the decimal value to a whole number and wrap the value. */\r\n\t\t\t\t\t\t\t\t\t\treturn "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* With all other browsers, normalization is not required; return the same values that were passed in. */\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\t\treturn "opacity";\r\n\t\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\t\treturn propertyValue;\r\n\t\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\t\treturn propertyValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t/*****************************\r\n\t\t\t\t Batched Registrations\r\n\t\t\t\t *****************************/\r\n\r\n\t\t\t\t/* Note: Batched normalizations extend the CSS.Normalizations.registered object. */\r\n\t\t\t\tregister: function() {\r\n\r\n\t\t\t\t\t/*****************\r\n\t\t\t\t\t Transforms\r\n\t\t\t\t\t *****************/\r\n\r\n\t\t\t\t\t/* Transforms are the subproperties contained by the CSS "transform" property. Transforms must undergo normalization\r\n\t\t\t\t\t so that they can be referenced in a properties map by their individual names. */\r\n\t\t\t\t\t/* Note: When transforms are "set", they are actually assigned to a per-element transformCache. When all transform\r\n\t\t\t\t\t setting is complete complete, CSS.flushTransformCache() must be manually called to flush the values to the DOM.\r\n\t\t\t\t\t Transform setting is batched in this way to improve performance: the transform style only needs to be updated\r\n\t\t\t\t\t once when multiple transform subproperties are being animated simultaneously. */\r\n\t\t\t\t\t/* Note: IE9 and Android Gingerbread have support for 2D -- but not 3D -- transforms. Since animating unsupported\r\n\t\t\t\t\t transform properties results in the browser ignoring the *entire* transform string, we prevent these 3D values\r\n\t\t\t\t\t from being normalized for these browsers so that tweening skips these properties altogether\r\n\t\t\t\t\t (since it will ignore them as being unsupported by the browser.) */\r\n\t\t\t\t\tif ((!IE || IE > 9) && !Velocity.State.isGingerbread) {\r\n\t\t\t\t\t\t/* Note: Since the standalone CSS "perspective" property and the CSS transform "perspective" subproperty\r\n\t\t\t\t\t\t share the same name, the latter is given a unique token within Velocity: "transformPerspective". */\r\n\t\t\t\t\t\tCSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (var i = 0; i < CSS.Lists.transformsBase.length; i++) {\r\n\t\t\t\t\t\t/* Wrap the dynamically generated normalization function in a new scope so that transformName\'s value is\r\n\t\t\t\t\t\t paired with its respective function. (Otherwise, all functions would take the final for loop\'s transformName.) */\r\n\t\t\t\t\t\t(function() {\r\n\t\t\t\t\t\t\tvar transformName = CSS.Lists.transformsBase[i];\r\n\r\n\t\t\t\t\t\t\tCSS.Normalizations.registered[transformName] = function(type, element, propertyValue) {\r\n\t\t\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\t\t\t/* The normalized property name is the parent "transform" property -- the property that is actually set in CSS. */\r\n\t\t\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\t\t\treturn "transform";\r\n\t\t\t\t\t\t\t\t\t\t/* Transform values are cached onto a per-element transformCache object. */\r\n\t\t\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\t\t\t/* If this transform has yet to be assigned a value, return its null value. */\r\n\t\t\t\t\t\t\t\t\t\tif (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\t/* Scale CSS.Lists.transformsBase default to 1 whereas all other transform properties default to 0. */\r\n\t\t\t\t\t\t\t\t\t\t\treturn /^scale/i.test(transformName) ? 1 : 0;\r\n\t\t\t\t\t\t\t\t\t\t\t/* When transform values are set, they are wrapped in parentheses as per the CSS spec.\r\n\t\t\t\t\t\t\t\t\t\t\t Thus, when extracting their values (for tween calculations), we strip off the parentheses. */\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturn Data(element).transformCache[transformName].replace(/[()]/g, "");\r\n\t\t\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\t\t\tvar invalid = false;\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* If an individual transform property contains an unsupported unit type, the browser ignores the *entire* transform property.\r\n\t\t\t\t\t\t\t\t\t\t Thus, protect users from themselves by skipping setting for transform values supplied with invalid unit types. */\r\n\t\t\t\t\t\t\t\t\t\t/* Switch on the base transform type; ignore the axis by removing the last letter from the transform\'s name. */\r\n\t\t\t\t\t\t\t\t\t\tswitch (transformName.substr(0, transformName.length - 1)) {\r\n\t\t\t\t\t\t\t\t\t\t\t/* Whitelist unit types for each transform. */\r\n\t\t\t\t\t\t\t\t\t\t\tcase "translate":\r\n\t\t\t\t\t\t\t\t\t\t\t\tinvalid = !/(%|px|em|rem|vw|vh|\\d)$/i.test(propertyValue);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* Since an axis-free "scale" property is supported as well, a little hack is used here to detect it by chopping off its last letter. */\r\n\t\t\t\t\t\t\t\t\t\t\tcase "scal":\r\n\t\t\t\t\t\t\t\t\t\t\tcase "scale":\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* Chrome on Android has a bug in which scaled elements blur if their initial scale\r\n\t\t\t\t\t\t\t\t\t\t\t\t value is below 1 (which can happen with forcefeeding). Thus, we detect a yet-unset scale property\r\n\t\t\t\t\t\t\t\t\t\t\t\t and ensure that its first value is always 1. More info: http://stackoverflow.com/questions/10417890/css3-animations-with-transform-causes-blurred-elements-on-webkit/10417962#10417962 */\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyValue = 1;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tinvalid = !/(\\d)$/i.test(propertyValue);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\tcase "skew":\r\n\t\t\t\t\t\t\t\t\t\t\t\tinvalid = !/(deg|\\d)$/i.test(propertyValue);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\tcase "rotate":\r\n\t\t\t\t\t\t\t\t\t\t\t\tinvalid = !/(deg|\\d)$/i.test(propertyValue);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (!invalid) {\r\n\t\t\t\t\t\t\t\t\t\t\t/* As per the CSS spec, wrap the value in parentheses. */\r\n\t\t\t\t\t\t\t\t\t\t\tData(element).transformCache[transformName] = "(" + propertyValue + ")";\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* Although the value is set on the transformCache object, return the newly-updated value for the calling code to process as normal. */\r\n\t\t\t\t\t\t\t\t\t\treturn Data(element).transformCache[transformName];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t})();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/*************\r\n\t\t\t\t\t Colors\r\n\t\t\t\t\t *************/\r\n\r\n\t\t\t\t\t/* Since Velocity only animates a single numeric value per property, color animation is achieved by hooking the individual RGBA components of CSS color properties.\r\n\t\t\t\t\t Accordingly, color values must be normalized (e.g. "#ff0000", "red", and "rgb(255, 0, 0)" ==> "255 0 0 1") so that their components can be injected/extracted by CSS.Hooks logic. */\r\n\t\t\t\t\tfor (var j = 0; j < CSS.Lists.colors.length; j++) {\r\n\t\t\t\t\t\t/* Wrap the dynamically generated normalization function in a new scope so that colorName\'s value is paired with its respective function.\r\n\t\t\t\t\t\t (Otherwise, all functions would take the final for loop\'s colorName.) */\r\n\t\t\t\t\t\t(function() {\r\n\t\t\t\t\t\t\tvar colorName = CSS.Lists.colors[j];\r\n\r\n\t\t\t\t\t\t\t/* Note: In IE<=8, which support rgb but not rgba, color properties are reverted to rgb by stripping off the alpha component. */\r\n\t\t\t\t\t\t\tCSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {\r\n\t\t\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\t\t\treturn colorName;\r\n\t\t\t\t\t\t\t\t\t\t/* Convert all color values into the rgb format. (Old IE can return hex values and color names instead of rgb/rgba.) */\r\n\t\t\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\t\t\tvar extracted;\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* If the color is already in its hookable form (e.g. "255 255 255 1") due to having been previously extracted, skip extraction. */\r\n\t\t\t\t\t\t\t\t\t\tif (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {\r\n\t\t\t\t\t\t\t\t\t\t\textracted = propertyValue;\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tvar converted,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolorNames = {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tblack: "rgb(0, 0, 0)",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tblue: "rgb(0, 0, 255)",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgray: "rgb(128, 128, 128)",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgreen: "rgb(0, 128, 0)",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tred: "rgb(255, 0, 0)",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twhite: "rgb(255, 255, 255)"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t/* Convert color names to rgb. */\r\n\t\t\t\t\t\t\t\t\t\t\tif (/^[A-z]+$/i.test(propertyValue)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (colorNames[propertyValue] !== undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconverted = colorNames[propertyValue];\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t/* If an unmatched color name is provided, default to black. */\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tconverted = colorNames.black;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* Convert hex values to rgb. */\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (CSS.RegEx.isHex.test(propertyValue)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconverted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* If the provided color doesn\'t match any of the accepted color formats, default to black. */\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (!(/^rgba?\\(/i.test(propertyValue))) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconverted = colorNames.black;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t/* Remove the surrounding "rgb/rgba()" string then replace commas with spaces and strip\r\n\t\t\t\t\t\t\t\t\t\t\t repeated spaces (in case the value included spaces to begin with). */\r\n\t\t\t\t\t\t\t\t\t\t\textracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\\s+)?/g, " ");\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* So long as this isn\'t <=IE8, add a fourth (alpha) component if it\'s missing and default it to 1 (visible). */\r\n\t\t\t\t\t\t\t\t\t\tif ((!IE || IE > 8) && extracted.split(" ").length === 3) {\r\n\t\t\t\t\t\t\t\t\t\t\textracted += " 1";\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\treturn extracted;\r\n\t\t\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\t\t\t/* If we have a pattern then it might already have the right values */\r\n\t\t\t\t\t\t\t\t\t\tif (/^rgb/.test(propertyValue)) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn propertyValue;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* If this is IE<=8 and an alpha component exists, strip it off. */\r\n\t\t\t\t\t\t\t\t\t\tif (IE <= 8) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (propertyValue.split(" ").length === 4) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tpropertyValue = propertyValue.split(/\\s+/).slice(0, 3).join(" ");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t/* Otherwise, add a fourth (alpha) component if it\'s missing and default it to 1 (visible). */\r\n\t\t\t\t\t\t\t\t\t\t} else if (propertyValue.split(" ").length === 3) {\r\n\t\t\t\t\t\t\t\t\t\t\tpropertyValue += " 1";\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* Re-insert the browser-appropriate wrapper("rgb/rgba()"), insert commas, and strip off decimal units\r\n\t\t\t\t\t\t\t\t\t\t on all values but the fourth (R, G, and B only accept whole numbers). */\r\n\t\t\t\t\t\t\t\t\t\treturn (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\\s+/g, ",").replace(/\\.(\\d)+(?=,)/g, "") + ")";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t})();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/**************\r\n\t\t\t\t\t Dimensions\r\n\t\t\t\t\t **************/\r\n\t\t\t\t\tfunction augmentDimension(name, element, wantInner) {\r\n\t\t\t\t\t\tvar isBorderBox = CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() === "border-box";\r\n\r\n\t\t\t\t\t\tif (isBorderBox === (wantInner || false)) {\r\n\t\t\t\t\t\t\t/* in box-sizing mode, the CSS width / height accessors already give the outerWidth / outerHeight. */\r\n\t\t\t\t\t\t\tvar i,\r\n\t\t\t\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\t\t\t\taugment = 0,\r\n\t\t\t\t\t\t\t\t\tsides = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"],\r\n\t\t\t\t\t\t\t\t\tfields = ["padding" + sides[0], "padding" + sides[1], "border" + sides[0] + "Width", "border" + sides[1] + "Width"];\r\n\r\n\t\t\t\t\t\t\tfor (i = 0; i < fields.length; i++) {\r\n\t\t\t\t\t\t\t\tvalue = parseFloat(CSS.getPropertyValue(element, fields[i]));\r\n\t\t\t\t\t\t\t\tif (!isNaN(value)) {\r\n\t\t\t\t\t\t\t\t\taugment += value;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn wantInner ? -augment : augment;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction getDimension(name, wantInner) {\r\n\t\t\t\t\t\treturn function(type, element, propertyValue) {\r\n\t\t\t\t\t\t\tswitch (type) {\r\n\t\t\t\t\t\t\t\tcase "name":\r\n\t\t\t\t\t\t\t\t\treturn name;\r\n\t\t\t\t\t\t\t\tcase "extract":\r\n\t\t\t\t\t\t\t\t\treturn parseFloat(propertyValue) + augmentDimension(name, element, wantInner);\r\n\t\t\t\t\t\t\t\tcase "inject":\r\n\t\t\t\t\t\t\t\t\treturn (parseFloat(propertyValue) - augmentDimension(name, element, wantInner)) + "px";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tCSS.Normalizations.registered.innerWidth = getDimension("width", true);\r\n\t\t\t\t\tCSS.Normalizations.registered.innerHeight = getDimension("height", true);\r\n\t\t\t\t\tCSS.Normalizations.registered.outerWidth = getDimension("width");\r\n\t\t\t\t\tCSS.Normalizations.registered.outerHeight = getDimension("height");\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t/************************\r\n\t\t\t CSS Property Names\r\n\t\t\t ************************/\r\n\r\n\t\t\tNames: {\r\n\t\t\t\t/* Camelcase a property name into its JavaScript notation (e.g. "background-color" ==> "backgroundColor").\r\n\t\t\t\t Camelcasing is used to normalize property names between and across calls. */\r\n\t\t\t\tcamelCase: function(property) {\r\n\t\t\t\t\treturn property.replace(/-(\\w)/g, function(match, subMatch) {\r\n\t\t\t\t\t\treturn subMatch.toUpperCase();\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\t/* For SVG elements, some properties (namely, dimensional ones) are GET/SET via the element\'s HTML attributes (instead of via CSS styles). */\r\n\t\t\t\tSVGAttribute: function(property) {\r\n\t\t\t\t\tvar SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";\r\n\r\n\t\t\t\t\t/* Certain browsers require an SVG transform to be applied as an attribute. (Otherwise, application via CSS is preferable due to 3D support.) */\r\n\t\t\t\t\tif (IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) {\r\n\t\t\t\t\t\tSVGAttributes += "|transform";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn new RegExp("^(" + SVGAttributes + ")$", "i").test(property);\r\n\t\t\t\t},\r\n\t\t\t\t/* Determine whether a property should be set with a vendor prefix. */\r\n\t\t\t\t/* If a prefixed version of the property exists, return it. Otherwise, return the original property name.\r\n\t\t\t\t If the property is not at all supported by the browser, return a false flag. */\r\n\t\t\t\tprefixCheck: function(property) {\r\n\t\t\t\t\t/* If this property has already been checked, return the cached value. */\r\n\t\t\t\t\tif (Velocity.State.prefixMatches[property]) {\r\n\t\t\t\t\t\treturn [Velocity.State.prefixMatches[property], true];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar vendors = ["", "Webkit", "Moz", "ms", "O"];\r\n\r\n\t\t\t\t\t\tfor (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {\r\n\t\t\t\t\t\t\tvar propertyPrefixed;\r\n\r\n\t\t\t\t\t\t\tif (i === 0) {\r\n\t\t\t\t\t\t\t\tpropertyPrefixed = property;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t/* Capitalize the first letter of the property to conform to JavaScript vendor prefix notation (e.g. webkitFilter). */\r\n\t\t\t\t\t\t\t\tpropertyPrefixed = vendors[i] + property.replace(/^\\w/, function(match) {\r\n\t\t\t\t\t\t\t\t\treturn match.toUpperCase();\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Check if the browser supports this property as prefixed. */\r\n\t\t\t\t\t\t\tif (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {\r\n\t\t\t\t\t\t\t\t/* Cache the match. */\r\n\t\t\t\t\t\t\t\tVelocity.State.prefixMatches[property] = propertyPrefixed;\r\n\r\n\t\t\t\t\t\t\t\treturn [propertyPrefixed, true];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* If the browser doesn\'t support this property in any form, include a false flag so that the caller can decide how to proceed. */\r\n\t\t\t\t\t\treturn [property, false];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t/************************\r\n\t\t\t CSS Property Values\r\n\t\t\t ************************/\r\n\r\n\t\t\tValues: {\r\n\t\t\t\t/* Hex to RGB conversion. Copyright Tim Down: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb */\r\n\t\t\t\thexToRgb: function(hex) {\r\n\t\t\t\t\tvar shortformRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\r\n\t\t\t\t\t\t\tlongformRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\r\n\t\t\t\t\t\t\trgbParts;\r\n\r\n\t\t\t\t\thex = hex.replace(shortformRegex, function(m, r, g, b) {\r\n\t\t\t\t\t\treturn r + r + g + g + b + b;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\trgbParts = longformRegex.exec(hex);\r\n\r\n\t\t\t\t\treturn rgbParts ? [parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16)] : [0, 0, 0];\r\n\t\t\t\t},\r\n\t\t\t\tisCSSNullValue: function(value) {\r\n\t\t\t\t\t/* The browser defaults CSS values that have not been set to either 0 or one of several possible null-value strings.\r\n\t\t\t\t\t Thus, we check for both falsiness and these special strings. */\r\n\t\t\t\t\t/* Null-value checking is performed to default the special strings to 0 (for the sake of tweening) or their hook\r\n\t\t\t\t\t templates as defined as CSS.Hooks (for the sake of hook injection/extraction). */\r\n\t\t\t\t\t/* Note: Chrome returns "rgba(0, 0, 0, 0)" for an undefined color whereas IE returns "transparent". */\r\n\t\t\t\t\treturn (!value || /^(none|auto|transparent|(rgba\\(0, ?0, ?0, ?0\\)))$/i.test(value));\r\n\t\t\t\t},\r\n\t\t\t\t/* Retrieve a property\'s default unit type. Used for assigning a unit type when one is not supplied by the user. */\r\n\t\t\t\tgetUnitType: function(property) {\r\n\t\t\t\t\tif (/^(rotate|skew)/i.test(property)) {\r\n\t\t\t\t\t\treturn "deg";\r\n\t\t\t\t\t} else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {\r\n\t\t\t\t\t\t/* The above properties are unitless. */\r\n\t\t\t\t\t\treturn "";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Default to px for all other properties. */\r\n\t\t\t\t\t\treturn "px";\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t/* HTML elements default to an associated display type when they\'re not set to display:none. */\r\n\t\t\t\t/* Note: This function is used for correctly setting the non-"none" display value in certain Velocity redirects, such as fadeIn/Out. */\r\n\t\t\t\tgetDisplayType: function(element) {\r\n\t\t\t\t\tvar tagName = element && element.tagName.toString().toLowerCase();\r\n\r\n\t\t\t\t\tif (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {\r\n\t\t\t\t\t\treturn "inline";\r\n\t\t\t\t\t} else if (/^(li)$/i.test(tagName)) {\r\n\t\t\t\t\t\treturn "list-item";\r\n\t\t\t\t\t} else if (/^(tr)$/i.test(tagName)) {\r\n\t\t\t\t\t\treturn "table-row";\r\n\t\t\t\t\t} else if (/^(table)$/i.test(tagName)) {\r\n\t\t\t\t\t\treturn "table";\r\n\t\t\t\t\t} else if (/^(tbody)$/i.test(tagName)) {\r\n\t\t\t\t\t\treturn "table-row-group";\r\n\t\t\t\t\t\t/* Default to "block" when no match is found. */\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn "block";\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t/* The class add/remove functions are used to temporarily apply a "velocity-animating" class to elements while they\'re animating. */\r\n\t\t\t\taddClass: function(element, className) {\r\n\t\t\t\t\tif (element) {\r\n\t\t\t\t\t\tif (element.classList) {\r\n\t\t\t\t\t\t\telement.classList.add(className);\r\n\t\t\t\t\t\t} else if (Type.isString(element.className)) {\r\n\t\t\t\t\t\t\t// Element.className is around 15% faster then set/getAttribute\r\n\t\t\t\t\t\t\telement.className += (element.className.length ? " " : "") + className;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Work around for IE strict mode animating SVG - and anything else that doesn\'t behave correctly - the same way jQuery does it\r\n\t\t\t\t\t\t\tvar currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";\r\n\r\n\t\t\t\t\t\t\telement.setAttribute("class", currentClass + (currentClass ? " " : "") + className);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tremoveClass: function(element, className) {\r\n\t\t\t\t\tif (element) {\r\n\t\t\t\t\t\tif (element.classList) {\r\n\t\t\t\t\t\t\telement.classList.remove(className);\r\n\t\t\t\t\t\t} else if (Type.isString(element.className)) {\r\n\t\t\t\t\t\t\t// Element.className is around 15% faster then set/getAttribute\r\n\t\t\t\t\t\t\t// TODO: Need some jsperf tests on performance - can we get rid of the regex and maybe use split / array manipulation?\r\n\t\t\t\t\t\t\telement.className = element.className.toString().replace(new RegExp("(^|\\\\s)" + className.split(" ").join("|") + "(\\\\s|$)", "gi"), " ");\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Work around for IE strict mode animating SVG - and anything else that doesn\'t behave correctly - the same way jQuery does it\r\n\t\t\t\t\t\t\tvar currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";\r\n\r\n\t\t\t\t\t\t\telement.setAttribute("class", currentClass.replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " "));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t/****************************\r\n\t\t\t Style Getting & Setting\r\n\t\t\t ****************************/\r\n\r\n\t\t\t/* The singular getPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */\r\n\t\t\tgetPropertyValue: function(element, property, rootPropertyValue, forceStyleLookup) {\r\n\t\t\t\t/* Get an element\'s computed property value. */\r\n\t\t\t\t/* Note: Retrieving the value of a CSS property cannot simply be performed by checking an element\'s\r\n\t\t\t\t style attribute (which only reflects user-defined values). Instead, the browser must be queried for a property\'s\r\n\t\t\t\t *computed* value. You can read more about getComputedStyle here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */\r\n\t\t\t\tfunction computePropertyValue(element, property) {\r\n\t\t\t\t\t/* When box-sizing isn\'t set to border-box, height and width style values are incorrectly computed when an\r\n\t\t\t\t\t element\'s scrollbars are visible (which expands the element\'s dimensions). Thus, we defer to the more accurate\r\n\t\t\t\t\t offsetHeight/Width property, which includes the total dimensions for interior, border, padding, and scrollbar.\r\n\t\t\t\t\t We subtract border and padding to get the sum of interior + scrollbar. */\r\n\t\t\t\t\tvar computedValue = 0;\r\n\r\n\t\t\t\t\t/* IE<=8 doesn\'t support window.getComputedStyle, thus we defer to jQuery, which has an extensive array\r\n\t\t\t\t\t of hacks to accurately retrieve IE8 property values. Re-implementing that logic here is not worth bloating the\r\n\t\t\t\t\t codebase for a dying browser. The performance repercussions of using jQuery here are minimal since\r\n\t\t\t\t\t Velocity is optimized to rarely (and sometimes never) query the DOM. Further, the $.css() codepath isn\'t that slow. */\r\n\t\t\t\t\tif (IE <= 8) {\r\n\t\t\t\t\t\tcomputedValue = $.css(element, property); /* GET */\r\n\t\t\t\t\t\t/* All other browsers support getComputedStyle. The returned live object reference is cached onto its\r\n\t\t\t\t\t\t associated element so that it does not need to be refetched upon every GET. */\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Browsers do not return height and width values for elements that are set to display:"none". Thus, we temporarily\r\n\t\t\t\t\t\t toggle display to the element type\'s default value. */\r\n\t\t\t\t\t\tvar toggleDisplay = false;\r\n\r\n\t\t\t\t\t\tif (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {\r\n\t\t\t\t\t\t\ttoggleDisplay = true;\r\n\t\t\t\t\t\t\tCSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar revertDisplay = function() {\r\n\t\t\t\t\t\t\tif (toggleDisplay) {\r\n\t\t\t\t\t\t\t\tCSS.setPropertyValue(element, "display", "none");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tif (!forceStyleLookup) {\r\n\t\t\t\t\t\t\tif (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {\r\n\t\t\t\t\t\t\t\tvar contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);\r\n\t\t\t\t\t\t\t\trevertDisplay();\r\n\r\n\t\t\t\t\t\t\t\treturn contentBoxHeight;\r\n\t\t\t\t\t\t\t} else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {\r\n\t\t\t\t\t\t\t\tvar contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);\r\n\t\t\t\t\t\t\t\trevertDisplay();\r\n\r\n\t\t\t\t\t\t\t\treturn contentBoxWidth;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar computedStyle;\r\n\r\n\t\t\t\t\t\t/* For elements that Velocity hasn\'t been called on directly (e.g. when Velocity queries the DOM on behalf\r\n\t\t\t\t\t\t of a parent of an element its animating), perform a direct getComputedStyle lookup since the object isn\'t cached. */\r\n\t\t\t\t\t\tif (Data(element) === undefined) {\r\n\t\t\t\t\t\t\tcomputedStyle = window.getComputedStyle(element, null); /* GET */\r\n\t\t\t\t\t\t\t/* If the computedStyle object has yet to be cached, do so now. */\r\n\t\t\t\t\t\t} else if (!Data(element).computedStyle) {\r\n\t\t\t\t\t\t\tcomputedStyle = Data(element).computedStyle = window.getComputedStyle(element, null); /* GET */\r\n\t\t\t\t\t\t\t/* If computedStyle is cached, use it. */\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcomputedStyle = Data(element).computedStyle;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side\'s color.\r\n\t\t\t\t\t\t Also, in all browsers, when border colors aren\'t all the same, a compound value is returned that Velocity isn\'t setup to parse.\r\n\t\t\t\t\t\t So, as a polyfill for querying individual border side colors, we just return the top border\'s color and animate all borders from that value. */\r\n\t\t\t\t\t\tif (property === "borderColor") {\r\n\t\t\t\t\t\t\tproperty = "borderTopColor";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* IE9 has a bug in which the "filter" property must be accessed from computedStyle using the getPropertyValue method\r\n\t\t\t\t\t\t instead of a direct property lookup. The getPropertyValue method is slower than a direct lookup, which is why we avoid it by default. */\r\n\t\t\t\t\t\tif (IE === 9 && property === "filter") {\r\n\t\t\t\t\t\t\tcomputedValue = computedStyle.getPropertyValue(property); /* GET */\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcomputedValue = computedStyle[property];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Fall back to the property\'s style value (if defined) when computedValue returns nothing,\r\n\t\t\t\t\t\t which can happen when the element hasn\'t been painted. */\r\n\t\t\t\t\t\tif (computedValue === "" || computedValue === null) {\r\n\t\t\t\t\t\t\tcomputedValue = element.style[property];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trevertDisplay();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,\r\n\t\t\t\t\t defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same\r\n\t\t\t\t\t effect as being set to 0, so no conversion is necessary.) */\r\n\t\t\t\t\t/* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"\r\n\t\t\t\t\t property, which reverts to "auto", left\'s value is 0 relative to its parent element, but is often non-zero relative\r\n\t\t\t\t\t to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */\r\n\t\t\t\t\tif (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {\r\n\t\t\t\t\t\tvar position = computePropertyValue(element, "position"); /* GET */\r\n\r\n\t\t\t\t\t\t/* For absolute positioning, jQuery\'s $.position() only returns values for top and left;\r\n\t\t\t\t\t\t right and bottom will have their "auto" value reverted to 0. */\r\n\t\t\t\t\t\t/* Note: A jQuery object must be created here since jQuery doesn\'t have a low-level alias for $.position().\r\n\t\t\t\t\t\t Not a big deal since we\'re currently in a GET batch anyway. */\r\n\t\t\t\t\t\tif (position === "fixed" || (position === "absolute" && /top|left/i.test(property))) {\r\n\t\t\t\t\t\t\t/* Note: jQuery strips the pixel unit from its returned values; we re-add it here to conform with computePropertyValue\'s behavior. */\r\n\t\t\t\t\t\t\tcomputedValue = $(element).position()[property] + "px"; /* GET */\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn computedValue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar propertyValue;\r\n\r\n\t\t\t\t/* If this is a hooked property (e.g. "clipLeft" instead of the root property of "clip"),\r\n\t\t\t\t extract the hook\'s value from a normalized rootPropertyValue using CSS.Hooks.extractValue(). */\r\n\t\t\t\tif (CSS.Hooks.registered[property]) {\r\n\t\t\t\t\tvar hook = property,\r\n\t\t\t\t\t\t\thookRoot = CSS.Hooks.getRoot(hook);\r\n\r\n\t\t\t\t\t/* If a cached rootPropertyValue wasn\'t passed in (which Velocity always attempts to do in order to avoid requerying the DOM),\r\n\t\t\t\t\t query the DOM for the root property\'s value. */\r\n\t\t\t\t\tif (rootPropertyValue === undefined) {\r\n\t\t\t\t\t\t/* Since the browser is now being directly queried, use the official post-prefixing property name for this lookup. */\r\n\t\t\t\t\t\trootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]); /* GET */\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* If this root has a normalization registered, peform the associated normalization extraction. */\r\n\t\t\t\t\tif (CSS.Normalizations.registered[hookRoot]) {\r\n\t\t\t\t\t\trootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Extract the hook\'s value. */\r\n\t\t\t\t\tpropertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);\r\n\r\n\t\t\t\t\t/* If this is a normalized property (e.g. "opacity" becomes "filter" in <=IE8) or "translateX" becomes "transform"),\r\n\t\t\t\t\t normalize the property\'s name and value, and handle the special case of transforms. */\r\n\t\t\t\t\t/* Note: Normalizing a property is mutually exclusive from hooking a property since hook-extracted values are strictly\r\n\t\t\t\t\t numerical and therefore do not require normalization extraction. */\r\n\t\t\t\t} else if (CSS.Normalizations.registered[property]) {\r\n\t\t\t\t\tvar normalizedPropertyName,\r\n\t\t\t\t\t\t\tnormalizedPropertyValue;\r\n\r\n\t\t\t\t\tnormalizedPropertyName = CSS.Normalizations.registered[property]("name", element);\r\n\r\n\t\t\t\t\t/* Transform values are calculated via normalization extraction (see below), which checks against the element\'s transformCache.\r\n\t\t\t\t\t At no point do transform GETs ever actually query the DOM; initial stylesheet values are never processed.\r\n\t\t\t\t\t This is because parsing 3D transform matrices is not always accurate and would bloat our codebase;\r\n\t\t\t\t\t thus, normalization extraction defaults initial transform values to their zero-values (e.g. 1 for scaleX and 0 for translateX). */\r\n\t\t\t\t\tif (normalizedPropertyName !== "transform") {\r\n\t\t\t\t\t\tnormalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]); /* GET */\r\n\r\n\t\t\t\t\t\t/* If the value is a CSS null-value and this property has a hook template, use that zero-value template so that hooks can be extracted from it. */\r\n\t\t\t\t\t\tif (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {\r\n\t\t\t\t\t\t\tnormalizedPropertyValue = CSS.Hooks.templates[property][1];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpropertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* If a (numeric) value wasn\'t produced via hook extraction or normalization, query the DOM. */\r\n\t\t\t\tif (!/^[\\d-]/.test(propertyValue)) {\r\n\t\t\t\t\t/* For SVG elements, dimensional properties (which SVGAttribute() detects) are tweened via\r\n\t\t\t\t\t their HTML attribute values instead of their CSS style values. */\r\n\t\t\t\t\tvar data = Data(element);\r\n\r\n\t\t\t\t\tif (data && data.isSVG && CSS.Names.SVGAttribute(property)) {\r\n\t\t\t\t\t\t/* Since the height/width attribute values must be set manually, they don\'t reflect computed values.\r\n\t\t\t\t\t\t Thus, we use use getBBox() to ensure we always get values for elements with undefined height/width attributes. */\r\n\t\t\t\t\t\tif (/^(height|width)$/i.test(property)) {\r\n\t\t\t\t\t\t\t/* Firefox throws an error if .getBBox() is called on an SVG that isn\'t attached to the DOM. */\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tpropertyValue = element.getBBox()[property];\r\n\t\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\t\tpropertyValue = 0;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* Otherwise, access the attribute value directly. */\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tpropertyValue = element.getAttribute(property);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]); /* GET */\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* Since property lookups are for animation purposes (which entails computing the numeric delta between start and end values),\r\n\t\t\t\t convert CSS null-values to an integer of value 0. */\r\n\t\t\t\tif (CSS.Values.isCSSNullValue(propertyValue)) {\r\n\t\t\t\t\tpropertyValue = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (Velocity.debug >= 2) {\r\n\t\t\t\t\tconsole.log("Get " + property + ": " + propertyValue);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn propertyValue;\r\n\t\t\t},\r\n\t\t\t/* The singular setPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */\r\n\t\t\tsetPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {\r\n\t\t\t\tvar propertyName = property;\r\n\r\n\t\t\t\t/* In order to be subjected to call options and element queueing, scroll animation is routed through Velocity as if it were a standard CSS property. */\r\n\t\t\t\tif (property === "scroll") {\r\n\t\t\t\t\t/* If a container option is present, scroll the container instead of the browser window. */\r\n\t\t\t\t\tif (scrollData.container) {\r\n\t\t\t\t\t\tscrollData.container["scroll" + scrollData.direction] = propertyValue;\r\n\t\t\t\t\t\t/* Otherwise, Velocity defaults to scrolling the browser window. */\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (scrollData.direction === "Left") {\r\n\t\t\t\t\t\t\twindow.scrollTo(propertyValue, scrollData.alternateValue);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\twindow.scrollTo(scrollData.alternateValue, propertyValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* Transforms (translateX, rotateZ, etc.) are applied to a per-element transformCache object, which is manually flushed via flushTransformCache().\r\n\t\t\t\t\t Thus, for now, we merely cache transforms being SET. */\r\n\t\t\t\t\tif (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {\r\n\t\t\t\t\t\t/* Perform a normalization injection. */\r\n\t\t\t\t\t\t/* Note: The normalization logic handles the transformCache updating. */\r\n\t\t\t\t\t\tCSS.Normalizations.registered[property]("inject", element, propertyValue);\r\n\r\n\t\t\t\t\t\tpropertyName = "transform";\r\n\t\t\t\t\t\tpropertyValue = Data(element).transformCache[property];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Inject hooks. */\r\n\t\t\t\t\t\tif (CSS.Hooks.registered[property]) {\r\n\t\t\t\t\t\t\tvar hookName = property,\r\n\t\t\t\t\t\t\t\t\thookRoot = CSS.Hooks.getRoot(property);\r\n\r\n\t\t\t\t\t\t\t/* If a cached rootPropertyValue was not provided, query the DOM for the hookRoot\'s current value. */\r\n\t\t\t\t\t\t\trootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot); /* GET */\r\n\r\n\t\t\t\t\t\t\tpropertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);\r\n\t\t\t\t\t\t\tproperty = hookRoot;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Normalize names and values. */\r\n\t\t\t\t\t\tif (CSS.Normalizations.registered[property]) {\r\n\t\t\t\t\t\t\tpropertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);\r\n\t\t\t\t\t\t\tproperty = CSS.Normalizations.registered[property]("name", element);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Assign the appropriate vendor prefix before performing an official style update. */\r\n\t\t\t\t\t\tpropertyName = CSS.Names.prefixCheck(property)[0];\r\n\r\n\t\t\t\t\t\t/* A try/catch is used for IE<=8, which throws an error when "invalid" CSS values are set, e.g. a negative width.\r\n\t\t\t\t\t\t Try/catch is avoided for other browsers since it incurs a performance overhead. */\r\n\t\t\t\t\t\tif (IE <= 8) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\telement.style[propertyName] = propertyValue;\r\n\t\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\t\t\tconsole.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* SVG elements have their dimensional properties (width, height, x, y, cx, etc.) applied directly as attributes instead of as styles. */\r\n\t\t\t\t\t\t\t/* Note: IE8 does not support SVG elements, so it\'s okay that we skip it for SVG animation. */\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar data = Data(element);\r\n\r\n\t\t\t\t\t\t\tif (data && data.isSVG && CSS.Names.SVGAttribute(property)) {\r\n\t\t\t\t\t\t\t\t/* Note: For SVG attributes, vendor-prefixed property names are never used. */\r\n\t\t\t\t\t\t\t\t/* Note: Not all CSS properties can be animated via attributes, but the browser won\'t throw an error for unsupported properties. */\r\n\t\t\t\t\t\t\t\telement.setAttribute(property, propertyValue);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\telement.style[propertyName] = propertyValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (Velocity.debug >= 2) {\r\n\t\t\t\t\t\t\tconsole.log("Set " + property + " (" + propertyName + "): " + propertyValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* Return the normalized property name and value in case the caller wants to know how these values were modified before being applied to the DOM. */\r\n\t\t\t\treturn [propertyName, propertyValue];\r\n\t\t\t},\r\n\t\t\t/* To increase performance by batching transform updates into a single SET, transforms are not directly applied to an element until flushTransformCache() is called. */\r\n\t\t\t/* Note: Velocity applies transform properties in the same order that they are chronogically introduced to the element\'s CSS styles. */\r\n\t\t\tflushTransformCache: function(element) {\r\n\t\t\t\tvar transformString = "",\r\n\t\t\t\t\t\tdata = Data(element);\r\n\r\n\t\t\t\t/* Certain browsers require that SVG transforms be applied as an attribute. However, the SVG transform attribute takes a modified version of CSS\'s transform string\r\n\t\t\t\t (units are dropped and, except for skewX/Y, subproperties are merged into their master property -- e.g. scaleX and scaleY are merged into scale(X Y). */\r\n\t\t\t\tif ((IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) && data && data.isSVG) {\r\n\t\t\t\t\t/* Since transform values are stored in their parentheses-wrapped form, we use a helper function to strip out their numeric values.\r\n\t\t\t\t\t Further, SVG transform properties only take unitless (representing pixels) values, so it\'s okay that parseFloat() strips the unit suffixed to the float value. */\r\n\t\t\t\t\tvar getTransformFloat = function(transformProperty) {\r\n\t\t\t\t\t\treturn parseFloat(CSS.getPropertyValue(element, transformProperty));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/* Create an object to organize all the transforms that we\'ll apply to the SVG element. To keep the logic simple,\r\n\t\t\t\t\t we process *all* transform properties -- even those that may not be explicitly applied (since they default to their zero-values anyway). */\r\n\t\t\t\t\tvar SVGTransforms = {\r\n\t\t\t\t\t\ttranslate: [getTransformFloat("translateX"), getTransformFloat("translateY")],\r\n\t\t\t\t\t\tskewX: [getTransformFloat("skewX")], skewY: [getTransformFloat("skewY")],\r\n\t\t\t\t\t\t/* If the scale property is set (non-1), use that value for the scaleX and scaleY values\r\n\t\t\t\t\t\t (this behavior mimics the result of animating all these properties at once on HTML elements). */\r\n\t\t\t\t\t\tscale: getTransformFloat("scale") !== 1 ? [getTransformFloat("scale"), getTransformFloat("scale")] : [getTransformFloat("scaleX"), getTransformFloat("scaleY")],\r\n\t\t\t\t\t\t/* Note: SVG\'s rotate transform takes three values: rotation degrees followed by the X and Y values\r\n\t\t\t\t\t\t defining the rotation\'s origin point. We ignore the origin values (default them to 0). */\r\n\t\t\t\t\t\trotate: [getTransformFloat("rotateZ"), 0, 0]\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/* Iterate through the transform properties in the user-defined property map order.\r\n\t\t\t\t\t (This mimics the behavior of non-SVG transform animation.) */\r\n\t\t\t\t\t$.each(Data(element).transformCache, function(transformName) {\r\n\t\t\t\t\t\t/* Except for with skewX/Y, revert the axis-specific transform subproperties to their axis-free master\r\n\t\t\t\t\t\t properties so that they match up with SVG\'s accepted transform properties. */\r\n\t\t\t\t\t\tif (/^translate/i.test(transformName)) {\r\n\t\t\t\t\t\t\ttransformName = "translate";\r\n\t\t\t\t\t\t} else if (/^scale/i.test(transformName)) {\r\n\t\t\t\t\t\t\ttransformName = "scale";\r\n\t\t\t\t\t\t} else if (/^rotate/i.test(transformName)) {\r\n\t\t\t\t\t\t\ttransformName = "rotate";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Check that we haven\'t yet deleted the property from the SVGTransforms container. */\r\n\t\t\t\t\t\tif (SVGTransforms[transformName]) {\r\n\t\t\t\t\t\t\t/* Append the transform property in the SVG-supported transform format. As per the spec, surround the space-delimited values in parentheses. */\r\n\t\t\t\t\t\t\ttransformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";\r\n\r\n\t\t\t\t\t\t\t/* After processing an SVG transform property, delete it from the SVGTransforms container so we don\'t\r\n\t\t\t\t\t\t\t re-insert the same master property if we encounter another one of its axis-specific properties. */\r\n\t\t\t\t\t\t\tdelete SVGTransforms[transformName];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar transformValue,\r\n\t\t\t\t\t\t\tperspective;\r\n\r\n\t\t\t\t\t/* Transform properties are stored as members of the transformCache object. Concatenate all the members into a string. */\r\n\t\t\t\t\t$.each(Data(element).transformCache, function(transformName) {\r\n\t\t\t\t\t\ttransformValue = Data(element).transformCache[transformName];\r\n\r\n\t\t\t\t\t\t/* Transform\'s perspective subproperty must be set first in order to take effect. Store it temporarily. */\r\n\t\t\t\t\t\tif (transformName === "transformPerspective") {\r\n\t\t\t\t\t\t\tperspective = transformValue;\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* IE9 only supports one rotation type, rotateZ, which it refers to as "rotate". */\r\n\t\t\t\t\t\tif (IE === 9 && transformName === "rotateZ") {\r\n\t\t\t\t\t\t\ttransformName = "rotate";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttransformString += transformName + transformValue + " ";\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/* If present, set the perspective subproperty first. */\r\n\t\t\t\t\tif (perspective) {\r\n\t\t\t\t\t\ttransformString = "perspective" + perspective + " " + transformString;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tCSS.setPropertyValue(element, "transform", transformString);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t/* Register hooks and normalizations. */\r\n\t\tCSS.Hooks.register();\r\n\t\tCSS.Normalizations.register();\r\n\r\n\t\t/* Allow hook setting in the same fashion as jQuery\'s $.css(). */\r\n\t\tVelocity.hook = function(elements, arg2, arg3) {\r\n\t\t\tvar value;\r\n\r\n\t\t\telements = sanitizeElements(elements);\r\n\r\n\t\t\t$.each(elements, function(i, element) {\r\n\t\t\t\t/* Initialize Velocity\'s per-element data cache if this element hasn\'t previously been animated. */\r\n\t\t\t\tif (Data(element) === undefined) {\r\n\t\t\t\t\tVelocity.init(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* Get property value. If an element set was passed in, only return the value for the first element. */\r\n\t\t\t\tif (arg3 === undefined) {\r\n\t\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\t\tvalue = CSS.getPropertyValue(element, arg2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Set property value. */\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* sPV returns an array of the normalized propertyName/propertyValue pair used to update the DOM. */\r\n\t\t\t\t\tvar adjustedSet = CSS.setPropertyValue(element, arg2, arg3);\r\n\r\n\t\t\t\t\t/* Transform properties don\'t automatically set. They have to be flushed to the DOM. */\r\n\t\t\t\t\tif (adjustedSet[0] === "transform") {\r\n\t\t\t\t\t\tVelocity.CSS.flushTransformCache(element);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvalue = adjustedSet;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn value;\r\n\t\t};\r\n\r\n\t\t/*****************\r\n\t\t Animation\r\n\t\t *****************/\r\n\r\n\t\tvar animate = function() {\r\n\t\t\tvar opts;\r\n\r\n\t\t\t/******************\r\n\t\t\t Call Chain\r\n\t\t\t ******************/\r\n\r\n\t\t\t/* Logic for determining what to return to the call stack when exiting out of Velocity. */\r\n\t\t\tfunction getChain() {\r\n\t\t\t\t/* If we are using the utility function, attempt to return this call\'s promise. If no promise library was detected,\r\n\t\t\t\t default to null instead of returning the targeted elements so that utility function\'s return value is standardized. */\r\n\t\t\t\tif (isUtility) {\r\n\t\t\t\t\treturn promiseData.promise || null;\r\n\t\t\t\t\t/* Otherwise, if we\'re using $.fn, return the jQuery-/Zepto-wrapped element set. */\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn elementsWrapped;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/*************************\r\n\t\t\t Arguments Assignment\r\n\t\t\t *************************/\r\n\r\n\t\t\t/* To allow for expressive CoffeeScript code, Velocity supports an alternative syntax in which "elements" (or "e"), "properties" (or "p"), and "options" (or "o")\r\n\t\t\t objects are defined on a container object that\'s passed in as Velocity\'s sole argument. */\r\n\t\t\t/* Note: Some browsers automatically populate arguments with a "properties" object. We detect it by checking for its default "names" property. */\r\n\t\t\tvar syntacticSugar = (arguments[0] && (arguments[0].p || (($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names) || Type.isString(arguments[0].properties)))),\r\n\t\t\t\t\t/* Whether Velocity was called via the utility function (as opposed to on a jQuery/Zepto object). */\r\n\t\t\t\t\tisUtility,\r\n\t\t\t\t\t/* When Velocity is called via the utility function ($.Velocity()/Velocity()), elements are explicitly\r\n\t\t\t\t\t passed in as the first parameter. Thus, argument positioning varies. We normalize them here. */\r\n\t\t\t\t\telementsWrapped,\r\n\t\t\t\t\targumentIndex;\r\n\r\n\t\t\tvar elements,\r\n\t\t\t\t\tpropertiesMap,\r\n\t\t\t\t\toptions;\r\n\r\n\t\t\t/* Detect jQuery/Zepto elements being animated via the $.fn method. */\r\n\t\t\tif (Type.isWrapped(this)) {\r\n\t\t\t\tisUtility = false;\r\n\r\n\t\t\t\targumentIndex = 0;\r\n\t\t\t\telements = this;\r\n\t\t\t\telementsWrapped = this;\r\n\t\t\t\t/* Otherwise, raw elements are being animated via the utility function. */\r\n\t\t\t} else {\r\n\t\t\t\tisUtility = true;\r\n\r\n\t\t\t\targumentIndex = 1;\r\n\t\t\t\telements = syntacticSugar ? (arguments[0].elements || arguments[0].e) : arguments[0];\r\n\t\t\t}\r\n\r\n\t\t\t/***************\r\n\t\t\t Promises\r\n\t\t\t ***************/\r\n\r\n\t\t\tvar promiseData = {\r\n\t\t\t\tpromise: null,\r\n\t\t\t\tresolver: null,\r\n\t\t\t\trejecter: null\r\n\t\t\t};\r\n\r\n\t\t\t/* If this call was made via the utility function (which is the default method of invocation when jQuery/Zepto are not being used), and if\r\n\t\t\t promise support was detected, create a promise object for this call and store references to its resolver and rejecter methods. The resolve\r\n\t\t\t method is used when a call completes naturally or is prematurely stopped by the user. In both cases, completeCall() handles the associated\r\n\t\t\t call cleanup and promise resolving logic. The reject method is used when an invalid set of arguments is passed into a Velocity call. */\r\n\t\t\t/* Note: Velocity employs a call-based queueing architecture, which means that stopping an animating element actually stops the full call that\r\n\t\t\t triggered it -- not that one element exclusively. Similarly, there is one promise per call, and all elements targeted by a Velocity call are\r\n\t\t\t grouped together for the purposes of resolving and rejecting a promise. */\r\n\t\t\tif (isUtility && Velocity.Promise) {\r\n\t\t\t\tpromiseData.promise = new Velocity.Promise(function(resolve, reject) {\r\n\t\t\t\t\tpromiseData.resolver = resolve;\r\n\t\t\t\t\tpromiseData.rejecter = reject;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (syntacticSugar) {\r\n\t\t\t\tpropertiesMap = arguments[0].properties || arguments[0].p;\r\n\t\t\t\toptions = arguments[0].options || arguments[0].o;\r\n\t\t\t} else {\r\n\t\t\t\tpropertiesMap = arguments[argumentIndex];\r\n\t\t\t\toptions = arguments[argumentIndex + 1];\r\n\t\t\t}\r\n\r\n\t\t\telements = sanitizeElements(elements);\r\n\r\n\t\t\tif (!elements) {\r\n\t\t\t\tif (promiseData.promise) {\r\n\t\t\t\t\tif (!propertiesMap || !options || options.promiseRejectEmpty !== false) {\r\n\t\t\t\t\t\tpromiseData.rejecter();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpromiseData.resolver();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t/* The length of the element set (in the form of a nodeList or an array of elements) is defaulted to 1 in case a\r\n\t\t\t single raw DOM element is passed in (which doesn\'t contain a length property). */\r\n\t\t\tvar elementsLength = elements.length,\r\n\t\t\t\t\telementsIndex = 0;\r\n\r\n\t\t\t/***************************\r\n\t\t\t Argument Overloading\r\n\t\t\t ***************************/\r\n\r\n\t\t\t/* Support is included for jQuery\'s argument overloading: $.animate(propertyMap [, duration] [, easing] [, complete]).\r\n\t\t\t Overloading is detected by checking for the absence of an object being passed into options. */\r\n\t\t\t/* Note: The stop/finish/pause/resume actions do not accept animation options, and are therefore excluded from this check. */\r\n\t\t\tif (!/^(stop|finish|finishAll|pause|resume)$/i.test(propertiesMap) && !$.isPlainObject(options)) {\r\n\t\t\t\t/* The utility function shifts all arguments one position to the right, so we adjust for that offset. */\r\n\t\t\t\tvar startingArgumentPosition = argumentIndex + 1;\r\n\r\n\t\t\t\toptions = {};\r\n\r\n\t\t\t\t/* Iterate through all options arguments */\r\n\t\t\t\tfor (var i = startingArgumentPosition; i < arguments.length; i++) {\r\n\t\t\t\t\t/* Treat a number as a duration. Parse it out. */\r\n\t\t\t\t\t/* Note: The following RegEx will return true if passed an array with a number as its first item.\r\n\t\t\t\t\t Thus, arrays are skipped from this check. */\r\n\t\t\t\t\tif (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\\d/.test(arguments[i]))) {\r\n\t\t\t\t\t\toptions.duration = arguments[i];\r\n\t\t\t\t\t\t/* Treat strings and arrays as easings. */\r\n\t\t\t\t\t} else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {\r\n\t\t\t\t\t\toptions.easing = arguments[i];\r\n\t\t\t\t\t\t/* Treat a function as a complete callback. */\r\n\t\t\t\t\t} else if (Type.isFunction(arguments[i])) {\r\n\t\t\t\t\t\toptions.complete = arguments[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/*********************\r\n\t\t\t Action Detection\r\n\t\t\t *********************/\r\n\r\n\t\t\t/* Velocity\'s behavior is categorized into "actions": Elements can either be specially scrolled into view,\r\n\t\t\t or they can be started, stopped, paused, resumed, or reversed . If a literal or referenced properties map is passed in as Velocity\'s\r\n\t\t\t first argument, the associated action is "start". Alternatively, "scroll", "reverse", "pause", "resume" or "stop" can be passed in \r\n\t\t\t instead of a properties map. */\r\n\t\t\tvar action;\r\n\r\n\t\t\tswitch (propertiesMap) {\r\n\t\t\t\tcase "scroll":\r\n\t\t\t\t\taction = "scroll";\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase "reverse":\r\n\t\t\t\t\taction = "reverse";\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase "pause":\r\n\r\n\t\t\t\t\t/*******************\r\n\t\t\t\t\t Action: Pause\r\n\t\t\t\t\t *******************/\r\n\r\n\t\t\t\t\tvar currentTime = (new Date()).getTime();\r\n\r\n\t\t\t\t\t/* Handle delay timers */\r\n\t\t\t\t\t$.each(elements, function(i, element) {\r\n\t\t\t\t\t\tpauseDelayOnElement(element, currentTime);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/* Pause and Resume are call-wide (not on a per element basis). Thus, calling pause or resume on a \r\n\t\t\t\t\t single element will cause any calls that containt tweens for that element to be paused/resumed\r\n\t\t\t\t\t as well. */\r\n\r\n\t\t\t\t\t/* Iterate through all calls and pause any that contain any of our elements */\r\n\t\t\t\t\t$.each(Velocity.State.calls, function(i, activeCall) {\r\n\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\t/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */\r\n\t\t\t\t\t\tif (activeCall) {\r\n\t\t\t\t\t\t\t/* Iterate through the active call\'s targeted elements. */\r\n\t\t\t\t\t\t\t$.each(activeCall[1], function(k, activeElement) {\r\n\t\t\t\t\t\t\t\tvar queueName = (options === undefined) ? "" : options;\r\n\r\n\t\t\t\t\t\t\t\tif (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/* Iterate through the calls targeted by the stop command. */\r\n\t\t\t\t\t\t\t\t$.each(elements, function(l, element) {\r\n\t\t\t\t\t\t\t\t\t/* Check that this call was applied to the target element. */\r\n\t\t\t\t\t\t\t\t\tif (element === activeElement) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* Set call to paused */\r\n\t\t\t\t\t\t\t\t\t\tactiveCall[5] = {\r\n\t\t\t\t\t\t\t\t\t\t\tresume: false\r\n\t\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* Once we match an element, we can bounce out to the next call entirely */\r\n\t\t\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t/* Proceed to check next call if we have already matched */\r\n\t\t\t\t\t\t\t\tif (found) {\r\n\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/* Since pause creates no new tweens, exit out of Velocity. */\r\n\t\t\t\t\treturn getChain();\r\n\r\n\t\t\t\tcase "resume":\r\n\r\n\t\t\t\t\t/*******************\r\n\t\t\t\t\t Action: Resume\r\n\t\t\t\t\t *******************/\r\n\r\n\t\t\t\t\t/* Handle delay timers */\r\n\t\t\t\t\t$.each(elements, function(i, element) {\r\n\t\t\t\t\t\tresumeDelayOnElement(element, currentTime);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/* Pause and Resume are call-wide (not on a per elemnt basis). Thus, calling pause or resume on a \r\n\t\t\t\t\t single element will cause any calls that containt tweens for that element to be paused/resumed\r\n\t\t\t\t\t as well. */\r\n\r\n\t\t\t\t\t/* Iterate through all calls and pause any that contain any of our elements */\r\n\t\t\t\t\t$.each(Velocity.State.calls, function(i, activeCall) {\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\t/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */\r\n\t\t\t\t\t\tif (activeCall) {\r\n\t\t\t\t\t\t\t/* Iterate through the active call\'s targeted elements. */\r\n\t\t\t\t\t\t\t$.each(activeCall[1], function(k, activeElement) {\r\n\t\t\t\t\t\t\t\tvar queueName = (options === undefined) ? "" : options;\r\n\r\n\t\t\t\t\t\t\t\tif (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/* Skip any calls that have never been paused */\r\n\t\t\t\t\t\t\t\tif (!activeCall[5]) {\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/* Iterate through the calls targeted by the stop command. */\r\n\t\t\t\t\t\t\t\t$.each(elements, function(l, element) {\r\n\t\t\t\t\t\t\t\t\t/* Check that this call was applied to the target element. */\r\n\t\t\t\t\t\t\t\t\tif (element === activeElement) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* Flag a pause object to be resumed, which will occur during the next tick. In\r\n\t\t\t\t\t\t\t\t\t\t addition, the pause object will at that time be deleted */\r\n\t\t\t\t\t\t\t\t\t\tactiveCall[5].resume = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t/* Once we match an element, we can bounce out to the next call entirely */\r\n\t\t\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t/* Proceed to check next call if we have already matched */\r\n\t\t\t\t\t\t\t\tif (found) {\r\n\t\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/* Since resume creates no new tweens, exit out of Velocity. */\r\n\t\t\t\t\treturn getChain();\r\n\r\n\t\t\t\tcase "finish":\r\n\t\t\t\tcase "finishAll":\r\n\t\t\t\tcase "stop":\r\n\t\t\t\t\t/*******************\r\n\t\t\t\t\t Action: Stop\r\n\t\t\t\t\t *******************/\r\n\r\n\t\t\t\t\t/* Clear the currently-active delay on each targeted element. */\r\n\t\t\t\t\t$.each(elements, function(i, element) {\r\n\t\t\t\t\t\tif (Data(element) && Data(element).delayTimer) {\r\n\t\t\t\t\t\t\t/* Stop the timer from triggering its cached next() function. */\r\n\t\t\t\t\t\t\tclearTimeout(Data(element).delayTimer.setTimeout);\r\n\r\n\t\t\t\t\t\t\t/* Manually call the next() function so that the subsequent queue items can progress. */\r\n\t\t\t\t\t\t\tif (Data(element).delayTimer.next) {\r\n\t\t\t\t\t\t\t\tData(element).delayTimer.next();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tdelete Data(element).delayTimer;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* If we want to finish everything in the queue, we have to iterate through it\r\n\t\t\t\t\t\t and call each function. This will make them active calls below, which will\r\n\t\t\t\t\t\t cause them to be applied via the duration setting. */\r\n\t\t\t\t\t\tif (propertiesMap === "finishAll" && (options === true || Type.isString(options))) {\r\n\t\t\t\t\t\t\t/* Iterate through the items in the element\'s queue. */\r\n\t\t\t\t\t\t\t$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {\r\n\t\t\t\t\t\t\t\t/* The queue array can contain an "inprogress" string, which we skip. */\r\n\t\t\t\t\t\t\t\tif (Type.isFunction(item)) {\r\n\t\t\t\t\t\t\t\t\titem();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t/* Clearing the $.queue() array is achieved by resetting it to []. */\r\n\t\t\t\t\t\t\t$.queue(element, Type.isString(options) ? options : "", []);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tvar callsToStop = [];\r\n\r\n\t\t\t\t\t/* When the stop action is triggered, the elements\' currently active call is immediately stopped. The active call might have\r\n\t\t\t\t\t been applied to multiple elements, in which case all of the call\'s elements will be stopped. When an element\r\n\t\t\t\t\t is stopped, the next item in its animation queue is immediately triggered. */\r\n\t\t\t\t\t/* An additional argument may be passed in to clear an element\'s remaining queued calls. Either true (which defaults to the "fx" queue)\r\n\t\t\t\t\t or a custom queue string can be passed in. */\r\n\t\t\t\t\t/* Note: The stop command runs prior to Velocity\'s Queueing phase since its behavior is intended to take effect *immediately*,\r\n\t\t\t\t\t regardless of the element\'s current queue state. */\r\n\r\n\t\t\t\t\t/* Iterate through every active call. */\r\n\t\t\t\t\t$.each(Velocity.State.calls, function(i, activeCall) {\r\n\t\t\t\t\t\t/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */\r\n\t\t\t\t\t\tif (activeCall) {\r\n\t\t\t\t\t\t\t/* Iterate through the active call\'s targeted elements. */\r\n\t\t\t\t\t\t\t$.each(activeCall[1], function(k, activeElement) {\r\n\t\t\t\t\t\t\t\t/* If true was passed in as a secondary argument, clear absolutely all calls on this element. Otherwise, only\r\n\t\t\t\t\t\t\t\t clear calls associated with the relevant queue. */\r\n\t\t\t\t\t\t\t\t/* Call stopping logic works as follows:\r\n\t\t\t\t\t\t\t\t - options === true --\x3e stop current default queue calls (and queue:false calls), including remaining queued ones.\r\n\t\t\t\t\t\t\t\t - options === undefined --\x3e stop current queue:"" call and all queue:false calls.\r\n\t\t\t\t\t\t\t\t - options === false --\x3e stop only queue:false calls.\r\n\t\t\t\t\t\t\t\t - options === "custom" --\x3e stop current queue:"custom" call, including remaining queued ones (there is no functionality to only clear the currently-running queue:"custom" call). */\r\n\t\t\t\t\t\t\t\tvar queueName = (options === undefined) ? "" : options;\r\n\r\n\t\t\t\t\t\t\t\tif (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/* Iterate through the calls targeted by the stop command. */\r\n\t\t\t\t\t\t\t\t$.each(elements, function(l, element) {\r\n\t\t\t\t\t\t\t\t\t/* Check that this call was applied to the target element. */\r\n\t\t\t\t\t\t\t\t\tif (element === activeElement) {\r\n\t\t\t\t\t\t\t\t\t\t/* Optionally clear the remaining queued calls. If we\'re doing "finishAll" this won\'t find anything,\r\n\t\t\t\t\t\t\t\t\t\t due to the queue-clearing above. */\r\n\t\t\t\t\t\t\t\t\t\tif (options === true || Type.isString(options)) {\r\n\t\t\t\t\t\t\t\t\t\t\t/* Iterate through the items in the element\'s queue. */\r\n\t\t\t\t\t\t\t\t\t\t\t$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t/* The queue array can contain an "inprogress" string, which we skip. */\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (Type.isFunction(item)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t/* Pass the item\'s callback a flag indicating that we want to abort from the queue call.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t (Specifically, the queue will resolve the call\'s associated promise then abort.)  */\r\n\t\t\t\t\t\t\t\t\t\t\t\t\titem(null, true);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t/* Clearing the $.queue() array is achieved by resetting it to []. */\r\n\t\t\t\t\t\t\t\t\t\t\t$.queue(element, Type.isString(options) ? options : "", []);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (propertiesMap === "stop") {\r\n\t\t\t\t\t\t\t\t\t\t\t/* Since "reverse" uses cached start values (the previous call\'s endValues), these values must be\r\n\t\t\t\t\t\t\t\t\t\t\t changed to reflect the final value that the elements were actually tweened to. */\r\n\t\t\t\t\t\t\t\t\t\t\t/* Note: If only queue:false/queue:"custom" animations are currently running on an element, it won\'t have a tweensContainer\r\n\t\t\t\t\t\t\t\t\t\t\t object. Also, queue:false/queue:"custom" animations can\'t be reversed. */\r\n\t\t\t\t\t\t\t\t\t\t\tvar data = Data(element);\r\n\t\t\t\t\t\t\t\t\t\t\tif (data && data.tweensContainer && (queueName === true || queueName === "")) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t$.each(data.tweensContainer, function(m, activeTween) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tactiveTween.endValue = activeTween.currentValue;\r\n\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tcallsToStop.push(i);\r\n\t\t\t\t\t\t\t\t\t\t} else if (propertiesMap === "finish" || propertiesMap === "finishAll") {\r\n\t\t\t\t\t\t\t\t\t\t\t/* To get active tweens to finish immediately, we forcefully shorten their durations to 1ms so that\r\n\t\t\t\t\t\t\t\t\t\t\t they finish upon the next rAf tick then proceed with normal call completion logic. */\r\n\t\t\t\t\t\t\t\t\t\t\tactiveCall[2].duration = 1;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t/* Prematurely call completeCall() on each matched active call. Pass an additional flag for "stop" to indicate\r\n\t\t\t\t\t that the complete callback and display:none setting should be skipped since we\'re completing prematurely. */\r\n\t\t\t\t\tif (propertiesMap === "stop") {\r\n\t\t\t\t\t\t$.each(callsToStop, function(i, j) {\r\n\t\t\t\t\t\t\tcompleteCall(j, true);\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tif (promiseData.promise) {\r\n\t\t\t\t\t\t\t/* Immediately resolve the promise associated with this stop call since stop runs synchronously. */\r\n\t\t\t\t\t\t\tpromiseData.resolver(elements);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Since we\'re stopping, and not proceeding with queueing, exit out of Velocity. */\r\n\t\t\t\t\treturn getChain();\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t/* Treat a non-empty plain object as a literal properties map. */\r\n\t\t\t\t\tif ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {\r\n\t\t\t\t\t\taction = "start";\r\n\r\n\t\t\t\t\t\t/****************\r\n\t\t\t\t\t\t Redirects\r\n\t\t\t\t\t\t ****************/\r\n\r\n\t\t\t\t\t\t/* Check if a string matches a registered redirect (see Redirects above). */\r\n\t\t\t\t\t} else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {\r\n\t\t\t\t\t\topts = $.extend({}, options);\r\n\r\n\t\t\t\t\t\tvar durationOriginal = opts.duration,\r\n\t\t\t\t\t\t\t\tdelayOriginal = opts.delay || 0;\r\n\r\n\t\t\t\t\t\t/* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */\r\n\t\t\t\t\t\tif (opts.backwards === true) {\r\n\t\t\t\t\t\t\telements = $.extend(true, [], elements).reverse();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */\r\n\t\t\t\t\t\t$.each(elements, function(elementIndex, element) {\r\n\t\t\t\t\t\t\t/* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */\r\n\t\t\t\t\t\t\tif (parseFloat(opts.stagger)) {\r\n\t\t\t\t\t\t\t\topts.delay = delayOriginal + (parseFloat(opts.stagger) * elementIndex);\r\n\t\t\t\t\t\t\t} else if (Type.isFunction(opts.stagger)) {\r\n\t\t\t\t\t\t\t\topts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)\r\n\t\t\t\t\t\t\t the duration of each element\'s animation, using floors to prevent producing very short durations. */\r\n\t\t\t\t\t\t\tif (opts.drag) {\r\n\t\t\t\t\t\t\t\t/* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */\r\n\t\t\t\t\t\t\t\topts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1000 : DURATION_DEFAULT);\r\n\r\n\t\t\t\t\t\t\t\t/* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,\r\n\t\t\t\t\t\t\t\t B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).\r\n\t\t\t\t\t\t\t\t The end result is a baseline of 75% of the redirect\'s duration that increases/decreases as the end of the element set is approached. */\r\n\t\t\t\t\t\t\t\topts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex / elementsLength : (elementIndex + 1) / elementsLength), opts.duration * 0.75, 200);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Pass in the call\'s opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to\r\n\t\t\t\t\t\t\t reduce the opts checking logic required inside the redirect. */\r\n\t\t\t\t\t\t\tVelocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t/* Since the animation logic resides within the redirect\'s own code, abort the remainder of this call.\r\n\t\t\t\t\t\t (The performance overhead up to this point is virtually non-existant.) */\r\n\t\t\t\t\t\t/* Note: The jQuery call chain is kept intact by returning the complete element set. */\r\n\t\t\t\t\t\treturn getChain();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";\r\n\r\n\t\t\t\t\t\tif (promiseData.promise) {\r\n\t\t\t\t\t\t\tpromiseData.rejecter(new Error(abortError));\r\n\t\t\t\t\t\t} else if (window.console) {\r\n\t\t\t\t\t\t\tconsole.log(abortError);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn getChain();\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**************************\r\n\t\t\t Call-Wide Variables\r\n\t\t\t **************************/\r\n\r\n\t\t\t/* A container for CSS unit conversion ratios (e.g. %, rem, and em ==> px) that is used to cache ratios across all elements\r\n\t\t\t being animated in a single Velocity call. Calculating unit ratios necessitates DOM querying and updating, and is therefore\r\n\t\t\t avoided (via caching) wherever possible. This container is call-wide instead of page-wide to avoid the risk of using stale\r\n\t\t\t conversion metrics across Velocity animations that are not immediately consecutively chained. */\r\n\t\t\tvar callUnitConversionData = {\r\n\t\t\t\tlastParent: null,\r\n\t\t\t\tlastPosition: null,\r\n\t\t\t\tlastFontSize: null,\r\n\t\t\t\tlastPercentToPxWidth: null,\r\n\t\t\t\tlastPercentToPxHeight: null,\r\n\t\t\t\tlastEmToPx: null,\r\n\t\t\t\tremToPx: null,\r\n\t\t\t\tvwToPx: null,\r\n\t\t\t\tvhToPx: null\r\n\t\t\t};\r\n\r\n\t\t\t/* A container for all the ensuing tween data and metadata associated with this call. This container gets pushed to the page-wide\r\n\t\t\t Velocity.State.calls array that is processed during animation ticking. */\r\n\t\t\tvar call = [];\r\n\r\n\t\t\t/************************\r\n\t\t\t Element Processing\r\n\t\t\t ************************/\r\n\r\n\t\t\t/* Element processing consists of three parts -- data processing that cannot go stale and data processing that *can* go stale (i.e. third-party style modifications):\r\n\t\t\t 1) Pre-Queueing: Element-wide variables, including the element\'s data storage, are instantiated. Call options are prepared. If triggered, the Stop action is executed.\r\n\t\t\t 2) Queueing: The logic that runs once this call has reached its point of execution in the element\'s $.queue() stack. Most logic is placed here to avoid risking it becoming stale.\r\n\t\t\t 3) Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.\r\n\t\t\t `elementArrayIndex` allows passing index of the element in the original array to value functions.\r\n\t\t\t If `elementsIndex` were used instead the index would be determined by the elements\' per-element queue.\r\n\t\t\t */\r\n\t\t\tfunction processElement(element, elementArrayIndex) {\r\n\r\n\t\t\t\t/*************************\r\n\t\t\t\t Part I: Pre-Queueing\r\n\t\t\t\t *************************/\r\n\r\n\t\t\t\t/***************************\r\n\t\t\t\t Element-Wide Variables\r\n\t\t\t\t ***************************/\r\n\r\n\t\t\t\tvar /* The runtime opts object is the extension of the current call\'s options and Velocity\'s page-wide option defaults. */\r\n\t\t\t\t\t\topts = $.extend({}, Velocity.defaults, options),\r\n\t\t\t\t\t\t/* A container for the processed data associated with each property in the propertyMap.\r\n\t\t\t\t\t\t (Each property in the map produces its own "tween".) */\r\n\t\t\t\t\t\ttweensContainer = {},\r\n\t\t\t\t\t\telementUnitConversionData;\r\n\r\n\t\t\t\t/******************\r\n\t\t\t\t Element Init\r\n\t\t\t\t ******************/\r\n\r\n\t\t\t\tif (Data(element) === undefined) {\r\n\t\t\t\t\tVelocity.init(element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/******************\r\n\t\t\t\t Option: Delay\r\n\t\t\t\t ******************/\r\n\r\n\t\t\t\t/* Since queue:false doesn\'t respect the item\'s existing queue, we avoid injecting its delay here (it\'s set later on). */\r\n\t\t\t\t/* Note: Velocity rolls its own delay function since jQuery doesn\'t have a utility alias for $.fn.delay()\r\n\t\t\t\t (and thus requires jQuery element creation, which we avoid since its overhead includes DOM querying). */\r\n\t\t\t\tif (parseFloat(opts.delay) && opts.queue !== false) {\r\n\t\t\t\t\t$.queue(element, opts.queue, function(next, clearQueue) {\r\n\t\t\t\t\t\tif (clearQueue === true) {\r\n\t\t\t\t\t\t\t/* Do not continue with animation queueing. */\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* This is a flag used to indicate to the upcoming completeCall() function that this queue entry was initiated by Velocity. See completeCall() for further details. */\r\n\t\t\t\t\t\tVelocity.velocityQueueEntryFlag = true;\r\n\r\n\t\t\t\t\t\t/* The ensuing queue item (which is assigned to the "next" argument that $.queue() automatically passes in) will be triggered after a setTimeout delay.\r\n\t\t\t\t\t\t The setTimeout is stored so that it can be subjected to clearTimeout() if this animation is prematurely stopped via Velocity\'s "stop" command, and\r\n\t\t\t\t\t\t delayBegin/delayTime is used to ensure we can "pause" and "resume" a tween that is still mid-delay. */\r\n\r\n\t\t\t\t\t\t/* Temporarily store delayed elements to facilite access for global pause/resume */\r\n\t\t\t\t\t\tvar callIndex = Velocity.State.delayedElements.count++;\r\n\t\t\t\t\t\tVelocity.State.delayedElements[callIndex] = element;\r\n\r\n\t\t\t\t\t\tvar delayComplete = (function(index) {\r\n\t\t\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t\t\t/* Clear the temporary element */\r\n\t\t\t\t\t\t\t\tVelocity.State.delayedElements[index] = false;\r\n\r\n\t\t\t\t\t\t\t\t/* Finally, issue the call */\r\n\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t})(callIndex);\r\n\r\n\r\n\t\t\t\t\t\tData(element).delayBegin = (new Date()).getTime();\r\n\t\t\t\t\t\tData(element).delay = parseFloat(opts.delay);\r\n\t\t\t\t\t\tData(element).delayTimer = {\r\n\t\t\t\t\t\t\tsetTimeout: setTimeout(next, parseFloat(opts.delay)),\r\n\t\t\t\t\t\t\tnext: delayComplete\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*********************\r\n\t\t\t\t Option: Duration\r\n\t\t\t\t *********************/\r\n\r\n\t\t\t\t/* Support for jQuery\'s named durations. */\r\n\t\t\t\tswitch (opts.duration.toString().toLowerCase()) {\r\n\t\t\t\t\tcase "fast":\r\n\t\t\t\t\t\topts.duration = 200;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase "normal":\r\n\t\t\t\t\t\topts.duration = DURATION_DEFAULT;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase "slow":\r\n\t\t\t\t\t\topts.duration = 600;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t/* Remove the potential "ms" suffix and default to 1 if the user is attempting to set a duration of 0 (in order to produce an immediate style change). */\r\n\t\t\t\t\t\topts.duration = parseFloat(opts.duration) || 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/************************\r\n\t\t\t\t Global Option: Mock\r\n\t\t\t\t ************************/\r\n\r\n\t\t\t\tif (Velocity.mock !== false) {\r\n\t\t\t\t\t/* In mock mode, all animations are forced to 1ms so that they occur immediately upon the next rAF tick.\r\n\t\t\t\t\t Alternatively, a multiplier can be passed in to time remap all delays and durations. */\r\n\t\t\t\t\tif (Velocity.mock === true) {\r\n\t\t\t\t\t\topts.duration = opts.delay = 1;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\topts.duration *= parseFloat(Velocity.mock) || 1;\r\n\t\t\t\t\t\topts.delay *= parseFloat(Velocity.mock) || 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*******************\r\n\t\t\t\t Option: Easing\r\n\t\t\t\t *******************/\r\n\r\n\t\t\t\topts.easing = getEasing(opts.easing, opts.duration);\r\n\r\n\t\t\t\t/**********************\r\n\t\t\t\t Option: Callbacks\r\n\t\t\t\t **********************/\r\n\r\n\t\t\t\t/* Callbacks must functions. Otherwise, default to null. */\r\n\t\t\t\tif (opts.begin && !Type.isFunction(opts.begin)) {\r\n\t\t\t\t\topts.begin = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (opts.progress && !Type.isFunction(opts.progress)) {\r\n\t\t\t\t\topts.progress = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (opts.complete && !Type.isFunction(opts.complete)) {\r\n\t\t\t\t\topts.complete = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*********************************\r\n\t\t\t\t Option: Display & Visibility\r\n\t\t\t\t *********************************/\r\n\r\n\t\t\t\t/* Refer to Velocity\'s documentation (VelocityJS.org/#displayAndVisibility) for a description of the display and visibility options\' behavior. */\r\n\t\t\t\t/* Note: We strictly check for undefined instead of falsiness because display accepts an empty string value. */\r\n\t\t\t\tif (opts.display !== undefined && opts.display !== null) {\r\n\t\t\t\t\topts.display = opts.display.toString().toLowerCase();\r\n\r\n\t\t\t\t\t/* Users can pass in a special "auto" value to instruct Velocity to set the element to its default display value. */\r\n\t\t\t\t\tif (opts.display === "auto") {\r\n\t\t\t\t\t\topts.display = Velocity.CSS.Values.getDisplayType(element);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (opts.visibility !== undefined && opts.visibility !== null) {\r\n\t\t\t\t\topts.visibility = opts.visibility.toString().toLowerCase();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/**********************\r\n\t\t\t\t Option: mobileHA\r\n\t\t\t\t **********************/\r\n\r\n\t\t\t\t/* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)\r\n\t\t\t\t on animating elements. HA is removed from the element at the completion of its animation. */\r\n\t\t\t\t/* Note: Android Gingerbread doesn\'t support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */\r\n\t\t\t\t/* Note: You can read more about the use of mobileHA in Velocity\'s documentation: VelocityJS.org/#mobileHA. */\r\n\t\t\t\topts.mobileHA = (opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread);\r\n\r\n\t\t\t\t/***********************\r\n\t\t\t\t Part II: Queueing\r\n\t\t\t\t ***********************/\r\n\r\n\t\t\t\t/* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.\r\n\t\t\t\t In this way, each element\'s existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */\r\n\t\t\t\t/* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,\r\n\t\t\t\t the call array is pushed to Velocity.State.calls for live processing by the requestAnimationFrame tick. */\r\n\t\t\t\tfunction buildQueue(next) {\r\n\t\t\t\t\tvar data, lastTweensContainer;\r\n\r\n\t\t\t\t\t/*******************\r\n\t\t\t\t\t Option: Begin\r\n\t\t\t\t\t *******************/\r\n\r\n\t\t\t\t\t/* The begin callback is fired once per call -- not once per elemenet -- and is passed the full raw DOM element set as both its context and its first argument. */\r\n\t\t\t\t\tif (opts.begin && elementsIndex === 0) {\r\n\t\t\t\t\t\t/* We throw callbacks in a setTimeout so that thrown errors don\'t halt the execution of Velocity itself. */\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\topts.begin.call(elements, elements);\r\n\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\tthrow error;\r\n\t\t\t\t\t\t\t}, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/*****************************************\r\n\t\t\t\t\t Tween Data Construction (for Scroll)\r\n\t\t\t\t\t *****************************************/\r\n\r\n\t\t\t\t\t/* Note: In order to be subjected to chaining and animation options, scroll\'s tweening is routed through Velocity as if it were a standard CSS property animation. */\r\n\t\t\t\t\tif (action === "scroll") {\r\n\t\t\t\t\t\t/* The scroll action uniquely takes an optional "offset" option -- specified in pixels -- that offsets the targeted scroll position. */\r\n\t\t\t\t\t\tvar scrollDirection = (/^x$/i.test(opts.axis) ? "Left" : "Top"),\r\n\t\t\t\t\t\t\t\tscrollOffset = parseFloat(opts.offset) || 0,\r\n\t\t\t\t\t\t\t\tscrollPositionCurrent,\r\n\t\t\t\t\t\t\t\tscrollPositionCurrentAlternate,\r\n\t\t\t\t\t\t\t\tscrollPositionEnd;\r\n\r\n\t\t\t\t\t\t/* Scroll also uniquely takes an optional "container" option, which indicates the parent element that should be scrolled --\r\n\t\t\t\t\t\t as opposed to the browser window itself. This is useful for scrolling toward an element that\'s inside an overflowing parent element. */\r\n\t\t\t\t\t\tif (opts.container) {\r\n\t\t\t\t\t\t\t/* Ensure that either a jQuery object or a raw DOM element was passed in. */\r\n\t\t\t\t\t\t\tif (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {\r\n\t\t\t\t\t\t\t\t/* Extract the raw DOM element from the jQuery wrapper. */\r\n\t\t\t\t\t\t\t\topts.container = opts.container[0] || opts.container;\r\n\t\t\t\t\t\t\t\t/* Note: Unlike other properties in Velocity, the browser\'s scroll position is never cached since it so frequently changes\r\n\t\t\t\t\t\t\t\t (due to the user\'s natural interaction with the page). */\r\n\t\t\t\t\t\t\t\tscrollPositionCurrent = opts.container["scroll" + scrollDirection]; /* GET */\r\n\r\n\t\t\t\t\t\t\t\t/* $.position() values are relative to the container\'s currently viewable area (without taking into account the container\'s true dimensions\r\n\t\t\t\t\t\t\t\t -- say, for example, if the container was not overflowing). Thus, the scroll end value is the sum of the child element\'s position *and*\r\n\t\t\t\t\t\t\t\t the scroll container\'s current scroll position. */\r\n\t\t\t\t\t\t\t\tscrollPositionEnd = (scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()]) + scrollOffset; /* GET */\r\n\t\t\t\t\t\t\t\t/* If a value other than a jQuery object or a raw DOM element was passed in, default to null so that this option is ignored. */\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\topts.container = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t/* If the window itself is being scrolled -- not a containing element -- perform a live scroll position lookup using\r\n\t\t\t\t\t\t\t the appropriate cached property names (which differ based on browser type). */\r\n\t\t\t\t\t\t\tscrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]]; /* GET */\r\n\t\t\t\t\t\t\t/* When scrolling the browser window, cache the alternate axis\'s current value since window.scrollTo() doesn\'t let us change only one value at a time. */\r\n\t\t\t\t\t\t\tscrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]]; /* GET */\r\n\r\n\t\t\t\t\t\t\t/* Unlike $.position(), $.offset() values are relative to the browser window\'s true dimensions -- not merely its currently viewable area --\r\n\t\t\t\t\t\t\t and therefore end values do not need to be compounded onto current values. */\r\n\t\t\t\t\t\t\tscrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset; /* GET */\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Since there\'s only one format that scroll\'s associated tweensContainer can take, we create it manually. */\r\n\t\t\t\t\t\ttweensContainer = {\r\n\t\t\t\t\t\t\tscroll: {\r\n\t\t\t\t\t\t\t\trootPropertyValue: false,\r\n\t\t\t\t\t\t\t\tstartValue: scrollPositionCurrent,\r\n\t\t\t\t\t\t\t\tcurrentValue: scrollPositionCurrent,\r\n\t\t\t\t\t\t\t\tendValue: scrollPositionEnd,\r\n\t\t\t\t\t\t\t\tunitType: "",\r\n\t\t\t\t\t\t\t\teasing: opts.easing,\r\n\t\t\t\t\t\t\t\tscrollData: {\r\n\t\t\t\t\t\t\t\t\tcontainer: opts.container,\r\n\t\t\t\t\t\t\t\t\tdirection: scrollDirection,\r\n\t\t\t\t\t\t\t\t\talternateValue: scrollPositionCurrentAlternate\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\tconsole.log("tweensContainer (scroll): ", tweensContainer.scroll, element);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/******************************************\r\n\t\t\t\t\t\t Tween Data Construction (for Reverse)\r\n\t\t\t\t\t\t ******************************************/\r\n\r\n\t\t\t\t\t\t/* Reverse acts like a "start" action in that a property map is animated toward. The only difference is\r\n\t\t\t\t\t\t that the property map used for reverse is the inverse of the map used in the previous call. Thus, we manipulate\r\n\t\t\t\t\t\t the previous call to construct our new map: use the previous map\'s end values as our new map\'s start values. Copy over all other data. */\r\n\t\t\t\t\t\t/* Note: Reverse can be directly called via the "reverse" parameter, or it can be indirectly triggered via the loop option. (Loops are composed of multiple reverses.) */\r\n\t\t\t\t\t\t/* Note: Reverse calls do not need to be consecutively chained onto a currently-animating element in order to operate on cached values;\r\n\t\t\t\t\t\t there is no harm to reverse being called on a potentially stale data cache since reverse\'s behavior is simply defined\r\n\t\t\t\t\t\t as reverting to the element\'s values as they were prior to the previous *Velocity* call. */\r\n\t\t\t\t\t} else if (action === "reverse") {\r\n\t\t\t\t\t\tdata = Data(element);\r\n\r\n\t\t\t\t\t\t/* Abort if there is no prior animation data to reverse to. */\r\n\t\t\t\t\t\tif (!data) {\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!data.tweensContainer) {\r\n\t\t\t\t\t\t\t/* Dequeue the element so that this queue entry releases itself immediately, allowing subsequent queue entries to run. */\r\n\t\t\t\t\t\t\t$.dequeue(element, opts.queue);\r\n\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t/*********************\r\n\t\t\t\t\t\t\t Options Parsing\r\n\t\t\t\t\t\t\t *********************/\r\n\r\n\t\t\t\t\t\t\t/* If the element was hidden via the display option in the previous call,\r\n\t\t\t\t\t\t\t revert display to "auto" prior to reversal so that the element is visible again. */\r\n\t\t\t\t\t\t\tif (data.opts.display === "none") {\r\n\t\t\t\t\t\t\t\tdata.opts.display = "auto";\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (data.opts.visibility === "hidden") {\r\n\t\t\t\t\t\t\t\tdata.opts.visibility = "visible";\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* If the loop option was set in the previous call, disable it so that "reverse" calls aren\'t recursively generated.\r\n\t\t\t\t\t\t\t Further, remove the previous call\'s callback options; typically, users do not want these to be refired. */\r\n\t\t\t\t\t\t\tdata.opts.loop = false;\r\n\t\t\t\t\t\t\tdata.opts.begin = null;\r\n\t\t\t\t\t\t\tdata.opts.complete = null;\r\n\r\n\t\t\t\t\t\t\t/* Since we\'re extending an opts object that has already been extended with the defaults options object,\r\n\t\t\t\t\t\t\t we remove non-explicitly-defined properties that are auto-assigned values. */\r\n\t\t\t\t\t\t\tif (!options.easing) {\r\n\t\t\t\t\t\t\t\tdelete opts.easing;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (!options.duration) {\r\n\t\t\t\t\t\t\t\tdelete opts.duration;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* The opts object used for reversal is an extension of the options object optionally passed into this\r\n\t\t\t\t\t\t\t reverse call plus the options used in the previous Velocity call. */\r\n\t\t\t\t\t\t\topts = $.extend({}, data.opts, opts);\r\n\r\n\t\t\t\t\t\t\t/*************************************\r\n\t\t\t\t\t\t\t Tweens Container Reconstruction\r\n\t\t\t\t\t\t\t *************************************/\r\n\r\n\t\t\t\t\t\t\t/* Create a deepy copy (indicated via the true flag) of the previous call\'s tweensContainer. */\r\n\t\t\t\t\t\t\tlastTweensContainer = $.extend(true, {}, data ? data.tweensContainer : null);\r\n\r\n\t\t\t\t\t\t\t/* Manipulate the previous tweensContainer by replacing its end values and currentValues with its start values. */\r\n\t\t\t\t\t\t\tfor (var lastTween in lastTweensContainer) {\r\n\t\t\t\t\t\t\t\t/* In addition to tween data, tweensContainers contain an element property that we ignore here. */\r\n\t\t\t\t\t\t\t\tif (lastTweensContainer.hasOwnProperty(lastTween) && lastTween !== "element") {\r\n\t\t\t\t\t\t\t\t\tvar lastStartValue = lastTweensContainer[lastTween].startValue;\r\n\r\n\t\t\t\t\t\t\t\t\tlastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;\r\n\t\t\t\t\t\t\t\t\tlastTweensContainer[lastTween].endValue = lastStartValue;\r\n\r\n\t\t\t\t\t\t\t\t\t/* Easing is the only option that embeds into the individual tween data (since it can be defined on a per-property basis).\r\n\t\t\t\t\t\t\t\t\t Accordingly, every property\'s easing value must be updated when an options object is passed in with a reverse call.\r\n\t\t\t\t\t\t\t\t\t The side effect of this extensibility is that all per-property easing values are forcefully reset to the new value. */\r\n\t\t\t\t\t\t\t\t\tif (!Type.isEmptyObject(options)) {\r\n\t\t\t\t\t\t\t\t\t\tlastTweensContainer[lastTween].easing = opts.easing;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\t\t\t\tconsole.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttweensContainer = lastTweensContainer;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/*****************************************\r\n\t\t\t\t\t\t Tween Data Construction (for Start)\r\n\t\t\t\t\t\t *****************************************/\r\n\r\n\t\t\t\t\t} else if (action === "start") {\r\n\r\n\t\t\t\t\t\t/*************************\r\n\t\t\t\t\t\t Value Transferring\r\n\t\t\t\t\t\t *************************/\r\n\r\n\t\t\t\t\t\t/* If this queue entry follows a previous Velocity-initiated queue entry *and* if this entry was created\r\n\t\t\t\t\t\t while the element was in the process of being animated by Velocity, then this current call is safe to use\r\n\t\t\t\t\t\t the end values from the prior call as its start values. Velocity attempts to perform this value transfer\r\n\t\t\t\t\t\t process whenever possible in order to avoid requerying the DOM. */\r\n\t\t\t\t\t\t/* If values aren\'t transferred from a prior call and start values were not forcefed by the user (more on this below),\r\n\t\t\t\t\t\t then the DOM is queried for the element\'s current values as a last resort. */\r\n\t\t\t\t\t\t/* Note: Conversely, animation reversal (and looping) *always* perform inter-call value transfers; they never requery the DOM. */\r\n\r\n\t\t\t\t\t\tdata = Data(element);\r\n\r\n\t\t\t\t\t\t/* The per-element isAnimating flag is used to indicate whether it\'s safe (i.e. the data isn\'t stale)\r\n\t\t\t\t\t\t to transfer over end values to use as start values. If it\'s set to true and there is a previous\r\n\t\t\t\t\t\t Velocity call to pull values from, do so. */\r\n\t\t\t\t\t\tif (data && data.tweensContainer && data.isAnimating === true) {\r\n\t\t\t\t\t\t\tlastTweensContainer = data.tweensContainer;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/***************************\r\n\t\t\t\t\t\t Tween Data Calculation\r\n\t\t\t\t\t\t ***************************/\r\n\r\n\t\t\t\t\t\t/* This function parses property data and defaults endValue, easing, and startValue as appropriate. */\r\n\t\t\t\t\t\t/* Property map values can either take the form of 1) a single value representing the end value,\r\n\t\t\t\t\t\t or 2) an array in the form of [ endValue, [, easing] [, startValue] ].\r\n\t\t\t\t\t\t The optional third parameter is a forcefed startValue to be used instead of querying the DOM for\r\n\t\t\t\t\t\t the element\'s current value. Read Velocity\'s docmentation to learn more about forcefeeding: VelocityJS.org/#forcefeeding */\r\n\t\t\t\t\t\tvar parsePropertyValue = function(valueData, skipResolvingEasing) {\r\n\t\t\t\t\t\t\tvar endValue, easing, startValue;\r\n\r\n\t\t\t\t\t\t\t/* If we have a function as the main argument then resolve it first, in case it returns an array that needs to be split */\r\n\t\t\t\t\t\t\tif (Type.isFunction(valueData)) {\r\n\t\t\t\t\t\t\t\tvalueData = valueData.call(element, elementArrayIndex, elementsLength);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Handle the array format, which can be structured as one of three potential overloads:\r\n\t\t\t\t\t\t\t A) [ endValue, easing, startValue ], B) [ endValue, easing ], or C) [ endValue, startValue ] */\r\n\t\t\t\t\t\t\tif (Type.isArray(valueData)) {\r\n\t\t\t\t\t\t\t\t/* endValue is always the first item in the array. Don\'t bother validating endValue\'s value now\r\n\t\t\t\t\t\t\t\t since the ensuing property cycling logic does that. */\r\n\t\t\t\t\t\t\t\tendValue = valueData[0];\r\n\r\n\t\t\t\t\t\t\t\t/* Two-item array format: If the second item is a number, function, or hex string, treat it as a\r\n\t\t\t\t\t\t\t\t start value since easings can only be non-hex strings or arrays. */\r\n\t\t\t\t\t\t\t\tif ((!Type.isArray(valueData[1]) && /^[\\d-]/.test(valueData[1])) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {\r\n\t\t\t\t\t\t\t\t\tstartValue = valueData[1];\r\n\t\t\t\t\t\t\t\t\t/* Two or three-item array: If the second item is a non-hex string easing name or an array, treat it as an easing. */\r\n\t\t\t\t\t\t\t\t} else if ((Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1]) && Velocity.Easings[valueData[1]]) || Type.isArray(valueData[1])) {\r\n\t\t\t\t\t\t\t\t\teasing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);\r\n\r\n\t\t\t\t\t\t\t\t\t/* Don\'t bother validating startValue\'s value now since the ensuing property cycling logic inherently does that. */\r\n\t\t\t\t\t\t\t\t\tstartValue = valueData[2];\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tstartValue = valueData[1] || valueData[2];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t/* Handle the single-value format. */\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tendValue = valueData;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Default to the call\'s easing if a per-property easing type was not defined. */\r\n\t\t\t\t\t\t\tif (!skipResolvingEasing) {\r\n\t\t\t\t\t\t\t\teasing = easing || opts.easing;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* If functions were passed in as values, pass the function the current element as its context,\r\n\t\t\t\t\t\t\t plus the element\'s index and the element set\'s size as arguments. Then, assign the returned value. */\r\n\t\t\t\t\t\t\tif (Type.isFunction(endValue)) {\r\n\t\t\t\t\t\t\t\tendValue = endValue.call(element, elementArrayIndex, elementsLength);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (Type.isFunction(startValue)) {\r\n\t\t\t\t\t\t\t\tstartValue = startValue.call(element, elementArrayIndex, elementsLength);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Allow startValue to be left as undefined to indicate to the ensuing code that its value was not forcefed. */\r\n\t\t\t\t\t\t\treturn [endValue || 0, easing, startValue];\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tvar fixPropertyValue = function(property, valueData) {\r\n\t\t\t\t\t\t\t/* In case this property is a hook, there are circumstances where we will intend to work on the hook\'s root property and not the hooked subproperty. */\r\n\t\t\t\t\t\t\tvar rootProperty = CSS.Hooks.getRoot(property),\r\n\t\t\t\t\t\t\t\t\trootPropertyValue = false,\r\n\t\t\t\t\t\t\t\t\t/* Parse out endValue, easing, and startValue from the property\'s data. */\r\n\t\t\t\t\t\t\t\t\tendValue = valueData[0],\r\n\t\t\t\t\t\t\t\t\teasing = valueData[1],\r\n\t\t\t\t\t\t\t\t\tstartValue = valueData[2],\r\n\t\t\t\t\t\t\t\t\tpattern;\r\n\r\n\t\t\t\t\t\t\t/**************************\r\n\t\t\t\t\t\t\t Start Value Sourcing\r\n\t\t\t\t\t\t\t **************************/\r\n\r\n\t\t\t\t\t\t\t/* Other than for the dummy tween property, properties that are not supported by the browser (and do not have an associated normalization) will\r\n\t\t\t\t\t\t\t inherently produce no style changes when set, so they are skipped in order to decrease animation tick overhead.\r\n\t\t\t\t\t\t\t Property support is determined via prefixCheck(), which returns a false flag when no supported is detected. */\r\n\t\t\t\t\t\t\t/* Note: Since SVG elements have some of their properties directly applied as HTML attributes,\r\n\t\t\t\t\t\t\t there is no way to check for their explicit browser support, and so we skip skip this check for them. */\r\n\t\t\t\t\t\t\tif ((!data || !data.isSVG) && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {\r\n\t\t\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\t\t\tconsole.log("Skipping [" + rootProperty + "] due to a lack of browser support.");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* If the display option is being set to a non-"none" (e.g. "block") and opacity (filter on IE<=8) is being\r\n\t\t\t\t\t\t\t animated to an endValue of non-zero, the user\'s intention is to fade in from invisible, thus we forcefeed opacity\r\n\t\t\t\t\t\t\t a startValue of 0 if its startValue hasn\'t already been sourced by value transferring or prior forcefeeding. */\r\n\t\t\t\t\t\t\tif (((opts.display !== undefined && opts.display !== null && opts.display !== "none") || (opts.visibility !== undefined && opts.visibility !== "hidden")) && /opacity|filter/.test(property) && !startValue && endValue !== 0) {\r\n\t\t\t\t\t\t\t\tstartValue = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* If values have been transferred from the previous Velocity call, extract the endValue and rootPropertyValue\r\n\t\t\t\t\t\t\t for all of the current call\'s properties that were *also* animated in the previous call. */\r\n\t\t\t\t\t\t\t/* Note: Value transferring can optionally be disabled by the user via the _cacheValues option. */\r\n\t\t\t\t\t\t\tif (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {\r\n\t\t\t\t\t\t\t\tif (startValue === undefined) {\r\n\t\t\t\t\t\t\t\t\tstartValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/* The previous call\'s rootPropertyValue is extracted from the element\'s data cache since that\'s the\r\n\t\t\t\t\t\t\t\t instance of rootPropertyValue that gets freshly updated by the tweening process, whereas the rootPropertyValue\r\n\t\t\t\t\t\t\t\t attached to the incoming lastTweensContainer is equal to the root property\'s value prior to any tweening. */\r\n\t\t\t\t\t\t\t\trootPropertyValue = data.rootPropertyValueCache[rootProperty];\r\n\t\t\t\t\t\t\t\t/* If values were not transferred from a previous Velocity call, query the DOM as needed. */\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t/* Handle hooked properties. */\r\n\t\t\t\t\t\t\t\tif (CSS.Hooks.registered[property]) {\r\n\t\t\t\t\t\t\t\t\tif (startValue === undefined) {\r\n\t\t\t\t\t\t\t\t\t\trootPropertyValue = CSS.getPropertyValue(element, rootProperty); /* GET */\r\n\t\t\t\t\t\t\t\t\t\t/* Note: The following getPropertyValue() call does not actually trigger a DOM query;\r\n\t\t\t\t\t\t\t\t\t\t getPropertyValue() will extract the hook from rootPropertyValue. */\r\n\t\t\t\t\t\t\t\t\t\tstartValue = CSS.getPropertyValue(element, property, rootPropertyValue);\r\n\t\t\t\t\t\t\t\t\t\t/* If startValue is already defined via forcefeeding, do not query the DOM for the root property\'s value;\r\n\t\t\t\t\t\t\t\t\t\t just grab rootProperty\'s zero-value template from CSS.Hooks. This overwrites the element\'s actual\r\n\t\t\t\t\t\t\t\t\t\t root property value (if one is set), but this is acceptable since the primary reason users forcefeed is\r\n\t\t\t\t\t\t\t\t\t\t to avoid DOM queries, and thus we likewise avoid querying the DOM for the root property\'s value. */\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t/* Grab this hook\'s zero-value template, e.g. "0px 0px 0px black". */\r\n\t\t\t\t\t\t\t\t\t\trootPropertyValue = CSS.Hooks.templates[rootProperty][1];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t/* Handle non-hooked properties that haven\'t already been defined via forcefeeding. */\r\n\t\t\t\t\t\t\t\t} else if (startValue === undefined) {\r\n\t\t\t\t\t\t\t\t\tstartValue = CSS.getPropertyValue(element, property); /* GET */\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/**************************\r\n\t\t\t\t\t\t\t Value Data Extraction\r\n\t\t\t\t\t\t\t **************************/\r\n\r\n\t\t\t\t\t\t\tvar separatedValue,\r\n\t\t\t\t\t\t\t\t\tendValueUnitType,\r\n\t\t\t\t\t\t\t\t\tstartValueUnitType,\r\n\t\t\t\t\t\t\t\t\toperator = false;\r\n\r\n\t\t\t\t\t\t\t/* Separates a property value into its numeric value and its unit type. */\r\n\t\t\t\t\t\t\tvar separateValue = function(property, value) {\r\n\t\t\t\t\t\t\t\tvar unitType,\r\n\t\t\t\t\t\t\t\t\t\tnumericValue;\r\n\r\n\t\t\t\t\t\t\t\tnumericValue = (value || "0")\r\n\t\t\t\t\t\t\t\t\t\t.toString()\r\n\t\t\t\t\t\t\t\t\t\t.toLowerCase()\r\n\t\t\t\t\t\t\t\t\t\t/* Match the unit type at the end of the value. */\r\n\t\t\t\t\t\t\t\t\t\t.replace(/[%A-z]+$/, function(match) {\r\n\t\t\t\t\t\t\t\t\t\t\t/* Grab the unit type. */\r\n\t\t\t\t\t\t\t\t\t\t\tunitType = match;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t/* Strip the unit type off of value. */\r\n\t\t\t\t\t\t\t\t\t\t\treturn "";\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\t/* If no unit type was supplied, assign one that is appropriate for this property (e.g. "deg" for rotateZ or "px" for width). */\r\n\t\t\t\t\t\t\t\tif (!unitType) {\r\n\t\t\t\t\t\t\t\t\tunitType = CSS.Values.getUnitType(property);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treturn [numericValue, unitType];\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\tif (startValue !== endValue && Type.isString(startValue) && Type.isString(endValue)) {\r\n\t\t\t\t\t\t\t\tpattern = "";\r\n\t\t\t\t\t\t\t\tvar iStart = 0, // index in startValue\r\n\t\t\t\t\t\t\t\t\t\tiEnd = 0, // index in endValue\r\n\t\t\t\t\t\t\t\t\t\taStart = [], // array of startValue numbers\r\n\t\t\t\t\t\t\t\t\t\taEnd = [], // array of endValue numbers\r\n\t\t\t\t\t\t\t\t\t\tinCalc = 0, // Keep track of being inside a "calc()" so we don\'t duplicate it\r\n\t\t\t\t\t\t\t\t\t\tinRGB = 0, // Keep track of being inside an RGB as we can\'t use fractional values\r\n\t\t\t\t\t\t\t\t\t\tinRGBA = 0; // Keep track of being inside an RGBA as we must pass fractional for the alpha channel\r\n\r\n\t\t\t\t\t\t\t\tstartValue = CSS.Hooks.fixColors(startValue);\r\n\t\t\t\t\t\t\t\tendValue = CSS.Hooks.fixColors(endValue);\r\n\t\t\t\t\t\t\t\twhile (iStart < startValue.length && iEnd < endValue.length) {\r\n\t\t\t\t\t\t\t\t\tvar cStart = startValue[iStart],\r\n\t\t\t\t\t\t\t\t\t\t\tcEnd = endValue[iEnd];\r\n\r\n\t\t\t\t\t\t\t\t\tif (/[\\d\\.-]/.test(cStart) && /[\\d\\.-]/.test(cEnd)) {\r\n\t\t\t\t\t\t\t\t\t\tvar tStart = cStart, // temporary character buffer\r\n\t\t\t\t\t\t\t\t\t\t\t\ttEnd = cEnd, // temporary character buffer\r\n\t\t\t\t\t\t\t\t\t\t\t\tdotStart = ".", // Make sure we can only ever match a single dot in a decimal\r\n\t\t\t\t\t\t\t\t\t\t\t\tdotEnd = "."; // Make sure we can only ever match a single dot in a decimal\r\n\r\n\t\t\t\t\t\t\t\t\t\twhile (++iStart < startValue.length) {\r\n\t\t\t\t\t\t\t\t\t\t\tcStart = startValue[iStart];\r\n\t\t\t\t\t\t\t\t\t\t\tif (cStart === dotStart) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdotStart = ".."; // Can never match two characters\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (!/\\d/.test(cStart)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\ttStart += cStart;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\twhile (++iEnd < endValue.length) {\r\n\t\t\t\t\t\t\t\t\t\t\tcEnd = endValue[iEnd];\r\n\t\t\t\t\t\t\t\t\t\t\tif (cEnd === dotEnd) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdotEnd = ".."; // Can never match two characters\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (!/\\d/.test(cEnd)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\ttEnd += cEnd;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tvar uStart = CSS.Hooks.getUnit(startValue, iStart), // temporary unit type\r\n\t\t\t\t\t\t\t\t\t\t\t\tuEnd = CSS.Hooks.getUnit(endValue, iEnd); // temporary unit type\r\n\r\n\t\t\t\t\t\t\t\t\t\tiStart += uStart.length;\r\n\t\t\t\t\t\t\t\t\t\tiEnd += uEnd.length;\r\n\t\t\t\t\t\t\t\t\t\tif (uStart === uEnd) {\r\n\t\t\t\t\t\t\t\t\t\t\t// Same units\r\n\t\t\t\t\t\t\t\t\t\t\tif (tStart === tEnd) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Same numbers, so just copy over\r\n\t\t\t\t\t\t\t\t\t\t\t\tpattern += tStart + uStart;\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Different numbers, so store them\r\n\t\t\t\t\t\t\t\t\t\t\t\tpattern += "{" + aStart.length + (inRGB ? "!" : "") + "}" + uStart;\r\n\t\t\t\t\t\t\t\t\t\t\t\taStart.push(parseFloat(tStart));\r\n\t\t\t\t\t\t\t\t\t\t\t\taEnd.push(parseFloat(tEnd));\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t// Different units, so put into a "calc(from + to)" and animate each side to/from zero\r\n\t\t\t\t\t\t\t\t\t\t\tvar nStart = parseFloat(tStart),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnEnd = parseFloat(tEnd);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tpattern += (inCalc < 5 ? "calc" : "") + "("\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (nStart ? "{" + aStart.length + (inRGB ? "!" : "") + "}" : "0") + uStart\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ " + "\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (nEnd ? "{" + (aStart.length + (nStart ? 1 : 0)) + (inRGB ? "!" : "") + "}" : "0") + uEnd\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ ")";\r\n\t\t\t\t\t\t\t\t\t\t\tif (nStart) {\r\n\t\t\t\t\t\t\t\t\t\t\t\taStart.push(nStart);\r\n\t\t\t\t\t\t\t\t\t\t\t\taEnd.push(0);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif (nEnd) {\r\n\t\t\t\t\t\t\t\t\t\t\t\taStart.push(0);\r\n\t\t\t\t\t\t\t\t\t\t\t\taEnd.push(nEnd);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else if (cStart === cEnd) {\r\n\t\t\t\t\t\t\t\t\t\tpattern += cStart;\r\n\t\t\t\t\t\t\t\t\t\tiStart++;\r\n\t\t\t\t\t\t\t\t\t\tiEnd++;\r\n\t\t\t\t\t\t\t\t\t\t// Keep track of being inside a calc()\r\n\t\t\t\t\t\t\t\t\t\tif (inCalc === 0 && cStart === "c"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inCalc === 1 && cStart === "a"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inCalc === 2 && cStart === "l"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inCalc === 3 && cStart === "c"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inCalc >= 4 && cStart === "("\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tinCalc++;\r\n\t\t\t\t\t\t\t\t\t\t} else if ((inCalc && inCalc < 5)\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inCalc >= 4 && cStart === ")" && --inCalc < 5) {\r\n\t\t\t\t\t\t\t\t\t\t\tinCalc = 0;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t// Keep track of being inside an rgb() / rgba()\r\n\t\t\t\t\t\t\t\t\t\tif (inRGB === 0 && cStart === "r"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inRGB === 1 && cStart === "g"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inRGB === 2 && cStart === "b"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inRGB === 3 && cStart === "a"\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inRGB >= 3 && cStart === "("\r\n\t\t\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (inRGB === 3 && cStart === "a") {\r\n\t\t\t\t\t\t\t\t\t\t\t\tinRGBA = 1;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tinRGB++;\r\n\t\t\t\t\t\t\t\t\t\t} else if (inRGBA && cStart === ",") {\r\n\t\t\t\t\t\t\t\t\t\t\tif (++inRGBA > 3) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tinRGB = inRGBA = 0;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else if ((inRGBA && inRGB < (inRGBA ? 5 : 4))\r\n\t\t\t\t\t\t\t\t\t\t\t\t|| inRGB >= (inRGBA ? 4 : 3) && cStart === ")" && --inRGB < (inRGBA ? 5 : 4)) {\r\n\t\t\t\t\t\t\t\t\t\t\tinRGB = inRGBA = 0;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tinCalc = 0;\r\n\t\t\t\t\t\t\t\t\t\t// TODO: changing units, fixing colours\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (iStart !== startValue.length || iEnd !== endValue.length) {\r\n\t\t\t\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\t\t\t\tconsole.error("Trying to pattern match mis-matched strings [\\"" + endValue + "\\", \\"" + startValue + "\\"]");\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tpattern = undefined;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (pattern) {\r\n\t\t\t\t\t\t\t\t\tif (aStart.length) {\r\n\t\t\t\t\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\t\t\t\t\tconsole.log("Pattern found \\"" + pattern + "\\" -> ", aStart, aEnd, "[" + startValue + "," + endValue + "]");\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tstartValue = aStart;\r\n\t\t\t\t\t\t\t\t\t\tendValue = aEnd;\r\n\t\t\t\t\t\t\t\t\t\tendValueUnitType = startValueUnitType = "";\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tpattern = undefined;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (!pattern) {\r\n\t\t\t\t\t\t\t\t/* Separate startValue. */\r\n\t\t\t\t\t\t\t\tseparatedValue = separateValue(property, startValue);\r\n\t\t\t\t\t\t\t\tstartValue = separatedValue[0];\r\n\t\t\t\t\t\t\t\tstartValueUnitType = separatedValue[1];\r\n\r\n\t\t\t\t\t\t\t\t/* Separate endValue, and extract a value operator (e.g. "+=", "-=") if one exists. */\r\n\t\t\t\t\t\t\t\tseparatedValue = separateValue(property, endValue);\r\n\t\t\t\t\t\t\t\tendValue = separatedValue[0].replace(/^([+-\\/*])=/, function(match, subMatch) {\r\n\t\t\t\t\t\t\t\t\toperator = subMatch;\r\n\r\n\t\t\t\t\t\t\t\t\t/* Strip the operator off of the value. */\r\n\t\t\t\t\t\t\t\t\treturn "";\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\tendValueUnitType = separatedValue[1];\r\n\r\n\t\t\t\t\t\t\t\t/* Parse float values from endValue and startValue. Default to 0 if NaN is returned. */\r\n\t\t\t\t\t\t\t\tstartValue = parseFloat(startValue) || 0;\r\n\t\t\t\t\t\t\t\tendValue = parseFloat(endValue) || 0;\r\n\r\n\t\t\t\t\t\t\t\t/***************************************\r\n\t\t\t\t\t\t\t\t Property-Specific Value Conversion\r\n\t\t\t\t\t\t\t\t ***************************************/\r\n\r\n\t\t\t\t\t\t\t\t/* Custom support for properties that don\'t actually accept the % unit type, but where pollyfilling is trivial and relatively foolproof. */\r\n\t\t\t\t\t\t\t\tif (endValueUnitType === "%") {\r\n\t\t\t\t\t\t\t\t\t/* A %-value fontSize/lineHeight is relative to the parent\'s fontSize (as opposed to the parent\'s dimensions),\r\n\t\t\t\t\t\t\t\t\t which is identical to the em unit\'s behavior, so we piggyback off of that. */\r\n\t\t\t\t\t\t\t\t\tif (/^(fontSize|lineHeight)$/.test(property)) {\r\n\t\t\t\t\t\t\t\t\t\t/* Convert % into an em decimal value. */\r\n\t\t\t\t\t\t\t\t\t\tendValue = endValue / 100;\r\n\t\t\t\t\t\t\t\t\t\tendValueUnitType = "em";\r\n\t\t\t\t\t\t\t\t\t\t/* For scaleX and scaleY, convert the value into its decimal format and strip off the unit type. */\r\n\t\t\t\t\t\t\t\t\t} else if (/^scale/.test(property)) {\r\n\t\t\t\t\t\t\t\t\t\tendValue = endValue / 100;\r\n\t\t\t\t\t\t\t\t\t\tendValueUnitType = "";\r\n\t\t\t\t\t\t\t\t\t\t/* For RGB components, take the defined percentage of 255 and strip off the unit type. */\r\n\t\t\t\t\t\t\t\t\t} else if (/(Red|Green|Blue)$/i.test(property)) {\r\n\t\t\t\t\t\t\t\t\t\tendValue = (endValue / 100) * 255;\r\n\t\t\t\t\t\t\t\t\t\tendValueUnitType = "";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/***************************\r\n\t\t\t\t\t\t\t Unit Ratio Calculation\r\n\t\t\t\t\t\t\t ***************************/\r\n\r\n\t\t\t\t\t\t\t/* When queried, the browser returns (most) CSS property values in pixels. Therefore, if an endValue with a unit type of\r\n\t\t\t\t\t\t\t %, em, or rem is animated toward, startValue must be converted from pixels into the same unit type as endValue in order\r\n\t\t\t\t\t\t\t for value manipulation logic (increment/decrement) to proceed. Further, if the startValue was forcefed or transferred\r\n\t\t\t\t\t\t\t from a previous call, startValue may also not be in pixels. Unit conversion logic therefore consists of two steps:\r\n\t\t\t\t\t\t\t 1) Calculating the ratio of %/em/rem/vh/vw relative to pixels\r\n\t\t\t\t\t\t\t 2) Converting startValue into the same unit of measurement as endValue based on these ratios. */\r\n\t\t\t\t\t\t\t/* Unit conversion ratios are calculated by inserting a sibling node next to the target node, copying over its position property,\r\n\t\t\t\t\t\t\t setting values with the target unit type then comparing the returned pixel value. */\r\n\t\t\t\t\t\t\t/* Note: Even if only one of these unit types is being animated, all unit ratios are calculated at once since the overhead\r\n\t\t\t\t\t\t\t of batching the SETs and GETs together upfront outweights the potential overhead\r\n\t\t\t\t\t\t\t of layout thrashing caused by re-querying for uncalculated ratios for subsequently-processed properties. */\r\n\t\t\t\t\t\t\t/* Todo: Shift this logic into the calls\' first tick instance so that it\'s synced with RAF. */\r\n\t\t\t\t\t\t\tvar calculateUnitRatios = function() {\r\n\r\n\t\t\t\t\t\t\t\t/************************\r\n\t\t\t\t\t\t\t\t Same Ratio Checks\r\n\t\t\t\t\t\t\t\t ************************/\r\n\r\n\t\t\t\t\t\t\t\t/* The properties below are used to determine whether the element differs sufficiently from this call\'s\r\n\t\t\t\t\t\t\t\t previously iterated element to also differ in its unit conversion ratios. If the properties match up with those\r\n\t\t\t\t\t\t\t\t of the prior element, the prior element\'s conversion ratios are used. Like most optimizations in Velocity,\r\n\t\t\t\t\t\t\t\t this is done to minimize DOM querying. */\r\n\t\t\t\t\t\t\t\tvar sameRatioIndicators = {\r\n\t\t\t\t\t\t\t\t\tmyParent: element.parentNode || document.body, /* GET */\r\n\t\t\t\t\t\t\t\t\tposition: CSS.getPropertyValue(element, "position"), /* GET */\r\n\t\t\t\t\t\t\t\t\tfontSize: CSS.getPropertyValue(element, "fontSize") /* GET */\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\t\t/* Determine if the same % ratio can be used. % is based on the element\'s position value and its parent\'s width and height dimensions. */\r\n\t\t\t\t\t\t\t\t\t\tsamePercentRatio = ((sameRatioIndicators.position === callUnitConversionData.lastPosition) && (sameRatioIndicators.myParent === callUnitConversionData.lastParent)),\r\n\t\t\t\t\t\t\t\t\t\t/* Determine if the same em ratio can be used. em is relative to the element\'s fontSize. */\r\n\t\t\t\t\t\t\t\t\t\tsameEmRatio = (sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize);\r\n\r\n\t\t\t\t\t\t\t\t/* Store these ratio indicators call-wide for the next element to compare against. */\r\n\t\t\t\t\t\t\t\tcallUnitConversionData.lastParent = sameRatioIndicators.myParent;\r\n\t\t\t\t\t\t\t\tcallUnitConversionData.lastPosition = sameRatioIndicators.position;\r\n\t\t\t\t\t\t\t\tcallUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;\r\n\r\n\t\t\t\t\t\t\t\t/***************************\r\n\t\t\t\t\t\t\t\t Element-Specific Units\r\n\t\t\t\t\t\t\t\t ***************************/\r\n\r\n\t\t\t\t\t\t\t\t/* Note: IE8 rounds to the nearest pixel when returning CSS values, thus we perform conversions using a measurement\r\n\t\t\t\t\t\t\t\t of 100 (instead of 1) to give our ratios a precision of at least 2 decimal values. */\r\n\t\t\t\t\t\t\t\tvar measurement = 100,\r\n\t\t\t\t\t\t\t\t\t\tunitRatios = {};\r\n\r\n\t\t\t\t\t\t\t\tif (!sameEmRatio || !samePercentRatio) {\r\n\t\t\t\t\t\t\t\t\tvar dummy = data && data.isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");\r\n\r\n\t\t\t\t\t\t\t\t\tVelocity.init(dummy);\r\n\t\t\t\t\t\t\t\t\tsameRatioIndicators.myParent.appendChild(dummy);\r\n\r\n\t\t\t\t\t\t\t\t\t/* To accurately and consistently calculate conversion ratios, the element\'s cascaded overflow and box-sizing are stripped.\r\n\t\t\t\t\t\t\t\t\t Similarly, since width/height can be artificially constrained by their min-/max- equivalents, these are controlled for as well. */\r\n\t\t\t\t\t\t\t\t\t/* Note: Overflow must be also be controlled for per-axis since the overflow property overwrites its per-axis values. */\r\n\t\t\t\t\t\t\t\t\t$.each(["overflow", "overflowX", "overflowY"], function(i, property) {\r\n\t\t\t\t\t\t\t\t\t\tVelocity.CSS.setPropertyValue(dummy, property, "hidden");\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\tVelocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);\r\n\t\t\t\t\t\t\t\t\tVelocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);\r\n\t\t\t\t\t\t\t\t\tVelocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");\r\n\r\n\t\t\t\t\t\t\t\t\t/* width and height act as our proxy properties for measuring the horizontal and vertical % ratios. */\r\n\t\t\t\t\t\t\t\t\t$.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(i, property) {\r\n\t\t\t\t\t\t\t\t\t\tVelocity.CSS.setPropertyValue(dummy, property, measurement + "%");\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t/* paddingLeft arbitrarily acts as our proxy property for the em ratio. */\r\n\t\t\t\t\t\t\t\t\tVelocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");\r\n\r\n\t\t\t\t\t\t\t\t\t/* Divide the returned value by the measurement to get the ratio between 1% and 1px. Default to 1 since working with 0 can produce Infinite. */\r\n\t\t\t\t\t\t\t\t\tunitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement; /* GET */\r\n\t\t\t\t\t\t\t\t\tunitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement; /* GET */\r\n\t\t\t\t\t\t\t\t\tunitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement; /* GET */\r\n\r\n\t\t\t\t\t\t\t\t\tsameRatioIndicators.myParent.removeChild(dummy);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tunitRatios.emToPx = callUnitConversionData.lastEmToPx;\r\n\t\t\t\t\t\t\t\t\tunitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;\r\n\t\t\t\t\t\t\t\t\tunitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/***************************\r\n\t\t\t\t\t\t\t\t Element-Agnostic Units\r\n\t\t\t\t\t\t\t\t ***************************/\r\n\r\n\t\t\t\t\t\t\t\t/* Whereas % and em ratios are determined on a per-element basis, the rem unit only needs to be checked\r\n\t\t\t\t\t\t\t\t once per call since it\'s exclusively dependant upon document.body\'s fontSize. If this is the first time\r\n\t\t\t\t\t\t\t\t that calculateUnitRatios() is being run during this call, remToPx will still be set to its default value of null,\r\n\t\t\t\t\t\t\t\t so we calculate it now. */\r\n\t\t\t\t\t\t\t\tif (callUnitConversionData.remToPx === null) {\r\n\t\t\t\t\t\t\t\t\t/* Default to browsers\' default fontSize of 16px in the case of 0. */\r\n\t\t\t\t\t\t\t\t\tcallUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16; /* GET */\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t/* Similarly, viewport units are %-relative to the window\'s inner dimensions. */\r\n\t\t\t\t\t\t\t\tif (callUnitConversionData.vwToPx === null) {\r\n\t\t\t\t\t\t\t\t\tcallUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100; /* GET */\r\n\t\t\t\t\t\t\t\t\tcallUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100; /* GET */\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tunitRatios.remToPx = callUnitConversionData.remToPx;\r\n\t\t\t\t\t\t\t\tunitRatios.vwToPx = callUnitConversionData.vwToPx;\r\n\t\t\t\t\t\t\t\tunitRatios.vhToPx = callUnitConversionData.vhToPx;\r\n\r\n\t\t\t\t\t\t\t\tif (Velocity.debug >= 1) {\r\n\t\t\t\t\t\t\t\t\tconsole.log("Unit ratios: " + JSON.stringify(unitRatios), element);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn unitRatios;\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t/********************\r\n\t\t\t\t\t\t\t Unit Conversion\r\n\t\t\t\t\t\t\t ********************/\r\n\r\n\t\t\t\t\t\t\t/* The * and / operators, which are not passed in with an associated unit, inherently use startValue\'s unit. Skip value and unit conversion. */\r\n\t\t\t\t\t\t\tif (/[\\/*]/.test(operator)) {\r\n\t\t\t\t\t\t\t\tendValueUnitType = startValueUnitType;\r\n\t\t\t\t\t\t\t\t/* If startValue and endValue differ in unit type, convert startValue into the same unit type as endValue so that if endValueUnitType\r\n\t\t\t\t\t\t\t\t is a relative unit (%, em, rem), the values set during tweening will continue to be accurately relative even if the metrics they depend\r\n\t\t\t\t\t\t\t\t on are dynamically changing during the course of the animation. Conversely, if we always normalized into px and used px for setting values, the px ratio\r\n\t\t\t\t\t\t\t\t would become stale if the original unit being animated toward was relative and the underlying metrics change during the animation. */\r\n\t\t\t\t\t\t\t\t/* Since 0 is 0 in any unit type, no conversion is necessary when startValue is 0 -- we just start at 0 with endValueUnitType. */\r\n\t\t\t\t\t\t\t} else if ((startValueUnitType !== endValueUnitType) && startValue !== 0) {\r\n\t\t\t\t\t\t\t\t/* Unit conversion is also skipped when endValue is 0, but *startValueUnitType* must be used for tween values to remain accurate. */\r\n\t\t\t\t\t\t\t\t/* Note: Skipping unit conversion here means that if endValueUnitType was originally a relative unit, the animation won\'t relatively\r\n\t\t\t\t\t\t\t\t match the underlying metrics if they change, but this is acceptable since we\'re animating toward invisibility instead of toward visibility,\r\n\t\t\t\t\t\t\t\t which remains past the point of the animation\'s completion. */\r\n\t\t\t\t\t\t\t\tif (endValue === 0) {\r\n\t\t\t\t\t\t\t\t\tendValueUnitType = startValueUnitType;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t/* By this point, we cannot avoid unit conversion (it\'s undesirable since it causes layout thrashing).\r\n\t\t\t\t\t\t\t\t\t If we haven\'t already, we trigger calculateUnitRatios(), which runs once per element per call. */\r\n\t\t\t\t\t\t\t\t\telementUnitConversionData = elementUnitConversionData || calculateUnitRatios();\r\n\r\n\t\t\t\t\t\t\t\t\t/* The following RegEx matches CSS properties that have their % values measured relative to the x-axis. */\r\n\t\t\t\t\t\t\t\t\t/* Note: W3C spec mandates that all of margin and padding\'s properties (even top and bottom) are %-relative to the *width* of the parent element. */\r\n\t\t\t\t\t\t\t\t\tvar axis = (/margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x") ? "x" : "y";\r\n\r\n\t\t\t\t\t\t\t\t\t/* In order to avoid generating n^2 bespoke conversion functions, unit conversion is a two-step process:\r\n\t\t\t\t\t\t\t\t\t 1) Convert startValue into pixels. 2) Convert this new pixel value into endValue\'s unit type. */\r\n\t\t\t\t\t\t\t\t\tswitch (startValueUnitType) {\r\n\t\t\t\t\t\t\t\t\t\tcase "%":\r\n\t\t\t\t\t\t\t\t\t\t\t/* Note: translateX and translateY are the only properties that are %-relative to an element\'s own dimensions -- not its parent\'s dimensions.\r\n\t\t\t\t\t\t\t\t\t\t\t Velocity does not include a special conversion process to account for this behavior. Therefore, animating translateX/Y from a % value\r\n\t\t\t\t\t\t\t\t\t\t\t to a non-% value will produce an incorrect start value. Fortunately, this sort of cross-unit conversion is rarely done by users in practice. */\r\n\t\t\t\t\t\t\t\t\t\t\tstartValue *= (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase "px":\r\n\t\t\t\t\t\t\t\t\t\t\t/* px acts as our midpoint in the unit conversion process; do nothing. */\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\t\tstartValue *= elementUnitConversionData[startValueUnitType + "ToPx"];\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t/* Invert the px ratios to convert into to the target unit. */\r\n\t\t\t\t\t\t\t\t\tswitch (endValueUnitType) {\r\n\t\t\t\t\t\t\t\t\t\tcase "%":\r\n\t\t\t\t\t\t\t\t\t\t\tstartValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase "px":\r\n\t\t\t\t\t\t\t\t\t\t\t/* startValue is already in px, do nothing; we\'re done. */\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t\t\tstartValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/*********************\r\n\t\t\t\t\t\t\t Relative Values\r\n\t\t\t\t\t\t\t *********************/\r\n\r\n\t\t\t\t\t\t\t/* Operator logic must be performed last since it requires unit-normalized start and end values. */\r\n\t\t\t\t\t\t\t/* Note: Relative *percent values* do not behave how most people think; while one would expect "+=50%"\r\n\t\t\t\t\t\t\t to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:\r\n\t\t\t\t\t\t\t 50 points is added on top of the current % value. */\r\n\t\t\t\t\t\t\tswitch (operator) {\r\n\t\t\t\t\t\t\t\tcase "+":\r\n\t\t\t\t\t\t\t\t\tendValue = startValue + endValue;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase "-":\r\n\t\t\t\t\t\t\t\t\tendValue = startValue - endValue;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase "*":\r\n\t\t\t\t\t\t\t\t\tendValue = startValue * endValue;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tcase "/":\r\n\t\t\t\t\t\t\t\t\tendValue = startValue / endValue;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/**************************\r\n\t\t\t\t\t\t\t tweensContainer Push\r\n\t\t\t\t\t\t\t **************************/\r\n\r\n\t\t\t\t\t\t\t/* Construct the per-property tween object, and push it to the element\'s tweensContainer. */\r\n\t\t\t\t\t\t\ttweensContainer[property] = {\r\n\t\t\t\t\t\t\t\trootPropertyValue: rootPropertyValue,\r\n\t\t\t\t\t\t\t\tstartValue: startValue,\r\n\t\t\t\t\t\t\t\tcurrentValue: startValue,\r\n\t\t\t\t\t\t\t\tendValue: endValue,\r\n\t\t\t\t\t\t\t\tunitType: endValueUnitType,\r\n\t\t\t\t\t\t\t\teasing: easing\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tif (pattern) {\r\n\t\t\t\t\t\t\t\ttweensContainer[property].pattern = pattern;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (Velocity.debug) {\r\n\t\t\t\t\t\t\t\tconsole.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t/* Create a tween out of each property, and append its associated data to tweensContainer. */\r\n\t\t\t\t\t\tfor (var property in propertiesMap) {\r\n\r\n\t\t\t\t\t\t\tif (!propertiesMap.hasOwnProperty(property)) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t/* The original property name\'s format must be used for the parsePropertyValue() lookup,\r\n\t\t\t\t\t\t\t but we then use its camelCase styling to normalize it for manipulation. */\r\n\t\t\t\t\t\t\tvar propertyName = CSS.Names.camelCase(property),\r\n\t\t\t\t\t\t\t\t\tvalueData = parsePropertyValue(propertiesMap[property]);\r\n\r\n\t\t\t\t\t\t\t/* Find shorthand color properties that have been passed a hex string. */\r\n\t\t\t\t\t\t\t/* Would be quicker to use CSS.Lists.colors.includes() if possible */\r\n\t\t\t\t\t\t\tif (_inArray(CSS.Lists.colors, propertyName)) {\r\n\t\t\t\t\t\t\t\t/* Parse the value data for each shorthand. */\r\n\t\t\t\t\t\t\t\tvar endValue = valueData[0],\r\n\t\t\t\t\t\t\t\t\t\teasing = valueData[1],\r\n\t\t\t\t\t\t\t\t\t\tstartValue = valueData[2];\r\n\r\n\t\t\t\t\t\t\t\tif (CSS.RegEx.isHex.test(endValue)) {\r\n\t\t\t\t\t\t\t\t\t/* Convert the hex strings into their RGB component arrays. */\r\n\t\t\t\t\t\t\t\t\tvar colorComponents = ["Red", "Green", "Blue"],\r\n\t\t\t\t\t\t\t\t\t\t\tendValueRGB = CSS.Values.hexToRgb(endValue),\r\n\t\t\t\t\t\t\t\t\t\t\tstartValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;\r\n\r\n\t\t\t\t\t\t\t\t\t/* Inject the RGB component tweens into propertiesMap. */\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < colorComponents.length; i++) {\r\n\t\t\t\t\t\t\t\t\t\tvar dataArray = [endValueRGB[i]];\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (easing) {\r\n\t\t\t\t\t\t\t\t\t\t\tdataArray.push(easing);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (startValueRGB !== undefined) {\r\n\t\t\t\t\t\t\t\t\t\t\tdataArray.push(startValueRGB[i]);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tfixPropertyValue(propertyName + colorComponents[i], dataArray);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t/* If we have replaced a shortcut color value then don\'t update the standard property name */\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfixPropertyValue(propertyName, valueData);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Along with its property data, store a reference to the element itself onto tweensContainer. */\r\n\t\t\t\t\t\ttweensContainer.element = element;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/*****************\r\n\t\t\t\t\t Call Push\r\n\t\t\t\t\t *****************/\r\n\r\n\t\t\t\t\t/* Note: tweensContainer can be empty if all of the properties in this call\'s property map were skipped due to not\r\n\t\t\t\t\t being supported by the browser. The element property is used for checking that the tweensContainer has been appended to. */\r\n\t\t\t\t\tif (tweensContainer.element) {\r\n\t\t\t\t\t\t/* Apply the "velocity-animating" indicator class. */\r\n\t\t\t\t\t\tCSS.Values.addClass(element, "velocity-animating");\r\n\r\n\t\t\t\t\t\t/* The call array houses the tweensContainers for each element being animated in the current call. */\r\n\t\t\t\t\t\tcall.push(tweensContainer);\r\n\r\n\t\t\t\t\t\tdata = Data(element);\r\n\r\n\t\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\t\t/* Store the tweensContainer and options if we\'re working on the default effects queue, so that they can be used by the reverse command. */\r\n\t\t\t\t\t\t\tif (opts.queue === "") {\r\n\r\n\t\t\t\t\t\t\t\tdata.tweensContainer = tweensContainer;\r\n\t\t\t\t\t\t\t\tdata.opts = opts;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Switch on the element\'s animating flag. */\r\n\t\t\t\t\t\t\tdata.isAnimating = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Once the final element in this call\'s element set has been processed, push the call array onto\r\n\t\t\t\t\t\t Velocity.State.calls for the animation tick to immediately begin processing. */\r\n\t\t\t\t\t\tif (elementsIndex === elementsLength - 1) {\r\n\t\t\t\t\t\t\t/* Add the current call plus its associated metadata (the element set and the call\'s options) onto the global call container.\r\n\t\t\t\t\t\t\t Anything on this call container is subjected to tick() processing. */\r\n\t\t\t\t\t\t\tVelocity.State.calls.push([call, elements, opts, null, promiseData.resolver, null, 0]);\r\n\r\n\t\t\t\t\t\t\t/* If the animation tick isn\'t running, start it. (Velocity shuts it off when there are no active calls to process.) */\r\n\t\t\t\t\t\t\tif (Velocity.State.isTicking === false) {\r\n\t\t\t\t\t\t\t\tVelocity.State.isTicking = true;\r\n\r\n\t\t\t\t\t\t\t\t/* Start the tick loop. */\r\n\t\t\t\t\t\t\t\ttick();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\telementsIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* When the queue option is set to false, the call skips the element\'s queue and fires immediately. */\r\n\t\t\t\tif (opts.queue === false) {\r\n\t\t\t\t\t/* Since this buildQueue call doesn\'t respect the element\'s existing queue (which is where a delay option would have been appended),\r\n\t\t\t\t\t we manually inject the delay property here with an explicit setTimeout. */\r\n\t\t\t\t\tif (opts.delay) {\r\n\r\n\t\t\t\t\t\t/* Temporarily store delayed elements to facilitate access for global pause/resume */\r\n\t\t\t\t\t\tvar callIndex = Velocity.State.delayedElements.count++;\r\n\t\t\t\t\t\tVelocity.State.delayedElements[callIndex] = element;\r\n\r\n\t\t\t\t\t\tvar delayComplete = (function(index) {\r\n\t\t\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\t\t\t/* Clear the temporary element */\r\n\t\t\t\t\t\t\t\tVelocity.State.delayedElements[index] = false;\r\n\r\n\t\t\t\t\t\t\t\t/* Finally, issue the call */\r\n\t\t\t\t\t\t\t\tbuildQueue();\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t})(callIndex);\r\n\r\n\t\t\t\t\t\tData(element).delayBegin = (new Date()).getTime();\r\n\t\t\t\t\t\tData(element).delay = parseFloat(opts.delay);\r\n\t\t\t\t\t\tData(element).delayTimer = {\r\n\t\t\t\t\t\t\tsetTimeout: setTimeout(buildQueue, parseFloat(opts.delay)),\r\n\t\t\t\t\t\t\tnext: delayComplete\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbuildQueue();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* Otherwise, the call undergoes element queueing as normal. */\r\n\t\t\t\t\t/* Note: To interoperate with jQuery, Velocity uses jQuery\'s own $.queue() stack for queuing logic. */\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$.queue(element, opts.queue, function(next, clearQueue) {\r\n\t\t\t\t\t\t/* If the clearQueue flag was passed in by the stop command, resolve this call\'s promise. (Promises can only be resolved once,\r\n\t\t\t\t\t\t so it\'s fine if this is repeatedly triggered for each element in the associated call.) */\r\n\t\t\t\t\t\tif (clearQueue === true) {\r\n\t\t\t\t\t\t\tif (promiseData.promise) {\r\n\t\t\t\t\t\t\t\tpromiseData.resolver(elements);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t/* Do not continue with animation queueing. */\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* This flag indicates to the upcoming completeCall() function that this queue entry was initiated by Velocity.\r\n\t\t\t\t\t\t See completeCall() for further details. */\r\n\t\t\t\t\t\tVelocity.velocityQueueEntryFlag = true;\r\n\r\n\t\t\t\t\t\tbuildQueue(next);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*********************\r\n\t\t\t\t Auto-Dequeuing\r\n\t\t\t\t *********************/\r\n\r\n\t\t\t\t/* As per jQuery\'s $.queue() behavior, to fire the first non-custom-queue entry on an element, the element\r\n\t\t\t\t must be dequeued if its queue stack consists *solely* of the current call. (This can be determined by checking\r\n\t\t\t\t for the "inprogress" item that jQuery prepends to active queue stack arrays.) Regardless, whenever the element\'s\r\n\t\t\t\t queue is further appended with additional items -- including $.delay()\'s or even $.animate() calls, the queue\'s\r\n\t\t\t\t first entry is automatically fired. This behavior contrasts that of custom queues, which never auto-fire. */\r\n\t\t\t\t/* Note: When an element set is being subjected to a non-parallel Velocity call, the animation will not begin until\r\n\t\t\t\t each one of the elements in the set has reached the end of its individually pre-existing queue chain. */\r\n\t\t\t\t/* Note: Unfortunately, most people don\'t fully grasp jQuery\'s powerful, yet quirky, $.queue() function.\r\n\t\t\t\t Lean more here: http://stackoverflow.com/questions/1058158/can-somebody-explain-jquery-queue-to-me */\r\n\t\t\t\tif ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {\r\n\t\t\t\t\t$.dequeue(element);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/**************************\r\n\t\t\t Element Set Iteration\r\n\t\t\t **************************/\r\n\r\n\t\t\t/* If the "nodeType" property exists on the elements variable, we\'re animating a single element.\r\n\t\t\t Place it in an array so that $.each() can iterate over it. */\r\n\t\t\t$.each(elements, function(i, element) {\r\n\t\t\t\t/* Ensure each element in a set has a nodeType (is a real element) to avoid throwing errors. */\r\n\t\t\t\tif (Type.isNode(element)) {\r\n\t\t\t\t\tprocessElement(element, i);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t/******************\r\n\t\t\t Option: Loop\r\n\t\t\t ******************/\r\n\r\n\t\t\t/* The loop option accepts an integer indicating how many times the element should loop between the values in the\r\n\t\t\t current call\'s properties map and the element\'s property values prior to this call. */\r\n\t\t\t/* Note: The loop option\'s logic is performed here -- after element processing -- because the current call needs\r\n\t\t\t to undergo its queue insertion prior to the loop option generating its series of constituent "reverse" calls,\r\n\t\t\t which chain after the current call. Two reverse calls (two "alternations") constitute one loop. */\r\n\t\t\topts = $.extend({}, Velocity.defaults, options);\r\n\t\t\topts.loop = parseInt(opts.loop, 10);\r\n\t\t\tvar reverseCallsCount = (opts.loop * 2) - 1;\r\n\r\n\t\t\tif (opts.loop) {\r\n\t\t\t\t/* Double the loop count to convert it into its appropriate number of "reverse" calls.\r\n\t\t\t\t Subtract 1 from the resulting value since the current call is included in the total alternation count. */\r\n\t\t\t\tfor (var x = 0; x < reverseCallsCount; x++) {\r\n\t\t\t\t\t/* Since the logic for the reverse action occurs inside Queueing and therefore this call\'s options object\r\n\t\t\t\t\t isn\'t parsed until then as well, the current call\'s delay option must be explicitly passed into the reverse\r\n\t\t\t\t\t call so that the delay logic that occurs inside *Pre-Queueing* can process it. */\r\n\t\t\t\t\tvar reverseOptions = {\r\n\t\t\t\t\t\tdelay: opts.delay,\r\n\t\t\t\t\t\tprogress: opts.progress\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/* If a complete callback was passed into this call, transfer it to the loop redirect\'s final "reverse" call\r\n\t\t\t\t\t so that it\'s triggered when the entire redirect is complete (and not when the very first animation is complete). */\r\n\t\t\t\t\tif (x === reverseCallsCount - 1) {\r\n\t\t\t\t\t\treverseOptions.display = opts.display;\r\n\t\t\t\t\t\treverseOptions.visibility = opts.visibility;\r\n\t\t\t\t\t\treverseOptions.complete = opts.complete;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tanimate(elements, "reverse", reverseOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/***************\r\n\t\t\t Chaining\r\n\t\t\t ***************/\r\n\r\n\t\t\t/* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */\r\n\t\t\treturn getChain();\r\n\t\t};\r\n\r\n\t\t/* Turn Velocity into the animation function, extended with the pre-existing Velocity object. */\r\n\t\tVelocity = $.extend(animate, Velocity);\r\n\t\t/* For legacy support, also expose the literal animate method. */\r\n\t\tVelocity.animate = animate;\r\n\r\n\t\t/**************\r\n\t\t Timing\r\n\t\t **************/\r\n\r\n\t\t/* Ticker function. */\r\n\t\tvar ticker = window.requestAnimationFrame || rAFShim;\r\n\r\n\t\t/* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.\r\n\t\t To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn\'t* pause) when the tab loses focus. We skip this for mobile\r\n\t\t devices to avoid wasting battery power on inactive tabs. */\r\n\t\t/* Note: Tab focus detection doesn\'t work on older versions of IE, but that\'s okay since they don\'t support rAF to begin with. */\r\n\t\tif (!Velocity.State.isMobile && document.hidden !== undefined) {\r\n\t\t\tvar updateTicker = function() {\r\n\t\t\t\t/* Reassign the rAF function (which the global tick() function uses) based on the tab\'s focus state. */\r\n\t\t\t\tif (document.hidden) {\r\n\t\t\t\t\tticker = function(callback) {\r\n\t\t\t\t\t\t/* The tick function needs a truthy first argument in order to pass its internal timestamp check. */\r\n\t\t\t\t\t\treturn setTimeout(function() {\r\n\t\t\t\t\t\t\tcallback(true);\r\n\t\t\t\t\t\t}, 16);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t/* The rAF loop has been paused by the browser, so we manually restart the tick. */\r\n\t\t\t\t\ttick();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tticker = window.requestAnimationFrame || rAFShim;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t/* Page could be sitting in the background at this time (i.e. opened as new tab) so making sure we use correct ticker from the start */\r\n\t\t\tupdateTicker();\r\n\r\n\t\t\t/* And then run check again every time visibility changes */\r\n\t\t\tdocument.addEventListener("visibilitychange", updateTicker);\r\n\t\t}\r\n\r\n\t\t/************\r\n\t\t Tick\r\n\t\t ************/\r\n\r\n\t\t/* Note: All calls to Velocity are pushed to the Velocity.State.calls array, which is fully iterated through upon each tick. */\r\n\t\tfunction tick(timestamp) {\r\n\t\t\t/* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.\r\n\t\t\t We leverage this metadata to fully ignore the first tick pass since RAF\'s initial pass is fired whenever\r\n\t\t\t the browser\'s next tick sync time occurs, which results in the first elements subjected to Velocity\r\n\t\t\t calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore\r\n\t\t\t the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated\r\n\t\t\t by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */\r\n\t\t\tif (timestamp) {\r\n\t\t\t\t/* We normally use RAF\'s high resolution timestamp but as it can be significantly offset when the browser is\r\n\t\t\t\t under high stress we give the option for choppiness over allowing the browser to drop huge chunks of frames.\r\n\t\t\t\t We use performance.now() and shim it if it doesn\'t exist for when the tab is hidden. */\r\n\t\t\t\tvar timeCurrent = Velocity.timestamp && timestamp !== true ? timestamp : performance.now();\r\n\r\n\t\t\t\t/********************\r\n\t\t\t\t Call Iteration\r\n\t\t\t\t ********************/\r\n\r\n\t\t\t\tvar callsLength = Velocity.State.calls.length;\r\n\r\n\t\t\t\t/* To speed up iterating over this array, it is compacted (falsey items -- calls that have completed -- are removed)\r\n\t\t\t\t when its length has ballooned to a point that can impact tick performance. This only becomes necessary when animation\r\n\t\t\t\t has been continuous with many elements over a long period of time; whenever all active calls are completed, completeCall() clears Velocity.State.calls. */\r\n\t\t\t\tif (callsLength > 10000) {\r\n\t\t\t\t\tVelocity.State.calls = compactSparseArray(Velocity.State.calls);\r\n\t\t\t\t\tcallsLength = Velocity.State.calls.length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* Iterate through each active call. */\r\n\t\t\t\tfor (var i = 0; i < callsLength; i++) {\r\n\t\t\t\t\t/* When a Velocity call is completed, its Velocity.State.calls entry is set to false. Continue on to the next call. */\r\n\t\t\t\t\tif (!Velocity.State.calls[i]) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/************************\r\n\t\t\t\t\t Call-Wide Variables\r\n\t\t\t\t\t ************************/\r\n\r\n\t\t\t\t\tvar callContainer = Velocity.State.calls[i],\r\n\t\t\t\t\t\t\tcall = callContainer[0],\r\n\t\t\t\t\t\t\topts = callContainer[2],\r\n\t\t\t\t\t\t\ttimeStart = callContainer[3],\r\n\t\t\t\t\t\t\tfirstTick = !timeStart,\r\n\t\t\t\t\t\t\ttweenDummyValue = null,\r\n\t\t\t\t\t\t\tpauseObject = callContainer[5],\r\n\t\t\t\t\t\t\tmillisecondsEllapsed = callContainer[6];\r\n\r\n\r\n\r\n\t\t\t\t\t/* If timeStart is undefined, then this is the first time that this call has been processed by tick().\r\n\t\t\t\t\t We assign timeStart now so that its value is as close to the real animation start time as possible.\r\n\t\t\t\t\t (Conversely, had timeStart been defined when this call was added to Velocity.State.calls, the delay\r\n\t\t\t\t\t between that time and now would cause the first few frames of the tween to be skipped since\r\n\t\t\t\t\t percentComplete is calculated relative to timeStart.) */\r\n\t\t\t\t\t/* Further, subtract 16ms (the approximate resolution of RAF) from the current time value so that the\r\n\t\t\t\t\t first tick iteration isn\'t wasted by animating at 0% tween completion, which would produce the\r\n\t\t\t\t\t same style value as the element\'s current value. */\r\n\t\t\t\t\tif (!timeStart) {\r\n\t\t\t\t\t\ttimeStart = Velocity.State.calls[i][3] = timeCurrent - 16;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* If a pause object is present, skip processing unless it has been set to resume */\r\n\t\t\t\t\tif (pauseObject) {\r\n\t\t\t\t\t\tif (pauseObject.resume === true) {\r\n\t\t\t\t\t\t\t/* Update the time start to accomodate the paused completion amount */\r\n\t\t\t\t\t\t\ttimeStart = callContainer[3] = Math.round(timeCurrent - millisecondsEllapsed - 16);\r\n\r\n\t\t\t\t\t\t\t/* Remove pause object after processing */\r\n\t\t\t\t\t\t\tcallContainer[5] = null;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmillisecondsEllapsed = callContainer[6] = timeCurrent - timeStart;\r\n\r\n\t\t\t\t\t/* The tween\'s completion percentage is relative to the tween\'s start time, not the tween\'s start value\r\n\t\t\t\t\t (which would result in unpredictable tween durations since JavaScript\'s timers are not particularly accurate).\r\n\t\t\t\t\t Accordingly, we ensure that percentComplete does not exceed 1. */\r\n\t\t\t\t\tvar percentComplete = Math.min((millisecondsEllapsed) / opts.duration, 1);\r\n\r\n\t\t\t\t\t/**********************\r\n\t\t\t\t\t Element Iteration\r\n\t\t\t\t\t **********************/\r\n\r\n\t\t\t\t\t/* For every call, iterate through each of the elements in its set. */\r\n\t\t\t\t\tfor (var j = 0, callLength = call.length; j < callLength; j++) {\r\n\t\t\t\t\t\tvar tweensContainer = call[j],\r\n\t\t\t\t\t\t\t\telement = tweensContainer.element;\r\n\r\n\t\t\t\t\t\t/* Check to see if this element has been deleted midway through the animation by checking for the\r\n\t\t\t\t\t\t continued existence of its data cache. If it\'s gone, or the element is currently paused, skip animating this element. */\r\n\t\t\t\t\t\tif (!Data(element)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar transformPropertyExists = false;\r\n\r\n\t\t\t\t\t\t/**********************************\r\n\t\t\t\t\t\t Display & Visibility Toggling\r\n\t\t\t\t\t\t **********************************/\r\n\r\n\t\t\t\t\t\t/* If the display option is set to non-"none", set it upfront so that the element can become visible before tweening begins.\r\n\t\t\t\t\t\t (Otherwise, display\'s "none" value is set in completeCall() once the animation has completed.) */\r\n\t\t\t\t\t\tif (opts.display !== undefined && opts.display !== null && opts.display !== "none") {\r\n\t\t\t\t\t\t\tif (opts.display === "flex") {\r\n\t\t\t\t\t\t\t\tvar flexValues = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];\r\n\r\n\t\t\t\t\t\t\t\t$.each(flexValues, function(i, flexValue) {\r\n\t\t\t\t\t\t\t\t\tCSS.setPropertyValue(element, "display", flexValue);\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tCSS.setPropertyValue(element, "display", opts.display);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Same goes with the visibility option, but its "none" equivalent is "hidden". */\r\n\t\t\t\t\t\tif (opts.visibility !== undefined && opts.visibility !== "hidden") {\r\n\t\t\t\t\t\t\tCSS.setPropertyValue(element, "visibility", opts.visibility);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/************************\r\n\t\t\t\t\t\t Property Iteration\r\n\t\t\t\t\t\t ************************/\r\n\r\n\t\t\t\t\t\t/* For every element, iterate through each property. */\r\n\t\t\t\t\t\tfor (var property in tweensContainer) {\r\n\t\t\t\t\t\t\t/* Note: In addition to property tween data, tweensContainer contains a reference to its associated element. */\r\n\t\t\t\t\t\t\tif (tweensContainer.hasOwnProperty(property) && property !== "element") {\r\n\t\t\t\t\t\t\t\tvar tween = tweensContainer[property],\r\n\t\t\t\t\t\t\t\t\t\tcurrentValue,\r\n\t\t\t\t\t\t\t\t\t\t/* Easing can either be a pre-genereated function or a string that references a pre-registered easing\r\n\t\t\t\t\t\t\t\t\t\t on the Velocity.Easings object. In either case, return the appropriate easing *function*. */\r\n\t\t\t\t\t\t\t\t\t\teasing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;\r\n\r\n\t\t\t\t\t\t\t\t/******************************\r\n\t\t\t\t\t\t\t\t Current Value Calculation\r\n\t\t\t\t\t\t\t\t ******************************/\r\n\r\n\t\t\t\t\t\t\t\tif (Type.isString(tween.pattern)) {\r\n\t\t\t\t\t\t\t\t\tvar patternReplace = percentComplete === 1 ?\r\n\t\t\t\t\t\t\t\t\t\t\tfunction($0, index, round) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar result = tween.endValue[index];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn round ? Math.round(result) : result;\r\n\t\t\t\t\t\t\t\t\t\t\t} :\r\n\t\t\t\t\t\t\t\t\t\t\tfunction($0, index, round) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvar startValue = tween.startValue[index],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttweenDelta = tween.endValue[index] - startValue,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult = startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn round ? Math.round(result) : result;\r\n\t\t\t\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentValue = tween.pattern.replace(/{(\\d+)(!)?}/g, patternReplace);\r\n\t\t\t\t\t\t\t\t} else if (percentComplete === 1) {\r\n\t\t\t\t\t\t\t\t\t/* If this is the last tick pass (if we\'ve reached 100% completion for this tween),\r\n\t\t\t\t\t\t\t\t\t ensure that currentValue is explicitly set to its target endValue so that it\'s not subjected to any rounding. */\r\n\t\t\t\t\t\t\t\t\tcurrentValue = tween.endValue;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t/* Otherwise, calculate currentValue based on the current delta from startValue. */\r\n\t\t\t\t\t\t\t\t\tvar tweenDelta = tween.endValue - tween.startValue;\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentValue = tween.startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));\r\n\t\t\t\t\t\t\t\t\t/* If no value change is occurring, don\'t proceed with DOM updating. */\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (!firstTick && (currentValue === tween.currentValue)) {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\ttween.currentValue = currentValue;\r\n\r\n\t\t\t\t\t\t\t\t/* If we\'re tweening a fake \'tween\' property in order to log transition values, update the one-per-call variable so that\r\n\t\t\t\t\t\t\t\t it can be passed into the progress callback. */\r\n\t\t\t\t\t\t\t\tif (property === "tween") {\r\n\t\t\t\t\t\t\t\t\ttweenDummyValue = currentValue;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t/******************\r\n\t\t\t\t\t\t\t\t\t Hooks: Part I\r\n\t\t\t\t\t\t\t\t\t ******************/\r\n\t\t\t\t\t\t\t\t\tvar hookRoot;\r\n\r\n\t\t\t\t\t\t\t\t\t/* For hooked properties, the newly-updated rootPropertyValueCache is cached onto the element so that it can be used\r\n\t\t\t\t\t\t\t\t\t for subsequent hooks in this call that are associated with the same root property. If we didn\'t cache the updated\r\n\t\t\t\t\t\t\t\t\t rootPropertyValue, each subsequent update to the root property in this tick pass would reset the previous hook\'s\r\n\t\t\t\t\t\t\t\t\t updates to rootPropertyValue prior to injection. A nice performance byproduct of rootPropertyValue caching is that\r\n\t\t\t\t\t\t\t\t\t subsequently chained animations using the same hookRoot but a different hook can use this cached rootPropertyValue. */\r\n\t\t\t\t\t\t\t\t\tif (CSS.Hooks.registered[property]) {\r\n\t\t\t\t\t\t\t\t\t\thookRoot = CSS.Hooks.getRoot(property);\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (rootPropertyValueCache) {\r\n\t\t\t\t\t\t\t\t\t\t\ttween.rootPropertyValue = rootPropertyValueCache;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t/*****************\r\n\t\t\t\t\t\t\t\t\t DOM Update\r\n\t\t\t\t\t\t\t\t\t *****************/\r\n\r\n\t\t\t\t\t\t\t\t\t/* setPropertyValue() returns an array of the property name and property value post any normalization that may have been performed. */\r\n\t\t\t\t\t\t\t\t\t/* Note: To solve an IE<=8 positioning bug, the unit type is dropped when setting a property value of 0. */\r\n\t\t\t\t\t\t\t\t\tvar adjustedSetData = CSS.setPropertyValue(element, /* SET */\r\n\t\t\t\t\t\t\t\t\t\t\tproperty,\r\n\t\t\t\t\t\t\t\t\t\t\ttween.currentValue + (IE < 9 && parseFloat(currentValue) === 0 ? "" : tween.unitType),\r\n\t\t\t\t\t\t\t\t\t\t\ttween.rootPropertyValue,\r\n\t\t\t\t\t\t\t\t\t\t\ttween.scrollData);\r\n\r\n\t\t\t\t\t\t\t\t\t/*******************\r\n\t\t\t\t\t\t\t\t\t Hooks: Part II\r\n\t\t\t\t\t\t\t\t\t *******************/\r\n\r\n\t\t\t\t\t\t\t\t\t/* Now that we have the hook\'s updated rootPropertyValue (the post-processed value provided by adjustedSetData), cache it onto the element. */\r\n\t\t\t\t\t\t\t\t\tif (CSS.Hooks.registered[property]) {\r\n\t\t\t\t\t\t\t\t\t\t/* Since adjustedSetData contains normalized data ready for DOM updating, the rootPropertyValue needs to be re-extracted from its normalized form. ?? */\r\n\t\t\t\t\t\t\t\t\t\tif (CSS.Normalizations.registered[hookRoot]) {\r\n\t\t\t\t\t\t\t\t\t\t\tData(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tData(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t/***************\r\n\t\t\t\t\t\t\t\t\t Transforms\r\n\t\t\t\t\t\t\t\t\t ***************/\r\n\r\n\t\t\t\t\t\t\t\t\t/* Flag whether a transform property is being animated so that flushTransformCache() can be triggered once this tick pass is complete. */\r\n\t\t\t\t\t\t\t\t\tif (adjustedSetData[0] === "transform") {\r\n\t\t\t\t\t\t\t\t\t\ttransformPropertyExists = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/****************\r\n\t\t\t\t\t\t mobileHA\r\n\t\t\t\t\t\t ****************/\r\n\r\n\t\t\t\t\t\t/* If mobileHA is enabled, set the translate3d transform to null to force hardware acceleration.\r\n\t\t\t\t\t\t It\'s safe to override this property since Velocity doesn\'t actually support its animation (hooks are used in its place). */\r\n\t\t\t\t\t\tif (opts.mobileHA) {\r\n\t\t\t\t\t\t\t/* Don\'t set the null transform hack if we\'ve already done so. */\r\n\t\t\t\t\t\t\tif (Data(element).transformCache.translate3d === undefined) {\r\n\t\t\t\t\t\t\t\t/* All entries on the transformCache object are later concatenated into a single transform string via flushTransformCache(). */\r\n\t\t\t\t\t\t\t\tData(element).transformCache.translate3d = "(0px, 0px, 0px)";\r\n\r\n\t\t\t\t\t\t\t\ttransformPropertyExists = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (transformPropertyExists) {\r\n\t\t\t\t\t\t\tCSS.flushTransformCache(element);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* The non-"none" display value is only applied to an element once -- when its associated call is first ticked through.\r\n\t\t\t\t\t Accordingly, it\'s set to false so that it isn\'t re-processed by this call in the next tick. */\r\n\t\t\t\t\tif (opts.display !== undefined && opts.display !== "none") {\r\n\t\t\t\t\t\tVelocity.State.calls[i][2].display = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (opts.visibility !== undefined && opts.visibility !== "hidden") {\r\n\t\t\t\t\t\tVelocity.State.calls[i][2].visibility = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Pass the elements and the timing data (percentComplete, msRemaining, timeStart, tweenDummyValue) into the progress callback. */\r\n\t\t\t\t\tif (opts.progress) {\r\n\t\t\t\t\t\topts.progress.call(callContainer[1],\r\n\t\t\t\t\t\t\t\tcallContainer[1],\r\n\t\t\t\t\t\t\t\tpercentComplete,\r\n\t\t\t\t\t\t\t\tMath.max(0, (timeStart + opts.duration) - timeCurrent),\r\n\t\t\t\t\t\t\t\ttimeStart,\r\n\t\t\t\t\t\t\t\ttweenDummyValue);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* If this call has finished tweening, pass its index to completeCall() to handle call cleanup. */\r\n\t\t\t\t\tif (percentComplete === 1) {\r\n\t\t\t\t\t\tcompleteCall(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Note: completeCall() sets the isTicking flag to false when the last call on Velocity.State.calls has completed. */\r\n\t\t\tif (Velocity.State.isTicking) {\r\n\t\t\t\tticker(tick);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**********************\r\n\t\t Call Completion\r\n\t\t **********************/\r\n\r\n\t\t/* Note: Unlike tick(), which processes all active calls at once, call completion is handled on a per-call basis. */\r\n\t\tfunction completeCall(callIndex, isStopped) {\r\n\t\t\t/* Ensure the call exists. */\r\n\t\t\tif (!Velocity.State.calls[callIndex]) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t/* Pull the metadata from the call. */\r\n\t\t\tvar call = Velocity.State.calls[callIndex][0],\r\n\t\t\t\t\telements = Velocity.State.calls[callIndex][1],\r\n\t\t\t\t\topts = Velocity.State.calls[callIndex][2],\r\n\t\t\t\t\tresolver = Velocity.State.calls[callIndex][4];\r\n\r\n\t\t\tvar remainingCallsExist = false;\r\n\r\n\t\t\t/*************************\r\n\t\t\t Element Finalization\r\n\t\t\t *************************/\r\n\r\n\t\t\tfor (var i = 0, callLength = call.length; i < callLength; i++) {\r\n\t\t\t\tvar element = call[i].element;\r\n\r\n\t\t\t\t/* If the user set display to "none" (intending to hide the element), set it now that the animation has completed. */\r\n\t\t\t\t/* Note: display:none isn\'t set when calls are manually stopped (via Velocity("stop"). */\r\n\t\t\t\t/* Note: Display gets ignored with "reverse" calls and infinite loops, since this behavior would be undesirable. */\r\n\t\t\t\tif (!isStopped && !opts.loop) {\r\n\t\t\t\t\tif (opts.display === "none") {\r\n\t\t\t\t\t\tCSS.setPropertyValue(element, "display", opts.display);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (opts.visibility === "hidden") {\r\n\t\t\t\t\t\tCSS.setPropertyValue(element, "visibility", opts.visibility);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* If the element\'s queue is empty (if only the "inprogress" item is left at position 0) or if its queue is about to run\r\n\t\t\t\t a non-Velocity-initiated entry, turn off the isAnimating flag. A non-Velocity-initiatied queue entry\'s logic might alter\r\n\t\t\t\t an element\'s CSS values and thereby cause Velocity\'s cached value data to go stale. To detect if a queue entry was initiated by Velocity,\r\n\t\t\t\t we check for the existence of our special Velocity.queueEntryFlag declaration, which minifiers won\'t rename since the flag\r\n\t\t\t\t is assigned to jQuery\'s global $ object and thus exists out of Velocity\'s own scope. */\r\n\t\t\t\tvar data = Data(element);\r\n\r\n\t\t\t\tif (opts.loop !== true && ($.queue(element)[1] === undefined || !/\\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {\r\n\t\t\t\t\t/* The element may have been deleted. Ensure that its data cache still exists before acting on it. */\r\n\t\t\t\t\tif (data) {\r\n\t\t\t\t\t\tdata.isAnimating = false;\r\n\t\t\t\t\t\t/* Clear the element\'s rootPropertyValueCache, which will become stale. */\r\n\t\t\t\t\t\tdata.rootPropertyValueCache = {};\r\n\r\n\t\t\t\t\t\tvar transformHAPropertyExists = false;\r\n\t\t\t\t\t\t/* If any 3D transform subproperty is at its default value (regardless of unit type), remove it. */\r\n\t\t\t\t\t\t$.each(CSS.Lists.transforms3D, function(i, transformName) {\r\n\t\t\t\t\t\t\tvar defaultValue = /^scale/.test(transformName) ? 1 : 0,\r\n\t\t\t\t\t\t\t\t\tcurrentValue = data.transformCache[transformName];\r\n\r\n\t\t\t\t\t\t\tif (data.transformCache[transformName] !== undefined && new RegExp("^\\\\(" + defaultValue + "[^.]").test(currentValue)) {\r\n\t\t\t\t\t\t\t\ttransformHAPropertyExists = true;\r\n\r\n\t\t\t\t\t\t\t\tdelete data.transformCache[transformName];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t/* Mobile devices have hardware acceleration removed at the end of the animation in order to avoid hogging the GPU\'s memory. */\r\n\t\t\t\t\t\tif (opts.mobileHA) {\r\n\t\t\t\t\t\t\ttransformHAPropertyExists = true;\r\n\t\t\t\t\t\t\tdelete data.transformCache.translate3d;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Flush the subproperty removals to the DOM. */\r\n\t\t\t\t\t\tif (transformHAPropertyExists) {\r\n\t\t\t\t\t\t\tCSS.flushTransformCache(element);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t/* Remove the "velocity-animating" indicator class. */\r\n\t\t\t\t\t\tCSS.Values.removeClass(element, "velocity-animating");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*********************\r\n\t\t\t\t Option: Complete\r\n\t\t\t\t *********************/\r\n\r\n\t\t\t\t/* Complete is fired once per call (not once per element) and is passed the full raw DOM element set as both its context and its first argument. */\r\n\t\t\t\t/* Note: Callbacks aren\'t fired when calls are manually stopped (via Velocity("stop"). */\r\n\t\t\t\tif (!isStopped && opts.complete && !opts.loop && (i === callLength - 1)) {\r\n\t\t\t\t\t/* We throw callbacks in a setTimeout so that thrown errors don\'t halt the execution of Velocity itself. */\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\topts.complete.call(elements, elements);\r\n\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\tthrow error;\r\n\t\t\t\t\t\t}, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/**********************\r\n\t\t\t\t Promise Resolving\r\n\t\t\t\t **********************/\r\n\r\n\t\t\t\t/* Note: Infinite loops don\'t return promises. */\r\n\t\t\t\tif (resolver && opts.loop !== true) {\r\n\t\t\t\t\tresolver(elements);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/****************************\r\n\t\t\t\t Option: Loop (Infinite)\r\n\t\t\t\t ****************************/\r\n\r\n\t\t\t\tif (data && opts.loop === true && !isStopped) {\r\n\t\t\t\t\t/* If a rotateX/Y/Z property is being animated by 360 deg with loop:true, swap tween start/end values to enable\r\n\t\t\t\t\t continuous iterative rotation looping. (Otherise, the element would just rotate back and forth.) */\r\n\t\t\t\t\t$.each(data.tweensContainer, function(propertyName, tweenContainer) {\r\n\t\t\t\t\t\tif (/^rotate/.test(propertyName) && ((parseFloat(tweenContainer.startValue) - parseFloat(tweenContainer.endValue)) % 360 === 0)) {\r\n\t\t\t\t\t\t\tvar oldStartValue = tweenContainer.startValue;\r\n\r\n\t\t\t\t\t\t\ttweenContainer.startValue = tweenContainer.endValue;\r\n\t\t\t\t\t\t\ttweenContainer.endValue = oldStartValue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {\r\n\t\t\t\t\t\t\ttweenContainer.endValue = 0;\r\n\t\t\t\t\t\t\ttweenContainer.startValue = 100;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tVelocity(element, "reverse", {loop: true, delay: opts.delay});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/***************\r\n\t\t\t\t Dequeueing\r\n\t\t\t\t ***************/\r\n\r\n\t\t\t\t/* Fire the next call in the queue so long as this call\'s queue wasn\'t set to false (to trigger a parallel animation),\r\n\t\t\t\t which would have already caused the next call to fire. Note: Even if the end of the animation queue has been reached,\r\n\t\t\t\t $.dequeue() must still be called in order to completely clear jQuery\'s animation queue. */\r\n\t\t\t\tif (opts.queue !== false) {\r\n\t\t\t\t\t$.dequeue(element, opts.queue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/************************\r\n\t\t\t Calls Array Cleanup\r\n\t\t\t ************************/\r\n\r\n\t\t\t/* Since this call is complete, set it to false so that the rAF tick skips it. This array is later compacted via compactSparseArray().\r\n\t\t\t (For performance reasons, the call is set to false instead of being deleted from the array: http://www.html5rocks.com/en/tutorials/speed/v8/) */\r\n\t\t\tVelocity.State.calls[callIndex] = false;\r\n\r\n\t\t\t/* Iterate through the calls array to determine if this was the final in-progress animation.\r\n\t\t\t If so, set a flag to end ticking and clear the calls array. */\r\n\t\t\tfor (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {\r\n\t\t\t\tif (Velocity.State.calls[j] !== false) {\r\n\t\t\t\t\tremainingCallsExist = true;\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (remainingCallsExist === false) {\r\n\t\t\t\t/* tick() will detect this flag upon its next iteration and subsequently turn itself off. */\r\n\t\t\t\tVelocity.State.isTicking = false;\r\n\r\n\t\t\t\t/* Clear the calls array so that its length is reset. */\r\n\t\t\t\tdelete Velocity.State.calls;\r\n\t\t\t\tVelocity.State.calls = [];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/******************\r\n\t\t Frameworks\r\n\t\t ******************/\r\n\r\n\t\t/* Both jQuery and Zepto allow their $.fn object to be extended to allow wrapped elements to be subjected to plugin calls.\r\n\t\t If either framework is loaded, register a "velocity" extension pointing to Velocity\'s core animate() method.  Velocity\r\n\t\t also registers itself onto a global container (window.jQuery || window.Zepto || window) so that certain features are\r\n\t\t accessible beyond just a per-element scope. This master object contains an .animate() method, which is later assigned to $.fn\r\n\t\t (if jQuery or Zepto are present). Accordingly, Velocity can both act on wrapped DOM elements and stand alone for targeting raw DOM elements. */\r\n\t\tglobal.Velocity = Velocity;\r\n\r\n\t\tif (global !== window) {\r\n\t\t\t/* Assign the element function to Velocity\'s core animate() method. */\r\n\t\t\tglobal.fn.velocity = animate;\r\n\t\t\t/* Assign the object function\'s defaults to Velocity\'s global defaults object. */\r\n\t\t\tglobal.fn.velocity.defaults = Velocity.defaults;\r\n\t\t}\r\n\r\n\t\t/***********************\r\n\t\t Packaged Redirects\r\n\t\t ***********************/\r\n\r\n\t\t/* slideUp, slideDown */\r\n\t\t$.each(["Down", "Up"], function(i, direction) {\r\n\t\t\tVelocity.Redirects["slide" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {\r\n\t\t\t\tvar opts = $.extend({}, options),\r\n\t\t\t\t\t\tbegin = opts.begin,\r\n\t\t\t\t\t\tcomplete = opts.complete,\r\n\t\t\t\t\t\tinlineValues = {},\r\n\t\t\t\t\t\tcomputedValues = {height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: ""};\r\n\r\n\t\t\t\tif (opts.display === undefined) {\r\n\t\t\t\t\t/* Show the element before slideDown begins and hide the element after slideUp completes. */\r\n\t\t\t\t\t/* Note: Inline elements cannot have dimensions animated, so they\'re reverted to inline-block. */\r\n\t\t\t\t\topts.display = (direction === "Down" ? (Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block") : "none");\r\n\t\t\t\t}\r\n\r\n\t\t\t\topts.begin = function() {\r\n\t\t\t\t\t/* If the user passed in a begin callback, fire it now. */\r\n\t\t\t\t\tif (elementsIndex === 0 && begin) {\r\n\t\t\t\t\t\tbegin.call(elements, elements);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Cache the elements\' original vertical dimensional property values so that we can animate back to them. */\r\n\t\t\t\t\tfor (var property in computedValues) {\r\n\t\t\t\t\t\tif (!computedValues.hasOwnProperty(property)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tinlineValues[property] = element.style[property];\r\n\r\n\t\t\t\t\t\t/* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,\r\n\t\t\t\t\t\t use forcefeeding to start from computed values and animate down to 0. */\r\n\t\t\t\t\t\tvar propertyValue = CSS.getPropertyValue(element, property);\r\n\t\t\t\t\t\tcomputedValues[property] = (direction === "Down") ? [propertyValue, 0] : [0, propertyValue];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* Force vertical overflow content to clip so that sliding works as expected. */\r\n\t\t\t\t\tinlineValues.overflow = element.style.overflow;\r\n\t\t\t\t\telement.style.overflow = "hidden";\r\n\t\t\t\t};\r\n\r\n\t\t\t\topts.complete = function() {\r\n\t\t\t\t\t/* Reset element to its pre-slide inline values once its slide animation is complete. */\r\n\t\t\t\t\tfor (var property in inlineValues) {\r\n\t\t\t\t\t\tif (inlineValues.hasOwnProperty(property)) {\r\n\t\t\t\t\t\t\telement.style[property] = inlineValues[property];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t/* If the user passed in a complete callback, fire it now. */\r\n\t\t\t\t\tif (elementsIndex === elementsSize - 1) {\r\n\t\t\t\t\t\tif (complete) {\r\n\t\t\t\t\t\t\tcomplete.call(elements, elements);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (promiseData) {\r\n\t\t\t\t\t\t\tpromiseData.resolver(elements);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tVelocity(element, computedValues, opts);\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\t/* fadeIn, fadeOut */\r\n\t\t$.each(["In", "Out"], function(i, direction) {\r\n\t\t\tVelocity.Redirects["fade" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {\r\n\t\t\t\tvar opts = $.extend({}, options),\r\n\t\t\t\t\t\tcomplete = opts.complete,\r\n\t\t\t\t\t\tpropertiesMap = {opacity: (direction === "In") ? 1 : 0};\r\n\r\n\t\t\t\t/* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering\r\n\t\t\t\t callbacks by firing them only when the final element has been reached. */\r\n\t\t\t\tif (elementsIndex !== 0) {\r\n\t\t\t\t\topts.begin = null;\r\n\t\t\t\t}\r\n\t\t\t\tif (elementsIndex !== elementsSize - 1) {\r\n\t\t\t\t\topts.complete = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\topts.complete = function() {\r\n\t\t\t\t\t\tif (complete) {\r\n\t\t\t\t\t\t\tcomplete.call(elements, elements);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (promiseData) {\r\n\t\t\t\t\t\t\tpromiseData.resolver(elements);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* If a display was passed in, use it. Otherwise, default to "none" for fadeOut or the element-specific default for fadeIn. */\r\n\t\t\t\t/* Note: We allow users to pass in "null" to skip display setting altogether. */\r\n\t\t\t\tif (opts.display === undefined) {\r\n\t\t\t\t\topts.display = (direction === "In" ? "auto" : "none");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tVelocity(this, propertiesMap, opts);\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\treturn Velocity;\r\n\t}((window.jQuery || window.Zepto || window), window, (window ? window.document : undefined));\r\n}));\r\n\r\n/******************\r\n Known Issues\r\n ******************/\r\n\r\n/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.\r\n Velocity, however, doesn\'t make this distinction. Thus, converting to or from the % unit with these subproperties\r\n will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */\r\n\n\n//# sourceURL=webpack://HsNavScroller/./node_modules/velocity-animate/velocity.js?'); },
    "./src/js/hs-nav-scroller.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HsNavScroller; });\n/* harmony import */ var velocity_animate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! velocity-animate */ \"./node_modules/velocity-animate/velocity.js\");\n/* harmony import */ var velocity_animate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(velocity_animate__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSNavScroller Plugin\n* @version: 2.0.0 (Sat, 06 Jul 2021)\n* @requires: Velocity 1.5.2 or later\n* @author: HtmlStream\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\n\nvar dataAttributeName = 'data-hs-nav-scroller-options';\nvar defaults = {\n  type: 'horizontal',\n  target: '.active',\n  offset: 0,\n  delay: 20\n};\n\nvar HsNavScroller = /*#__PURE__*/function () {\n  function HsNavScroller(el, options, id) {\n    _classCallCheck(this, HsNavScroller);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HsNavScroller, [{\n    key: \"_init\",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty('$initializedEl')) {\n          return \"continue\";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n\n        if (_options.type == 'vertical') {\n          velocity_animate__WEBPACK_IMPORTED_MODULE_0___default()(_$el, 'scroll', {\n            container: _$el,\n            offset: _$el.querySelector(_options.target).offsetTop - _options.offset,\n            duration: _options.delay,\n            axis: 'y'\n          });\n        } else if (_options.type == 'horizontal') {\n          _options.nav = _$el.querySelector('.nav');\n          _options.prev = _$el.querySelector('.hs-nav-scroller-arrow-prev');\n          _options.next = _$el.querySelector('.hs-nav-scroller-arrow-next');\n          _options.activeElementLeftPosition = _options.nav.querySelector(_options.target).offsetLeft;\n          _options.scrollMaxLeft = parseInt((_options.nav.scrollWidth.toFixed() - _options.nav.clientWidth).toFixed());\n          _options.scrollPosition = _options.nav.scrollLeft;\n\n          if (_options.scrollPosition <= 0) {\n            _options.prev.style.display = 'none';\n          }\n\n          if (_options.scrollMaxLeft <= 0) {\n            _options.next.style.display = 'none';\n          }\n\n          that.onResize(_$el, _options);\n          window.addEventListener('resize', function () {\n            return that.onResize(_$el, _options);\n          });\n\n          var navRect = _options.nav.getBoundingClientRect(),\n              prevRect = _options.prev.getBoundingClientRect(),\n              nextRect = _options.next.getBoundingClientRect();\n\n          if (_options.activeElementLeftPosition > navRect.width / 2) {\n            velocity_animate__WEBPACK_IMPORTED_MODULE_0___default()(_options.nav, 'scroll', {\n              container: _options.nav,\n              offset: _options.activeElementLeftPosition - _options.offset - prevRect.width,\n              duration: _options.delay,\n              axis: 'x'\n            });\n          }\n\n          _options.next.addEventListener('click', function () {\n            velocity_animate__WEBPACK_IMPORTED_MODULE_0___default()(_options.nav, 'scroll', {\n              container: _options.nav,\n              offset: _options.scrollPosition + _options.nav.clientWidth - nextRect.width,\n              duration: _options.delay,\n              axis: 'x'\n            });\n          });\n\n          _options.prev.addEventListener('click', function () {\n            velocity_animate__WEBPACK_IMPORTED_MODULE_0___default()(_options.nav, 'scroll', {\n              container: _options.nav,\n              offset: _options.scrollPosition - _options.nav.clientWidth + prevRect.width,\n              duration: _options.delay,\n              axis: 'x'\n            });\n          });\n\n          _options.nav.addEventListener('scroll', function () {\n            var scrollMaxLeft = (parseInt(_options.nav.scrollWidth.toFixed()) - parseInt(_options.nav.clientWidth)).toFixed(),\n                scrollPosition = _options.nav.scrollLeft; // Hide or Show Back Arrow\n\n            if (scrollPosition <= 0) {\n              _options.prev.style.display = 'none';\n            } else {\n              _options.prev.style.display = 'flex';\n            } // Hide or Show Next Arrow\n\n\n            if (scrollPosition >= scrollMaxLeft) {\n              _options.next.style.display = 'none';\n            } else {\n              _options.next.style.display = 'flex';\n            }\n          });\n        }\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"onResize\",\n    value: function onResize($el, settings) {\n      var scrollMaxLeft = parseInt(settings.nav.scrollWidth.toFixed()) - parseInt(settings.nav.clientWidth.toFixed()),\n          scrollPosition = settings.nav.scrollLeft;\n\n      if (scrollPosition <= 0) {\n        settings.prev.style.display = 'none';\n      } else {\n        settings.prev.style.display = 'flex';\n      }\n\n      if (scrollMaxLeft <= 0) {\n        settings.next.style.display = 'none';\n      } else {\n        settings.next.style.display = 'flex';\n      }\n    }\n  }, {\n    key: \"addToCollection\",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(item) {\n      if (typeof item === 'number') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HsNavScroller;\n}();\n\n\n\n//# sourceURL=webpack://HsNavScroller/./src/js/hs-nav-scroller.js?");
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-nav-scroller.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSFileAttach = e() : t.HSFileAttach = e(); }(window, (() => {
  return d = {
    "./src/js/hs-file-attach.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HSFileAttach; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSFileAttach Plugin\n* @version: 3.0.0 (Mon, 22 Feb 2021)\n* @author: HtmlStream\n* @event-namespace: .HSFileAttach\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2019 Htmlstream\n*/\nvar dataAttributeName = 'data-hs-file-attach-options';\nvar defaults = {\n  textTarget: null,\n  maxFileSize: 1024,\n  // Infinity - off file size detection\n  errorMessage: 'File is too big!',\n  typeErrorMessage: 'Unsupported file type',\n  mode: 'simple',\n  targetAttr: null,\n  resetTarget: null,\n  allowTypes: []\n};\n\nvar HSFileAttach = /*#__PURE__*/function () {\n  function HSFileAttach(el, options, id) {\n    _classCallCheck(this, HSFileAttach);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSFileAttach, [{\n    key: \"_init\",\n    value: function _init() {\n      var _this = this;\n\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty('$initializedEl')) {\n          return \"continue\";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        _options.$target = document.querySelector(_options.textTarget);\n\n        function getFileExtension(filename) {\n          return /[.]/.exec(filename) ? /[^.]+$/.exec(filename)[0] : null;\n        }\n\n        _$el.addEventListener('change', function (e) {\n          if (_$el.value === '') {\n            return;\n          }\n\n          if (e.target.files[0].size > _options.maxFileSize * 1024) {\n            alert(_options.errorMessage);\n            return e.target.value = '';\n          }\n\n          if (_options.allowTypes.length > 0) {\n            var type = '.' + getFileExtension(e.target.files[0].name);\n\n            if (!type || !_options.allowTypes.includes(type.toLowerCase())) {\n              alert(_options.typeErrorMessage);\n              return e.target.value = '';\n            }\n          }\n\n          if (_options.mode === 'image') {\n            _this.image(_$el, _options);\n          } else {\n            _this.simple(_$el, _options);\n          }\n        });\n\n        _options.resetTarget ? document.querySelector(_options.resetTarget).addEventListener('click', function () {\n          _$el.value = '';\n\n          _options.$target.setAttribute(_options.targetAttr, _options.resetImg);\n        }) : null;\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"simple\",\n    value: function simple($el, settings) {\n      settings.textContent = $el.value.replace(/.+[\\\\\\/]/, '');\n    }\n  }, {\n    key: \"image\",\n    value: function image($el, settings) {\n      var reader;\n\n      if ($el.files && $el.files[0]) {\n        reader = new FileReader();\n\n        reader.onload = function (e) {\n          settings.$target.setAttribute(settings.targetAttr, e.target.result);\n        };\n\n        reader.readAsDataURL($el.files[0]);\n      }\n    }\n  }, {\n    key: \"addToCollection\",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(item) {\n      if (typeof item === 'number') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSFileAttach;\n}();\n\n\n\n//# sourceURL=webpack://HSFileAttach/./src/js/hs-file-attach.js?");
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-file-attach.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSAddField = e() : t.HSAddField = e(); }(window, (() => {
  return d = {
    "./src/js/hs-add-field.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSAddField; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSAddField Plugin\n* @version: 2.0.1 (Jul, 31 Nov 2021)\n* @author: HtmlStream\n* @event-namespace: .HSAddField\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\nvar dataAttributeName = \'data-hs-add-field-options\';\nvar defaults = {\n  createTrigger: \'.js-create-field\',\n  deleteTrigger: \'.js-delete-field\',\n  limit: 5,\n  defaultCreated: 1,\n  nameSeparator: \'_\',\n  addedField: function addedField() {},\n  deletedField: function deletedField() {}\n};\n\nvar HSAddField = /*#__PURE__*/function () {\n  function HSAddField(el, options, id) {\n    _classCallCheck(this, HSAddField);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSAddField, [{\n    key: "_init",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        _options.flags = {\n          name: \'data-name\',\n          "delete": \'data-hs-add-field-delete\'\n        };\n        _options.fieldsCount = 0;\n        _options.fieldsCount = _options.defaultCreated;\n        _options.tempalte = document.querySelector(_options.template);\n        _options.contaienr = _$el.querySelector(_options.container);\n\n        for (key = 0; key < _options.defaultCreated; key++) {\n          that.addField(_$el, _options);\n        }\n\n        _$el.addEventListener(\'click\', function (e) {\n          if (e.target.closest(_options.createTrigger)) {\n            that.addField(_$el, _options);\n          } else if (e.target.closest(_options.deleteTrigger)) {\n            that.deleteField(_$el, _options, e.target.closest(_options.deleteTrigger).getAttribute(_options.flags["delete"]));\n          }\n        });\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var key;\n\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "addField",\n    value: function addField($el, settings) {\n      var that = this;\n\n      if (settings.fieldsCount < settings.limit) {\n        var field = settings.tempalte.cloneNode(true);\n        field.removeAttribute(\'id\');\n        field.style.display = null;\n        settings.contaienr.appendChild(field);\n        that.updateFieldsCount($el, settings);\n        that.renderName($el, settings);\n        that.renderKeys($el, settings);\n        that.toggleCreateButton($el, settings);\n        settings.addedField(field);\n      }\n    }\n  }, {\n    key: "deleteField",\n    value: function deleteField($el, settings, index) {\n      var that = this;\n\n      if (settings.fieldsCount > 0) {\n        settings.contaienr.childNodes[index].parentNode.removeChild(settings.contaienr.childNodes[index]);\n        that.updateFieldsCount($el, settings);\n        that.renderName($el, settings);\n        that.renderKeys($el, settings);\n        that.toggleCreateButton($el, settings);\n        settings.deletedField();\n      }\n    }\n  }, {\n    key: "renderName",\n    value: function renderName($el, settings) {\n      settings.contaienr.childNodes.forEach(function (el, key) {\n        if (el.nodeName === \'#text\') return;\n        var field = el.querySelector("[".concat(settings.flags.name, "]"));\n        if (!field) return;\n        field.setAttribute(\'name\', "".concat(field.getAttribute(\'data-name\')).concat(settings.nameSeparator).concat(key));\n      });\n    }\n  }, {\n    key: "renderKeys",\n    value: function renderKeys($el, settings) {\n      settings.contaienr.childNodes.forEach(function (el, key) {\n        if (el.nodeName === \'#text\') return;\n        var deleteTrigger = el.querySelector(settings.deleteTrigger);\n        deleteTrigger ? deleteTrigger.setAttribute(settings.flags["delete"], key) : null;\n      });\n    }\n  }, {\n    key: "updateFieldsCount",\n    value: function updateFieldsCount($el, settings) {\n      settings.fieldsCount = settings.contaienr.childNodes.length;\n    }\n  }, {\n    key: "toggleCreateButton",\n    value: function toggleCreateButton($el, settings) {\n      var createTrigger = $el.querySelector(settings.createTrigger);\n\n      if (settings.fieldsCount === settings.limit) {\n        createTrigger.style.display = \'none\';\n      } else {\n        createTrigger.style.display = null;\n      }\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSAddField;\n}();\n\n\n\n//# sourceURL=webpack://HSAddField/./src/js/hs-add-field.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-add-field.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.Quill = e() : t.Quill = e(); }(typeof self !== "undefined" ? self : this, (() => (function (t) { function e(r) { if (n[r]) return n[r].exports; const i = n[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, e), i.l = !0, i.exports; } var n = {}; return e.m = t, e.c = n, e.d = function (t, n, r) { e.o(t, n) || Object.defineProperty(t, n, { configurable: !1, enumerable: !0, get: r }); }, e.n = function (t) { const n = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return e.d(n, "a", n), n; }, e.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, e.p = "", e(e.s = 45); }([function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = n(17); const i = n(18); const o = n(19); const s = n(48); const a = n(49); const l = n(50); const u = n(51); const c = n(52); const d = n(11); const h = n(29); const p = n(30); const f = n(28); const m = n(1); const g = {
    Scope: m.Scope,
    create: m.create,
    find: m.find,
    query: m.query,
    register: m.register,
    Container: r.default,
    Format: i.default,
    Leaf: o.default,
    Embed: u.default,
    Scroll: s.default,
    Block: l.default,
    Inline: a.default,
    Text: c.default,
    Attributor: {
      Attribute: d.default, Class: h.default, Style: p.default, Store: f.default,
    },
  }; e.default = g;
}, function (t, e, n) {
  function r(t, e) { let n; if (void 0 === e && (e = s.ANY), typeof t === "string")n = c[t] || a[t]; else if (t instanceof Text || t.nodeType === Node.TEXT_NODE)n = c.text; else if (typeof t === "number")t & s.LEVEL & s.BLOCK ? n = c.block : t & s.LEVEL & s.INLINE && (n = c.inline); else if (t instanceof HTMLElement) { const r = (t.getAttribute("class") || "").split(/\s+/); for (const i in r) if (n = l[r[i]]) break; n = n || u[t.tagName]; } return n == null ? null : e & s.LEVEL & n.scope && e & s.TYPE & n.scope ? n : null; } const i = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) { function e(e) { let n = this; return e = `[Parchment] ${e}`, (n = t.call(this, e) || this).message = e, n.name = n.constructor.name, n; } return i(e, t), e; }(Error)); e.ParchmentError = o; let s; var a = {}; var l = {}; var u = {}; var c = {}; e.DATA_KEY = "__blot", (function (t) { t[t.TYPE = 3] = "TYPE", t[t.LEVEL = 12] = "LEVEL", t[t.ATTRIBUTE = 13] = "ATTRIBUTE", t[t.BLOT = 14] = "BLOT", t[t.INLINE = 7] = "INLINE", t[t.BLOCK = 11] = "BLOCK", t[t.BLOCK_BLOT = 10] = "BLOCK_BLOT", t[t.INLINE_BLOT = 6] = "INLINE_BLOT", t[t.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t[t.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t[t.ANY = 15] = "ANY"; }(s = e.Scope || (e.Scope = {}))), e.create = function (t, e) { const n = r(t); if (n == null) throw new o(`Unable to create ${t} blot`); const i = n; return new i(t instanceof Node || t.nodeType === Node.TEXT_NODE ? t : i.create(e), e); }, e.find = function t(n, r) { return void 0 === r && (r = !1), n == null ? null : n[e.DATA_KEY] != null ? n[e.DATA_KEY].blot : r ? t(n.parentNode, r) : null; }, e.query = r, e.register = function t() { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; if (e.length > 1) return e.map(((e) => t(e))); const r = e[0]; if (typeof r.blotName !== "string" && typeof r.attrName !== "string") throw new o("Invalid definition"); if (r.blotName === "abstract") throw new o("Cannot register abstract class"); if (c[r.blotName || r.attrName] = r, typeof r.keyName === "string")a[r.keyName] = r; else if (r.className != null && (l[r.className] = r), r.tagName != null) { Array.isArray(r.tagName) ? r.tagName = r.tagName.map(((t) => t.toUpperCase())) : r.tagName = r.tagName.toUpperCase(); const i = Array.isArray(r.tagName) ? r.tagName : [r.tagName]; i.forEach(((t) => { u[t] != null && r.className != null || (u[t] = r); })); } return r; };
}, function (t, e) {
  const n = Object.prototype.hasOwnProperty; const r = Object.prototype.toString; const i = Object.defineProperty; const o = Object.getOwnPropertyDescriptor; const s = function (t) { return typeof Array.isArray === "function" ? Array.isArray(t) : r.call(t) === "[object Array]"; }; const a = function (t) { if (!t || r.call(t) !== "[object Object]") return !1; let e; const i = n.call(t, "constructor"); const o = t.constructor && t.constructor.prototype && n.call(t.constructor.prototype, "isPrototypeOf"); if (t.constructor && !i && !o) return !1; for (e in t);return void 0 === e || n.call(t, e); }; const l = function (t, e) {
    i && e.name === "__proto__" ? i(t, e.name, {
      enumerable: !0, configurable: !0, value: e.newValue, writable: !0,
    }) : t[e.name] = e.newValue;
  }; const u = function (t, e) { if (e === "__proto__") { if (!n.call(t, e)) return; if (o) return o(t, e).value; } return t[e]; }; t.exports = function t() { let e; let n; let r; let i; let o; let c; let d = arguments[0]; let h = 1; const p = arguments.length; let f = !1; for (typeof d === "boolean" && (f = d, d = arguments[1] || {}, h = 2), (d == null || typeof d !== "object" && typeof d !== "function") && (d = {}); h < p; ++h) if ((e = arguments[h]) != null) for (n in e)r = u(d, n), d !== (i = u(e, n)) && (f && i && (a(i) || (o = s(i))) ? (o ? (o = !1, c = r && s(r) ? r : []) : c = r && a(r) ? r : {}, l(d, { name: n, newValue: t(f, c, i) })) : void 0 !== i && l(d, { name: n, newValue: i })); return d; };
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  } function a(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return t == null ? e : (typeof t.formats === "function" && (e = (0, c.default)(e, t.formats())), t.parent == null || t.parent.blotName == "scroll" || t.parent.statics.scope !== t.statics.scope ? e : a(t.parent, e)); }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.BlockEmbed = e.bubbleFormats = void 0; const l = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const u = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; var c = r(n(2)); const d = r(n(4)); const h = r(n(0)); const p = r(n(14)); const f = r(n(5)); const m = r(n(8)); const g = (function (t) { function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return s(e, t), l(e, [{ key: "attach", value() { u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "attach", this).call(this), this.attributes = new h.default.Attributor.Store(this.domNode); } }, { key: "delta", value() { return (new d.default()).insert(this.value(), (0, c.default)(this.formats(), this.attributes.values())); } }, { key: "format", value(t, e) { const n = h.default.query(t, h.default.Scope.BLOCK_ATTRIBUTE); n != null && this.attributes.attribute(n, e); } }, { key: "formatAt", value(t, e, n, r) { this.format(n, r); } }, { key: "insertAt", value(t, n, r) { if (typeof n === "string" && n.endsWith("\n")) { const i = h.default.create(v.blotName); this.parent.insertBefore(i, t === 0 ? this : this.next), i.insertAt(0, n.slice(0, -1)); } else u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, t, n, r); } }]), e; }(h.default.Embed)); g.scope = h.default.Scope.BLOCK_BLOT; var v = (function (t) { function e(t) { i(this, e); const n = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)); return n.cache = {}, n; } return s(e, t), l(e, [{ key: "delta", value() { return this.cache.delta == null && (this.cache.delta = this.descendants(h.default.Leaf).reduce(((t, e) => (e.length() === 0 ? t : t.insert(e.value(), a(e)))), new d.default()).insert("\n", a(this))), this.cache.delta; } }, { key: "deleteAt", value(t, n) { u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "deleteAt", this).call(this, t, n), this.cache = {}; } }, { key: "formatAt", value(t, n, r, i) { n <= 0 || (h.default.query(r, h.default.Scope.BLOCK) ? t + n === this.length() && this.format(r, i) : u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "formatAt", this).call(this, t, Math.min(n, this.length() - t - 1), r, i), this.cache = {}); } }, { key: "insertAt", value(t, n, r) { if (r != null) return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, t, n, r); if (n.length !== 0) { const i = n.split("\n"); const o = i.shift(); o.length > 0 && (t < this.length() - 1 || this.children.tail == null ? u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, Math.min(t, this.length() - 1), o) : this.children.tail.insertAt(this.children.tail.length(), o), this.cache = {}); let s = this; i.reduce(((t, e) => ((s = s.split(t, !0)).insertAt(0, e), e.length)), t + o.length); } } }, { key: "insertBefore", value(t, n) { const r = this.children.head; u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertBefore", this).call(this, t, n), r instanceof p.default && r.remove(), this.cache = {}; } }, { key: "length", value() { return this.cache.length == null && (this.cache.length = u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "length", this).call(this) + 1), this.cache.length; } }, { key: "moveChildren", value(t, n) { u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "moveChildren", this).call(this, t, n), this.cache = {}; } }, { key: "optimize", value(t) { u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t), this.cache = {}; } }, { key: "path", value(t) { return u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "path", this).call(this, t, !0); } }, { key: "removeChild", value(t) { u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "removeChild", this).call(this, t), this.cache = {}; } }, { key: "split", value(t) { const n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (n && (t === 0 || t >= this.length() - 1)) { const r = this.clone(); return t === 0 ? (this.parent.insertBefore(r, this), this) : (this.parent.insertBefore(r, this.next), r); } const i = u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "split", this).call(this, t, n); return this.cache = {}, i; } }]), e; }(h.default.Block)); v.blotName = "block", v.tagName = "P", v.defaultChild = "break", v.allowedChildren = [f.default, h.default.Embed, m.default], e.bubbleFormats = a, e.BlockEmbed = g, e.default = v;
}, function (t, e, n) { const r = n(54); const i = n(12); const o = n(2); const s = n(20); const a = String.fromCharCode(0); const l = function (t) { Array.isArray(t) ? this.ops = t : t != null && Array.isArray(t.ops) ? this.ops = t.ops : this.ops = []; }; l.prototype.insert = function (t, e) { const n = {}; return t.length === 0 ? this : (n.insert = t, e != null && typeof e === "object" && Object.keys(e).length > 0 && (n.attributes = e), this.push(n)); }, l.prototype.delete = function (t) { return t <= 0 ? this : this.push({ delete: t }); }, l.prototype.retain = function (t, e) { if (t <= 0) return this; const n = { retain: t }; return e != null && typeof e === "object" && Object.keys(e).length > 0 && (n.attributes = e), this.push(n); }, l.prototype.push = function (t) { let e = this.ops.length; let n = this.ops[e - 1]; if (t = o(!0, {}, t), typeof n === "object") { if (typeof t.delete === "number" && typeof n.delete === "number") return this.ops[e - 1] = { delete: n.delete + t.delete }, this; if (typeof n.delete === "number" && t.insert != null && (e -= 1, typeof (n = this.ops[e - 1]) !== "object")) return this.ops.unshift(t), this; if (i(t.attributes, n.attributes)) { if (typeof t.insert === "string" && typeof n.insert === "string") return this.ops[e - 1] = { insert: n.insert + t.insert }, typeof t.attributes === "object" && (this.ops[e - 1].attributes = t.attributes), this; if (typeof t.retain === "number" && typeof n.retain === "number") return this.ops[e - 1] = { retain: n.retain + t.retain }, typeof t.attributes === "object" && (this.ops[e - 1].attributes = t.attributes), this; } } return e === this.ops.length ? this.ops.push(t) : this.ops.splice(e, 0, t), this; }, l.prototype.chop = function () { const t = this.ops[this.ops.length - 1]; return t && t.retain && !t.attributes && this.ops.pop(), this; }, l.prototype.filter = function (t) { return this.ops.filter(t); }, l.prototype.forEach = function (t) { this.ops.forEach(t); }, l.prototype.map = function (t) { return this.ops.map(t); }, l.prototype.partition = function (t) { const e = []; const n = []; return this.forEach(((r) => { (t(r) ? e : n).push(r); })), [e, n]; }, l.prototype.reduce = function (t, e) { return this.ops.reduce(t, e); }, l.prototype.changeLength = function () { return this.reduce(((t, e) => (e.insert ? t + s.length(e) : e.delete ? t - e.delete : t)), 0); }, l.prototype.length = function () { return this.reduce(((t, e) => t + s.length(e)), 0); }, l.prototype.slice = function (t, e) { t = t || 0, typeof e !== "number" && (e = 1 / 0); for (var n = [], r = s.iterator(this.ops), i = 0; i < e && r.hasNext();) { var o; i < t ? o = r.next(t - i) : (o = r.next(e - i), n.push(o)), i += s.length(o); } return new l(n); }, l.prototype.compose = function (t) { const e = s.iterator(this.ops); const n = s.iterator(t.ops); const r = []; const o = n.peek(); if (o != null && typeof o.retain === "number" && o.attributes == null) { for (var a = o.retain; e.peekType() === "insert" && e.peekLength() <= a;)a -= e.peekLength(), r.push(e.next()); o.retain - a > 0 && n.next(o.retain - a); } for (var u = new l(r); e.hasNext() || n.hasNext();) if (n.peekType() === "insert")u.push(n.next()); else if (e.peekType() === "delete")u.push(e.next()); else { const c = Math.min(e.peekLength(), n.peekLength()); const d = e.next(c); const h = n.next(c); if (typeof h.retain === "number") { const p = {}; typeof d.retain === "number" ? p.retain = c : p.insert = d.insert; const f = s.attributes.compose(d.attributes, h.attributes, typeof d.retain === "number"); if (f && (p.attributes = f), u.push(p), !n.hasNext() && i(u.ops[u.ops.length - 1], p)) { const m = new l(e.rest()); return u.concat(m).chop(); } } else typeof h.delete === "number" && typeof d.retain === "number" && u.push(h); } return u.chop(); }, l.prototype.concat = function (t) { const e = new l(this.ops.slice()); return t.ops.length > 0 && (e.push(t.ops[0]), e.ops = e.ops.concat(t.ops.slice(1))), e; }, l.prototype.diff = function (t, e) { if (this.ops === t.ops) return new l(); const n = [this, t].map(((e) => e.map(((n) => { if (n.insert != null) return typeof n.insert === "string" ? n.insert : a; throw new Error(`diff() called ${e === t ? "on" : "with"} non-document`); })).join(""))); const o = new l(); const u = r(n[0], n[1], e); const c = s.iterator(this.ops); const d = s.iterator(t.ops); return u.forEach(((t) => { for (let e = t[1].length; e > 0;) { let n = 0; switch (t[0]) { case r.INSERT: n = Math.min(d.peekLength(), e), o.push(d.next(n)); break; case r.DELETE: n = Math.min(e, c.peekLength()), c.next(n), o.delete(n); break; case r.EQUAL: n = Math.min(c.peekLength(), d.peekLength(), e); var a = c.next(n); var l = d.next(n); i(a.insert, l.insert) ? o.retain(n, s.attributes.diff(a.attributes, l.attributes)) : o.push(l).delete(n); }e -= n; } })), o.chop(); }, l.prototype.eachLine = function (t, e) { e = e || "\n"; for (var n = s.iterator(this.ops), r = new l(), i = 0; n.hasNext();) { if (n.peekType() !== "insert") return; const o = n.peek(); const a = s.length(o) - n.peekLength(); const u = typeof o.insert === "string" ? o.insert.indexOf(e, a) - a : -1; if (u < 0)r.push(n.next()); else if (u > 0)r.push(n.next(u)); else { if (!1 === t(r, n.next(1).attributes || {}, i)) return; i += 1, r = new l(); } }r.length() > 0 && t(r, {}, i); }, l.prototype.transform = function (t, e) { if (e = !!e, typeof t === "number") return this.transformPosition(t, e); for (var n = s.iterator(this.ops), r = s.iterator(t.ops), i = new l(); n.hasNext() || r.hasNext();) if (n.peekType() !== "insert" || !e && r.peekType() === "insert") if (r.peekType() === "insert")i.push(r.next()); else { const o = Math.min(n.peekLength(), r.peekLength()); const a = n.next(o); const u = r.next(o); if (a.delete) continue; u.delete ? i.push(u) : i.retain(o, s.attributes.transform(a.attributes, u.attributes, e)); } else i.retain(s.length(n.next())); return i.chop(); }, l.prototype.transformPosition = function (t, e) { e = !!e; for (let n = s.iterator(this.ops), r = 0; n.hasNext() && r <= t;) { const i = n.peekLength(); const o = n.peekType(); n.next(), o !== "delete" ? (o === "insert" && (r < t || !e) && (t += i), r += i) : t -= Math.min(i, t - r); } return t; }, t.exports = l; }, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const s = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const a = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const l = r(n(8)); const u = r(n(0)); const c = (function (t) {
    function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), s(e, [{ key: "formatAt", value(t, n, r, i) { if (e.compare(this.statics.blotName, r) < 0 && u.default.query(r, u.default.Scope.BLOT)) { const o = this.isolate(t, n); i && o.wrap(r, i); } else a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "formatAt", this).call(this, t, n, r, i); } }, { key: "optimize", value(t) { if (a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t), this.parent instanceof e && e.compare(this.statics.blotName, this.parent.statics.blotName) > 0) { const n = this.parent.isolate(this.offset(), this.length()); this.moveChildren(n), n.wrap(this); } } }], [{ key: "compare", value(t, n) { const r = e.order.indexOf(t); const i = e.order.indexOf(n); return r >= 0 || i >= 0 ? r - i : t === n ? 0 : t < n ? -1 : 1; } }]), e;
  }(u.default.Inline)); c.allowedChildren = [c, u.default.Embed, l.default], c.order = ["cursor", "inline", "underline", "strike", "italic", "bold", "script", "link", "code"], e.default = c;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : t[e] = n, t;
  } function o(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function s(t, e) { if ((e = (0, b.default)(!0, { container: t, modules: { clipboard: !0, keyboard: !0, history: !0 } }, e)).theme && e.theme !== k.DEFAULTS.theme) { if (e.theme = k.import(`themes/${e.theme}`), e.theme == null) throw new Error(`Invalid theme ${e.theme}. Did you register it?`); } else e.theme = x.default; const n = (0, b.default)(!0, {}, e.theme.DEFAULTS); [n, e].forEach(((t) => { t.modules = t.modules || {}, Object.keys(t.modules).forEach(((e) => { !0 === t.modules[e] && (t.modules[e] = {}); })); })); const r = Object.keys(n.modules).concat(Object.keys(e.modules)).reduce(((t, e) => { const n = k.import(`modules/${e}`); return n == null ? S.error(`Cannot load ${e} module. Are you sure you registered it?`) : t[e] = n.DEFAULTS || {}, t; }), {}); return e.modules != null && e.modules.toolbar && e.modules.toolbar.constructor !== Object && (e.modules.toolbar = { container: e.modules.toolbar }), e = (0, b.default)(!0, {}, k.DEFAULTS, { modules: r }, n, e), ["bounds", "container", "scrollingContainer"].forEach(((t) => { typeof e[t] === "string" && (e[t] = document.querySelector(e[t])); })), e.modules = Object.keys(e.modules).reduce(((t, n) => (e.modules[n] && (t[n] = e.modules[n]), t)), {}), e; } function a(t, e, n, r) { if (this.options.strict && !this.isEnabled() && e === m.default.sources.USER) return new p.default(); let i = n == null ? null : this.getSelection(); const o = this.editor.delta; const s = t(); if (i != null && (!0 === n && (n = i.index), r == null ? i = u(i, s, e) : r !== 0 && (i = u(i, n, r, e)), this.setSelection(i, m.default.sources.SILENT)), s.length() > 0) { let a; let l; const c = [m.default.events.TEXT_CHANGE, s, o, e]; if ((a = this.emitter).emit.apply(a, [m.default.events.EDITOR_CHANGE].concat(c)), e !== m.default.sources.SILENT)(l = this.emitter).emit.apply(l, c); } return s; } function l(t, e, n, r, i) { let o = {}; return typeof t.index === "number" && typeof t.length === "number" ? typeof e !== "number" ? (i = r, r = n, n = e, e = t.length, t = t.index) : (e = t.length, t = t.index) : typeof e !== "number" && (i = r, r = n, n = e, e = 0), (void 0 === n ? "undefined" : c(n)) === "object" ? (o = n, i = r) : typeof n === "string" && (r != null ? o[n] = r : i = n), [t, e, o, i = i || m.default.sources.API]; } function u(t, e, n, r) { if (t == null) return null; let i = void 0; let o = void 0; if (e instanceof p.default) { const s = [t.index, t.index + t.length].map(((t) => e.transformPosition(t, r !== m.default.sources.USER))); const a = d(s, 2); i = a[0], o = a[1]; } else { const l = [t.index, t.index + t.length].map(((t) => (t < e || t === e && r === m.default.sources.USER ? t : n >= 0 ? t + n : Math.max(e, t + n)))); const u = d(l, 2); i = u[0], o = u[1]; } return new y.Range(i, o - i); }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.overload = e.expandConfig = void 0; var c = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }; var d = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const h = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); n(53); var p = r(n(4)); const f = r(n(57)); var m = r(n(9)); const g = r(n(7)); const v = r(n(0)); var y = n(22); const _ = r(y); var b = r(n(2)); const w = r(n(10)); var x = r(n(32)); var S = (0, w.default)("quill"); var k = (function () {
    function t(e) { const n = this; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (o(this, t), this.options = s(e, r), this.container = this.options.container, this.container == null) return S.error("Invalid Quill container", e); this.options.debug && t.debug(this.options.debug); const i = this.container.innerHTML.trim(); this.container.classList.add("ql-container"), this.container.innerHTML = "", this.container.__quill = this, this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.root.setAttribute("data-gramm", !1), this.scrollingContainer = this.options.scrollingContainer || this.root, this.emitter = new m.default(), this.scroll = v.default.create(this.root, { emitter: this.emitter, whitelist: this.options.formats }), this.editor = new f.default(this.scroll), this.selection = new _.default(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.theme.init(), this.emitter.on(m.default.events.EDITOR_CHANGE, ((t) => { t === m.default.events.TEXT_CHANGE && n.root.classList.toggle("ql-blank", n.editor.isBlank()); })), this.emitter.on(m.default.events.SCROLL_UPDATE, ((t, e) => { const r = n.selection.lastRange; const i = r && r.length === 0 ? r.index : void 0; a.call(n, (() => n.editor.update(null, e, i)), t); })); const l = this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">${i}<p><br></p></div>`); this.setContents(l), this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable(); } return h(t, null, [{ key: "debug", value(t) { !0 === t && (t = "log"), w.default.level(t); } }, { key: "find", value(t) { return t.__quill || v.default.find(t); } }, { key: "import", value(t) { return this.imports[t] == null && S.error(`Cannot import ${t}. Are you sure it was registered?`), this.imports[t]; } }, { key: "register", value(t, e) { const n = this; const r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (typeof t !== "string") { const i = t.attrName || t.blotName; typeof i === "string" ? this.register(`formats/${i}`, t, e) : Object.keys(t).forEach(((r) => { n.register(r, t[r], e); })); } else this.imports[t] == null || r || S.warn(`Overwriting ${t} with`, e), this.imports[t] = e, (t.startsWith("blots/") || t.startsWith("formats/")) && e.blotName !== "abstract" ? v.default.register(e) : t.startsWith("modules") && typeof e.register === "function" && e.register(); } }]), h(t, [{ key: "addContainer", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (typeof t === "string") { const n = t; (t = document.createElement("div")).classList.add(n); } return this.container.insertBefore(t, e), t; } }, { key: "blur", value() { this.selection.setRange(null); } }, { key: "deleteText", value(t, e, n) { const r = this; const i = l(t, e, n); const o = d(i, 4); return t = o[0], e = o[1], n = o[3], a.call(this, (() => r.editor.deleteText(t, e)), n, t, -1 * e); } }, { key: "disable", value() { this.enable(!1); } }, { key: "enable", value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.scroll.enable(t), this.container.classList.toggle("ql-disabled", !t); } }, { key: "focus", value() { const t = this.scrollingContainer.scrollTop; this.selection.focus(), this.scrollingContainer.scrollTop = t, this.scrollIntoView(); } }, { key: "format", value(t, e) { const n = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m.default.sources.API; return a.call(this, (() => { const r = n.getSelection(!0); let o = new p.default(); if (r == null) return o; if (v.default.query(t, v.default.Scope.BLOCK))o = n.editor.formatLine(r.index, r.length, i({}, t, e)); else { if (r.length === 0) return n.selection.format(t, e), o; o = n.editor.formatText(r.index, r.length, i({}, t, e)); } return n.setSelection(r, m.default.sources.SILENT), o; }), r); } }, { key: "formatLine", value(t, e, n, r, i) { let o; const s = this; const u = l(t, e, n, r, i); const c = d(u, 4); return t = c[0], e = c[1], o = c[2], i = c[3], a.call(this, (() => s.editor.formatLine(t, e, o)), i, t, 0); } }, { key: "formatText", value(t, e, n, r, i) { let o; const s = this; const u = l(t, e, n, r, i); const c = d(u, 4); return t = c[0], e = c[1], o = c[2], i = c[3], a.call(this, (() => s.editor.formatText(t, e, o)), i, t, 0); } }, {
      key: "getBounds",
      value(t) {
        const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; let n = void 0; n = typeof t === "number" ? this.selection.getBounds(t, e) : this.selection.getBounds(t.index, t.length); const r = this.container.getBoundingClientRect(); return {
          bottom: n.bottom - r.top, height: n.height, left: n.left - r.left, right: n.right - r.left, top: n.top - r.top, width: n.width,
        };
      },
    }, { key: "getContents", value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t; const n = l(t, e); const r = d(n, 2); return t = r[0], e = r[1], this.editor.getContents(t, e); } }, { key: "getFormat", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(!0); const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; return typeof t === "number" ? this.editor.getFormat(t, e) : this.editor.getFormat(t.index, t.length); } }, { key: "getIndex", value(t) { return t.offset(this.scroll); } }, { key: "getLength", value() { return this.scroll.length(); } }, { key: "getLeaf", value(t) { return this.scroll.leaf(t); } }, { key: "getLine", value(t) { return this.scroll.line(t); } }, { key: "getLines", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE; return typeof t !== "number" ? this.scroll.lines(t.index, t.length) : this.scroll.lines(t, e); } }, { key: "getModule", value(t) { return this.theme.modules[t]; } }, { key: "getSelection", value() { return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0]; } }, { key: "getText", value() { let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t; const n = l(t, e); const r = d(n, 2); return t = r[0], e = r[1], this.editor.getText(t, e); } }, { key: "hasFocus", value() { return this.selection.hasFocus(); } }, { key: "insertEmbed", value(e, n, r) { const i = this; const o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.sources.API; return a.call(this, (() => i.editor.insertEmbed(e, n, r)), o, e); } }, { key: "insertText", value(t, e, n, r, i) { let o; const s = this; const u = l(t, 0, n, r, i); const c = d(u, 4); return t = c[0], o = c[2], i = c[3], a.call(this, (() => s.editor.insertText(t, e, o)), i, t, e.length); } }, { key: "isEnabled", value() { return !this.container.classList.contains("ql-disabled"); } }, { key: "off", value() { return this.emitter.off.apply(this.emitter, arguments); } }, { key: "on", value() { return this.emitter.on.apply(this.emitter, arguments); } }, { key: "once", value() { return this.emitter.once.apply(this.emitter, arguments); } }, { key: "pasteHTML", value(t, e, n) { this.clipboard.dangerouslyPasteHTML(t, e, n); } }, { key: "removeFormat", value(t, e, n) { const r = this; const i = l(t, e, n); const o = d(i, 4); return t = o[0], e = o[1], n = o[3], a.call(this, (() => r.editor.removeFormat(t, e)), n, t); } }, { key: "scrollIntoView", value() { this.selection.scrollIntoView(this.scrollingContainer); } }, { key: "setContents", value(t) { const e = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API; return a.call(this, (() => { t = new p.default(t); const n = e.getLength(); const r = e.editor.deleteText(0, n); const i = e.editor.applyDelta(t); const o = i.ops[i.ops.length - 1]; return o != null && typeof o.insert === "string" && o.insert[o.insert.length - 1] === "\n" && (e.editor.deleteText(e.getLength() - 1, 1), i.delete(1)), r.compose(i); }), n); } }, { key: "setSelection", value(e, n, r) { if (e == null) this.selection.setRange(null, n || t.sources.API); else { const i = l(e, n, r); const o = d(i, 4); e = o[0], n = o[1], r = o[3], this.selection.setRange(new y.Range(e, n), r), r !== m.default.sources.SILENT && this.selection.scrollIntoView(this.scrollingContainer); } } }, { key: "setText", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API; const n = (new p.default()).insert(t); return this.setContents(n, e); } }, { key: "update", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m.default.sources.USER; const e = this.scroll.update(t); return this.selection.update(t), e; } }, { key: "updateContents", value(t) { const e = this; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.default.sources.API; return a.call(this, (() => (t = new p.default(t), e.editor.applyDelta(t, n))), n, !0); } }]), t;
  }()); k.DEFAULTS = {
    bounds: null, formats: null, modules: {}, placeholder: "", readOnly: !1, scrollingContainer: null, strict: !0, theme: "default",
  }, k.events = m.default.events, k.sources = m.default.sources, k.version = "1.3.7", k.imports = {
    delta: p.default, parchment: v.default, "core/module": g.default, "core/theme": x.default,
  }, e.expandConfig = s, e.overload = l, e.default = k;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }Object.defineProperty(e, "__esModule", { value: !0 }); const i = function t(e) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; r(this, t), this.quill = e, this.options = n; }; i.DEFAULTS = {}, e.default = i;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))).default.Text)); e.default = o;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; }Object.defineProperty(e, "__esModule", { value: !0 }); const i = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const o = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const s = r(n(58)); const a = (0, r(n(10)).default)("quill:events"); ["selectionchange", "mousedown", "mouseup", "click"].forEach(((t) => { document.addEventListener(t, (function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; [].slice.call(document.querySelectorAll(".ql-container")).forEach(((t) => { let n; t.__quill && t.__quill.emitter && (n = t.__quill.emitter).handleDOM.apply(n, e); })); })); })); const l = (function (t) {
    function e() { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const t = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this))); return t.listeners = {}, t.on("error", a.error), t; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), i(e, [{ key: "emit", value() { a.log.apply(a, arguments), o(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "emit", this).apply(this, arguments); } }, { key: "handleDOM", value(t) { for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; (this.listeners[t.type] || []).forEach(((e) => { const r = e.node; const i = e.handler; (t.target === r || r.contains(t.target)) && i.apply(void 0, [t].concat(n)); })); } }, { key: "listenDOM", value(t, e, n) { this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push({ node: e, handler: n }); } }]), e;
  }(s.default)); l.events = {
    EDITOR_CHANGE: "editor-change", SCROLL_BEFORE_UPDATE: "scroll-before-update", SCROLL_OPTIMIZE: "scroll-optimize", SCROLL_UPDATE: "scroll-update", SELECTION_CHANGE: "selection-change", TEXT_CHANGE: "text-change",
  }, l.sources = { API: "api", SILENT: "silent", USER: "user" }, e.default = l;
}, function (t, e, n) {
  function r(t) { if (o.indexOf(t) <= o.indexOf(s)) { for (var e, n = arguments.length, r = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; (e = console)[t].apply(e, r); } } function i(t) { return o.reduce(((e, n) => (e[n] = r.bind(console, n, t), e)), {}); }Object.defineProperty(e, "__esModule", { value: !0 }); var o = ["error", "warn", "log", "info"]; var s = "warn"; r.level = i.level = function (t) { s = t; }, e.default = i;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = n(1); const i = (function () { function t(t, e, n) { void 0 === n && (n = {}), this.attrName = t, this.keyName = e; const i = r.Scope.TYPE & r.Scope.ATTRIBUTE; n.scope != null ? this.scope = n.scope & r.Scope.LEVEL | i : this.scope = r.Scope.ATTRIBUTE, n.whitelist != null && (this.whitelist = n.whitelist); } return t.keys = function (t) { return [].map.call(t.attributes, ((t) => t.name)); }, t.prototype.add = function (t, e) { return !!this.canAdd(t, e) && (t.setAttribute(this.keyName, e), !0); }, t.prototype.canAdd = function (t, e) { return r.query(t, r.Scope.BLOT & (this.scope | r.Scope.TYPE)) != null && (this.whitelist == null || (typeof e === "string" ? this.whitelist.indexOf(e.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e) > -1)); }, t.prototype.remove = function (t) { t.removeAttribute(this.keyName); }, t.prototype.value = function (t) { const e = t.getAttribute(this.keyName); return this.canAdd(t, e) && e ? e : ""; }, t; }()); e.default = i;
}, function (t, e, n) { function r(t) { return t == null; } function i(t) { return !(!t || typeof t !== "object" || typeof t.length !== "number" || typeof t.copy !== "function" || typeof t.slice !== "function" || t.length > 0 && typeof t[0] !== "number"); } const o = Array.prototype.slice; const s = n(55); const a = n(56); var l = t.exports = function (t, e, n) { return n || (n = {}), t === e || (t instanceof Date && e instanceof Date ? t.getTime() === e.getTime() : !t || !e || typeof t !== "object" && typeof e !== "object" ? n.strict ? t === e : t == e : (function (t, e, n) { let u; let c; if (r(t) || r(e)) return !1; if (t.prototype !== e.prototype) return !1; if (a(t)) return !!a(e) && (t = o.call(t), e = o.call(e), l(t, e, n)); if (i(t)) { if (!i(e)) return !1; if (t.length !== e.length) return !1; for (u = 0; u < t.length; u++) if (t[u] !== e[u]) return !1; return !0; } try { var d = s(t); var h = s(e); } catch (t) { return !1; } if (d.length != h.length) return !1; for (d.sort(), h.sort(), u = d.length - 1; u >= 0; u--) if (d[u] != h[u]) return !1; for (u = d.length - 1; u >= 0; u--) if (c = d[u], !l(t[c], e[c], n)) return !1; return typeof t === typeof e; }(t, e, n))); }; }, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.Code = void 0; const a = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const l = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const u = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const c = r(n(4)); const d = r(n(0)); const h = r(n(3)); const p = r(n(5)); const f = r(n(8)); const m = (function (t) { function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return s(e, t), e; }(p.default)); m.blotName = "code", m.tagName = "CODE"; const g = (function (t) { function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return s(e, t), l(e, [{ key: "delta", value() { const t = this; let e = this.domNode.textContent; return e.endsWith("\n") && (e = e.slice(0, -1)), e.split("\n").reduce(((e, n) => e.insert(n).insert("\n", t.formats())), new c.default()); } }, { key: "format", value(t, n) { if (t !== this.statics.blotName || !n) { const r = this.descendant(f.default, this.length() - 1); const i = a(r, 1)[0]; i != null && i.deleteAt(i.length() - 1, 1), u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n); } } }, { key: "formatAt", value(t, n, r, i) { if (n !== 0 && d.default.query(r, d.default.Scope.BLOCK) != null && (r !== this.statics.blotName || i !== this.statics.formats(this.domNode))) { const o = this.newlineIndex(t); if (!(o < 0 || o >= t + n)) { const s = this.newlineIndex(t, !0) + 1; const a = o - s + 1; const l = this.isolate(s, a); const u = l.next; l.format(r, i), u instanceof e && u.formatAt(0, t - s + n - a, r, i); } } } }, { key: "insertAt", value(t, e, n) { if (n == null) { const r = this.descendant(f.default, t); const i = a(r, 2); const o = i[0]; const s = i[1]; o.insertAt(s, e); } } }, { key: "length", value() { const t = this.domNode.textContent.length; return this.domNode.textContent.endsWith("\n") ? t : t + 1; } }, { key: "newlineIndex", value(t) { if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) return this.domNode.textContent.slice(0, t).lastIndexOf("\n"); const e = this.domNode.textContent.slice(t).indexOf("\n"); return e > -1 ? t + e : -1; } }, { key: "optimize", value(t) { this.domNode.textContent.endsWith("\n") || this.appendChild(d.default.create("text", "\n")), u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t); const n = this.next; n != null && n.prev === this && n.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === n.statics.formats(n.domNode) && (n.optimize(t), n.moveChildren(this), n.remove()); } }, { key: "replace", value(t) { u(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replace", this).call(this, t), [].slice.call(this.domNode.querySelectorAll("*")).forEach(((t) => { const e = d.default.find(t); e == null ? t.parentNode.removeChild(t) : e instanceof d.default.Embed ? e.remove() : e.unwrap(); })); } }], [{ key: "create", value(t) { const n = u(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t); return n.setAttribute("spellcheck", !1), n; } }, { key: "formats", value() { return !0; } }]), e; }(h.default)); g.blotName = "code-block", g.tagName = "PRE", g.TAB = "  ", e.Code = m, e.default = g;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "insertInto", value(t, n) { t.children.length === 0 ? (function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertInto", this)).call(this, t, n) : this.remove(); } }, { key: "length", value() { return 0; } }, { key: "value", value() { return ""; } }], [{ key: "value", value() {} }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))).default.Embed)); s.blotName = "break", s.tagName = "BR", e.default = s;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function o(t, e) { const n = document.createElement("a"); n.href = t; const r = n.href.slice(0, n.href.indexOf(":")); return e.indexOf(r) > -1; }Object.defineProperty(e, "__esModule", { value: !0 }), e.sanitize = e.default = void 0; const s = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const a = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const l = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), s(e, [{ key: "format", value(t, n) { if (t !== this.statics.blotName || !n) return a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n); n = this.constructor.sanitize(n), this.domNode.setAttribute("href", n); } }], [{ key: "create", value(t) { const n = a(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t); return t = this.sanitize(t), n.setAttribute("href", t), n.setAttribute("rel", "noopener noreferrer"), n.setAttribute("target", "_blank"), n; } }, { key: "formats", value(t) { return t.getAttribute("href"); } }, { key: "sanitize", value(t) { return o(t, this.PROTOCOL_WHITELIST) ? t : this.SANITIZED_URL; } }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(5))).default)); l.blotName = "link", l.tagName = "A", l.SANITIZED_URL = "about:blank", l.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"], e.default = l, e.sanitize = o;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { t.setAttribute(e, !(t.getAttribute(e) === "true")); }Object.defineProperty(e, "__esModule", { value: !0 }); const o = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }; const s = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const a = r(n(25)); const l = r(n(106)); let u = 0; const c = (function () { function t(e) { const n = this; (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.select = e, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", (() => { n.togglePicker(); })), this.label.addEventListener("keydown", ((t) => { switch (t.keyCode) { case a.default.keys.ENTER: n.togglePicker(); break; case a.default.keys.ESCAPE: n.escape(), t.preventDefault(); } })), this.select.addEventListener("change", this.update.bind(this)); } return s(t, [{ key: "togglePicker", value() { this.container.classList.toggle("ql-expanded"), i(this.label, "aria-expanded"), i(this.options, "aria-hidden"); } }, { key: "buildItem", value(t) { const e = this; const n = document.createElement("span"); return n.tabIndex = "0", n.setAttribute("role", "button"), n.classList.add("ql-picker-item"), t.hasAttribute("value") && n.setAttribute("data-value", t.getAttribute("value")), t.textContent && n.setAttribute("data-label", t.textContent), n.addEventListener("click", (() => { e.selectItem(n, !0); })), n.addEventListener("keydown", ((t) => { switch (t.keyCode) { case a.default.keys.ENTER: e.selectItem(n, !0), t.preventDefault(); break; case a.default.keys.ESCAPE: e.escape(), t.preventDefault(); } })), n; } }, { key: "buildLabel", value() { const t = document.createElement("span"); return t.classList.add("ql-picker-label"), t.innerHTML = l.default, t.tabIndex = "0", t.setAttribute("role", "button"), t.setAttribute("aria-expanded", "false"), this.container.appendChild(t), t; } }, { key: "buildOptions", value() { const t = this; const e = document.createElement("span"); e.classList.add("ql-picker-options"), e.setAttribute("aria-hidden", "true"), e.tabIndex = "-1", e.id = `ql-picker-options-${u}`, u += 1, this.label.setAttribute("aria-controls", e.id), this.options = e, [].slice.call(this.select.options).forEach(((n) => { const r = t.buildItem(n); e.appendChild(r), !0 === n.selected && t.selectItem(r); })), this.container.appendChild(e); } }, { key: "buildPicker", value() { const t = this; [].slice.call(this.select.attributes).forEach(((e) => { t.container.setAttribute(e.name, e.value); })), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions(); } }, { key: "escape", value() { const t = this; this.close(), setTimeout((() => t.label.focus()), 1); } }, { key: "close", value() { this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true"); } }, { key: "selectItem", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = this.container.querySelector(".ql-selected"); if (t !== n && (n != null && n.classList.remove("ql-selected"), t != null && (t.classList.add("ql-selected"), this.select.selectedIndex = [].indexOf.call(t.parentNode.children, t), t.hasAttribute("data-value") ? this.label.setAttribute("data-value", t.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t.hasAttribute("data-label") ? this.label.setAttribute("data-label", t.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e))) { if (typeof Event === "function") this.select.dispatchEvent(new Event("change")); else if ((typeof Event === "undefined" ? "undefined" : o(Event)) === "object") { const r = document.createEvent("Event"); r.initEvent("change", !0, !0), this.select.dispatchEvent(r); } this.close(); } } }, { key: "update", value() { let t = void 0; if (this.select.selectedIndex > -1) { const e = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]; t = this.select.options[this.select.selectedIndex], this.selectItem(e); } else this.selectItem(null); const n = t != null && t !== this.select.querySelector("option[selected]"); this.label.classList.toggle("ql-active", n); } }]), t; }()); e.default = c;
}, function (t, e, n) {
  function r(t) { let e = a.find(t); if (e == null) try { e = a.create(t); } catch (n) { e = a.create(a.Scope.INLINE), [].slice.call(t.childNodes).forEach(((t) => { e.domNode.appendChild(t); })), t.parentNode && t.parentNode.replaceChild(e.domNode, t), e.attach(); } return e; } const i = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const o = n(47); const s = n(27); var a = n(1); const l = (function (t) { function e(e) { const n = t.call(this, e) || this; return n.build(), n; } return i(e, t), e.prototype.appendChild = function (t) { this.insertBefore(t); }, e.prototype.attach = function () { t.prototype.attach.call(this), this.children.forEach(((t) => { t.attach(); })); }, e.prototype.build = function () { const t = this; this.children = new o.default(), [].slice.call(this.domNode.childNodes).reverse().forEach(((e) => { try { const n = r(e); t.insertBefore(n, t.children.head || void 0); } catch (t) { if (t instanceof a.ParchmentError) return; throw t; } })); }, e.prototype.deleteAt = function (t, e) { if (t === 0 && e === this.length()) return this.remove(); this.children.forEachAt(t, e, ((t, e, n) => { t.deleteAt(e, n); })); }, e.prototype.descendant = function (t, n) { const r = this.children.find(n); const i = r[0]; const o = r[1]; return t.blotName == null && t(i) || t.blotName != null && i instanceof t ? [i, o] : i instanceof e ? i.descendant(t, o) : [null, -1]; }, e.prototype.descendants = function (t, n, r) { void 0 === n && (n = 0), void 0 === r && (r = Number.MAX_VALUE); let i = []; let o = r; return this.children.forEachAt(n, r, ((n, r, s) => { (t.blotName == null && t(n) || t.blotName != null && n instanceof t) && i.push(n), n instanceof e && (i = i.concat(n.descendants(t, r, o))), o -= s; })), i; }, e.prototype.detach = function () { this.children.forEach(((t) => { t.detach(); })), t.prototype.detach.call(this); }, e.prototype.formatAt = function (t, e, n, r) { this.children.forEachAt(t, e, ((t, e, i) => { t.formatAt(e, i, n, r); })); }, e.prototype.insertAt = function (t, e, n) { const r = this.children.find(t); const i = r[0]; const o = r[1]; if (i)i.insertAt(o, e, n); else { const s = n == null ? a.create("text", e) : a.create(e, n); this.appendChild(s); } }, e.prototype.insertBefore = function (t, e) { if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(((e) => t instanceof e))) throw new a.ParchmentError(`Cannot insert ${t.statics.blotName} into ${this.statics.blotName}`); t.insertInto(this, e); }, e.prototype.length = function () { return this.children.reduce(((t, e) => t + e.length()), 0); }, e.prototype.moveChildren = function (t, e) { this.children.forEach(((n) => { t.insertBefore(n, e); })); }, e.prototype.optimize = function (e) { if (t.prototype.optimize.call(this, e), this.children.length === 0) if (this.statics.defaultChild != null) { const n = a.create(this.statics.defaultChild); this.appendChild(n), n.optimize(e); } else this.remove(); }, e.prototype.path = function (t, n) { void 0 === n && (n = !1); const r = this.children.find(t, n); const i = r[0]; const o = r[1]; const s = [[this, t]]; return i instanceof e ? s.concat(i.path(o, n)) : (i != null && s.push([i, o]), s); }, e.prototype.removeChild = function (t) { this.children.remove(t); }, e.prototype.replace = function (n) { n instanceof e && n.moveChildren(this), t.prototype.replace.call(this, n); }, e.prototype.split = function (t, e) { if (void 0 === e && (e = !1), !e) { if (t === 0) return this; if (t === this.length()) return this.next; } const n = this.clone(); return this.parent.insertBefore(n, this.next), this.children.forEachAt(t, this.length(), ((t, r, i) => { t = t.split(r, e), n.appendChild(t); })), n; }, e.prototype.unwrap = function () { this.moveChildren(this.parent, this.next), this.remove(); }, e.prototype.update = function (t, e) { const n = this; const i = []; const o = []; t.forEach(((t) => { t.target === n.domNode && t.type === "childList" && (i.push.apply(i, t.addedNodes), o.push.apply(o, t.removedNodes)); })), o.forEach(((t) => { if (!(t.parentNode != null && t.tagName !== "IFRAME" && document.body.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY)) { const e = a.find(t); e != null && (e.domNode.parentNode != null && e.domNode.parentNode !== n.domNode || e.detach()); } })), i.filter(((t) => t.parentNode == n.domNode)).sort(((t, e) => (t === e ? 0 : t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1))).forEach(((t) => { let e = null; t.nextSibling != null && (e = a.find(t.nextSibling)); const i = r(t); i.next == e && i.next != null || (i.parent != null && i.parent.removeChild(n), n.insertBefore(i, e || void 0)); })); }, e; }(s.default)); e.default = l;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(11); const o = n(28); const s = n(17); const a = n(1); const l = (function (t) { function e(e) { const n = t.call(this, e) || this; return n.attributes = new o.default(n.domNode), n; } return r(e, t), e.formats = function (t) { return typeof this.tagName === "string" || (Array.isArray(this.tagName) ? t.tagName.toLowerCase() : void 0); }, e.prototype.format = function (t, e) { const n = a.query(t); n instanceof i.default ? this.attributes.attribute(n, e) : e && (n == null || t === this.statics.blotName && this.formats()[t] === e || this.replaceWith(t, e)); }, e.prototype.formats = function () { const t = this.attributes.values(); const e = this.statics.formats(this.domNode); return e != null && (t[this.statics.blotName] = e), t; }, e.prototype.replaceWith = function (e, n) { const r = t.prototype.replaceWith.call(this, e, n); return this.attributes.copy(r), r; }, e.prototype.update = function (e, n) { const r = this; t.prototype.update.call(this, e, n), e.some(((t) => t.target === r.domNode && t.type === "attributes")) && this.attributes.build(); }, e.prototype.wrap = function (n, r) { const i = t.prototype.wrap.call(this, n, r); return i instanceof e && i.statics.scope === this.statics.scope && this.attributes.move(i), i; }, e; }(s.default)); e.default = l;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(27); const o = n(1); const s = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return r(e, t), e.value = function (t) { return !0; }, e.prototype.index = function (t, e) { return this.domNode === t || this.domNode.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e, 1) : -1; }, e.prototype.position = function (t, e) { let n = [].indexOf.call(this.parent.domNode.childNodes, this.domNode); return t > 0 && (n += 1), [this.parent.domNode, n]; }, e.prototype.value = function () { let t; return (t = {})[this.statics.blotName] = this.statics.value(this.domNode) || !0, t; }, e.scope = o.Scope.INLINE_BLOT, e; }(i.default)); e.default = s;
}, function (t, e, n) { function r(t) { this.ops = t, this.index = 0, this.offset = 0; } const i = n(12); const o = n(2); const s = { attributes: { compose(t, e, n) { typeof t !== "object" && (t = {}), typeof e !== "object" && (e = {}); let r = o(!0, {}, e); for (const i in n || (r = Object.keys(r).reduce(((t, e) => (r[e] != null && (t[e] = r[e]), t)), {})), t) void 0 !== t[i] && void 0 === e[i] && (r[i] = t[i]); return Object.keys(r).length > 0 ? r : void 0; }, diff(t, e) { typeof t !== "object" && (t = {}), typeof e !== "object" && (e = {}); const n = Object.keys(t).concat(Object.keys(e)).reduce(((n, r) => (i(t[r], e[r]) || (n[r] = void 0 === e[r] ? null : e[r]), n)), {}); return Object.keys(n).length > 0 ? n : void 0; }, transform(t, e, n) { if (typeof t !== "object") return e; if (typeof e === "object") { if (!n) return e; const r = Object.keys(e).reduce(((n, r) => (void 0 === t[r] && (n[r] = e[r]), n)), {}); return Object.keys(r).length > 0 ? r : void 0; } } }, iterator(t) { return new r(t); }, length(t) { return typeof t.delete === "number" ? t.delete : typeof t.retain === "number" ? t.retain : typeof t.insert === "string" ? t.insert.length : 1; } }; r.prototype.hasNext = function () { return this.peekLength() < 1 / 0; }, r.prototype.next = function (t) { t || (t = 1 / 0); const e = this.ops[this.index]; if (e) { const n = this.offset; const r = s.length(e); if (t >= r - n ? (t = r - n, this.index += 1, this.offset = 0) : this.offset += t, typeof e.delete === "number") return { delete: t }; const i = {}; return e.attributes && (i.attributes = e.attributes), typeof e.retain === "number" ? i.retain = t : typeof e.insert === "string" ? i.insert = e.insert.substr(n, t) : i.insert = e.insert, i; } return { retain: 1 / 0 }; }, r.prototype.peek = function () { return this.ops[this.index]; }, r.prototype.peekLength = function () { return this.ops[this.index] ? s.length(this.ops[this.index]) - this.offset : 1 / 0; }, r.prototype.peekType = function () { return this.ops[this.index] ? typeof this.ops[this.index].delete === "number" ? "delete" : typeof this.ops[this.index].retain === "number" ? "retain" : "insert" : "retain"; }, r.prototype.rest = function () { if (this.hasNext()) { if (this.offset === 0) return this.ops.slice(this.index); const t = this.offset; const e = this.index; const n = this.next(); const r = this.ops.slice(this.index); return this.offset = t, this.index = e, [n].concat(r); } return []; }, t.exports = s; }, function (t, e) {
  const n = (function () {
    function t(t, e) { return e != null && t instanceof e; } function e(n, a, l, u, c) { typeof a === "object" && (l = a.depth, u = a.prototype, c = a.includeNonEnumerable, a = a.circular); const d = []; const h = []; const p = typeof Buffer !== "undefined"; return void 0 === a && (a = !0), void 0 === l && (l = 1 / 0), (function n(l, f) { if (l === null) return null; if (f === 0) return l; let m; let g; if (typeof l !== "object") return l; if (t(l, i))m = new i(); else if (t(l, o))m = new o(); else if (t(l, s))m = new s(((t, e) => { l.then(((e) => { t(n(e, f - 1)); }), ((t) => { e(n(t, f - 1)); })); })); else if (e.__isArray(l))m = []; else if (e.__isRegExp(l))m = new RegExp(l.source, r(l)), l.lastIndex && (m.lastIndex = l.lastIndex); else if (e.__isDate(l))m = new Date(l.getTime()); else { if (p && Buffer.isBuffer(l)) return m = Buffer.allocUnsafe ? Buffer.allocUnsafe(l.length) : new Buffer(l.length), l.copy(m), m; t(l, Error) ? m = Object.create(l) : void 0 === u ? (g = Object.getPrototypeOf(l), m = Object.create(g)) : (m = Object.create(u), g = u); } if (a) { const v = d.indexOf(l); if (v != -1) return h[v]; d.push(l), h.push(m); } for (var y in t(l, i) && l.forEach(((t, e) => { const r = n(e, f - 1); const i = n(t, f - 1); m.set(r, i); })), t(l, o) && l.forEach(((t) => { const e = n(t, f - 1); m.add(e); })), l) { var _; g && (_ = Object.getOwnPropertyDescriptor(g, y)), _ && _.set == null || (m[y] = n(l[y], f - 1)); } if (Object.getOwnPropertySymbols) { const b = Object.getOwnPropertySymbols(l); for (y = 0; y < b.length; y++) { const w = b[y]; (!(S = Object.getOwnPropertyDescriptor(l, w)) || S.enumerable || c) && (m[w] = n(l[w], f - 1), S.enumerable || Object.defineProperty(m, w, { enumerable: !1 })); } } if (c) { const x = Object.getOwnPropertyNames(l); for (y = 0; y < x.length; y++) { var S; const k = x[y]; (S = Object.getOwnPropertyDescriptor(l, k)) && S.enumerable || (m[k] = n(l[k], f - 1), Object.defineProperty(m, k, { enumerable: !1 })); } } return m; }(n, l)); } function n(t) { return Object.prototype.toString.call(t); } function r(t) { let e = ""; return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), e; } let i; let o; let s; try { i = Map; } catch (t) { i = function () {}; } try { o = Set; } catch (t) { o = function () {}; } try { s = Promise; } catch (t) { s = function () {}; } return e.clonePrototype = function (t) { if (t === null) return null; const e = function () {}; return e.prototype = t, new e(); }, e.__objToStr = n, e.__isDate = function (t) { return typeof t === "object" && n(t) === "[object Date]"; }, e.__isArray = function (t) { return typeof t === "object" && n(t) === "[object Array]"; }, e.__isRegExp = function (t) { return typeof t === "object" && n(t) === "[object RegExp]"; }, e.__getRegExpFlags = r, e;
  }()); typeof t === "object" && t.exports && (t.exports = n);
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t) { if (Array.isArray(t)) { for (var e = 0, n = Array(t.length); e < t.length; e++)n[e] = t[e]; return n; } return Array.from(t); } function o(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function s(t, e) { try { e.parentNode; } catch (t) { return !1; } return e instanceof Text && (e = e.parentNode), t.contains(e); }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.Range = void 0; const a = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const l = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const u = r(n(0)); const c = r(n(21)); const d = r(n(12)); const h = r(n(9)); const p = (0, r(n(10)).default)("quill:selection"); const f = function t(e) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; o(this, t), this.index = e, this.length = n; }; const m = (function () {
    function t(e, n) { const r = this; o(this, t), this.emitter = n, this.scroll = e, this.composing = !1, this.mouseDown = !1, this.root = this.scroll.domNode, this.cursor = u.default.create("cursor", this), this.lastRange = this.savedRange = new f(0, 0), this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, (() => { r.mouseDown || setTimeout(r.update.bind(r, h.default.sources.USER), 1); })), this.emitter.on(h.default.events.EDITOR_CHANGE, ((t, e) => { t === h.default.events.TEXT_CHANGE && e.length() > 0 && r.update(h.default.sources.SILENT); })), this.emitter.on(h.default.events.SCROLL_BEFORE_UPDATE, (() => { if (r.hasFocus()) { const t = r.getNativeRange(); t != null && t.start.node !== r.cursor.textNode && r.emitter.once(h.default.events.SCROLL_UPDATE, (() => { try { r.setNativeRange(t.start.node, t.start.offset, t.end.node, t.end.offset); } catch (t) {} })); } })), this.emitter.on(h.default.events.SCROLL_OPTIMIZE, ((t, e) => { if (e.range) { const n = e.range; const i = n.startNode; const o = n.startOffset; const s = n.endNode; const a = n.endOffset; r.setNativeRange(i, o, s, a); } })), this.update(h.default.sources.SILENT); } return l(t, [{ key: "handleComposition", value() { const t = this; this.root.addEventListener("compositionstart", (() => { t.composing = !0; })), this.root.addEventListener("compositionend", (() => { if (t.composing = !1, t.cursor.parent) { const e = t.cursor.restore(); if (!e) return; setTimeout((() => { t.setNativeRange(e.startNode, e.startOffset, e.endNode, e.endOffset); }), 1); } })); } }, { key: "handleDragging", value() { const t = this; this.emitter.listenDOM("mousedown", document.body, (() => { t.mouseDown = !0; })), this.emitter.listenDOM("mouseup", document.body, (() => { t.mouseDown = !1, t.update(h.default.sources.USER); })); } }, { key: "focus", value() { this.hasFocus() || (this.root.focus(), this.setRange(this.savedRange)); } }, { key: "format", value(t, e) { if (this.scroll.whitelist == null || this.scroll.whitelist[t]) { this.scroll.update(); const n = this.getNativeRange(); if (n != null && n.native.collapsed && !u.default.query(t, u.default.Scope.BLOCK)) { if (n.start.node !== this.cursor.textNode) { const r = u.default.find(n.start.node, !1); if (r == null) return; if (r instanceof u.default.Leaf) { const i = r.split(n.start.offset); r.parent.insertBefore(this.cursor, i); } else r.insertBefore(this.cursor, n.start.node); this.cursor.attach(); } this.cursor.format(t, e), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update(); } } } }, {
      key: "getBounds",
      value(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; const n = this.scroll.length(); t = Math.min(t, n - 1), e = Math.min(t + e, n - 1) - t; let r = void 0; const i = this.scroll.leaf(t); const o = a(i, 2); let s = o[0]; let l = o[1]; if (s == null) return null; const u = s.position(l, !0); const c = a(u, 2); r = c[0], l = c[1]; const d = document.createRange(); if (e > 0) { d.setStart(r, l); const h = this.scroll.leaf(t + e); const p = a(h, 2); if (s = p[0], l = p[1], s == null) return null; const f = s.position(l, !0); const m = a(f, 2); return r = m[0], l = m[1], d.setEnd(r, l), d.getBoundingClientRect(); } let g = "left"; let v = void 0; return r instanceof Text ? (l < r.data.length ? (d.setStart(r, l), d.setEnd(r, l + 1)) : (d.setStart(r, l - 1), d.setEnd(r, l), g = "right"), v = d.getBoundingClientRect()) : (v = s.domNode.getBoundingClientRect(), l > 0 && (g = "right")), {
          bottom: v.top + v.height, height: v.height, left: v[g], right: v[g], top: v.top, width: 0,
        };
      }, 
    }, { key: "getNativeRange", value() { const t = document.getSelection(); if (t == null || t.rangeCount <= 0) return null; const e = t.getRangeAt(0); if (e == null) return null; const n = this.normalizeNative(e); return p.info("getNativeRange", n), n; } }, { key: "getRange", value() { const t = this.getNativeRange(); return t == null ? [null, null] : [this.normalizedToRange(t), t]; } }, { key: "hasFocus", value() { return document.activeElement === this.root; } }, { key: "normalizedToRange", value(t) { const e = this; const n = [[t.start.node, t.start.offset]]; t.native.collapsed || n.push([t.end.node, t.end.offset]); const r = n.map(((t) => { const n = a(t, 2); const r = n[0]; const i = n[1]; const o = u.default.find(r, !0); const s = o.offset(e.scroll); return i === 0 ? s : o instanceof u.default.Container ? s + o.length() : s + o.index(r, i); })); const o = Math.min(Math.max.apply(Math, i(r)), this.scroll.length() - 1); const s = Math.min.apply(Math, [o].concat(i(r))); return new f(s, o - s); } }, { key: "normalizeNative", value(t) { if (!s(this.root, t.startContainer) || !t.collapsed && !s(this.root, t.endContainer)) return null; const e = { start: { node: t.startContainer, offset: t.startOffset }, end: { node: t.endContainer, offset: t.endOffset }, native: t }; return [e.start, e.end].forEach(((t) => { for (var e = t.node, n = t.offset; !(e instanceof Text) && e.childNodes.length > 0;) if (e.childNodes.length > n)e = e.childNodes[n], n = 0; else { if (e.childNodes.length !== n) break; n = (e = e.lastChild) instanceof Text ? e.data.length : e.childNodes.length + 1; }t.node = e, t.offset = n; })), e; } }, { key: "rangeToNative", value(t) { const e = this; const n = t.collapsed ? [t.index] : [t.index, t.index + t.length]; let r = []; const i = this.scroll.length(); return n.forEach(((t, n) => { t = Math.min(i - 1, t); let o; const s = e.scroll.leaf(t); const l = a(s, 2); const u = l[0]; let c = l[1]; const d = u.position(c, n !== 0); const h = a(d, 2); o = h[0], c = h[1], r.push(o, c); })), r.length < 2 && (r = r.concat(r)), r; } }, { key: "scrollIntoView", value(t) { const e = this.lastRange; if (e != null) { const n = this.getBounds(e.index, e.length); if (n != null) { const r = this.scroll.length() - 1; const i = this.scroll.line(Math.min(e.index, r)); const o = a(i, 1)[0]; let s = o; if (e.length > 0) { const l = this.scroll.line(Math.min(e.index + e.length, r)); s = a(l, 1)[0]; } if (o != null && s != null) { const u = t.getBoundingClientRect(); n.top < u.top ? t.scrollTop -= u.top - n.top : n.bottom > u.bottom && (t.scrollTop += n.bottom - u.bottom); } } } } }, { key: "setNativeRange", value(t, e) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t; let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e; const i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; if (p.info("setNativeRange", t, e, n, r), t == null || this.root.parentNode != null && t.parentNode != null && n.parentNode != null) { const o = document.getSelection(); if (o != null) if (t != null) { this.hasFocus() || this.root.focus(); const s = (this.getNativeRange() || {}).native; if (s == null || i || t !== s.startContainer || e !== s.startOffset || n !== s.endContainer || r !== s.endOffset) { t.tagName == "BR" && (e = [].indexOf.call(t.parentNode.childNodes, t), t = t.parentNode), n.tagName == "BR" && (r = [].indexOf.call(n.parentNode.childNodes, n), n = n.parentNode); const a = document.createRange(); a.setStart(t, e), a.setEnd(n, r), o.removeAllRanges(), o.addRange(a); } } else o.removeAllRanges(), this.root.blur(), document.body.focus(); } } }, { key: "setRange", value(t) { let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.default.sources.API; if (typeof e === "string" && (n = e, e = !1), p.info("setRange", t), t != null) { const r = this.rangeToNative(t); this.setNativeRange.apply(this, i(r).concat([e])); } else this.setNativeRange(null); this.update(n); } }, { key: "update", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : h.default.sources.USER; const e = this.lastRange; const n = this.getRange(); const r = a(n, 2); const i = r[0]; const o = r[1]; if (this.lastRange = i, this.lastRange != null && (this.savedRange = this.lastRange), !(0, d.default)(e, this.lastRange)) { let s; !this.composing && o != null && o.native.collapsed && o.start.node !== this.cursor.textNode && this.cursor.restore(); let l; const u = [h.default.events.SELECTION_CHANGE, (0, c.default)(this.lastRange), (0, c.default)(e), t]; if ((s = this.emitter).emit.apply(s, [h.default.events.EDITOR_CHANGE].concat(u)), t !== h.default.sources.SILENT)(l = this.emitter).emit.apply(l, u); } } }]), t;
  }()); e.Range = f, e.default = m;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const s = r(n(0)); const a = n(3); const l = r(a); const u = (function (t) {
    function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), e;
  }(s.default.Container)); u.allowedChildren = [l.default, a.BlockEmbed, u], e.default = u;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }), e.ColorStyle = e.ColorClass = e.ColorAttributor = void 0; const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const a = (function (t) {
 function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
 if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
 constructor: {
    value: t, enumerable: !1, writable: !0, configurable: !0, 
  } 
}), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e); 
}(e, t)), o(e, [{ key: "value", value(t) { let n = (function t(e, n, r) { e === null && (e = Function.prototype); let i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { let o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; let s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "value", this)).call(this, t); return n.startsWith("rgb(") ? `#${ (n = n.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "")).split(",").map(((t) => (`00${parseInt(t).toString(16)}`).slice(-2))).join("")}` : n; } }]), e; 
}(s.default.Attributor.Style)); const l = new s.default.Attributor.Class("color", "ql-color", { scope: s.default.Scope.INLINE }); const u = new a("color", "color", { scope: s.default.Scope.INLINE }); e.ColorAttributor = a, e.ColorClass = l, e.ColorStyle = u;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : t[e] = n, t;
  } function o(t, e) { let n; const r = t === T.keys.LEFT ? "prefix" : "suffix"; return i(n = { key: t, shiftKey: e, altKey: null }, r, /^$/), i(n, "handler", (function (n) { let r = n.index; t === T.keys.RIGHT && (r += n.length + 1); const i = this.quill.getLeaf(r); return !(f(i, 1)[0] instanceof w.default.Embed && (t === T.keys.LEFT ? e ? this.quill.setSelection(n.index - 1, n.length + 1, x.default.sources.USER) : this.quill.setSelection(n.index - 1, x.default.sources.USER) : e ? this.quill.setSelection(n.index, n.length + 1, x.default.sources.USER) : this.quill.setSelection(n.index + n.length + 1, x.default.sources.USER), 1)); })), n; } function s(t, e) { if (!(t.index === 0 || this.quill.getLength() <= 1)) { const n = this.quill.getLine(t.index); const r = f(n, 1)[0]; let i = {}; if (e.offset === 0) { const o = this.quill.getLine(t.index - 1); const s = f(o, 1)[0]; if (s != null && s.length() > 1) { const a = r.formats(); const l = this.quill.getFormat(t.index - 1, 1); i = b.default.attributes.diff(a, l) || {}; } } const u = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e.prefix) ? 2 : 1; this.quill.deleteText(t.index - u, u, x.default.sources.USER), Object.keys(i).length > 0 && this.quill.formatLine(t.index - u, u, i, x.default.sources.USER), this.quill.focus(); } } function a(t, e) { const n = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e.suffix) ? 2 : 1; if (!(t.index >= this.quill.getLength() - n)) { let r = {}; let i = 0; const o = this.quill.getLine(t.index); const s = f(o, 1)[0]; if (e.offset >= s.length() - 1) { const a = this.quill.getLine(t.index + 1); const l = f(a, 1)[0]; if (l) { const u = s.formats(); const c = this.quill.getFormat(t.index, 1); r = b.default.attributes.diff(u, c) || {}, i = l.length(); } } this.quill.deleteText(t.index, n, x.default.sources.USER), Object.keys(r).length > 0 && this.quill.formatLine(t.index + i - 1, n, r, x.default.sources.USER); } } function l(t) { const e = this.quill.getLines(t); let n = {}; if (e.length > 1) { const r = e[0].formats(); const i = e[e.length - 1].formats(); n = b.default.attributes.diff(i, r) || {}; } this.quill.deleteText(t, x.default.sources.USER), Object.keys(n).length > 0 && this.quill.formatLine(t.index, 1, n, x.default.sources.USER), this.quill.setSelection(t.index, x.default.sources.SILENT), this.quill.focus(); } function u(t, e) { const n = this; t.length > 0 && this.quill.scroll.deleteAt(t.index, t.length); const r = Object.keys(e.format).reduce(((t, n) => (w.default.query(n, w.default.Scope.BLOCK) && !Array.isArray(e.format[n]) && (t[n] = e.format[n]), t)), {}); this.quill.insertText(t.index, "\n", r, x.default.sources.USER), this.quill.setSelection(t.index + 1, x.default.sources.SILENT), this.quill.focus(), Object.keys(e.format).forEach(((t) => { r[t] == null && (Array.isArray(e.format[t]) || t !== "link" && n.quill.format(t, e.format[t], x.default.sources.USER)); })); } function c(t) {
    return {
      key: T.keys.TAB, shiftKey: !t, format: { "code-block": !0 }, handler(e) { const n = w.default.query("code-block"); let r = e.index; let i = e.length; const o = this.quill.scroll.descendant(n, r); const s = f(o, 2); const a = s[0]; let l = s[1]; if (a != null) { const u = this.quill.getIndex(a); const c = a.newlineIndex(l, !0) + 1; const d = a.newlineIndex(u + l + i); const h = a.domNode.textContent.slice(c, d).split("\n"); l = 0, h.forEach(((e, o) => { t ? (a.insertAt(c + l, n.TAB), l += n.TAB.length, o === 0 ? r += n.TAB.length : i += n.TAB.length) : e.startsWith(n.TAB) && (a.deleteAt(c + l, n.TAB.length), l -= n.TAB.length, o === 0 ? r -= n.TAB.length : i -= n.TAB.length), l += e.length + 1; })), this.quill.update(x.default.sources.USER), this.quill.setSelection(r, i, x.default.sources.SILENT); } },
    };
  } function d(t) { return { key: t[0].toUpperCase(), shortKey: !0, handler(e, n) { this.quill.format(t, !n.format[t], x.default.sources.USER); } }; } function h(t) { if (typeof t === "string" || typeof t === "number") return h({ key: t }); if ((void 0 === t ? "undefined" : p(t)) === "object" && (t = (0, g.default)(t, !1)), typeof t.key === "string") if (T.keys[t.key.toUpperCase()] != null)t.key = T.keys[t.key.toUpperCase()]; else { if (t.key.length !== 1) return null; t.key = t.key.toUpperCase().charCodeAt(0); } return t.shortKey && (t[E] = t.shortKey, delete t.shortKey), t; }Object.defineProperty(e, "__esModule", { value: !0 }), e.SHORTKEY = e.default = void 0; var p = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }; var f = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const m = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); var g = r(n(21)); const v = r(n(12)); const y = r(n(2)); const _ = r(n(4)); var b = r(n(20)); var w = r(n(0)); var x = r(n(6)); const S = r(n(10)); const k = r(n(7)); const C = (0, S.default)("quill:keyboard"); var E = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey"; var T = (function (t) {
    function e(t, n) {
      !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))); return r.bindings = {}, Object.keys(r.options.bindings).forEach(((e) => { (e !== "list autofill" || t.scroll.whitelist == null || t.scroll.whitelist.list) && r.options.bindings[e] && r.addBinding(r.options.bindings[e]); })), r.addBinding({ key: e.keys.ENTER, shiftKey: null }, u), r.addBinding({
        key: e.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null,
      }, (() => {})), /Firefox/i.test(navigator.userAgent) ? (r.addBinding({ key: e.keys.BACKSPACE }, { collapsed: !0 }, s), r.addBinding({ key: e.keys.DELETE }, { collapsed: !0 }, a)) : (r.addBinding({ key: e.keys.BACKSPACE }, { collapsed: !0, prefix: /^.?$/ }, s), r.addBinding({ key: e.keys.DELETE }, { collapsed: !0, suffix: /^.?$/ }, a)), r.addBinding({ key: e.keys.BACKSPACE }, { collapsed: !1 }, l), r.addBinding({ key: e.keys.DELETE }, { collapsed: !1 }, l), r.addBinding({
        key: e.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null,
      }, { collapsed: !0, offset: 0 }, s), r.listen(), r;
    } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        },
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), m(e, null, [{ key: "match", value(t, e) { return e = h(e), !["altKey", "ctrlKey", "metaKey", "shiftKey"].some(((n) => !!e[n] !== t[n] && e[n] !== null)) && e.key === (t.which || t.keyCode); } }]), m(e, [{ key: "addBinding", value(t) { let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; let r = h(t); if (r == null || r.key == null) return C.warn("Attempted to add invalid keyboard binding", r); typeof e === "function" && (e = { handler: e }), typeof n === "function" && (n = { handler: n }), r = (0, y.default)(r, e, n), this.bindings[r.key] = this.bindings[r.key] || [], this.bindings[r.key].push(r); } }, {
      key: "listen",
      value() {
        const t = this; this.quill.root.addEventListener("keydown", ((n) => {
          if (!n.defaultPrevented) {
            const r = n.which || n.keyCode; const i = (t.bindings[r] || []).filter(((t) => e.match(n, t))); if (i.length !== 0) {
              const o = t.quill.getSelection(); if (o != null && t.quill.hasFocus()) {
                const s = t.quill.getLine(o.index); const a = f(s, 2); const l = a[0]; const u = a[1]; const c = t.quill.getLeaf(o.index); const d = f(c, 2); const h = d[0]; const m = d[1]; const g = o.length === 0 ? [h, m] : t.quill.getLeaf(o.index + o.length); const y = f(g, 2); const _ = y[0]; const b = y[1]; const x = h instanceof w.default.Text ? h.value().slice(0, m) : ""; const S = _ instanceof w.default.Text ? _.value().slice(b) : ""; const k = {
                  collapsed: o.length === 0, empty: o.length === 0 && l.length() <= 1, format: t.quill.getFormat(o), offset: u, prefix: x, suffix: S,
                }; i.some(((e) => { if (e.collapsed != null && e.collapsed !== k.collapsed) return !1; if (e.empty != null && e.empty !== k.empty) return !1; if (e.offset != null && e.offset !== k.offset) return !1; if (Array.isArray(e.format)) { if (e.format.every(((t) => k.format[t] == null))) return !1; } else if (p(e.format) === "object" && !Object.keys(e.format).every(((t) => (!0 === e.format[t] ? k.format[t] != null : !1 === e.format[t] ? k.format[t] == null : (0, v.default)(e.format[t], k.format[t]))))) return !1; return !(e.prefix != null && !e.prefix.test(k.prefix) || e.suffix != null && !e.suffix.test(k.suffix) || !0 === e.handler.call(t, o, k)); })) && n.preventDefault();
              }
            }
          }
        }));
      },
    }]), e;
  }(k.default)); T.keys = {
    BACKSPACE: 8, TAB: 9, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, DELETE: 46,
  }, T.DEFAULTS = {
    bindings: {
      bold: d("bold"),
      italic: d("italic"),
      underline: d("underline"),
      indent: { key: T.keys.TAB, format: ["blockquote", "indent", "list"], handler(t, e) { if (e.collapsed && e.offset !== 0) return !0; this.quill.format("indent", "+1", x.default.sources.USER); } },
      outdent: {
        key: T.keys.TAB, shiftKey: !0, format: ["blockquote", "indent", "list"], handler(t, e) { if (e.collapsed && e.offset !== 0) return !0; this.quill.format("indent", "-1", x.default.sources.USER); },
      },
      "outdent backspace": {
        key: T.keys.BACKSPACE, collapsed: !0, shiftKey: null, metaKey: null, ctrlKey: null, altKey: null, format: ["indent", "list"], offset: 0, handler(t, e) { e.format.indent != null ? this.quill.format("indent", "-1", x.default.sources.USER) : e.format.list != null && this.quill.format("list", !1, x.default.sources.USER); },
      },
      "indent code-block": c(!0),
      "outdent code-block": c(!1),
      "remove tab": {
        key: T.keys.TAB, shiftKey: !0, collapsed: !0, prefix: /\t$/, handler(t) { this.quill.deleteText(t.index - 1, 1, x.default.sources.USER); },
      },
      tab: { key: T.keys.TAB, handler(t) { this.quill.history.cutoff(); const e = (new _.default()).retain(t.index).delete(t.length).insert("\t"); this.quill.updateContents(e, x.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index + 1, x.default.sources.SILENT); } },
      "list empty enter": {
        key: T.keys.ENTER, collapsed: !0, format: ["list"], empty: !0, handler(t, e) { this.quill.format("list", !1, x.default.sources.USER), e.format.indent && this.quill.format("indent", !1, x.default.sources.USER); },
      },
      "checklist enter": {
        key: T.keys.ENTER,
        collapsed: !0,
        format: { list: "checked" },
        handler(t) {
          const e = this.quill.getLine(t.index); const n = f(e, 2); const r = n[0]; const i = n[1]; const o = (0, y.default)({}, r.formats(), { list: "checked" }); const s = (new _.default()).retain(t.index).insert("\n", o).retain(r.length() - i - 1)
            .retain(1, { list: "unchecked" }); this.quill.updateContents(s, x.default.sources.USER), this.quill.setSelection(t.index + 1, x.default.sources.SILENT), this.quill.scrollIntoView();
        },
      },
      "header enter": {
        key: T.keys.ENTER,
        collapsed: !0,
        format: ["header"],
        suffix: /^$/,
        handler(t, e) {
          const n = this.quill.getLine(t.index); const r = f(n, 2); const i = r[0]; const o = r[1]; const s = (new _.default()).retain(t.index).insert("\n", e.format).retain(i.length() - o - 1)
            .retain(1, { header: null }); this.quill.updateContents(s, x.default.sources.USER), this.quill.setSelection(t.index + 1, x.default.sources.SILENT), this.quill.scrollIntoView();
        },
      },
      "list autofill": {
        key: " ",
        collapsed: !0,
        format: { list: !1 },
        prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
        handler(t, e) {
          const n = e.prefix.length; const r = this.quill.getLine(t.index); const i = f(r, 2); const o = i[0]; const s = i[1]; if (s > n) return !0; let a = void 0; switch (e.prefix.trim()) { case "[]": case "[ ]": a = "unchecked"; break; case "[x]": a = "checked"; break; case "-": case "*": a = "bullet"; break; default: a = "ordered"; } this.quill.insertText(t.index, " ", x.default.sources.USER), this.quill.history.cutoff(); const l = (new _.default()).retain(t.index - s).delete(n + 1).retain(o.length() - 2 - s)
            .retain(1, { list: a }); this.quill.updateContents(l, x.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t.index - n, x.default.sources.SILENT);
        },
      },
      "code exit": {
        key: T.keys.ENTER, collapsed: !0, format: ["code-block"], prefix: /\n\n$/, suffix: /^\s+$/, handler(t) { const e = this.quill.getLine(t.index); const n = f(e, 2); const r = n[0]; const i = n[1]; const o = (new _.default()).retain(t.index + r.length() - i - 2).retain(1, { "code-block": null }).delete(1); this.quill.updateContents(o, x.default.sources.USER); },
      },
      "embed left": o(T.keys.LEFT, !1),
      "embed left shift": o(T.keys.LEFT, !0),
      "embed right": o(T.keys.RIGHT, !1),
      "embed right shift": o(T.keys.RIGHT, !0),
    },
  }, e.default = T, e.SHORTKEY = E;
}, function (t, e, n) {
  t.exports = {
    align: {
      "": n(75), center: n(76), right: n(77), justify: n(78),
    },
    background: n(79),
    blockquote: n(80),
    bold: n(81),
    clean: n(82),
    code: n(40),
    "code-block": n(40),
    color: n(83),
    direction: { "": n(84), rtl: n(85) },
    float: {
      center: n(86), full: n(87), left: n(88), right: n(89),
    },
    formula: n(90),
    header: { 1: n(91), 2: n(92) },
    italic: n(93),
    image: n(94),
    indent: { "+1": n(95), "-1": n(96) },
    link: n(97),
    list: { ordered: n(98), bullet: n(99), check: n(100) },
    script: { sub: n(101), super: n(102) },
    strike: n(103),
    underline: n(104),
    video: n(105),
  };
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = n(1); const i = (function () { function t(t) { this.domNode = t, this.domNode[r.DATA_KEY] = { blot: this }; } return Object.defineProperty(t.prototype, "statics", { get() { return this.constructor; }, enumerable: !0, configurable: !0 }), t.create = function (t) { if (this.tagName == null) throw new r.ParchmentError("Blot definition missing tagName"); let e; return Array.isArray(this.tagName) ? (typeof t === "string" && (t = t.toUpperCase(), parseInt(t).toString() === t && (t = parseInt(t))), e = typeof t === "number" ? document.createElement(this.tagName[t - 1]) : this.tagName.indexOf(t) > -1 ? document.createElement(t) : document.createElement(this.tagName[0])) : e = document.createElement(this.tagName), this.className && e.classList.add(this.className), e; }, t.prototype.attach = function () { this.parent != null && (this.scroll = this.parent.scroll); }, t.prototype.clone = function () { const t = this.domNode.cloneNode(!1); return r.create(t); }, t.prototype.detach = function () { this.parent != null && this.parent.removeChild(this), delete this.domNode[r.DATA_KEY]; }, t.prototype.deleteAt = function (t, e) { this.isolate(t, e).remove(); }, t.prototype.formatAt = function (t, e, n, i) { const o = this.isolate(t, e); if (r.query(n, r.Scope.BLOT) != null && i)o.wrap(n, i); else if (r.query(n, r.Scope.ATTRIBUTE) != null) { const s = r.create(this.statics.scope); o.wrap(s), s.format(n, i); } }, t.prototype.insertAt = function (t, e, n) { const i = n == null ? r.create("text", e) : r.create(e, n); const o = this.split(t); this.parent.insertBefore(i, o); }, t.prototype.insertInto = function (t, e) { void 0 === e && (e = null), this.parent != null && this.parent.children.remove(this); let n = null; t.children.insertBefore(this, e), e != null && (n = e.domNode), this.domNode.parentNode == t.domNode && this.domNode.nextSibling == n || t.domNode.insertBefore(this.domNode, n), this.parent = t, this.attach(); }, t.prototype.isolate = function (t, e) { const n = this.split(t); return n.split(e), n; }, t.prototype.length = function () { return 1; }, t.prototype.offset = function (t) { return void 0 === t && (t = this.parent), this.parent == null || this == t ? 0 : this.parent.children.offset(this) + this.parent.offset(t); }, t.prototype.optimize = function (t) { this.domNode[r.DATA_KEY] != null && delete this.domNode[r.DATA_KEY].mutations; }, t.prototype.remove = function () { this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach(); }, t.prototype.replace = function (t) { t.parent != null && (t.parent.insertBefore(this, t.next), t.remove()); }, t.prototype.replaceWith = function (t, e) { const n = typeof t === "string" ? r.create(t, e) : t; return n.replace(this), n; }, t.prototype.split = function (t, e) { return t === 0 ? this : this.next; }, t.prototype.update = function (t, e) {}, t.prototype.wrap = function (t, e) { const n = typeof t === "string" ? r.create(t, e) : t; return this.parent != null && this.parent.insertBefore(n, this.next), n.appendChild(this), n; }, t.blotName = "abstract", t; }()); e.default = i;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = n(11); const i = n(29); const o = n(30); const s = n(1); const a = (function () { function t(t) { this.attributes = {}, this.domNode = t, this.build(); } return t.prototype.attribute = function (t, e) { e ? t.add(this.domNode, e) && (t.value(this.domNode) != null ? this.attributes[t.attrName] = t : delete this.attributes[t.attrName]) : (t.remove(this.domNode), delete this.attributes[t.attrName]); }, t.prototype.build = function () { const t = this; this.attributes = {}; const e = r.default.keys(this.domNode); const n = i.default.keys(this.domNode); const a = o.default.keys(this.domNode); e.concat(n).concat(a).forEach(((e) => { const n = s.query(e, s.Scope.ATTRIBUTE); n instanceof r.default && (t.attributes[n.attrName] = n); })); }, t.prototype.copy = function (t) { const e = this; Object.keys(this.attributes).forEach(((n) => { const r = e.attributes[n].value(e.domNode); t.format(n, r); })); }, t.prototype.move = function (t) { const e = this; this.copy(t), Object.keys(this.attributes).forEach(((t) => { e.attributes[t].remove(e.domNode); })), this.attributes = {}; }, t.prototype.values = function () { const t = this; return Object.keys(this.attributes).reduce(((e, n) => (e[n] = t.attributes[n].value(t.domNode), e)), {}); }, t; }()); e.default = a;
}, function (t, e, n) {
  function r(t, e) { return (t.getAttribute("class") || "").split(/\s+/).filter(((t) => t.indexOf(`${e}-`) === 0)); } const i = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return i(e, t), e.keys = function (t) { return (t.getAttribute("class") || "").split(/\s+/).map(((t) => t.split("-").slice(0, -1).join("-"))); }, e.prototype.add = function (t, e) { return !!this.canAdd(t, e) && (this.remove(t), t.classList.add(`${this.keyName}-${e}`), !0); }, e.prototype.remove = function (t) { r(t, this.keyName).forEach(((e) => { t.classList.remove(e); })), t.classList.length === 0 && t.removeAttribute("class"); }, e.prototype.value = function (t) { const e = (r(t, this.keyName)[0] || "").slice(this.keyName.length + 1); return this.canAdd(t, e) ? e : ""; }, e; }(n(11).default)); e.default = o;
}, function (t, e, n) {
  function r(t) { const e = t.split("-"); const n = e.slice(1).map(((t) => t[0].toUpperCase() + t.slice(1))).join(""); return e[0] + n; } const i = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return i(e, t), e.keys = function (t) { return (t.getAttribute("style") || "").split(";").map(((t) => t.split(":")[0].trim())); }, e.prototype.add = function (t, e) { return !!this.canAdd(t, e) && (t.style[r(this.keyName)] = e, !0); }, e.prototype.remove = function (t) { t.style[r(this.keyName)] = "", t.getAttribute("style") || t.removeAttribute("style"); }, e.prototype.value = function (t) { const e = t.style[r(this.keyName)]; return this.canAdd(t, e) ? e : ""; }, e; }(n(11).default)); e.default = o;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; }Object.defineProperty(e, "__esModule", { value: !0 }); const i = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const o = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const s = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const a = r(n(0)); const l = r(n(8)); const u = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t))); return r.selection = n, r.textNode = document.createTextNode(e.CONTENTS), r.domNode.appendChild(r.textNode), r._length = 0, r; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), s(e, null, [{ key: "value", value() {} }]), s(e, [{ key: "detach", value() { this.parent != null && this.parent.removeChild(this); } }, { key: "format", value(t, n) { if (this._length !== 0) return o(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n); for (var r = this, i = 0; r != null && r.statics.scope !== a.default.Scope.BLOCK_BLOT;)i += r.offset(r.parent), r = r.parent; r != null && (this._length = e.CONTENTS.length, r.optimize(), r.formatAt(i, e.CONTENTS.length, t, n), this._length = 0); } }, { key: "index", value(t, n) { return t === this.textNode ? 0 : o(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "index", this).call(this, t, n); } }, { key: "length", value() { return this._length; } }, { key: "position", value() { return [this.textNode, this.textNode.data.length]; } }, { key: "remove", value() { o(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "remove", this).call(this), this.parent = null; } }, {
      key: "restore",
      value() {
        if (!this.selection.composing && this.parent != null) {
          const t = this.textNode; const n = this.selection.getNativeRange(); let r = void 0; let o = void 0; let s = void 0; if (n != null && n.start.node === t && n.end.node === t) { const u = [t, n.start.offset, n.end.offset]; r = u[0], o = u[1], s = u[2]; } for (;this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode;) this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode); if (this.textNode.data !== e.CONTENTS) { const c = this.textNode.data.split(e.CONTENTS).join(""); this.next instanceof l.default ? (r = this.next.domNode, this.next.insertAt(0, c), this.textNode.data = e.CONTENTS) : (this.textNode.data = c, this.parent.insertBefore(a.default.create(this.textNode), this), this.textNode = document.createTextNode(e.CONTENTS), this.domNode.appendChild(this.textNode)); } if (this.remove(), o != null) {
            const d = [o, s].map(((t) => Math.max(0, Math.min(r.data.length, t - 1)))); const h = i(d, 2); return o = h[0], s = h[1], {
              startNode: r, startOffset: o, endNode: r, endOffset: s,
            };
          }
        }
      }, 
    }, { key: "update", value(t, e) { const n = this; if (t.some(((t) => t.type === "characterData" && t.target === n.textNode))) { const r = this.restore(); r && (e.range = r); } } }, { key: "value", value() { return ""; } }]), e;
  }(a.default.Embed)); u.blotName = "cursor", u.className = "ql-cursor", u.tagName = "span", u.CONTENTS = "\ufeff", e.default = u;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const i = (function () { function t(e, n) { (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.quill = e, this.options = n, this.modules = {}; } return r(t, [{ key: "init", value() { const t = this; Object.keys(this.options.modules).forEach(((e) => { t.modules[e] == null && t.addModule(e); })); } }, { key: "addModule", value(t) { const e = this.quill.constructor.import(`modules/${t}`); return this.modules[t] = new e(this.quill, this.options.modules[t] || {}), this.modules[t]; } }]), t; }()); i.DEFAULTS = { modules: {} }, i.themes = { default: i }, e.default = i;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; }Object.defineProperty(e, "__esModule", { value: !0 }); const i = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const o = r(n(0)); const s = r(n(8)); const a = "\ufeff"; const l = (function (t) {
    function e(t) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const n = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t))); return n.contentNode = document.createElement("span"), n.contentNode.setAttribute("contenteditable", !1), [].slice.call(n.domNode.childNodes).forEach(((t) => { n.contentNode.appendChild(t); })), n.leftGuard = document.createTextNode(a), n.rightGuard = document.createTextNode(a), n.domNode.appendChild(n.leftGuard), n.domNode.appendChild(n.contentNode), n.domNode.appendChild(n.rightGuard), n; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), i(e, [{ key: "index", value(t, n) { return t === this.leftGuard ? 0 : t === this.rightGuard ? 1 : (function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "index", this)).call(this, t, n); } }, { key: "restore", value(t) { let e = void 0; let n = void 0; const r = t.data.split(a).join(""); if (t === this.leftGuard) if (this.prev instanceof s.default) { const i = this.prev.length(); this.prev.insertAt(i, r), e = { startNode: this.prev.domNode, startOffset: i + r.length }; } else n = document.createTextNode(r), this.parent.insertBefore(o.default.create(n), this), e = { startNode: n, startOffset: r.length }; else t === this.rightGuard && (this.next instanceof s.default ? (this.next.insertAt(0, r), e = { startNode: this.next.domNode, startOffset: r.length }) : (n = document.createTextNode(r), this.parent.insertBefore(o.default.create(n), this.next), e = { startNode: n, startOffset: r.length })); return t.data = a, e; } }, { key: "update", value(t, e) { const n = this; t.forEach(((t) => { if (t.type === "characterData" && (t.target === n.leftGuard || t.target === n.rightGuard)) { const r = n.restore(t.target); r && (e.range = r); } })); } }]), e;
  }(o.default.Embed)); e.default = l;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.AlignStyle = e.AlignClass = e.AlignAttribute = void 0; const r = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const i = { scope: r.default.Scope.BLOCK, whitelist: ["right", "center", "justify"] }; const o = new r.default.Attributor.Attribute("align", "align", i); const s = new r.default.Attributor.Class("align", "ql-align", i); const a = new r.default.Attributor.Style("align", "text-align", i); e.AlignAttribute = o, e.AlignClass = s, e.AlignStyle = a;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BackgroundStyle = e.BackgroundClass = void 0; const r = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const i = n(24); const o = new r.default.Attributor.Class("background", "ql-bg", { scope: r.default.Scope.INLINE }); const s = new i.ColorAttributor("background", "background-color", { scope: r.default.Scope.INLINE }); e.BackgroundClass = o, e.BackgroundStyle = s;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DirectionStyle = e.DirectionClass = e.DirectionAttribute = void 0; const r = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const i = { scope: r.default.Scope.BLOCK, whitelist: ["rtl"] }; const o = new r.default.Attributor.Attribute("direction", "dir", i); const s = new r.default.Attributor.Class("direction", "ql-direction", i); const a = new r.default.Attributor.Style("direction", "direction", i); e.DirectionAttribute = o, e.DirectionClass = s, e.DirectionStyle = a;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }), e.FontClass = e.FontStyle = void 0; const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const a = { scope: s.default.Scope.INLINE, whitelist: ["serif", "monospace"] }; const l = new s.default.Attributor.Class("font", "ql-font", a); const u = new (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        },
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "value", value(t) { return (function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "value", this)).call(this, t).replace(/["']/g, ""); } }]), e;
  }(s.default.Attributor.Style))("font", "font-family", a); e.FontStyle = u, e.FontClass = l;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SizeStyle = e.SizeClass = void 0; const r = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const i = new r.default.Attributor.Class("size", "ql-size", { scope: r.default.Scope.INLINE, whitelist: ["small", "large", "huge"] }); const o = new r.default.Attributor.Style("size", "font-size", { scope: r.default.Scope.INLINE, whitelist: ["10px", "18px", "32px"] }); e.SizeClass = i, e.SizeStyle = o;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const a = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "optimize", value(t) { s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName); } }], [{ key: "create", value() { return s(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this); } }, { key: "formats", value() { return !0; } }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(5))).default)); a.blotName = "bold", a.tagName = ["STRONG", "B"], e.default = a;
}, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>'; }, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const i = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const o = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t))); return r.label.innerHTML = n, r.container.classList.add("ql-color-picker"), [].slice.call(r.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(((t) => { t.classList.add("ql-primary"); })), r; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), r(e, [{ key: "buildItem", value(t) { const n = i(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "buildItem", this).call(this, t); return n.style.backgroundColor = t.getAttribute("value") || "", n; } }, { key: "selectItem", value(t, n) { i(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "selectItem", this).call(this, t, n); const r = this.label.querySelector(".ql-color-label"); const o = t && t.getAttribute("data-value") || ""; r && (r.tagName === "line" ? r.style.stroke = o : r.style.fill = o); } }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(16))).default)); e.default = o;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const i = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t))); return r.container.classList.add("ql-icon-picker"), [].forEach.call(r.container.querySelectorAll(".ql-picker-item"), ((t) => { t.innerHTML = n[t.getAttribute("data-value") || ""]; })), r.defaultItem = r.container.querySelector(".ql-selected"), r.selectItem(r.defaultItem), r; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), r(e, [{ key: "selectItem", value(t, n) { (function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "selectItem", this)).call(this, t, n), t = t || this.defaultItem, this.label.innerHTML = t.innerHTML; } }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(16))).default)); e.default = i;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const i = (function () { function t(e, n) { const r = this; (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.quill = e, this.boundsContainer = n || document.body, this.root = e.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, this.quill.root === this.quill.scrollingContainer && this.quill.root.addEventListener("scroll", (() => { r.root.style.marginTop = `${-1 * r.quill.root.scrollTop}px`; })), this.hide(); } return r(t, [{ key: "hide", value() { this.root.classList.add("ql-hidden"); } }, { key: "position", value(t) { const e = t.left + t.width / 2 - this.root.offsetWidth / 2; const n = t.bottom + this.quill.root.scrollTop; this.root.style.left = `${e}px`, this.root.style.top = `${n}px`, this.root.classList.remove("ql-flip"); const r = this.boundsContainer.getBoundingClientRect(); const i = this.root.getBoundingClientRect(); let o = 0; if (i.right > r.right && (o = r.right - i.right, this.root.style.left = `${e + o}px`), i.left < r.left && (o = r.left - i.left, this.root.style.left = `${e + o}px`), i.bottom > r.bottom) { const s = i.bottom - i.top; const a = t.bottom - t.top + s; this.root.style.top = `${n - a}px`, this.root.classList.add("ql-flip"); } return o; } }, { key: "show", value() { this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden"); } }]), t; }()); e.default = i;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  } function a(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; e.forEach(((e) => { const r = document.createElement("option"); e === n ? r.setAttribute("selected", "selected") : r.setAttribute("value", e), t.appendChild(r); })); }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.BaseTooltip = void 0; const l = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const u = r(n(2)); const c = r(n(4)); const d = r(n(9)); const h = r(n(25)); const p = r(n(32)); const f = r(n(41)); const m = r(n(42)); const g = r(n(16)); const v = r(n(43)); const y = [!1, "center", "right", "justify"]; const _ = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"]; const b = [!1, "serif", "monospace"]; const w = ["1", "2", "3", !1]; const x = ["small", !1, "large", "huge"]; const S = (function (t) { function e(t, n) { i(this, e); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return t.emitter.listenDOM("click", document.body, (function e(n) { if (!document.body.contains(t.root)) return document.body.removeEventListener("click", e); r.tooltip == null || r.tooltip.root.contains(n.target) || document.activeElement === r.tooltip.textbox || r.quill.hasFocus() || r.tooltip.hide(), r.pickers != null && r.pickers.forEach(((t) => { t.container.contains(n.target) || t.close(); })); })), r; } return s(e, t), l(e, [{ key: "addModule", value(t) { const n = (function t(e, n, r) { e === null && (e = Function.prototype); let i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { let o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; let s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "addModule", this)).call(this, t); return t === "toolbar" && this.extendToolbar(n), n; } }, { key: "buildButtons", value(t, e) { t.forEach(((t) => { (t.getAttribute("class") || "").split(/\s+/).forEach(((n) => { if (n.startsWith("ql-") && (n = n.slice("ql-".length), e[n] != null)) if (n === "direction")t.innerHTML = e[n][""] + e[n].rtl; else if (typeof e[n] === "string")t.innerHTML = e[n]; else { const r = t.value || ""; r != null && e[n][r] && (t.innerHTML = e[n][r]); } })); })); } }, { key: "buildPickers", value(t, e) { const n = this; this.pickers = t.map(((t) => { if (t.classList.contains("ql-align")) return t.querySelector("option") == null && a(t, y), new m.default(t, e.align); if (t.classList.contains("ql-background") || t.classList.contains("ql-color")) { const n = t.classList.contains("ql-background") ? "background" : "color"; return t.querySelector("option") == null && a(t, _, n === "background" ? "#ffffff" : "#000000"), new f.default(t, e[n]); } return t.querySelector("option") == null && (t.classList.contains("ql-font") ? a(t, b) : t.classList.contains("ql-header") ? a(t, w) : t.classList.contains("ql-size") && a(t, x)), new g.default(t); })); this.quill.on(d.default.events.EDITOR_CHANGE, (() => { n.pickers.forEach(((t) => { t.update(); })); })); } }]), e; }(p.default)); S.DEFAULTS = (0, u.default)(!0, {}, p.default.DEFAULTS, { modules: { toolbar: { handlers: { formula() { this.quill.theme.tooltip.edit("formula"); }, image() { const t = this; let e = this.container.querySelector("input.ql-image[type=file]"); e == null && ((e = document.createElement("input")).setAttribute("type", "file"), e.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon"), e.classList.add("ql-image"), e.addEventListener("change", (() => { if (e.files != null && e.files[0] != null) { const n = new FileReader(); n.onload = function (n) { const r = t.quill.getSelection(!0); t.quill.updateContents((new c.default()).retain(r.index).delete(r.length).insert({ image: n.target.result }), d.default.sources.USER), t.quill.setSelection(r.index + 1, d.default.sources.SILENT), e.value = ""; }, n.readAsDataURL(e.files[0]); } })), this.container.appendChild(e)), e.click(); }, video() { this.quill.theme.tooltip.edit("video"); } } } } }); const k = (function (t) { function e(t, n) { i(this, e); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return r.textbox = r.root.querySelector('input[type="text"]'), r.listen(), r; } return s(e, t), l(e, [{ key: "listen", value() { const t = this; this.textbox.addEventListener("keydown", ((e) => { h.default.match(e, "enter") ? (t.save(), e.preventDefault()) : h.default.match(e, "escape") && (t.cancel(), e.preventDefault()); })); } }, { key: "cancel", value() { this.hide(); } }, { key: "edit", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "link"; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), e != null ? this.textbox.value = e : t !== this.root.getAttribute("data-mode") && (this.textbox.value = ""), this.position(this.quill.getBounds(this.quill.selection.savedRange)), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${t}`) || ""), this.root.setAttribute("data-mode", t); } }, { key: "restoreFocus", value() { const t = this.quill.scrollingContainer.scrollTop; this.quill.focus(), this.quill.scrollingContainer.scrollTop = t; } }, { key: "save", value() { let t = this.textbox.value; switch (this.root.getAttribute("data-mode")) { case "link": var e = this.quill.root.scrollTop; this.linkRange ? (this.quill.formatText(this.linkRange, "link", t, d.default.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t, d.default.sources.USER)), this.quill.root.scrollTop = e; break; case "video": t = (function (t) { let e = t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/); return e ? `${e[1] || "https" }://www.youtube.com/embed/${ e[2] }?showinfo=0` : (e = t.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) ? `${e[1] || "https" }://player.vimeo.com/video/${ e[2] }/` : t; }(t)); case "formula": if (!t) break; var n = this.quill.getSelection(!0); if (n != null) { const r = n.index + n.length; this.quill.insertEmbed(r, this.root.getAttribute("data-mode"), t, d.default.sources.USER), this.root.getAttribute("data-mode") === "formula" && this.quill.insertText(r + 1, " ", d.default.sources.USER), this.quill.setSelection(r + 2, d.default.sources.USER); } } this.textbox.value = "", this.hide(); } }]), e; }(v.default)); e.BaseTooltip = k, e.default = S;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; }Object.defineProperty(e, "__esModule", { value: !0 }); const i = r(n(46)); const o = n(34); const s = n(36); const a = n(62); const l = r(n(63)); const u = r(n(64)); const c = n(65); const d = r(c); const h = n(35); const p = n(24); const f = n(37); const m = n(38); const g = r(n(39)); const v = r(n(66)); const y = r(n(15)); const _ = r(n(67)); const b = r(n(68)); const w = r(n(69)); const x = r(n(70)); const S = r(n(71)); const k = n(13); const C = r(k); const E = r(n(72)); const T = r(n(73)); const P = r(n(74)); const O = r(n(26)); const A = r(n(16)); const M = r(n(41)); const L = r(n(42)); const I = r(n(43)); const j = r(n(107)); const D = r(n(108)); i.default.register({
    "attributors/attribute/direction": s.DirectionAttribute, "attributors/class/align": o.AlignClass, "attributors/class/background": h.BackgroundClass, "attributors/class/color": p.ColorClass, "attributors/class/direction": s.DirectionClass, "attributors/class/font": f.FontClass, "attributors/class/size": m.SizeClass, "attributors/style/align": o.AlignStyle, "attributors/style/background": h.BackgroundStyle, "attributors/style/color": p.ColorStyle, "attributors/style/direction": s.DirectionStyle, "attributors/style/font": f.FontStyle, "attributors/style/size": m.SizeStyle,
  }, !0), i.default.register({
    "formats/align": o.AlignClass, "formats/direction": s.DirectionClass, "formats/indent": a.IndentClass, "formats/background": h.BackgroundStyle, "formats/color": p.ColorStyle, "formats/font": f.FontClass, "formats/size": m.SizeClass, "formats/blockquote": l.default, "formats/code-block": C.default, "formats/header": u.default, "formats/list": d.default, "formats/bold": g.default, "formats/code": k.Code, "formats/italic": v.default, "formats/link": y.default, "formats/script": _.default, "formats/strike": b.default, "formats/underline": w.default, "formats/image": x.default, "formats/video": S.default, "formats/list/item": c.ListItem, "modules/formula": E.default, "modules/syntax": T.default, "modules/toolbar": P.default, "themes/bubble": j.default, "themes/snow": D.default, "ui/icons": O.default, "ui/picker": A.default, "ui/icon-picker": L.default, "ui/color-picker": M.default, "ui/tooltip": I.default,
  }, !0), e.default = i.default;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; }Object.defineProperty(e, "__esModule", { value: !0 }); const i = r(n(0)); const o = r(n(6)); const s = n(3); const a = r(s); const l = r(n(14)); const u = r(n(23)); const c = r(n(31)); const d = r(n(33)); const h = r(n(5)); const p = r(n(59)); const f = r(n(8)); const m = r(n(60)); const g = r(n(61)); const v = r(n(25)); o.default.register({
    "blots/block": a.default, "blots/block/embed": s.BlockEmbed, "blots/break": l.default, "blots/container": u.default, "blots/cursor": c.default, "blots/embed": d.default, "blots/inline": h.default, "blots/scroll": p.default, "blots/text": f.default, "modules/clipboard": m.default, "modules/history": g.default, "modules/keyboard": v.default,
  }), i.default.register(a.default, l.default, c.default, h.default, p.default, f.default), e.default = o.default;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = (function () { function t() { this.head = this.tail = null, this.length = 0; } return t.prototype.append = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; this.insertBefore(t[0], null), t.length > 1 && this.append.apply(this, t.slice(1)); }, t.prototype.contains = function (t) { for (var e, n = this.iterator(); e = n();) if (e === t) return !0; return !1; }, t.prototype.insertBefore = function (t, e) { t && (t.next = e, e != null ? (t.prev = e.prev, e.prev != null && (e.prev.next = t), e.prev = t, e === this.head && (this.head = t)) : this.tail != null ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : (t.prev = null, this.head = this.tail = t), this.length += 1); }, t.prototype.offset = function (t) { for (let e = 0, n = this.head; n != null;) { if (n === t) return e; e += n.length(), n = n.next; } return -1; }, t.prototype.remove = function (t) { this.contains(t) && (t.prev != null && (t.prev.next = t.next), t.next != null && (t.next.prev = t.prev), t === this.head && (this.head = t.next), t === this.tail && (this.tail = t.prev), this.length -= 1); }, t.prototype.iterator = function (t) { return void 0 === t && (t = this.head), function () { const e = t; return t != null && (t = t.next), e; }; }, t.prototype.find = function (t, e) { void 0 === e && (e = !1); for (var n, r = this.iterator(); n = r();) { const i = n.length(); if (t < i || e && t === i && (n.next == null || n.next.length() !== 0)) return [n, t]; t -= i; } return [null, 0]; }, t.prototype.forEach = function (t) { for (var e, n = this.iterator(); e = n();)t(e); }, t.prototype.forEachAt = function (t, e, n) { if (!(e <= 0)) for (var r, i = this.find(t), o = i[0], s = t - i[1], a = this.iterator(o); (r = a()) && s < t + e;) { const l = r.length(); t > s ? n(r, t - s, Math.min(e, s + l - t)) : n(r, 0, Math.min(l, t + e - s)), s += l; } }, t.prototype.map = function (t) { return this.reduce(((e, n) => (e.push(t(n)), e)), []); }, t.prototype.reduce = function (t, e) { for (var n, r = this.iterator(); n = r();)e = t(e, n); return e; }, t; }()); e.default = r;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(17); const o = n(1); const s = {
    attributes: !0, characterData: !0, characterDataOldValue: !0, childList: !0, subtree: !0,
  }; const a = (function (t) { function e(e) { const n = t.call(this, e) || this; return n.scroll = n, n.observer = new MutationObserver(((t) => { n.update(t); })), n.observer.observe(n.domNode, s), n.attach(), n; } return r(e, t), e.prototype.detach = function () { t.prototype.detach.call(this), this.observer.disconnect(); }, e.prototype.deleteAt = function (e, n) { this.update(), e === 0 && n === this.length() ? this.children.forEach(((t) => { t.remove(); })) : t.prototype.deleteAt.call(this, e, n); }, e.prototype.formatAt = function (e, n, r, i) { this.update(), t.prototype.formatAt.call(this, e, n, r, i); }, e.prototype.insertAt = function (e, n, r) { this.update(), t.prototype.insertAt.call(this, e, n, r); }, e.prototype.optimize = function (e, n) { const r = this; void 0 === e && (e = []), void 0 === n && (n = {}), t.prototype.optimize.call(this, n); for (var s = [].slice.call(this.observer.takeRecords()); s.length > 0;)e.push(s.pop()); for (var a = function (t, e) { void 0 === e && (e = !0), t != null && t !== r && t.domNode.parentNode != null && (t.domNode[o.DATA_KEY].mutations == null && (t.domNode[o.DATA_KEY].mutations = []), e && a(t.parent)); }, l = function (t) { t.domNode[o.DATA_KEY] != null && t.domNode[o.DATA_KEY].mutations != null && (t instanceof i.default && t.children.forEach(l), t.optimize(n)); }, u = e, c = 0; u.length > 0; c += 1) { if (c >= 100) throw new Error("[Parchment] Maximum optimize iterations reached"); for (u.forEach(((t) => { const e = o.find(t.target, !0); e != null && (e.domNode === t.target && (t.type === "childList" ? (a(o.find(t.previousSibling, !1)), [].forEach.call(t.addedNodes, ((t) => { const e = o.find(t, !1); a(e, !1), e instanceof i.default && e.children.forEach(((t) => { a(t, !1); })); }))) : t.type === "attributes" && a(e.prev)), a(e)); })), this.children.forEach(l), s = (u = [].slice.call(this.observer.takeRecords())).slice(); s.length > 0;)e.push(s.pop()); } }, e.prototype.update = function (e, n) { const r = this; void 0 === n && (n = {}), (e = e || this.observer.takeRecords()).map(((t) => { const e = o.find(t.target, !0); return e == null ? null : e.domNode[o.DATA_KEY].mutations == null ? (e.domNode[o.DATA_KEY].mutations = [t], e) : (e.domNode[o.DATA_KEY].mutations.push(t), null); })).forEach(((t) => { t != null && t !== r && t.domNode[o.DATA_KEY] != null && t.update(t.domNode[o.DATA_KEY].mutations || [], n); })), this.domNode[o.DATA_KEY].mutations != null && t.prototype.update.call(this, this.domNode[o.DATA_KEY].mutations, n), this.optimize(e, n); }, e.blotName = "scroll", e.defaultChild = "block", e.scope = o.Scope.BLOCK_BLOT, e.tagName = "DIV", e; }(i.default)); e.default = a;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(18); const o = n(1); const s = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return r(e, t), e.formats = function (n) { if (n.tagName !== e.tagName) return t.formats.call(this, n); }, e.prototype.format = function (n, r) { const o = this; n !== this.statics.blotName || r ? t.prototype.format.call(this, n, r) : (this.children.forEach(((t) => { t instanceof i.default || (t = t.wrap(e.blotName, !0)), o.attributes.copy(t); })), this.unwrap()); }, e.prototype.formatAt = function (e, n, r, i) { this.formats()[r] != null || o.query(r, o.Scope.ATTRIBUTE) ? this.isolate(e, n).format(r, i) : t.prototype.formatAt.call(this, e, n, r, i); }, e.prototype.optimize = function (n) { t.prototype.optimize.call(this, n); const r = this.formats(); if (Object.keys(r).length === 0) return this.unwrap(); const i = this.next; i instanceof e && i.prev === this && (function (t, e) { if (Object.keys(t).length !== Object.keys(e).length) return !1; for (const n in t) if (t[n] !== e[n]) return !1; return !0; }(r, i.formats())) && (i.moveChildren(this), i.remove()); }, e.blotName = "inline", e.scope = o.Scope.INLINE_BLOT, e.tagName = "SPAN", e; }(i.default)); e.default = s;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(18); const o = n(1); const s = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return r(e, t), e.formats = function (n) { const r = o.query(e.blotName).tagName; if (n.tagName !== r) return t.formats.call(this, n); }, e.prototype.format = function (n, r) { o.query(n, o.Scope.BLOCK) != null && (n !== this.statics.blotName || r ? t.prototype.format.call(this, n, r) : this.replaceWith(e.blotName)); }, e.prototype.formatAt = function (e, n, r, i) { o.query(r, o.Scope.BLOCK) != null ? this.format(r, i) : t.prototype.formatAt.call(this, e, n, r, i); }, e.prototype.insertAt = function (e, n, r) { if (r == null || o.query(n, o.Scope.INLINE) != null)t.prototype.insertAt.call(this, e, n, r); else { const i = this.split(e); const s = o.create(n, r); i.parent.insertBefore(s, i); } }, e.prototype.update = function (e, n) { navigator.userAgent.match(/Trident/) ? this.build() : t.prototype.update.call(this, e, n); }, e.blotName = "block", e.scope = o.Scope.BLOCK_BLOT, e.tagName = "P", e; }(i.default)); e.default = s;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = (function (t) { function e() { return t !== null && t.apply(this, arguments) || this; } return r(e, t), e.formats = function (t) {}, e.prototype.format = function (e, n) { t.prototype.formatAt.call(this, 0, this.length(), e, n); }, e.prototype.formatAt = function (e, n, r, i) { e === 0 && n === this.length() ? this.format(r, i) : t.prototype.formatAt.call(this, e, n, r, i); }, e.prototype.formats = function () { return this.statics.formats(this.domNode); }, e; }(n(19).default)); e.default = i;
}, function (t, e, n) {
  const r = this && this.__extends || (function () { const t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e; } || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); }; return function (e, n) { function r() { this.constructor = e; }t(e, n), e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r()); }; }()); Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(19); const o = n(1); const s = (function (t) { function e(e) { const n = t.call(this, e) || this; return n.text = n.statics.value(n.domNode), n; } return r(e, t), e.create = function (t) { return document.createTextNode(t); }, e.value = function (t) { let e = t.data; return e.normalize && (e = e.normalize()), e; }, e.prototype.deleteAt = function (t, e) { this.domNode.data = this.text = this.text.slice(0, t) + this.text.slice(t + e); }, e.prototype.index = function (t, e) { return this.domNode === t ? e : -1; }, e.prototype.insertAt = function (e, n, r) { r == null ? (this.text = this.text.slice(0, e) + n + this.text.slice(e), this.domNode.data = this.text) : t.prototype.insertAt.call(this, e, n, r); }, e.prototype.length = function () { return this.text.length; }, e.prototype.optimize = function (n) { t.prototype.optimize.call(this, n), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof e && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove()); }, e.prototype.position = function (t, e) { return void 0 === e && (e = !1), [this.domNode, t]; }, e.prototype.split = function (t, e) { if (void 0 === e && (e = !1), !e) { if (t === 0) return this; if (t === this.length()) return this.next; } const n = o.create(this.domNode.splitText(t)); return this.parent.insertBefore(n, this.next), this.text = this.statics.value(this.domNode), n; }, e.prototype.update = function (t, e) { const n = this; t.some(((t) => t.type === "characterData" && t.target === n.domNode)) && (this.text = this.statics.value(this.domNode)); }, e.prototype.value = function () { return this.text; }, e.blotName = "text", e.scope = o.Scope.INLINE_BLOT, e; }(i.default)); e.default = s;
}, function (t, e, n) {
  const r = document.createElement("div"); if (r.classList.toggle("test-class", !1), r.classList.contains("test-class")) { const i = DOMTokenList.prototype.toggle; DOMTokenList.prototype.toggle = function (t, e) { return arguments.length > 1 && !this.contains(t) == !e ? e : i.call(this, t); }; }String.prototype.startsWith || (String.prototype.startsWith = function (t, e) { return e = e || 0, this.substr(e, t.length) === t; }), String.prototype.endsWith || (String.prototype.endsWith = function (t, e) { const n = this.toString(); (typeof e !== "number" || !isFinite(e) || Math.floor(e) !== e || e > n.length) && (e = n.length), e -= t.length; const r = n.indexOf(t, e); return r !== -1 && r === e; }), Array.prototype.find || Object.defineProperty(Array.prototype, "find", { value(t) { if (this === null) throw new TypeError("Array.prototype.find called on null or undefined"); if (typeof t !== "function") throw new TypeError("predicate must be a function"); for (var e, n = Object(this), r = n.length >>> 0, i = arguments[1], o = 0; o < r; o++) if (e = n[o], t.call(i, e, o, n)) return e; } }), document.addEventListener("DOMContentLoaded", (() => { document.execCommand("enableObjectResizing", !1, !1), document.execCommand("autoUrlDetect", !1, !1); }));
}, function (t, e) { function n(t, e, n) { if (t == e) return t ? [[p, t]] : []; (n < 0 || t.length < n) && (n = null); let i = s(t, e); const o = t.substring(0, i); i = a(t = t.substring(i), e = e.substring(i)); const l = t.substring(t.length - i); let c = r(t = t.substring(0, t.length - i), e = e.substring(0, e.length - i)); return o && c.unshift([p, o]), l && c.push([p, l]), (function t(e) { e.push([p, ""]); for (var n, r = 0, i = 0, o = 0, l = "", u = ""; r < e.length;) switch (e[r][0]) { case h: o++, u += e[r][1], r++; break; case d: i++, l += e[r][1], r++; break; case p: i + o > 1 ? (i !== 0 && o !== 0 && ((n = s(u, l)) !== 0 && (r - i - o > 0 && e[r - i - o - 1][0] == p ? e[r - i - o - 1][1] += u.substring(0, n) : (e.splice(0, 0, [p, u.substring(0, n)]), r++), u = u.substring(n), l = l.substring(n)), (n = a(u, l)) !== 0 && (e[r][1] = u.substring(u.length - n) + e[r][1], u = u.substring(0, u.length - n), l = l.substring(0, l.length - n))), i === 0 ? e.splice(r - o, i + o, [h, u]) : o === 0 ? e.splice(r - i, i + o, [d, l]) : e.splice(r - i - o, i + o, [d, l], [h, u]), r = r - i - o + (i ? 1 : 0) + (o ? 1 : 0) + 1) : r !== 0 && e[r - 1][0] == p ? (e[r - 1][1] += e[r][1], e.splice(r, 1)) : r++, o = 0, i = 0, l = "", u = ""; }e[e.length - 1][1] === "" && e.pop(); let c = !1; for (r = 1; r < e.length - 1;)e[r - 1][0] == p && e[r + 1][0] == p && (e[r][1].substring(e[r][1].length - e[r - 1][1].length) == e[r - 1][1] ? (e[r][1] = e[r - 1][1] + e[r][1].substring(0, e[r][1].length - e[r - 1][1].length), e[r + 1][1] = e[r - 1][1] + e[r + 1][1], e.splice(r - 1, 1), c = !0) : e[r][1].substring(0, e[r + 1][1].length) == e[r + 1][1] && (e[r - 1][1] += e[r + 1][1], e[r][1] = e[r][1].substring(e[r + 1][1].length) + e[r + 1][1], e.splice(r + 1, 1), c = !0)), r++; c && t(e); }(c)), n != null && (c = u(c, n)), (function (t) { for (var e = !1, n = function (t) { return t.charCodeAt(0) >= 56320 && t.charCodeAt(0) <= 57343; }, r = 2; r < t.length; r += 1)t[r - 2][0] === p && (function (t) { return t.charCodeAt(t.length - 1) >= 55296 && t.charCodeAt(t.length - 1) <= 56319; }(t[r - 2][1])) && t[r - 1][0] === d && n(t[r - 1][1]) && t[r][0] === h && n(t[r][1]) && (e = !0, t[r - 1][1] = t[r - 2][1].slice(-1) + t[r - 1][1], t[r][1] = t[r - 2][1].slice(-1) + t[r][1], t[r - 2][1] = t[r - 2][1].slice(0, -1)); if (!e) return t; const i = []; for (r = 0; r < t.length; r += 1)t[r][1].length > 0 && i.push(t[r]); return i; }(c)); } function r(t, e) { let r; if (!t) return [[h, e]]; if (!e) return [[d, t]]; const o = t.length > e.length ? t : e; const s = t.length > e.length ? e : t; const a = o.indexOf(s); if (a != -1) return r = [[h, o.substring(0, a)], [p, s], [h, o.substring(a + s.length)]], t.length > e.length && (r[0][0] = r[2][0] = d), r; if (s.length == 1) return [[d, t], [h, e]]; const u = l(t, e); if (u) { const c = u[0]; const f = u[1]; const m = u[2]; const g = u[3]; const v = u[4]; const y = n(c, m); const _ = n(f, g); return y.concat([[p, v]], _); } return i(t, e); } function i(t, e) { for (var n = t.length, r = e.length, i = Math.ceil((n + r) / 2), s = i, a = 2 * i, l = new Array(a), u = new Array(a), c = 0; c < a; c++)l[c] = -1, u[c] = -1; l[s + 1] = 0, u[s + 1] = 0; for (let p = n - r, f = p % 2 != 0, m = 0, g = 0, v = 0, y = 0, _ = 0; _ < i; _++) { for (let b = -_ + m; b <= _ - g; b += 2) { for (var w = s + b, x = (T = b == -_ || b != _ && l[w - 1] < l[w + 1] ? l[w + 1] : l[w - 1] + 1) - b; T < n && x < r && t.charAt(T) == e.charAt(x);)T++, x++; if (l[w] = T, T > n)g += 2; else if (x > r)m += 2; else if (f) { if ((C = s + p - b) >= 0 && C < a && u[C] != -1) if (T >= (k = n - u[C])) return o(t, e, T, x); } } for (let S = -_ + v; S <= _ - y; S += 2) { for (var k, C = s + S, E = (k = S == -_ || S != _ && u[C - 1] < u[C + 1] ? u[C + 1] : u[C - 1] + 1) - S; k < n && E < r && t.charAt(n - k - 1) == e.charAt(r - E - 1);)k++, E++; if (u[C] = k, k > n)y += 2; else if (E > r)v += 2; else if (!f) { if ((w = s + p - S) >= 0 && w < a && l[w] != -1) { var T; x = s + (T = l[w]) - w; if (T >= (k = n - k)) return o(t, e, T, x); } } } } return [[d, t], [h, e]]; } function o(t, e, r, i) { const o = t.substring(0, r); const s = e.substring(0, i); const a = t.substring(r); const l = e.substring(i); const u = n(o, s); const c = n(a, l); return u.concat(c); } function s(t, e) { if (!t || !e || t.charAt(0) != e.charAt(0)) return 0; for (var n = 0, r = Math.min(t.length, e.length), i = r, o = 0; n < i;)t.substring(o, i) == e.substring(o, i) ? o = n = i : r = i, i = Math.floor((r - n) / 2 + n); return i; } function a(t, e) { if (!t || !e || t.charAt(t.length - 1) != e.charAt(e.length - 1)) return 0; for (var n = 0, r = Math.min(t.length, e.length), i = r, o = 0; n < i;)t.substring(t.length - i, t.length - o) == e.substring(e.length - i, e.length - o) ? o = n = i : r = i, i = Math.floor((r - n) / 2 + n); return i; } function l(t, e) { function n(t, e, n) { for (var r, i, o, l, u = t.substring(n, n + Math.floor(t.length / 4)), c = -1, d = ""; (c = e.indexOf(u, c + 1)) != -1;) { const h = s(t.substring(n), e.substring(c)); const p = a(t.substring(0, n), e.substring(0, c)); d.length < p + h && (d = e.substring(c - p, c) + e.substring(c, c + h), r = t.substring(0, n - p), i = t.substring(n + h), o = e.substring(0, c - p), l = e.substring(c + h)); } return 2 * d.length >= t.length ? [r, i, o, l, d] : null; } const r = t.length > e.length ? t : e; const i = t.length > e.length ? e : t; if (r.length < 4 || 2 * i.length < r.length) return null; let o; let l; let u; let c; let d; const h = n(r, i, Math.ceil(r.length / 4)); const p = n(r, i, Math.ceil(r.length / 2)); return h || p ? (o = p ? h && h[4].length > p[4].length ? h : p : h, t.length > e.length ? (l = o[0], u = o[1], c = o[2], d = o[3]) : (c = o[0], d = o[1], l = o[2], u = o[3]), [l, u, c, d, o[4]]) : null; } function u(t, e) { const n = (function (t, e) { if (e === 0) return [p, t]; for (let n = 0, r = 0; r < t.length; r++) { const i = t[r]; if (i[0] === d || i[0] === p) { const o = n + i[1].length; if (e === o) return [r + 1, t]; if (e < o) { t = t.slice(); const s = e - n; const a = [i[0], i[1].slice(0, s)]; const l = [i[0], i[1].slice(s)]; return t.splice(r, 1, a, l), [r + 1, t]; }n = o; } } throw new Error("cursor_pos is out of bounds!"); }(t, e)); const r = n[1]; const i = n[0]; const o = r[i]; const s = r[i + 1]; if (o == null) return t; if (o[0] !== p) return t; if (s != null && o[1] + s[1] === s[1] + o[1]) return r.splice(i, 2, s, o), c(r, i, 2); if (s != null && s[1].indexOf(o[1]) === 0) { r.splice(i, 2, [s[0], o[1]], [0, o[1]]); const a = s[1].slice(o[1].length); return a.length > 0 && r.splice(i + 2, 0, [s[0], a]), c(r, i, 3); } return t; } function c(t, e, n) { for (let r = e + n - 1; r >= 0 && r >= e - 1; r--) if (r + 1 < t.length) { const i = t[r]; const o = t[r + 1]; i[0] === o[1] && t.splice(r, 2, [i[0], i[1] + o[1]]); } return t; } var d = -1; var h = 1; var p = 0; const f = n; f.INSERT = h, f.DELETE = d, f.EQUAL = p, t.exports = f; }, function (t, e) { function n(t) { const e = []; for (const n in t)e.push(n); return e; }(t.exports = typeof Object.keys === "function" ? Object.keys : n).shim = n; }, function (t, e) { function n(t) { return Object.prototype.toString.call(t) == "[object Arguments]"; } function r(t) { return t && typeof t === "object" && typeof t.length === "number" && Object.prototype.hasOwnProperty.call(t, "callee") && !Object.prototype.propertyIsEnumerable.call(t, "callee") || !1; } const i = (function () { return Object.prototype.toString.call(arguments); }()) == "[object Arguments]"; (e = t.exports = i ? n : r).supported = n, e.unsupported = r; }, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { return Object.keys(e).reduce(((n, r) => (t[r] == null || (e[r] === t[r] ? n[r] = e[r] : Array.isArray(e[r]) ? e[r].indexOf(t[r]) < 0 && (n[r] = e[r].concat([t[r]])) : n[r] = [e[r], t[r]]), n)), {}); }Object.defineProperty(e, "__esModule", { value: !0 }); const o = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }; const s = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const a = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const l = r(n(4)); const u = r(n(20)); const c = r(n(0)); const d = r(n(13)); const h = r(n(31)); const p = n(3); const f = r(p); const m = r(n(14)); const g = r(n(21)); const v = r(n(12)); const y = r(n(2)); const _ = /^[ -~]*$/; const b = (function () {
    function t(e) { (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.scroll = e, this.delta = this.getDelta(); } return a(t, [{ key: "applyDelta", value(t) { const e = this; let n = !1; this.scroll.update(); let r = this.scroll.length(); return this.scroll.batchStart(), (t = (function (t) { return t.reduce(((t, e) => { if (e.insert === 1) { const n = (0, g.default)(e.attributes); return delete n.image, t.insert({ image: e.attributes.image }, n); } if (e.attributes == null || !0 !== e.attributes.list && !0 !== e.attributes.bullet || ((e = (0, g.default)(e)).attributes.list ? e.attributes.list = "ordered" : (e.attributes.list = "bullet", delete e.attributes.bullet)), typeof e.insert === "string") { const r = e.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n"); return t.insert(r, e.attributes); } return t.push(e); }), new l.default()); }(t))).reduce(((t, i) => { const a = i.retain || i.delete || i.insert.length || 1; let l = i.attributes || {}; if (i.insert != null) { if (typeof i.insert === "string") { let d = i.insert; d.endsWith("\n") && n && (n = !1, d = d.slice(0, -1)), t >= r && !d.endsWith("\n") && (n = !0), e.scroll.insertAt(t, d); const h = e.scroll.line(t); const m = s(h, 2); const g = m[0]; const v = m[1]; let _ = (0, y.default)({}, (0, p.bubbleFormats)(g)); if (g instanceof f.default) { const b = g.descendant(c.default.Leaf, v); const w = s(b, 1)[0]; _ = (0, y.default)(_, (0, p.bubbleFormats)(w)); }l = u.default.attributes.diff(_, l) || {}; } else if (o(i.insert) === "object") { const x = Object.keys(i.insert)[0]; if (x == null) return t; e.scroll.insertAt(t, x, i.insert[x]); }r += a; } return Object.keys(l).forEach(((n) => { e.scroll.formatAt(t, a, n, l[n]); })), t + a; }), 0), t.reduce(((t, n) => (typeof n.delete == "number" ? (e.scroll.deleteAt(t, n.delete), t) : t + (n.retain || n.insert.length || 1))), 0), this.scroll.batchEnd(), this.update(t); } }, { key: "deleteText", value(t, e) { return this.scroll.deleteAt(t, e), this.update((new l.default()).retain(t).delete(e)); } }, { key: "formatLine", value(t, e) { const n = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return this.scroll.update(), Object.keys(r).forEach(((i) => { if (n.scroll.whitelist == null || n.scroll.whitelist[i]) { const o = n.scroll.lines(t, Math.max(e, 1)); let s = e; o.forEach(((e) => { const o = e.length(); if (e instanceof d.default) { const a = t - e.offset(n.scroll); const l = e.newlineIndex(a + s) - a + 1; e.formatAt(a, l, i, r[i]); } else e.format(i, r[i]); s -= o; })); } })), this.scroll.optimize(), this.update((new l.default()).retain(t).retain(e, (0, g.default)(r))); } }, { key: "formatText", value(t, e) { const n = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return Object.keys(r).forEach(((i) => { n.scroll.formatAt(t, e, i, r[i]); })), this.update((new l.default()).retain(t).retain(e, (0, g.default)(r))); } }, { key: "getContents", value(t, e) { return this.delta.slice(t, t + e); } }, { key: "getDelta", value() { return this.scroll.lines().reduce(((t, e) => t.concat(e.delta())), new l.default()); } }, { key: "getFormat", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; let n = []; let r = []; e === 0 ? this.scroll.path(t).forEach(((t) => { const e = s(t, 1)[0]; e instanceof f.default ? n.push(e) : e instanceof c.default.Leaf && r.push(e); })) : (n = this.scroll.lines(t, e), r = this.scroll.descendants(c.default.Leaf, t, e)); const o = [n, r].map(((t) => { if (t.length === 0) return {}; for (var e = (0, p.bubbleFormats)(t.shift()); Object.keys(e).length > 0;) { const n = t.shift(); if (n == null) return e; e = i((0, p.bubbleFormats)(n), e); } return e; })); return y.default.apply(y.default, o); } }, { key: "getText", value(t, e) { return this.getContents(t, e).filter(((t) => typeof t.insert === "string")).map(((t) => t.insert)).join(""); } }, {
      key: "insertEmbed",
      value(t, e, n) {
        return this.scroll.insertAt(t, e, n), this.update((new l.default()).retain(t).insert(function (t, e, n) {
          return e in t ? Object.defineProperty(t, e, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }) : t[e] = n, t;
        }({}, e, n)));
      }, 
    }, { key: "insertText", value(t, e) { const n = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t, e), Object.keys(r).forEach(((i) => { n.scroll.formatAt(t, e.length, i, r[i]); })), this.update((new l.default()).retain(t).insert(e, (0, g.default)(r))); } }, { key: "isBlank", value() { if (this.scroll.children.length == 0) return !0; if (this.scroll.children.length > 1) return !1; const t = this.scroll.children.head; return t.statics.blotName === f.default.blotName && !(t.children.length > 1) && t.children.head instanceof m.default; } }, { key: "removeFormat", value(t, e) { const n = this.getText(t, e); const r = this.scroll.line(t + e); const i = s(r, 2); const o = i[0]; const a = i[1]; let u = 0; let c = new l.default(); o != null && (u = o instanceof d.default ? o.newlineIndex(a) - a + 1 : o.length() - a, c = o.delta().slice(a, a + u - 1).insert("\n")); const h = this.getContents(t, e + u).diff((new l.default()).insert(n).concat(c)); const p = (new l.default()).retain(t).concat(h); return this.applyDelta(p); } }, { key: "update", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0; const r = this.delta; if (e.length === 1 && e[0].type === "characterData" && e[0].target.data.match(_) && c.default.find(e[0].target)) { const i = c.default.find(e[0].target); const o = (0, p.bubbleFormats)(i); const s = i.offset(this.scroll); const a = e[0].oldValue.replace(h.default.CONTENTS, ""); const u = (new l.default()).insert(a); const d = (new l.default()).insert(i.value()); t = (new l.default()).retain(s).concat(u.diff(d, n)).reduce(((t, e) => (e.insert ? t.insert(e.insert, o) : t.push(e))), new l.default()), this.delta = r.compose(t); } else this.delta = this.getDelta(), t && (0, v.default)(r.compose(t), this.delta) || (t = r.diff(this.delta, n)); return t; } }]), t;
  }()); e.default = b;
}, function (t, e) {
  function n() {} function r(t, e, n) { this.fn = t, this.context = e, this.once = n || !1; } function i() { this._events = new n(), this._eventsCount = 0; } const o = Object.prototype.hasOwnProperty; let s = "~"; Object.create && (n.prototype = Object.create(null), (new n()).__proto__ || (s = !1)), i.prototype.eventNames = function () { let t; let e; const n = []; if (this._eventsCount === 0) return n; for (e in t = this._events)o.call(t, e) && n.push(s ? e.slice(1) : e); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n; }, i.prototype.listeners = function (t, e) { const n = s ? s + t : t; const r = this._events[n]; if (e) return !!r; if (!r) return []; if (r.fn) return [r.fn]; for (var i = 0, o = r.length, a = new Array(o); i < o; i++)a[i] = r[i].fn; return a; }, i.prototype.emit = function (t, e, n, r, i, o) { const a = s ? s + t : t; if (!this._events[a]) return !1; let l; let u; const c = this._events[a]; const d = arguments.length; if (c.fn) { switch (c.once && this.removeListener(t, c.fn, void 0, !0), d) { case 1: return c.fn.call(c.context), !0; case 2: return c.fn.call(c.context, e), !0; case 3: return c.fn.call(c.context, e, n), !0; case 4: return c.fn.call(c.context, e, n, r), !0; case 5: return c.fn.call(c.context, e, n, r, i), !0; case 6: return c.fn.call(c.context, e, n, r, i, o), !0; } for (u = 1, l = new Array(d - 1); u < d; u++)l[u - 1] = arguments[u]; c.fn.apply(c.context, l); } else { let h; const p = c.length; for (u = 0; u < p; u++) switch (c[u].once && this.removeListener(t, c[u].fn, void 0, !0), d) { case 1: c[u].fn.call(c[u].context); break; case 2: c[u].fn.call(c[u].context, e); break; case 3: c[u].fn.call(c[u].context, e, n); break; case 4: c[u].fn.call(c[u].context, e, n, r); break; default: if (!l) for (h = 1, l = new Array(d - 1); h < d; h++)l[h - 1] = arguments[h]; c[u].fn.apply(c[u].context, l); } } return !0; }, i.prototype.on = function (t, e, n) { const i = new r(e, n || this); const o = s ? s + t : t; return this._events[o] ? this._events[o].fn ? this._events[o] = [this._events[o], i] : this._events[o].push(i) : (this._events[o] = i, this._eventsCount++), this; }, i.prototype.once = function (t, e, n) { const i = new r(e, n || this, !0); const o = s ? s + t : t; return this._events[o] ? this._events[o].fn ? this._events[o] = [this._events[o], i] : this._events[o].push(i) : (this._events[o] = i, this._eventsCount++), this; }, i.prototype.removeListener = function (t, e, r, i) { const o = s ? s + t : t; if (!this._events[o]) return this; if (!e) return --this._eventsCount == 0 ? this._events = new n() : delete this._events[o], this; const a = this._events[o]; if (a.fn)a.fn !== e || i && !a.once || r && a.context !== r || (--this._eventsCount == 0 ? this._events = new n() : delete this._events[o]); else { for (var l = 0, u = [], c = a.length; l < c; l++)(a[l].fn !== e || i && !a[l].once || r && a[l].context !== r) && u.push(a[l]); u.length ? this._events[o] = u.length === 1 ? u[0] : u : --this._eventsCount == 0 ? this._events = new n() : delete this._events[o]; } return this; }, i.prototype.removeAllListeners = function (t) { let e; return t ? (e = s ? s + t : t, this._events[e] && (--this._eventsCount == 0 ? this._events = new n() : delete this._events[e])) : (this._events = new n(), this._eventsCount = 0), this; }, i.prototype.off = i.prototype.removeListener, i.prototype.addListener = i.prototype.on, i.prototype.setMaxListeners = function () { return this; }, i.prefixed = s, i.EventEmitter = i, void 0 !== t && (t.exports = i);
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t) { return t instanceof d.default || t instanceof c.BlockEmbed; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const s = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const a = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const l = r(n(0)); const u = r(n(9)); var c = n(3); var d = r(c); const h = r(n(14)); const p = r(n(13)); const f = r(n(23)); const m = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t))); return r.emitter = n.emitter, Array.isArray(n.whitelist) && (r.whitelist = n.whitelist.reduce(((t, e) => (t[e] = !0, t)), {})), r.domNode.addEventListener("DOMNodeInserted", (() => {})), r.optimize(), r.enable(), r; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), s(e, [{ key: "batchStart", value() { this.batch = !0; } }, { key: "batchEnd", value() { this.batch = !1, this.optimize(); } }, { key: "deleteAt", value(t, n) { const r = this.line(t); const i = o(r, 2); let s = i[0]; const l = i[1]; const u = this.line(t + n); const d = o(u, 1)[0]; if (a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "deleteAt", this).call(this, t, n), d != null && s !== d && l > 0) { if (s instanceof c.BlockEmbed || d instanceof c.BlockEmbed) return void this.optimize(); if (s instanceof p.default) { const f = s.newlineIndex(s.length(), !0); if (f > -1 && (s = s.split(f + 1)) === d) return void this.optimize(); } else if (d instanceof p.default) { const m = d.newlineIndex(0); m > -1 && d.split(m + 1); } const g = d.children.head instanceof h.default ? null : d.children.head; s.moveChildren(d, g), s.remove(); } this.optimize(); } }, { key: "enable", value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.domNode.setAttribute("contenteditable", t); } }, { key: "formatAt", value(t, n, r, i) { (this.whitelist == null || this.whitelist[r]) && (a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "formatAt", this).call(this, t, n, r, i), this.optimize()); } }, { key: "insertAt", value(t, n, r) { if (r == null || this.whitelist == null || this.whitelist[n]) { if (t >= this.length()) if (r == null || l.default.query(n, l.default.Scope.BLOCK) == null) { const i = l.default.create(this.statics.defaultChild); this.appendChild(i), r == null && n.endsWith("\n") && (n = n.slice(0, -1)), i.insertAt(0, n, r); } else { const o = l.default.create(n, r); this.appendChild(o); } else a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertAt", this).call(this, t, n, r); this.optimize(); } } }, { key: "insertBefore", value(t, n) { if (t.statics.scope === l.default.Scope.INLINE_BLOT) { const r = l.default.create(this.statics.defaultChild); r.appendChild(t), t = r; }a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertBefore", this).call(this, t, n); } }, { key: "leaf", value(t) { return this.path(t).pop() || [null, -1]; } }, { key: "line", value(t) { return t === this.length() ? this.line(t - 1) : this.descendant(i, t); } }, { key: "lines", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE; return (function t(e, n, r) { let o = []; let s = r; return e.children.forEachAt(n, r, ((e, n, r) => { i(e) ? o.push(e) : e instanceof l.default.Container && (o = o.concat(t(e, n, s))), s -= r; })), o; }(this, t, e)); } }, { key: "optimize", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; !0 !== this.batch && (a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t, n), t.length > 0 && this.emitter.emit(u.default.events.SCROLL_OPTIMIZE, t, n)); } }, { key: "path", value(t) { return a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "path", this).call(this, t).slice(1); } }, { key: "update", value(t) { if (!0 !== this.batch) { let n = u.default.sources.USER; typeof t === "string" && (n = t), Array.isArray(t) || (t = this.observer.takeRecords()), t.length > 0 && this.emitter.emit(u.default.events.SCROLL_BEFORE_UPDATE, n, t), a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "update", this).call(this, t.concat([])), t.length > 0 && this.emitter.emit(u.default.events.SCROLL_UPDATE, n, t); } } }]), e;
  }(l.default.Scroll)); m.blotName = "scroll", m.className = "ql-editor", m.tagName = "DIV", m.defaultChild = "block", m.allowedChildren = [d.default, c.BlockEmbed, f.default], e.default = m;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
      value: n, enumerable: !0, configurable: !0, writable: !0,
    }) : t[e] = n, t;
  } function o(t, e, n) { return (void 0 === e ? "undefined" : m(e)) === "object" ? Object.keys(e).reduce(((t, n) => o(t, n, e[n])), t) : t.reduce(((t, r) => (r.attributes && r.attributes[e] ? t.push(r) : t.insert(r.insert, (0, y.default)({}, i({}, e, n), r.attributes)))), new _.default()); } function s(t) { return t.nodeType !== Node.ELEMENT_NODE ? {} : t["__ql-computed-style"] || (t["__ql-computed-style"] = window.getComputedStyle(t)); } function a(t, e) { for (var n = "", r = t.ops.length - 1; r >= 0 && n.length < e.length; --r) { const i = t.ops[r]; if (typeof i.insert !== "string") break; n = i.insert + n; } return n.slice(-1 * e.length) === e; } function l(t) { return t.childNodes.length !== 0 && ["block", "list-item"].indexOf(s(t).display) > -1; } function u(t, e, n) { return o(n, t, !0); } function c(t, e) { const n = b.default.Attributor.Attribute.keys(t); const r = b.default.Attributor.Class.keys(t); const i = b.default.Attributor.Style.keys(t); const s = {}; return n.concat(r).concat(i).forEach(((e) => { let n = b.default.query(e, b.default.Scope.ATTRIBUTE); n != null && (s[n.attrName] = n.value(t), s[n.attrName]) || ((n = j[e]) == null || n.attrName !== e && n.keyName !== e || (s[n.attrName] = n.value(t) || void 0), (n = D[e]) == null || n.attrName !== e && n.keyName !== e || (n = D[e], s[n.attrName] = n.value(t) || void 0)); })), Object.keys(s).length > 0 && (e = o(e, s)), e; } function d(t, e) { const n = b.default.query(t); if (n == null) return e; if (n.prototype instanceof b.default.Embed) { const r = {}; const i = n.value(t); i != null && (r[n.blotName] = i, e = (new _.default()).insert(r, n.formats(t))); } else typeof n.formats === "function" && (e = o(e, n.blotName, n.formats(t))); return e; } function h(t, e) { return a(e, "\n") || (l(t) || e.length() > 0 && t.nextSibling && l(t.nextSibling)) && e.insert("\n"), e; } function p(t, e) { if (l(t) && t.nextElementSibling != null && !a(e, "\n\n")) { const n = t.offsetHeight + parseFloat(s(t).marginTop) + parseFloat(s(t).marginBottom); t.nextElementSibling.offsetTop > t.offsetTop + 1.5 * n && e.insert("\n"); } return e; } function f(t, e) { let n = t.data; if (t.parentNode.tagName === "O:P") return e.insert(n.trim()); if (n.trim().length === 0 && t.parentNode.classList.contains("ql-clipboard")) return e; if (!s(t.parentNode).whiteSpace.startsWith("pre")) { const r = function (t, e) { return (e = e.replace(/[^\u00a0]/g, "")).length < 1 && t ? " " : e; }; n = (n = n.replace(/\r\n/g, " ").replace(/\n/g, " ")).replace(/\s\s+/g, r.bind(r, !0)), (t.previousSibling == null && l(t.parentNode) || t.previousSibling != null && l(t.previousSibling)) && (n = n.replace(/^\s+/, r.bind(r, !1))), (t.nextSibling == null && l(t.parentNode) || t.nextSibling != null && l(t.nextSibling)) && (n = n.replace(/\s+$/, r.bind(r, !1))); } return e.insert(n); }Object.defineProperty(e, "__esModule", { value: !0 }), e.matchText = e.matchSpacing = e.matchNewline = e.matchBlot = e.matchAttributor = e.default = void 0; var m = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }; const g = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const v = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); var y = r(n(2)); var _ = r(n(4)); var b = r(n(0)); const w = r(n(6)); const x = r(n(10)); const S = r(n(7)); const k = n(34); const C = n(35); const E = r(n(13)); const T = n(24); const P = n(36); const O = n(37); const A = n(38); const M = (0, x.default)("quill:clipboard"); const L = "__ql-matcher"; const I = [[Node.TEXT_NODE, f], [Node.TEXT_NODE, h], ["br", function (t, e) { return a(e, "\n") || e.insert("\n"), e; }], [Node.ELEMENT_NODE, h], [Node.ELEMENT_NODE, d], [Node.ELEMENT_NODE, p], [Node.ELEMENT_NODE, c], [Node.ELEMENT_NODE, function (t, e) { const n = {}; const r = t.style || {}; return r.fontStyle && s(t).fontStyle === "italic" && (n.italic = !0), r.fontWeight && (s(t).fontWeight.startsWith("bold") || parseInt(s(t).fontWeight) >= 700) && (n.bold = !0), Object.keys(n).length > 0 && (e = o(e, n)), parseFloat(r.textIndent || 0) > 0 && (e = (new _.default()).insert("\t").concat(e)), e; }], ["li", function (t, e) { const n = b.default.query(t); if (n == null || n.blotName !== "list-item" || !a(e, "\n")) return e; for (var r = -1, i = t.parentNode; !i.classList.contains("ql-clipboard");)(b.default.query(i) || {}).blotName === "list" && (r += 1), i = i.parentNode; return r <= 0 ? e : e.compose((new _.default()).retain(e.length() - 1).retain(1, { indent: r })); }], ["b", u.bind(u, "bold")], ["i", u.bind(u, "italic")], ["style", function () { return new _.default(); }]]; var j = [k.AlignAttribute, P.DirectionAttribute].reduce(((t, e) => (t[e.keyName] = e, t)), {}); var D = [k.AlignStyle, C.BackgroundStyle, T.ColorStyle, P.DirectionStyle, O.FontStyle, A.SizeStyle].reduce(((t, e) => (t[e.keyName] = e, t)), {}); const N = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))); return r.quill.root.addEventListener("paste", r.onPaste.bind(r)), r.container = r.quill.addContainer("ql-clipboard"), r.container.setAttribute("contenteditable", !0), r.container.setAttribute("tabindex", -1), r.matchers = [], I.concat(r.options.matchers).forEach(((t) => { const e = g(t, 2); const i = e[0]; const o = e[1]; (n.matchVisual || o !== p) && r.addMatcher(i, o); })), r; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), v(e, [{ key: "addMatcher", value(t, e) { this.matchers.push([t, e]); } }, { key: "convert", value(t) { if (typeof t === "string") return this.container.innerHTML = t.replace(/\>\r?\n +\</g, "><"), this.convert(); const e = this.quill.getFormat(this.quill.selection.savedRange.index); if (e[E.default.blotName]) { const n = this.container.innerText; return this.container.innerHTML = "", (new _.default()).insert(n, i({}, E.default.blotName, e[E.default.blotName])); } const r = this.prepareMatching(); const o = g(r, 2); const s = o[0]; const l = o[1]; let u = (function t(e, n, r) { return e.nodeType === e.TEXT_NODE ? r.reduce(((t, n) => n(e, t)), new _.default()) : e.nodeType === e.ELEMENT_NODE ? [].reduce.call(e.childNodes || [], ((i, o) => { let s = t(o, n, r); return o.nodeType === e.ELEMENT_NODE && (s = n.reduce(((t, e) => e(o, t)), s), s = (o[L] || []).reduce(((t, e) => e(o, t)), s)), i.concat(s); }), new _.default()) : new _.default(); }(this.container, s, l)); return a(u, "\n") && u.ops[u.ops.length - 1].attributes == null && (u = u.compose((new _.default()).retain(u.length() - 1).delete(1))), M.log("convert", this.container.innerHTML, u), this.container.innerHTML = "", u; } }, { key: "dangerouslyPasteHTML", value(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : w.default.sources.API; if (typeof t === "string") this.quill.setContents(this.convert(t), e), this.quill.setSelection(0, w.default.sources.SILENT); else { const r = this.convert(e); this.quill.updateContents((new _.default()).retain(t).concat(r), n), this.quill.setSelection(t + r.length(), w.default.sources.SILENT); } } }, { key: "onPaste", value(t) { const e = this; if (!t.defaultPrevented && this.quill.isEnabled()) { const n = this.quill.getSelection(); let r = (new _.default()).retain(n.index); const i = this.quill.scrollingContainer.scrollTop; this.container.focus(), this.quill.selection.update(w.default.sources.SILENT), setTimeout((() => { r = r.concat(e.convert()).delete(n.length), e.quill.updateContents(r, w.default.sources.USER), e.quill.setSelection(r.length() - n.length, w.default.sources.SILENT), e.quill.scrollingContainer.scrollTop = i, e.quill.focus(); }), 1); } } }, { key: "prepareMatching", value() { const t = this; const e = []; const n = []; return this.matchers.forEach(((r) => { const i = g(r, 2); const o = i[0]; const s = i[1]; switch (o) { case Node.TEXT_NODE: n.push(s); break; case Node.ELEMENT_NODE: e.push(s); break; default: [].forEach.call(t.container.querySelectorAll(o), ((t) => { t[L] = t[L] || [], t[L].push(s); })); } })), [e, n]; } }]), e;
  }(S.default)); N.DEFAULTS = { matchers: [], matchVisual: !0 }, e.default = N, e.matchAttributor = c, e.matchBlot = d, e.matchNewline = h, e.matchSpacing = p, e.matchText = f;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t) { const e = t.reduce(((t, e) => t + (e.delete || 0)), 0); let n = t.length() - e; return (function (t) { const e = t.ops[t.ops.length - 1]; return e != null && (e.insert != null ? typeof e.insert === "string" && e.insert.endsWith("\n") : e.attributes != null && Object.keys(e.attributes).some(((t) => s.default.query(t, s.default.Scope.BLOCK) != null))); }(t)) && (n -= 1), n; }Object.defineProperty(e, "__esModule", { value: !0 }), e.getLastChangeIndex = e.default = void 0; const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); var s = r(n(0)); const a = r(n(6)); const l = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); const r = (function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))); return r.lastRecorded = 0, r.ignoreChange = !1, r.clear(), r.quill.on(a.default.events.EDITOR_CHANGE, ((t, e, n, i) => { t !== a.default.events.TEXT_CHANGE || r.ignoreChange || (r.options.userOnly && i !== a.default.sources.USER ? r.transform(e) : r.record(e, n)); })), r.quill.keyboard.addBinding({ key: "Z", shortKey: !0 }, r.undo.bind(r)), r.quill.keyboard.addBinding({ key: "Z", shortKey: !0, shiftKey: !0 }, r.redo.bind(r)), /Win/i.test(navigator.platform) && r.quill.keyboard.addBinding({ key: "Y", shortKey: !0 }, r.redo.bind(r)), r; } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "change", value(t, e) { if (this.stack[t].length !== 0) { const n = this.stack[t].pop(); this.stack[e].push(n), this.lastRecorded = 0, this.ignoreChange = !0, this.quill.updateContents(n[t], a.default.sources.USER), this.ignoreChange = !1; const r = i(n[t]); this.quill.setSelection(r); } } }, { key: "clear", value() { this.stack = { undo: [], redo: [] }; } }, { key: "cutoff", value() { this.lastRecorded = 0; } }, { key: "record", value(t, e) { if (t.ops.length !== 0) { this.stack.redo = []; let n = this.quill.getContents().diff(e); const r = Date.now(); if (this.lastRecorded + this.options.delay > r && this.stack.undo.length > 0) { const i = this.stack.undo.pop(); n = n.compose(i.undo), t = i.redo.compose(t); } else this.lastRecorded = r; this.stack.undo.push({ redo: t, undo: n }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift(); } } }, { key: "redo", value() { this.change("redo", "undo"); } }, { key: "transform", value(t) { this.stack.undo.forEach(((e) => { e.undo = t.transform(e.undo, !0), e.redo = t.transform(e.redo, !0); })), this.stack.redo.forEach(((e) => { e.undo = t.transform(e.undo, !0), e.redo = t.transform(e.redo, !0); })); } }, { key: "undo", value() { this.change("undo", "redo"); } }]), e;
  }(r(n(7)).default)); l.DEFAULTS = { delay: 1e3, maxStack: 100, userOnly: !1 }, e.default = l, e.getLastChangeIndex = i;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }), e.IndentClass = void 0; const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const a = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const l = new (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        },
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "add", value(t, n) { if (n === "+1" || n === "-1") { const r = this.value(t) || 0; n = n === "+1" ? r + 1 : r - 1; } return n === 0 ? (this.remove(t), !0) : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "add", this).call(this, t, n); } }, { key: "canAdd", value(t, n) { return s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "canAdd", this).call(this, t, n) || s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "canAdd", this).call(this, t, parseInt(n)); } }, { key: "value", value(t) { return parseInt(s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "value", this).call(this, t)) || void 0; } }]), e;
  }(a.default.Attributor.Class))("indent", "ql-indent", { scope: a.default.Scope.BLOCK, whitelist: [1, 2, 3, 4, 5, 6, 7, 8] }); e.IndentClass = l;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(3))).default)); o.blotName = "blockquote", o.tagName = "blockquote", e.default = o;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, null, [{ key: "formats", value(t) { return this.tagName.indexOf(t.tagName) + 1; } }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(3))).default)); s.blotName = "header", s.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"], e.default = s;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.ListItem = void 0; const a = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const l = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const u = r(n(0)); const c = r(n(3)); const d = r(n(23)); const h = (function (t) { function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return s(e, t), a(e, [{ key: "format", value(t, n) { t !== p.blotName || n ? l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n) : this.replaceWith(u.default.create(this.statics.scope)); } }, { key: "remove", value() { this.prev == null && this.next == null ? this.parent.remove() : l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "remove", this).call(this); } }, { key: "replaceWith", value(t, n) { return this.parent.isolate(this.offset(this.parent), this.length()), t === this.parent.statics.blotName ? (this.parent.replaceWith(t, n), this) : (this.parent.unwrap(), l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replaceWith", this).call(this, t, n)); } }], [{ key: "formats", value(t) { return t.tagName === this.tagName ? void 0 : l(e.__proto__ || Object.getPrototypeOf(e), "formats", this).call(this, t); } }]), e; }(c.default)); h.blotName = "list-item", h.tagName = "LI"; var p = (function (t) {
    function e(t) { i(this, e); const n = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)); const r = function (e) { if (e.target.parentNode === t) { const r = n.statics.formats(t); const i = u.default.find(e.target); r === "checked" ? i.format("list", "unchecked") : r === "unchecked" && i.format("list", "checked"); } }; return t.addEventListener("touchstart", r), t.addEventListener("mousedown", r), n; } return s(e, t), a(e, null, [{ key: "create", value(t) { const n = t === "ordered" ? "OL" : "UL"; const r = l(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, n); return t !== "checked" && t !== "unchecked" || r.setAttribute("data-checked", t === "checked"), r; } }, { key: "formats", value(t) { return t.tagName === "OL" ? "ordered" : t.tagName === "UL" ? t.hasAttribute("data-checked") ? t.getAttribute("data-checked") === "true" ? "checked" : "unchecked" : "bullet" : void 0; } }]), a(e, [{ key: "format", value(t, e) { this.children.length > 0 && this.children.tail.format(t, e); } }, {
      key: "formats",
      value() {
        return (function (t, e, n) {
          return e in t ? Object.defineProperty(t, e, {
            value: n, enumerable: !0, configurable: !0, writable: !0,
          }) : t[e] = n, t;
        }({}, this.statics.blotName, this.statics.formats(this.domNode)));
      }, 
    }, { key: "insertBefore", value(t, n) { if (t instanceof h)l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "insertBefore", this).call(this, t, n); else { const r = n == null ? this.length() : n.offset(this); const i = this.split(r); i.parent.insertBefore(t, i); } } }, { key: "optimize", value(t) { l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "optimize", this).call(this, t); const n = this.next; n != null && n.prev === this && n.statics.blotName === this.statics.blotName && n.domNode.tagName === this.domNode.tagName && n.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked") && (n.moveChildren(this), n.remove()); } }, { key: "replace", value(t) { if (t.statics.blotName !== this.statics.blotName) { const n = u.default.create(this.statics.defaultChild); t.moveChildren(n), this.appendChild(n); }l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replace", this).call(this, t); } }]), e;
  }(d.default)); p.blotName = "list", p.scope = u.default.Scope.BLOCK_BLOT, p.tagName = ["OL", "UL"], p.defaultChild = "list-item", p.allowedChildren = [h], e.ListItem = h, e.default = p;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(39))).default)); o.blotName = "italic", o.tagName = ["EM", "I"], e.default = o;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, null, [{ key: "create", value(t) { return t === "super" ? document.createElement("sup") : t === "sub" ? document.createElement("sub") : (function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.__proto__ || Object.getPrototypeOf(e), "create", this)).call(this, t); } }, { key: "formats", value(t) { return t.tagName === "SUB" ? "sub" : t.tagName === "SUP" ? "super" : void 0; } }]), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(5))).default)); s.blotName = "script", s.tagName = ["SUB", "SUP"], e.default = s;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(5))).default)); o.blotName = "strike", o.tagName = "S", e.default = o;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), e;
  }((function (t) { return t && t.__esModule ? t : { default: t }; }(n(5))).default)); o.blotName = "underline", o.tagName = "U", e.default = o;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const a = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(0))); const l = n(15); const u = ["alt", "height", "width"]; const c = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "format", value(t, n) { u.indexOf(t) > -1 ? n ? this.domNode.setAttribute(t, n) : this.domNode.removeAttribute(t) : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n); } }], [{ key: "create", value(t) { const n = s(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t); return typeof t === "string" && n.setAttribute("src", this.sanitize(t)), n; } }, { key: "formats", value(t) { return u.reduce(((e, n) => (t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e)), {}); } }, { key: "match", value(t) { return /\.(jpe?g|gif|png)$/.test(t) || /^data:image\/.+;base64/.test(t); } }, { key: "sanitize", value(t) { return (0, l.sanitize)(t, ["http", "https", "data"]) ? t : "//:0"; } }, { key: "value", value(t) { return t.getAttribute("src"); } }]), e;
  }(a.default.Embed)); c.blotName = "image", c.tagName = "IMG", e.default = c;
}, function (t, e, n) {
  function r(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; }Object.defineProperty(e, "__esModule", { value: !0 }); const o = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const s = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const a = n(3); const l = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(15))); const u = ["height", "width"]; const c = (function (t) {
    function e() { return r(this, e), i(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), o(e, [{ key: "format", value(t, n) { u.indexOf(t) > -1 ? n ? this.domNode.setAttribute(t, n) : this.domNode.removeAttribute(t) : s(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "format", this).call(this, t, n); } }], [{ key: "create", value(t) { const n = s(e.__proto__ || Object.getPrototypeOf(e), "create", this).call(this, t); return n.setAttribute("frameborder", "0"), n.setAttribute("allowfullscreen", !0), n.setAttribute("src", this.sanitize(t)), n; } }, { key: "formats", value(t) { return u.reduce(((e, n) => (t.hasAttribute(n) && (e[n] = t.getAttribute(n)), e)), {}); } }, { key: "sanitize", value(t) { return l.default.sanitize(t); } }, { key: "value", value(t) { return t.getAttribute("src"); } }]), e;
  }(a.BlockEmbed)); c.blotName = "video", c.className = "ql-video", c.tagName = "IFRAME", e.default = c;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.FormulaBlot = void 0; const a = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const l = r(n(33)); const u = r(n(6)); const c = r(n(7)); const d = (function (t) { function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return s(e, t), a(e, null, [{ key: "create", value(t) { const n = (function t(e, n, r) { e === null && (e = Function.prototype); let i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { let o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; let s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.__proto__ || Object.getPrototypeOf(e), "create", this)).call(this, t); return typeof t === "string" && (window.katex.render(t, n, { throwOnError: !1, errorColor: "#f00" }), n.setAttribute("data-value", t)), n; } }, { key: "value", value(t) { return t.getAttribute("data-value"); } }]), e; }(l.default)); d.blotName = "formula", d.className = "ql-formula", d.tagName = "SPAN"; const h = (function (t) { function e() { i(this, e); const t = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); if (window.katex == null) throw new Error("Formula module requires KaTeX."); return t; } return s(e, t), a(e, null, [{ key: "register", value() { u.default.register(d, !0); } }]), e; }(c.default)); e.FormulaBlot = d, e.default = h;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.CodeToken = e.CodeBlock = void 0; const a = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const l = r(n(0)); const u = r(n(6)); const c = r(n(7)); const d = (function (t) { function e() { return i(this, e), o(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments)); } return s(e, t), a(e, [{ key: "replaceWith", value(t) { this.domNode.textContent = this.domNode.textContent, this.attach(), (function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "replaceWith", this)).call(this, t); } }, { key: "highlight", value(t) { const e = this.domNode.textContent; this.cachedText !== e && ((e.trim().length > 0 || this.cachedText == null) && (this.domNode.innerHTML = t(e), this.domNode.normalize(), this.attach()), this.cachedText = e); } }]), e; }(r(n(13)).default)); d.className = "ql-syntax"; const h = new l.default.Attributor.Class("token", "hljs", { scope: l.default.Scope.INLINE }); const p = (function (t) { function e(t, n) { i(this, e); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); if (typeof r.options.highlight !== "function") throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill."); let s = null; return r.quill.on(u.default.events.SCROLL_OPTIMIZE, (() => { clearTimeout(s), s = setTimeout((() => { r.highlight(), s = null; }), r.options.interval); })), r.highlight(), r; } return s(e, t), a(e, null, [{ key: "register", value() { u.default.register(h, !0), u.default.register(d, !0); } }]), a(e, [{ key: "highlight", value() { const t = this; if (!this.quill.selection.composing) { this.quill.update(u.default.sources.USER); const e = this.quill.getSelection(); this.quill.scroll.descendants(d).forEach(((e) => { e.highlight(t.options.highlight); })), this.quill.update(u.default.sources.SILENT), e != null && this.quill.setSelection(e, u.default.sources.SILENT); } } }]), e; }(c.default)); p.DEFAULTS = { highlight: window.hljs == null ? null : function (t) { return window.hljs.highlightAuto(t).value; }, interval: 1e3 }, e.CodeBlock = d, e.CodeToken = h, e.default = p;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function o(t, e, n) { const r = document.createElement("button"); r.setAttribute("type", "button"), r.classList.add(`ql-${e}`), n != null && (r.value = n), t.appendChild(r); } function s(t, e) { Array.isArray(e[0]) || (e = [e]), e.forEach(((e) => { const n = document.createElement("span"); n.classList.add("ql-formats"), e.forEach(((t) => { if (typeof t === "string")o(n, t); else { const e = Object.keys(t)[0]; const r = t[e]; Array.isArray(r) ? (function (t, e, n) { const r = document.createElement("select"); r.classList.add(`ql-${e}`), n.forEach(((t) => { const e = document.createElement("option"); !1 !== t ? e.setAttribute("value", t) : e.setAttribute("selected", "selected"), r.appendChild(e); })), t.appendChild(r); }(n, e, r)) : o(n, e, r); } })), t.appendChild(n); })); }Object.defineProperty(e, "__esModule", { value: !0 }), e.addControls = e.default = void 0; const a = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const l = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const u = r(n(4)); const c = r(n(0)); const d = r(n(6)); const h = r(n(10)); const p = r(n(7)); const f = (0, h.default)("quill:toolbar"); const m = (function (t) {
    function e(t, n) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); let r; const o = i(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); if (Array.isArray(o.options.container)) { const l = document.createElement("div"); s(l, o.options.container), t.container.parentNode.insertBefore(l, t.container), o.container = l; } else typeof o.options.container === "string" ? o.container = document.querySelector(o.options.container) : o.container = o.options.container; return o.container instanceof HTMLElement ? (o.container.classList.add("ql-toolbar"), o.controls = [], o.handlers = {}, Object.keys(o.options.handlers).forEach(((t) => { o.addHandler(t, o.options.handlers[t]); })), [].forEach.call(o.container.querySelectorAll("button, select"), ((t) => { o.attach(t); })), o.quill.on(d.default.events.EDITOR_CHANGE, ((t, e) => { t === d.default.events.SELECTION_CHANGE && o.update(e); })), o.quill.on(d.default.events.SCROLL_OPTIMIZE, (() => { const t = o.quill.selection.getRange(); const e = a(t, 1)[0]; o.update(e); })), o) : (r = f.error("Container required for toolbar", o.options), i(o, r)); } return (function (t, e) {
      if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t, enumerable: !1, writable: !0, configurable: !0,
        }, 
      }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
    }(e, t)), l(e, [{ key: "addHandler", value(t, e) { this.handlers[t] = e; } }, {
      key: "attach",
      value(t) {
        const e = this; let n = [].find.call(t.classList, ((t) => t.indexOf("ql-") === 0)); if (n) {
          if (n = n.slice("ql-".length), t.tagName === "BUTTON" && t.setAttribute("type", "button"), this.handlers[n] == null) { if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[n] == null) return void f.warn("ignoring attaching to disabled format", n, t); if (c.default.query(n) == null) return void f.warn("ignoring attaching to nonexistent format", n, t); } const r = t.tagName === "SELECT" ? "change" : "click"; t.addEventListener(r, ((r) => {
            let i = void 0; if (t.tagName === "SELECT") { if (t.selectedIndex < 0) return; const o = t.options[t.selectedIndex]; i = !o.hasAttribute("selected") && (o.value || !1); } else i = !t.classList.contains("ql-active") && (t.value || !t.hasAttribute("value")), r.preventDefault(); e.quill.focus(); const s = e.quill.selection.getRange(); const l = a(s, 1)[0]; if (e.handlers[n] != null)e.handlers[n].call(e, i); else if (c.default.query(n).prototype instanceof c.default.Embed) {
              if (!(i = prompt(`Enter ${n}`))) return; e.quill.updateContents((new u.default()).retain(l.index).delete(l.length).insert(function (t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                  value: n, enumerable: !0, configurable: !0, writable: !0,
                }) : t[e] = n, t;
              }({}, n, i)), d.default.sources.USER);
            } else e.quill.format(n, i, d.default.sources.USER); e.update(l);
          })), this.controls.push([n, t]);
        }
      }, 
    }, { key: "update", value(t) { const e = t == null ? {} : this.quill.getFormat(t); this.controls.forEach(((n) => { const r = a(n, 2); const i = r[0]; const o = r[1]; if (o.tagName === "SELECT") { let s = void 0; if (t == null)s = null; else if (e[i] == null)s = o.querySelector("option[selected]"); else if (!Array.isArray(e[i])) { let l = e[i]; typeof l === "string" && (l = l.replace(/\"/g, '\\"')), s = o.querySelector(`option[value="${l}"]`); }s == null ? (o.value = "", o.selectedIndex = -1) : s.selected = !0; } else if (t == null)o.classList.remove("ql-active"); else if (o.hasAttribute("value")) { const u = e[i] === o.getAttribute("value") || e[i] != null && e[i].toString() === o.getAttribute("value") || e[i] == null && !o.getAttribute("value"); o.classList.toggle("ql-active", u); } else o.classList.toggle("ql-active", e[i] != null); })); } }]), e;
  }(p.default)); m.DEFAULTS = {}, m.DEFAULTS = {
    container: null,
    handlers: {
      clean() { const t = this; const e = this.quill.getSelection(); if (e != null) if (e.length == 0) { const n = this.quill.getFormat(); Object.keys(n).forEach(((e) => { c.default.query(e, c.default.Scope.INLINE) != null && t.quill.format(e, !1); })); } else this.quill.removeFormat(e, d.default.sources.USER); }, direction(t) { const e = this.quill.getFormat().align; t === "rtl" && e == null ? this.quill.format("align", "right", d.default.sources.USER) : t || e !== "right" || this.quill.format("align", !1, d.default.sources.USER), this.quill.format("direction", t, d.default.sources.USER); }, indent(t) { const e = this.quill.getSelection(); const n = this.quill.getFormat(e); const r = parseInt(n.indent || 0); if (t === "+1" || t === "-1") { let i = t === "+1" ? 1 : -1; n.direction === "rtl" && (i *= -1), this.quill.format("indent", r + i, d.default.sources.USER); } }, link(t) { !0 === t && (t = prompt("Enter link URL:")), this.quill.format("link", t, d.default.sources.USER); }, list(t) { const e = this.quill.getSelection(); const n = this.quill.getFormat(e); t === "check" ? n.list === "checked" || n.list === "unchecked" ? this.quill.format("list", !1, d.default.sources.USER) : this.quill.format("list", "unchecked", d.default.sources.USER) : this.quill.format("list", t, d.default.sources.USER); },
    },
  }, e.default = m, e.addControls = s;
}, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>'; }, function (t, e) { t.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>'; }, function (t, e) { t.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>'; }, function (t, e) { t.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>'; }, function (t, e) { t.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>'; }, function (t, e) { t.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>'; }, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }Object.defineProperty(e, "__esModule", { value: !0 }), e.default = e.BubbleTooltip = void 0; const a = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const l = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const u = r(n(2)); const c = r(n(9)); const d = n(44); const h = r(d); const p = n(22); const f = r(n(26)); const m = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]]; const g = (function (t) { function e(t, n) { i(this, e), n.modules.toolbar != null && n.modules.toolbar.container == null && (n.modules.toolbar.container = m); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return r.quill.container.classList.add("ql-bubble"), r; } return s(e, t), l(e, [{ key: "extendToolbar", value(t) { this.tooltip = new v(this.quill, this.options.bounds), this.tooltip.root.appendChild(t.container), this.buildButtons([].slice.call(t.container.querySelectorAll("button")), f.default), this.buildPickers([].slice.call(t.container.querySelectorAll("select")), f.default); } }]), e; }(h.default)); g.DEFAULTS = (0, u.default)(!0, {}, h.default.DEFAULTS, { modules: { toolbar: { handlers: { link(t) { t ? this.quill.theme.tooltip.edit() : this.quill.format("link", !1); } } } } }); var v = (function (t) { function e(t, n) { i(this, e); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return r.quill.on(c.default.events.EDITOR_CHANGE, ((t, e, n, i) => { if (t === c.default.events.SELECTION_CHANGE) if (e != null && e.length > 0 && i === c.default.sources.USER) { r.show(), r.root.style.left = "0px", r.root.style.width = "", r.root.style.width = `${r.root.offsetWidth}px`; const o = r.quill.getLines(e.index, e.length); if (o.length === 1)r.position(r.quill.getBounds(e)); else { const s = o[o.length - 1]; const a = r.quill.getIndex(s); const l = Math.min(s.length() - 1, e.index + e.length - a); const u = r.quill.getBounds(new p.Range(a, l)); r.position(u); } } else document.activeElement !== r.textbox && r.quill.hasFocus() && r.hide(); })), r; } return s(e, t), l(e, [{ key: "listen", value() { const t = this; a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "listen", this).call(this), this.root.querySelector(".ql-close").addEventListener("click", (() => { t.root.classList.remove("ql-editing"); })), this.quill.on(c.default.events.SCROLL_OPTIMIZE, (() => { setTimeout((() => { if (!t.root.classList.contains("ql-hidden")) { const e = t.quill.getSelection(); e != null && t.position(t.quill.getBounds(e)); } }), 1); })); } }, { key: "cancel", value() { this.show(); } }, { key: "position", value(t) { const n = a(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "position", this).call(this, t); const r = this.root.querySelector(".ql-tooltip-arrow"); if (r.style.marginLeft = "", n === 0) return n; r.style.marginLeft = `${-1 * n - r.offsetWidth / 2}px`; } }]), e; }(d.BaseTooltip)); v.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""), e.BubbleTooltip = v, e.default = g;
}, function (t, e, n) {
  function r(t) { return t && t.__esModule ? t : { default: t }; } function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== "object" && typeof e !== "function" ? t : e; } function s(t, e) {
    if (typeof e !== "function" && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${typeof e}`); t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t, enumerable: !1, writable: !0, configurable: !0,
      },
    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }Object.defineProperty(e, "__esModule", { value: !0 }); const a = function (t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return (function (t, e) { const n = []; let r = !0; let i = !1; let o = void 0; try { for (var s, a = t[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !e || n.length !== e); r = !0); } catch (t) { i = !0, o = t; } finally { try { !r && a.return && a.return(); } finally { if (i) throw o; } } return n; }(t, e)); throw new TypeError("Invalid attempt to destructure non-iterable instance"); }; const l = function t(e, n, r) { e === null && (e = Function.prototype); const i = Object.getOwnPropertyDescriptor(e, n); if (void 0 === i) { const o = Object.getPrototypeOf(e); return o === null ? void 0 : t(o, n, r); } if ("value" in i) return i.value; const s = i.get; return void 0 !== s ? s.call(r) : void 0; }; const u = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const c = r(n(2)); const d = r(n(9)); const h = n(44); const p = r(h); const f = r(n(15)); const m = n(22); const g = r(n(26)); const v = [[{ header: ["1", "2", "3", !1] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]]; const y = (function (t) { function e(t, n) { i(this, e), n.modules.toolbar != null && n.modules.toolbar.container == null && (n.modules.toolbar.container = v); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return r.quill.container.classList.add("ql-snow"), r; } return s(e, t), u(e, [{ key: "extendToolbar", value(t) { t.container.classList.add("ql-snow"), this.buildButtons([].slice.call(t.container.querySelectorAll("button")), g.default), this.buildPickers([].slice.call(t.container.querySelectorAll("select")), g.default), this.tooltip = new _(this.quill, this.options.bounds), t.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({ key: "K", shortKey: !0 }, ((e, n) => { t.handlers.link.call(t, !n.format.link); })); } }]), e; }(p.default)); y.DEFAULTS = (0, c.default)(!0, {}, p.default.DEFAULTS, { modules: { toolbar: { handlers: { link(t) { if (t) { const e = this.quill.getSelection(); if (e == null || e.length == 0) return; let n = this.quill.getText(e); /^\S+@\S+\.\S+$/.test(n) && n.indexOf("mailto:") !== 0 && (n = `mailto:${n}`), this.quill.theme.tooltip.edit("link", n); } else this.quill.format("link", !1); } } } } }); var _ = (function (t) { function e(t, n) { i(this, e); const r = o(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)); return r.preview = r.root.querySelector("a.ql-preview"), r; } return s(e, t), u(e, [{ key: "listen", value() { const t = this; l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "listen", this).call(this), this.root.querySelector("a.ql-action").addEventListener("click", ((e) => { t.root.classList.contains("ql-editing") ? t.save() : t.edit("link", t.preview.textContent), e.preventDefault(); })), this.root.querySelector("a.ql-remove").addEventListener("click", ((e) => { if (t.linkRange != null) { const n = t.linkRange; t.restoreFocus(), t.quill.formatText(n, "link", !1, d.default.sources.USER), delete t.linkRange; }e.preventDefault(), t.hide(); })), this.quill.on(d.default.events.SELECTION_CHANGE, ((e, n, r) => { if (e != null) { if (e.length === 0 && r === d.default.sources.USER) { const i = t.quill.scroll.descendant(f.default, e.index); const o = a(i, 2); const s = o[0]; const l = o[1]; if (s != null) { t.linkRange = new m.Range(e.index - l, s.length()); const u = f.default.formats(s.domNode); return t.preview.textContent = u, t.preview.setAttribute("href", u), t.show(), void t.position(t.quill.getBounds(t.linkRange)); } } else delete t.linkRange; t.hide(); } })); } }, { key: "show", value() { l(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "show", this).call(this), this.root.removeAttribute("data-mode"); } }]), e; }(h.BaseTooltip)); _.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""), e.default = y;
}])).default))), (function (t, e) { typeof exports === "object" && void 0 !== module ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : (t = typeof globalThis !== "undefined" ? globalThis : t || self).Swiper = e(); }(this, (() => {
  function t(t) { return t !== null && typeof t === "object" && "constructor" in t && t.constructor === Object; } function e(n = {}, r = {}) { Object.keys(r).forEach((i) => { void 0 === n[i] ? n[i] = r[i] : t(r[i]) && t(n[i]) && Object.keys(r[i]).length > 0 && e(n[i], r[i]); }); } const n = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: { blur() {}, nodeName: "" },
    querySelector: () => null,
    querySelectorAll: () => [],
    getElementById: () => null,
    createEvent: () => ({ initEvent() {} }),
    createElement: () => ({
      children: [], childNodes: [], style: {}, setAttribute() {}, getElementsByTagName: () => [],
    }),
    createElementNS: () => ({}),
    importNode: () => null,
    location: {
      hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "",
    },
  }; function r() { const t = typeof document !== "undefined" ? document : {}; return e(t, n), t; } const i = {
    document: n,
    navigator: { userAgent: "" },
    location: {
      hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "",
    },
    history: {
      replaceState() {}, pushState() {}, go() {}, back() {},
    },
    CustomEvent() { return this; },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle: () => ({ getPropertyValue: () => "" }),
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia: () => ({}),
    requestAnimationFrame: (t) => (typeof setTimeout === "undefined" ? (t(), null) : setTimeout(t, 0)),
    cancelAnimationFrame(t) { typeof setTimeout !== "undefined" && clearTimeout(t); },
  }; function o() { const t = typeof window !== "undefined" ? window : {}; return e(t, i), t; } class s extends Array {constructor(t) { super(...t || []), (function (t) { const e = t.__proto__; Object.defineProperty(t, "__proto__", { get: () => e, set(t) { e.__proto__ = t; } }); }(this)); }} function a(t = []) { const e = []; return t.forEach((t) => { Array.isArray(t) ? e.push(...a(t)) : e.push(t); }), e; } function l(t, e) { return Array.prototype.filter.call(t, e); } function u(t, e) { const n = o(); const i = r(); let a = []; if (!e && t instanceof s) return t; if (!t) return new s(a); if (typeof t === "string") { const n = t.trim(); if (n.indexOf("<") >= 0 && n.indexOf(">") >= 0) { let t = "div"; n.indexOf("<li") === 0 && (t = "ul"), n.indexOf("<tr") === 0 && (t = "tbody"), n.indexOf("<td") !== 0 && n.indexOf("<th") !== 0 || (t = "tr"), n.indexOf("<tbody") === 0 && (t = "table"), n.indexOf("<option") === 0 && (t = "select"); const e = i.createElement(t); e.innerHTML = n; for (let t = 0; t < e.childNodes.length; t += 1)a.push(e.childNodes[t]); } else a = (function (t, e) { if (typeof t !== "string") return [t]; const n = []; const r = e.querySelectorAll(t); for (let t = 0; t < r.length; t += 1)n.push(r[t]); return n; }(t.trim(), e || i)); } else if (t.nodeType || t === n || t === i)a.push(t); else if (Array.isArray(t)) { if (t instanceof s) return t; a = t; } return new s(function (t) { const e = []; for (let n = 0; n < t.length; n += 1)e.indexOf(t[n]) === -1 && e.push(t[n]); return e; }(a)); }u.fn = s.prototype; const c = {
    addClass(...t) { const e = a(t.map((t) => t.split(" "))); return this.forEach((t) => { t.classList.add(...e); }), this; }, removeClass(...t) { const e = a(t.map((t) => t.split(" "))); return this.forEach((t) => { t.classList.remove(...e); }), this; }, hasClass(...t) { const e = a(t.map((t) => t.split(" "))); return l(this, (t) => e.filter((e) => t.classList.contains(e)).length > 0).length > 0; }, toggleClass(...t) { const e = a(t.map((t) => t.split(" "))); this.forEach((t) => { e.forEach((e) => { t.classList.toggle(e); }); }); }, attr(t, e) { if (arguments.length === 1 && typeof t === "string") return this[0] ? this[0].getAttribute(t) : void 0; for (let n = 0; n < this.length; n += 1) if (arguments.length === 2) this[n].setAttribute(t, e); else for (const e in t) this[n][e] = t[e], this[n].setAttribute(e, t[e]); return this; }, removeAttr(t) { for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(t); return this; }, transform(t) { for (let e = 0; e < this.length; e += 1) this[e].style.transform = t; return this; }, transition(t) { for (let e = 0; e < this.length; e += 1) this[e].style.transitionDuration = typeof t !== "string" ? `${t}ms` : t; return this; }, on(...t) { let [e, n, r, i] = t; function o(t) { const e = t.target; if (!e) return; const i = t.target.dom7EventData || []; if (i.indexOf(t) < 0 && i.unshift(t), u(e).is(n))r.apply(e, i); else { const t = u(e).parents(); for (let e = 0; e < t.length; e += 1)u(t[e]).is(n) && r.apply(t[e], i); } } function s(t) { const e = t && t.target && t.target.dom7EventData || []; e.indexOf(t) < 0 && e.unshift(t), r.apply(this, e); } typeof t[1] === "function" && ([e, r, i] = t, n = void 0), i || (i = !1); const a = e.split(" "); let l; for (let t = 0; t < this.length; t += 1) { const e = this[t]; if (n) for (l = 0; l < a.length; l += 1) { const t = a[l]; e.dom7LiveListeners || (e.dom7LiveListeners = {}), e.dom7LiveListeners[t] || (e.dom7LiveListeners[t] = []), e.dom7LiveListeners[t].push({ listener: r, proxyListener: o }), e.addEventListener(t, o, i); } else for (l = 0; l < a.length; l += 1) { const t = a[l]; e.dom7Listeners || (e.dom7Listeners = {}), e.dom7Listeners[t] || (e.dom7Listeners[t] = []), e.dom7Listeners[t].push({ listener: r, proxyListener: s }), e.addEventListener(t, s, i); } } return this; }, off(...t) { let [e, n, r, i] = t; typeof t[1] === "function" && ([e, r, i] = t, n = void 0), i || (i = !1); const o = e.split(" "); for (let t = 0; t < o.length; t += 1) { const e = o[t]; for (let t = 0; t < this.length; t += 1) { const o = this[t]; let s; if (!n && o.dom7Listeners ? s = o.dom7Listeners[e] : n && o.dom7LiveListeners && (s = o.dom7LiveListeners[e]), s && s.length) for (let t = s.length - 1; t >= 0; t -= 1) { const n = s[t]; r && n.listener === r || r && n.listener && n.listener.dom7proxy && n.listener.dom7proxy === r ? (o.removeEventListener(e, n.proxyListener, i), s.splice(t, 1)) : r || (o.removeEventListener(e, n.proxyListener, i), s.splice(t, 1)); } } } return this; }, trigger(...t) { const e = o(); const n = t[0].split(" "); const r = t[1]; for (let i = 0; i < n.length; i += 1) { const o = n[i]; for (let n = 0; n < this.length; n += 1) { const i = this[n]; if (e.CustomEvent) { const n = new e.CustomEvent(o, { detail: r, bubbles: !0, cancelable: !0 }); i.dom7EventData = t.filter((t, e) => e > 0), i.dispatchEvent(n), i.dom7EventData = [], delete i.dom7EventData; } } } return this; }, transitionEnd(t) { const e = this; return t && e.on("transitionend", (function n(r) { r.target === this && (t.call(this, r), e.off("transitionend", n)); })), this; }, outerWidth(t) { if (this.length > 0) { if (t) { const t = this.styles(); return this[0].offsetWidth + parseFloat(t.getPropertyValue("margin-right")) + parseFloat(t.getPropertyValue("margin-left")); } return this[0].offsetWidth; } return null; }, outerHeight(t) { if (this.length > 0) { if (t) { const t = this.styles(); return this[0].offsetHeight + parseFloat(t.getPropertyValue("margin-top")) + parseFloat(t.getPropertyValue("margin-bottom")); } return this[0].offsetHeight; } return null; }, styles() { const t = o(); return this[0] ? t.getComputedStyle(this[0], null) : {}; }, offset() { if (this.length > 0) { const t = o(); const e = r(); const n = this[0]; const i = n.getBoundingClientRect(); const s = e.body; const a = n.clientTop || s.clientTop || 0; const l = n.clientLeft || s.clientLeft || 0; const u = n === t ? t.scrollY : n.scrollTop; const c = n === t ? t.scrollX : n.scrollLeft; return { top: i.top + u - a, left: i.left + c - l }; } return null; }, css(t, e) { const n = o(); let r; if (arguments.length === 1) { if (typeof t !== "string") { for (r = 0; r < this.length; r += 1) for (const e in t) this[r].style[e] = t[e]; return this; } if (this[0]) return n.getComputedStyle(this[0], null).getPropertyValue(t); } if (arguments.length === 2 && typeof t === "string") { for (r = 0; r < this.length; r += 1) this[r].style[t] = e; return this; } return this; }, each(t) { return t ? (this.forEach((e, n) => { t.apply(e, [e, n]); }), this) : this; }, html(t) { if (void 0 === t) return this[0] ? this[0].innerHTML : null; for (let e = 0; e < this.length; e += 1) this[e].innerHTML = t; return this; }, text(t) { if (void 0 === t) return this[0] ? this[0].textContent.trim() : null; for (let e = 0; e < this.length; e += 1) this[e].textContent = t; return this; }, is(t) { const e = o(); const n = r(); const i = this[0]; let a; let l; if (!i || void 0 === t) return !1; if (typeof t === "string") { if (i.matches) return i.matches(t); if (i.webkitMatchesSelector) return i.webkitMatchesSelector(t); if (i.msMatchesSelector) return i.msMatchesSelector(t); for (a = u(t), l = 0; l < a.length; l += 1) if (a[l] === i) return !0; return !1; } if (t === n) return i === n; if (t === e) return i === e; if (t.nodeType || t instanceof s) { for (a = t.nodeType ? [t] : t, l = 0; l < a.length; l += 1) if (a[l] === i) return !0; return !1; } return !1; }, index() { let t; let e = this[0]; if (e) { for (t = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (t += 1); return t; } }, eq(t) { if (void 0 === t) return this; const e = this.length; if (t > e - 1) return u([]); if (t < 0) { const n = e + t; return u(n < 0 ? [] : [this[n]]); } return u([this[t]]); }, append(...t) { let e; const n = r(); for (let r = 0; r < t.length; r += 1) { e = t[r]; for (let t = 0; t < this.length; t += 1) if (typeof e === "string") { const r = n.createElement("div"); for (r.innerHTML = e; r.firstChild;) this[t].appendChild(r.firstChild); } else if (e instanceof s) for (let n = 0; n < e.length; n += 1) this[t].appendChild(e[n]); else this[t].appendChild(e); } return this; }, prepend(t) { const e = r(); let n; let i; for (n = 0; n < this.length; n += 1) if (typeof t === "string") { const r = e.createElement("div"); for (r.innerHTML = t, i = r.childNodes.length - 1; i >= 0; i -= 1) this[n].insertBefore(r.childNodes[i], this[n].childNodes[0]); } else if (t instanceof s) for (i = 0; i < t.length; i += 1) this[n].insertBefore(t[i], this[n].childNodes[0]); else this[n].insertBefore(t, this[n].childNodes[0]); return this; }, next(t) { return this.length > 0 ? t ? this[0].nextElementSibling && u(this[0].nextElementSibling).is(t) ? u([this[0].nextElementSibling]) : u([]) : this[0].nextElementSibling ? u([this[0].nextElementSibling]) : u([]) : u([]); }, nextAll(t) { const e = []; let n = this[0]; if (!n) return u([]); for (;n.nextElementSibling;) { const r = n.nextElementSibling; t ? u(r).is(t) && e.push(r) : e.push(r), n = r; } return u(e); }, prev(t) { if (this.length > 0) { const e = this[0]; return t ? e.previousElementSibling && u(e.previousElementSibling).is(t) ? u([e.previousElementSibling]) : u([]) : e.previousElementSibling ? u([e.previousElementSibling]) : u([]); } return u([]); }, prevAll(t) { const e = []; let n = this[0]; if (!n) return u([]); for (;n.previousElementSibling;) { const r = n.previousElementSibling; t ? u(r).is(t) && e.push(r) : e.push(r), n = r; } return u(e); }, parent(t) { const e = []; for (let n = 0; n < this.length; n += 1) this[n].parentNode !== null && (t ? u(this[n].parentNode).is(t) && e.push(this[n].parentNode) : e.push(this[n].parentNode)); return u(e); }, parents(t) { const e = []; for (let n = 0; n < this.length; n += 1) { let r = this[n].parentNode; for (;r;)t ? u(r).is(t) && e.push(r) : e.push(r), r = r.parentNode; } return u(e); }, closest(t) { let e = this; return void 0 === t ? u([]) : (e.is(t) || (e = e.parents(t).eq(0)), e); }, find(t) { const e = []; for (let n = 0; n < this.length; n += 1) { const r = this[n].querySelectorAll(t); for (let t = 0; t < r.length; t += 1)e.push(r[t]); } return u(e); }, children(t) { const e = []; for (let n = 0; n < this.length; n += 1) { const r = this[n].children; for (let n = 0; n < r.length; n += 1)t && !u(r[n]).is(t) || e.push(r[n]); } return u(e); }, filter(t) { return u(l(this, t)); }, remove() { for (let t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]); return this; },
  }; function d(t, e = 0) { return setTimeout(t, e); } function h() { return Date.now(); } function p(t, e = "x") { const n = o(); let r; let i; let s; const a = (function (t) { const e = o(); let n; return e.getComputedStyle && (n = e.getComputedStyle(t, null)), !n && t.currentStyle && (n = t.currentStyle), n || (n = t.style), n; }(t)); return n.WebKitCSSMatrix ? (i = a.transform || a.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((t) => t.replace(",", ".")).join(", ")), s = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = s.toString().split(",")), e === "x" && (i = n.WebKitCSSMatrix ? s.m41 : r.length === 16 ? parseFloat(r[12]) : parseFloat(r[4])), e === "y" && (i = n.WebKitCSSMatrix ? s.m42 : r.length === 16 ? parseFloat(r[13]) : parseFloat(r[5])), i || 0; } function f(t) { return typeof t === "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object"; } function m(...t) { const e = Object(t[0]); const n = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < t.length; i += 1) { const o = t[i]; if (o != null && (r = o, !(typeof window !== "undefined" && void 0 !== window.HTMLElement ? r instanceof HTMLElement : r && (r.nodeType === 1 || r.nodeType === 11)))) { const t = Object.keys(Object(o)).filter((t) => n.indexOf(t) < 0); for (let n = 0, r = t.length; n < r; n += 1) { const r = t[n]; const i = Object.getOwnPropertyDescriptor(o, r); void 0 !== i && i.enumerable && (f(e[r]) && f(o[r]) ? o[r].__swiper__ ? e[r] = o[r] : m(e[r], o[r]) : !f(e[r]) && f(o[r]) ? (e[r] = {}, o[r].__swiper__ ? e[r] = o[r] : m(e[r], o[r])) : e[r] = o[r]); } } } let r; return e; } function g(t, e, n) { t.style.setProperty(e, n); } function v({ swiper: t, targetPosition: e, side: n }) { const r = o(); const i = -t.translate; let s; let a = null; const l = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID); const u = e > i ? "next" : "prev"; const c = (t, e) => u === "next" && t >= e || u === "prev" && t <= e; const d = () => { s = (new Date()).getTime(), a === null && (a = s); const o = Math.max(Math.min((s - a) / l, 1), 0); const u = 0.5 - Math.cos(o * Math.PI) / 2; let h = i + u * (e - i); if (c(h, e) && (h = e), t.wrapperEl.scrollTo({ [n]: h }), c(h, e)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [n]: h }); }), void r.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = r.requestAnimationFrame(d); }; d(); } let y; let _; let b; function w() {
    return y || (y = (function () {
      const t = o(); const e = r(); return {
        smoothScroll: e.documentElement && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch), passiveListener: (function () { let e = !1; try { const n = Object.defineProperty({}, "passive", { get() { e = !0; } }); t.addEventListener("testPassiveListener", null, n); } catch (t) {} return e; }()), gestures: "ongesturestart" in t,
      };
    }())), y;
  } function x(t = {}) { return _ || (_ = (function ({ userAgent: t } = {}) { const e = w(); const n = o(); const r = n.navigator.platform; const i = t || n.navigator.userAgent; const s = { ios: !1, android: !1 }; const a = n.screen.width; const l = n.screen.height; const u = i.match(/(Android);?[\s\/]+([\d.]+)?/); let c = i.match(/(iPad).*OS\s([\d_]+)/); const d = i.match(/(iPod)(.*OS\s([\d_]+))?/); const h = !c && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/); const p = r === "Win32"; let f = r === "MacIntel"; return !c && f && e.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${l}`) >= 0 && (c = i.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), f = !1), u && !p && (s.os = "android", s.android = !0), (c || h || d) && (s.os = "ios", s.ios = !0), s; }(t))), _; } function S() { return b || (b = (function () { const t = o(); return { isSafari: (function () { const e = t.navigator.userAgent.toLowerCase(); return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0; }()), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent) }; }())), b; } function k({
    swiper: t, runCallbacks: e, direction: n, step: r,
  }) { const { activeIndex: i, previousIndex: o } = t; let s = n; if (s || (s = i > o ? "next" : i < o ? "prev" : "reset"), t.emit(`transition${r}`), e && i !== o) { if (s === "reset") return void t.emit(`slideResetTransition${r}`); t.emit(`slideChangeTransition${r}`), s === "next" ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`); } } function C(t) {
    const e = this; const n = r(); const i = o(); const s = e.touchEventsData; const { params: a, touches: l, enabled: c } = e; if (!c) return; if (e.animating && a.preventInteractionOnTransition) return; !e.animating && a.cssMode && a.loop && e.loopFix(); let d = t; d.originalEvent && (d = d.originalEvent); let p = u(d.target); if (a.touchEventsTarget === "wrapper" && !p.closest(e.wrapperEl).length) return; if (s.isTouchEvent = d.type === "touchstart", !s.isTouchEvent && "which" in d && d.which === 3) return; if (!s.isTouchEvent && "button" in d && d.button > 0) return; if (s.isTouched && s.isMoved) return; a.noSwipingClass && a.noSwipingClass !== "" && d.target && d.target.shadowRoot && t.path && t.path[0] && (p = u(t.path[0])); const f = a.noSwipingSelector ? a.noSwipingSelector : `.${a.noSwipingClass}`; const m = !(!d.target || !d.target.shadowRoot); if (a.noSwiping && (m ? (function (t, e = this) { return (function e(n) { return n && n !== r() && n !== o() ? (n.assignedSlot && (n = n.assignedSlot), n.closest(t) || e(n.getRootNode().host)) : null; }(e)); }(f, d.target)) : p.closest(f)[0])) return void (e.allowClick = !0); if (a.swipeHandler && !p.closest(a.swipeHandler)[0]) return; l.currentX = d.type === "touchstart" ? d.targetTouches[0].pageX : d.pageX, l.currentY = d.type === "touchstart" ? d.targetTouches[0].pageY : d.pageY; const g = l.currentX; const v = l.currentY; const y = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection; const _ = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold; if (y && (g <= _ || g >= i.innerWidth - _)) { if (y !== "prevent") return; t.preventDefault(); } if (Object.assign(s, {
      isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0,
    }), l.startX = g, l.startY = v, s.touchStartTime = h(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, a.threshold > 0 && (s.allowThresholdMove = !1), d.type !== "touchstart") { let t = !0; p.is(s.focusableElements) && (t = !1), n.activeElement && u(n.activeElement).is(s.focusableElements) && n.activeElement !== p[0] && n.activeElement.blur(); const r = t && e.allowTouchMove && a.touchStartPreventDefault; !a.touchStartForcePreventDefault && !r || p[0].isContentEditable || d.preventDefault(); }e.emit("touchStart", d);
  } function E(t) {
    const e = r(); const n = this; const i = n.touchEventsData; const {
      params: o, touches: s, rtlTranslate: a, enabled: l,
    } = n; if (!l) return; let c = t; if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && n.emit("touchMoveOpposite", c)); if (i.isTouchEvent && c.type !== "touchmove") return; const d = c.type === "touchmove" && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]); const p = c.type === "touchmove" ? d.pageX : c.pageX; const f = c.type === "touchmove" ? d.pageY : c.pageY; if (c.preventedByNestedSwiper) return s.startX = p, void (s.startY = f); if (!n.allowTouchMove) {
      return n.allowClick = !1, void (i.isTouched && (Object.assign(s, {
        startX: p, startY: f, currentX: p, currentY: f,
      }), i.touchStartTime = h()));
    } if (i.isTouchEvent && o.touchReleaseOnEdges && !o.loop) if (n.isVertical()) { if (f < s.startY && n.translate <= n.maxTranslate() || f > s.startY && n.translate >= n.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1); } else if (p < s.startX && n.translate <= n.maxTranslate() || p > s.startX && n.translate >= n.minTranslate()) return; if (i.isTouchEvent && e.activeElement && c.target === e.activeElement && u(c.target).is(i.focusableElements)) return i.isMoved = !0, void (n.allowClick = !1); if (i.allowTouchCallbacks && n.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return; s.currentX = p, s.currentY = f; const m = s.currentX - s.startX; const g = s.currentY - s.startY; if (n.params.threshold && Math.sqrt(m ** 2 + g ** 2) < n.params.threshold) return; if (void 0 === i.isScrolling) { let t; n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? i.isScrolling = !1 : m * m + g * g >= 25 && (t = 180 * Math.atan2(Math.abs(g), Math.abs(m)) / Math.PI, i.isScrolling = n.isHorizontal() ? t > o.touchAngle : 90 - t > o.touchAngle); } if (i.isScrolling && n.emit("touchMoveOpposite", c), void 0 === i.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1); if (!i.startMoving) return; n.allowClick = !1, !o.cssMode && c.cancelable && c.preventDefault(), o.touchMoveStopPropagation && !o.nested && c.stopPropagation(), i.isMoved || (o.loop && !o.cssMode && n.loopFix(), i.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !o.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit("sliderFirstMove", c)), n.emit("sliderMove", c), i.isMoved = !0; let v = n.isHorizontal() ? m : g; s.diff = v, v *= o.touchRatio, a && (v = -v), n.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate; let y = !0; let _ = o.resistanceRatio; if (o.touchReleaseOnEdges && (_ = 0), v > 0 && i.currentTranslate > n.minTranslate() ? (y = !1, o.resistance && (i.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + i.startTranslate + v) ** _)) : v < 0 && i.currentTranslate < n.maxTranslate() && (y = !1, o.resistance && (i.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - i.startTranslate - v) ** _)), y && (c.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !n.allowSlidePrev && n.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.allowSlidePrev || n.allowSlideNext || (i.currentTranslate = i.startTranslate), o.threshold > 0) { if (!(Math.abs(v) > o.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, i.currentTranslate = i.startTranslate, void (s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY); }o.followFinger && !o.cssMode && ((o.freeMode && o.freeMode.enabled && n.freeMode || o.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && o.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(i.currentTranslate), n.setTranslate(i.currentTranslate));
  } function T(t) {
    const e = this; const n = e.touchEventsData; const {
      params: r, touches: i, rtlTranslate: o, slidesGrid: s, enabled: a,
    } = e; if (!a) return; let l = t; if (l.originalEvent && (l = l.originalEvent), n.allowTouchCallbacks && e.emit("touchEnd", l), n.allowTouchCallbacks = !1, !n.isTouched) return n.isMoved && r.grabCursor && e.setGrabCursor(!1), n.isMoved = !1, void (n.startMoving = !1); r.grabCursor && n.isMoved && n.isTouched && (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) && e.setGrabCursor(!1); const u = h(); const c = u - n.touchStartTime; if (e.allowClick && (e.updateClickedSlide(l), e.emit("tap click", l), c < 300 && u - n.lastClickTime < 300 && e.emit("doubleTap doubleClick", l)), n.lastClickTime = h(), d(() => { e.destroyed || (e.allowClick = !0); }), !n.isTouched || !n.isMoved || !e.swipeDirection || i.diff === 0 || n.currentTranslate === n.startTranslate) return n.isTouched = !1, n.isMoved = !1, void (n.startMoving = !1); let p; if (n.isTouched = !1, n.isMoved = !1, n.startMoving = !1, p = r.followFinger ? o ? e.translate : -e.translate : -n.currentTranslate, r.cssMode) return; if (e.params.freeMode && r.freeMode.enabled) return void e.freeMode.onTouchEnd({ currentPos: p }); let f = 0; let m = e.slidesSizesGrid[0]; for (let t = 0; t < s.length; t += t < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) { const e = t < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; void 0 !== s[t + e] ? p >= s[t] && p < s[t + e] && (f = t, m = s[t + e] - s[t]) : p >= s[t] && (f = t, m = s[s.length - 1] - s[s.length - 2]); } const g = (p - s[f]) / m; const v = f < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup; if (c > r.longSwipesMs) { if (!r.longSwipes) return void e.slideTo(e.activeIndex); e.swipeDirection === "next" && (g >= r.longSwipesRatio ? e.slideTo(f + v) : e.slideTo(f)), e.swipeDirection === "prev" && (g > 1 - r.longSwipesRatio ? e.slideTo(f + v) : e.slideTo(f)); } else { if (!r.shortSwipes) return void e.slideTo(e.activeIndex); !e.navigation || l.target !== e.navigation.nextEl && l.target !== e.navigation.prevEl ? (e.swipeDirection === "next" && e.slideTo(f + v), e.swipeDirection === "prev" && e.slideTo(f)) : l.target === e.navigation.nextEl ? e.slideTo(f + v) : e.slideTo(f); }
  } function P() { const t = this; const { params: e, el: n } = t; if (n && n.offsetWidth === 0) return; e.breakpoints && t.setBreakpoint(); const { allowSlideNext: r, allowSlidePrev: i, snapGrid: o } = t; t.allowSlideNext = !0, t.allowSlidePrev = !0, t.updateSize(), t.updateSlides(), t.updateSlidesClasses(), (e.slidesPerView === "auto" || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.run(), t.allowSlidePrev = i, t.allowSlideNext = r, t.params.watchOverflow && o !== t.snapGrid && t.checkOverflow(); } function O(t) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(), e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation()))); } function A() { const t = this; const { wrapperEl: e, rtlTranslate: n, enabled: r } = t; if (!r) return; let i; t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, t.translate === -0 && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses(); const o = t.maxTranslate() - t.minTranslate(); i = o === 0 ? 0 : (t.translate - t.minTranslate()) / o, i !== t.progress && t.updateProgress(n ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1); }Object.keys(c).forEach((t) => { Object.defineProperty(u.fn, t, { value: c[t], writable: !0 }); }); let M = !1; function L() {} const I = (t, e) => {
    const n = r(); const {
      params: i, touchEvents: o, el: s, wrapperEl: a, device: l, support: u,
    } = t; const c = !!i.nested; const d = e === "on" ? "addEventListener" : "removeEventListener"; const h = e; if (u.touch) { const e = !(o.start !== "touchstart" || !u.passiveListener || !i.passiveListeners) && { passive: !0, capture: !1 }; s[d](o.start, t.onTouchStart, e), s[d](o.move, t.onTouchMove, u.passiveListener ? { passive: !1, capture: c } : c), s[d](o.end, t.onTouchEnd, e), o.cancel && s[d](o.cancel, t.onTouchEnd, e); } else s[d](o.start, t.onTouchStart, !1), n[d](o.move, t.onTouchMove, c), n[d](o.end, t.onTouchEnd, !1); (i.preventClicks || i.preventClicksPropagation) && s[d]("click", t.onClick, !0), i.cssMode && a[d]("scroll", t.onScroll), i.updateOnWindowResize ? t[h](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", P, !0) : t[h]("observerUpdate", P, !0);
  }; const j = (t, e) => t.grid && e.grid && e.grid.rows > 1; const D = {
    init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1,
  }; function N(t, e) { return function (n = {}) { const r = Object.keys(n)[0]; const i = n[r]; typeof i === "object" && i !== null ? (["navigation", "pagination", "scrollbar"].indexOf(r) >= 0 && !0 === t[r] && (t[r] = { auto: !0 }), r in t && "enabled" in i ? (!0 === t[r] && (t[r] = { enabled: !0 }), typeof t[r] !== "object" || "enabled" in t[r] || (t[r].enabled = !0), t[r] || (t[r] = { enabled: !1 }), m(e, n)) : m(e, n)) : m(e, n); }; } const R = {
    eventsEmitter: {
      on(t, e, n) { const r = this; if (typeof e !== "function") return r; const i = n ? "unshift" : "push"; return t.split(" ").forEach((t) => { r.eventsListeners[t] || (r.eventsListeners[t] = []), r.eventsListeners[t][i](e); }), r; }, once(t, e, n) { const r = this; if (typeof e !== "function") return r; function i(...n) { r.off(t, i), i.__emitterProxy && delete i.__emitterProxy, e.apply(r, n); } return i.__emitterProxy = e, r.on(t, i, n); }, onAny(t, e) { const n = this; if (typeof t !== "function") return n; const r = e ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[r](t), n; }, offAny(t) { const e = this; if (!e.eventsAnyListeners) return e; const n = e.eventsAnyListeners.indexOf(t); return n >= 0 && e.eventsAnyListeners.splice(n, 1), e; }, off(t, e) { const n = this; return n.eventsListeners ? (t.split(" ").forEach((t) => { void 0 === e ? n.eventsListeners[t] = [] : n.eventsListeners[t] && n.eventsListeners[t].forEach((r, i) => { (r === e || r.__emitterProxy && r.__emitterProxy === e) && n.eventsListeners[t].splice(i, 1); }); }), n) : n; }, emit(...t) { const e = this; if (!e.eventsListeners) return e; let n; let r; let i; return typeof t[0] === "string" || Array.isArray(t[0]) ? (n = t[0], r = t.slice(1, t.length), i = e) : (n = t[0].events, r = t[0].data, i = t[0].context || e), r.unshift(i), (Array.isArray(n) ? n : n.split(" ")).forEach((t) => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e) => { e.apply(i, [t, ...r]); }), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((t) => { t.apply(i, r); }); }), e; },
    },
    update: {
      updateSize() { const t = this; let e; let n; const r = t.$el; e = void 0 !== t.params.width && t.params.width !== null ? t.params.width : r[0].clientWidth, n = void 0 !== t.params.height && t.params.height !== null ? t.params.height : r[0].clientHeight, e === 0 && t.isHorizontal() || n === 0 && t.isVertical() || (e = e - parseInt(r.css("padding-left") || 0, 10) - parseInt(r.css("padding-right") || 0, 10), n = n - parseInt(r.css("padding-top") || 0, 10) - parseInt(r.css("padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(n) && (n = 0), Object.assign(t, { width: e, height: n, size: t.isHorizontal() ? e : n })); },
      updateSlides() {
        const t = this; function e(e) {
          return t.isHorizontal() ? e : {
            width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom",
          }[e];
        } function n(t, n) { return parseFloat(t.getPropertyValue(e(n)) || 0); } const r = t.params; const {
          $wrapperEl: i, size: o, rtlTranslate: s, wrongRTL: a,
        } = t; const l = t.virtual && r.virtual.enabled; const u = l ? t.virtual.slides.length : t.slides.length; const c = i.children(`.${t.params.slideClass}`); const d = l ? t.virtual.slides.length : c.length; let h = []; const p = []; const f = []; let m = r.slidesOffsetBefore; typeof m === "function" && (m = r.slidesOffsetBefore.call(t)); let v = r.slidesOffsetAfter; typeof v === "function" && (v = r.slidesOffsetAfter.call(t)); const y = t.snapGrid.length; const _ = t.slidesGrid.length; let b = r.spaceBetween; let w = -m; let x = 0; let S = 0; if (void 0 === o) return; typeof b === "string" && b.indexOf("%") >= 0 && (b = parseFloat(b.replace("%", "")) / 100 * o), t.virtualSize = -b, s ? c.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : c.css({ marginRight: "", marginBottom: "", marginTop: "" }), r.centeredSlides && r.cssMode && (g(t.wrapperEl, "--swiper-centered-offset-before", ""), g(t.wrapperEl, "--swiper-centered-offset-after", "")); const k = r.grid && r.grid.rows > 1 && t.grid; let C; k && t.grid.initSlides(d); const E = r.slidesPerView === "auto" && r.breakpoints && Object.keys(r.breakpoints).filter((t) => void 0 !== r.breakpoints[t].slidesPerView).length > 0; for (let i = 0; i < d; i += 1) { C = 0; const s = c.eq(i); if (k && t.grid.updateSlide(i, s, d, e), s.css("display") !== "none") { if (r.slidesPerView === "auto") { E && (c[i].style[e("width")] = ""); const o = getComputedStyle(s[0]); const a = s[0].style.transform; const l = s[0].style.webkitTransform; if (a && (s[0].style.transform = "none"), l && (s[0].style.webkitTransform = "none"), r.roundLengths)C = t.isHorizontal() ? s.outerWidth(!0) : s.outerHeight(!0); else { const t = n(o, "width"); const e = n(o, "padding-left"); const r = n(o, "padding-right"); const i = n(o, "margin-left"); const a = n(o, "margin-right"); const l = o.getPropertyValue("box-sizing"); if (l && l === "border-box")C = t + i + a; else { const { clientWidth: n, offsetWidth: o } = s[0]; C = t + e + r + i + a + (o - n); } }a && (s[0].style.transform = a), l && (s[0].style.webkitTransform = l), r.roundLengths && (C = Math.floor(C)); } else C = (o - (r.slidesPerView - 1) * b) / r.slidesPerView, r.roundLengths && (C = Math.floor(C)), c[i] && (c[i].style[e("width")] = `${C}px`); c[i] && (c[i].swiperSlideSize = C), f.push(C), r.centeredSlides ? (w = w + C / 2 + x / 2 + b, x === 0 && i !== 0 && (w = w - o / 2 - b), i === 0 && (w = w - o / 2 - b), Math.abs(w) < 0.001 && (w = 0), r.roundLengths && (w = Math.floor(w)), S % r.slidesPerGroup == 0 && h.push(w), p.push(w)) : (r.roundLengths && (w = Math.floor(w)), (S - Math.min(t.params.slidesPerGroupSkip, S)) % t.params.slidesPerGroup == 0 && h.push(w), p.push(w), w = w + C + b), t.virtualSize += C + b, x = C, S += 1; } } if (t.virtualSize = Math.max(t.virtualSize, o) + v, s && a && (r.effect === "slide" || r.effect === "coverflow") && i.css({ width: `${t.virtualSize + r.spaceBetween}px` }), r.setWrapperSize && i.css({ [e("width")]: `${t.virtualSize + r.spaceBetween}px` }), k && t.grid.updateWrapperSize(C, h, e), !r.centeredSlides) { const e = []; for (let n = 0; n < h.length; n += 1) { let i = h[n]; r.roundLengths && (i = Math.floor(i)), h[n] <= t.virtualSize - o && e.push(i); }h = e, Math.floor(t.virtualSize - o) - Math.floor(h[h.length - 1]) > 1 && h.push(t.virtualSize - o); } if (h.length === 0 && (h = [0]), r.spaceBetween !== 0) { const n = t.isHorizontal() && s ? "marginLeft" : e("marginRight"); c.filter((t, e) => !r.cssMode || e !== c.length - 1).css({ [n]: `${b}px` }); } if (r.centeredSlides && r.centeredSlidesBounds) { let t = 0; f.forEach((e) => { t += e + (r.spaceBetween ? r.spaceBetween : 0); }), t -= r.spaceBetween; const e = t - o; h = h.map((t) => (t < 0 ? -m : t > e ? e + v : t)); } if (r.centerInsufficientSlides) { let t = 0; if (f.forEach((e) => { t += e + (r.spaceBetween ? r.spaceBetween : 0); }), t -= r.spaceBetween, t < o) { const e = (o - t) / 2; h.forEach((t, n) => { h[n] = t - e; }), p.forEach((t, n) => { p[n] = t + e; }); } } if (Object.assign(t, {
          slides: c, snapGrid: h, slidesGrid: p, slidesSizesGrid: f,
        }), r.centeredSlides && r.cssMode && !r.centeredSlidesBounds) { g(t.wrapperEl, "--swiper-centered-offset-before", `${-h[0]}px`), g(t.wrapperEl, "--swiper-centered-offset-after", `${t.size / 2 - f[f.length - 1] / 2}px`); const e = -t.snapGrid[0]; const n = -t.slidesGrid[0]; t.snapGrid = t.snapGrid.map((t) => t + e), t.slidesGrid = t.slidesGrid.map((t) => t + n); }d !== u && t.emit("slidesLengthChange"), h.length !== y && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), p.length !== _ && t.emit("slidesGridLengthChange"), r.watchSlidesProgress && t.updateSlidesOffset();
      },
      updateAutoHeight(t) { const e = this; const n = []; const r = e.virtual && e.params.virtual.enabled; let i; let o = 0; typeof t === "number" ? e.setTransition(t) : !0 === t && e.setTransition(e.params.speed); const s = (t) => (r ? e.slides.filter((e) => parseInt(e.getAttribute("data-swiper-slide-index"), 10) === t)[0] : e.slides.eq(t)[0]); if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides)e.visibleSlides.each((t) => { n.push(t); }); else for (i = 0; i < Math.ceil(e.params.slidesPerView); i += 1) { const t = e.activeIndex + i; if (t > e.slides.length && !r) break; n.push(s(t)); } else n.push(s(e.activeIndex)); for (i = 0; i < n.length; i += 1) if (void 0 !== n[i]) { const t = n[i].offsetHeight; o = t > o ? t : o; }o && e.$wrapperEl.css("height", `${o}px`); },
      updateSlidesOffset() { const t = this; const e = t.slides; for (let n = 0; n < e.length; n += 1)e[n].swiperSlideOffset = t.isHorizontal() ? e[n].offsetLeft : e[n].offsetTop; },
      updateSlidesProgress(t = this && this.translate || 0) { const e = this; const n = e.params; const { slides: r, rtlTranslate: i } = e; if (r.length === 0) return; void 0 === r[0].swiperSlideOffset && e.updateSlidesOffset(); let o = -t; i && (o = t), r.removeClass(n.slideVisibleClass), e.visibleSlidesIndexes = [], e.visibleSlides = []; for (let t = 0; t < r.length; t += 1) { const s = r[t]; let a = s.swiperSlideOffset; n.cssMode && n.centeredSlides && (a -= r[0].swiperSlideOffset); const l = (o + (n.centeredSlides ? e.minTranslate() : 0) - a) / (s.swiperSlideSize + n.spaceBetween); const u = -(o - a); const c = u + e.slidesSizesGrid[t]; (u >= 0 && u < e.size - 1 || c > 1 && c <= e.size || u <= 0 && c >= e.size) && (e.visibleSlides.push(s), e.visibleSlidesIndexes.push(t), r.eq(t).addClass(n.slideVisibleClass)), s.progress = i ? -l : l; }e.visibleSlides = u(e.visibleSlides); },
      updateProgress(t) { const e = this; if (void 0 === t) { const n = e.rtlTranslate ? -1 : 1; t = e && e.translate && e.translate * n || 0; } const n = e.params; const r = e.maxTranslate() - e.minTranslate(); let { progress: i, isBeginning: o, isEnd: s } = e; const a = o; const l = s; r === 0 ? (i = 0, o = !0, s = !0) : (i = (t - e.minTranslate()) / r, o = i <= 0, s = i >= 1), Object.assign(e, { progress: i, isBeginning: o, isEnd: s }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && e.updateSlidesProgress(t), o && !a && e.emit("reachBeginning toEdge"), s && !l && e.emit("reachEnd toEdge"), (a && !o || l && !s) && e.emit("fromEdge"), e.emit("progress", i); },
      updateSlidesClasses() {
        const t = this; const {
          slides: e, params: n, $wrapperEl: r, activeIndex: i, realIndex: o,
        } = t; const s = t.virtual && n.virtual.enabled; let a; e.removeClass(`${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`), a = s ? t.$wrapperEl.find(`.${n.slideClass}[data-swiper-slide-index="${i}"]`) : e.eq(i), a.addClass(n.slideActiveClass), n.loop && (a.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${o}"]`).addClass(n.slideDuplicateActiveClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${o}"]`).addClass(n.slideDuplicateActiveClass)); let l = a.nextAll(`.${n.slideClass}`).eq(0).addClass(n.slideNextClass); n.loop && l.length === 0 && (l = e.eq(0), l.addClass(n.slideNextClass)); let u = a.prevAll(`.${n.slideClass}`).eq(0).addClass(n.slidePrevClass); n.loop && u.length === 0 && (u = e.eq(-1), u.addClass(n.slidePrevClass)), n.loop && (l.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass), u.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${u.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${u.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass)), t.emitSlidesClasses();
      },
      updateActiveIndex(t) {
        const e = this; const n = e.rtlTranslate ? e.translate : -e.translate; const {
          slidesGrid: r, snapGrid: i, params: o, activeIndex: s, realIndex: a, snapIndex: l,
        } = e; let u; let c = t; if (void 0 === c) { for (let t = 0; t < r.length; t += 1) void 0 !== r[t + 1] ? n >= r[t] && n < r[t + 1] - (r[t + 1] - r[t]) / 2 ? c = t : n >= r[t] && n < r[t + 1] && (c = t + 1) : n >= r[t] && (c = t); o.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0); } if (i.indexOf(n) >= 0)u = i.indexOf(n); else { const t = Math.min(o.slidesPerGroupSkip, c); u = t + Math.floor((c - t) / o.slidesPerGroup); } if (u >= i.length && (u = i.length - 1), c === s) return void (u !== l && (e.snapIndex = u, e.emit("snapIndexChange"))); const d = parseInt(e.slides.eq(c).attr("data-swiper-slide-index") || c, 10); Object.assign(e, {
          snapIndex: u, realIndex: d, previousIndex: s, activeIndex: c,
        }), e.emit("activeIndexChange"), e.emit("snapIndexChange"), a !== d && e.emit("realIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange");
      },
      updateClickedSlide(t) { const e = this; const n = e.params; const r = u(t.target).closest(`.${n.slideClass}`)[0]; let i; let o = !1; if (r) for (let t = 0; t < e.slides.length; t += 1) if (e.slides[t] === r) { o = !0, i = t; break; } if (!r || !o) return e.clickedSlide = void 0, void (e.clickedIndex = void 0); e.clickedSlide = r, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(u(r).attr("data-swiper-slide-index"), 10) : e.clickedIndex = i, n.slideToClickedSlide && void 0 !== e.clickedIndex && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide(); },
    },
    translate: {
      getTranslate(t = (this.isHorizontal() ? "x" : "y")) {
        const {
          params: e, rtlTranslate: n, translate: r, $wrapperEl: i,
        } = this; if (e.virtualTranslate) return n ? -r : r; if (e.cssMode) return r; let o = p(i[0], t); return n && (o = -o), o || 0;
      },
      setTranslate(t, e) {
        const n = this; const {
          rtlTranslate: r, params: i, $wrapperEl: o, wrapperEl: s, progress: a,
        } = n; let l; let u = 0; let c = 0; n.isHorizontal() ? u = r ? -t : t : c = t, i.roundLengths && (u = Math.floor(u), c = Math.floor(c)), i.cssMode ? s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -u : -c : i.virtualTranslate || o.transform(`translate3d(${u}px, ${c}px, 0px)`), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? u : c; const d = n.maxTranslate() - n.minTranslate(); l = d === 0 ? 0 : (t - n.minTranslate()) / d, l !== a && n.updateProgress(t), n.emit("setTranslate", n.translate, e);
      },
      minTranslate() { return -this.snapGrid[0]; },
      maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1]; },
      translateTo(t = 0, e = this.params.speed, n = !0, r = !0, i) { const o = this; const { params: s, wrapperEl: a } = o; if (o.animating && s.preventInteractionOnTransition) return !1; const l = o.minTranslate(); const u = o.maxTranslate(); let c; if (c = r && t > l ? l : r && t < u ? u : t, o.updateProgress(c), s.cssMode) { const t = o.isHorizontal(); if (e === 0)a[t ? "scrollLeft" : "scrollTop"] = -c; else { if (!o.support.smoothScroll) return v({ swiper: o, targetPosition: -c, side: t ? "left" : "top" }), !0; a.scrollTo({ [t ? "left" : "top"]: -c, behavior: "smooth" }); } return !0; } return e === 0 ? (o.setTransition(0), o.setTranslate(c), n && (o.emit("beforeTransitionStart", e, i), o.emit("transitionEnd"))) : (o.setTransition(e), o.setTranslate(c), n && (o.emit("beforeTransitionStart", e, i), o.emit("transitionStart")), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function (t) { o && !o.destroyed && t.target === this && (o.$wrapperEl[0].removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.$wrapperEl[0].removeEventListener("webkitTransitionEnd", o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, n && o.emit("transitionEnd")); }), o.$wrapperEl[0].addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.$wrapperEl[0].addEventListener("webkitTransitionEnd", o.onTranslateToWrapperTransitionEnd))), !0; },
    },
    transition: {
      setTransition(t, e) { const n = this; n.params.cssMode || n.$wrapperEl.transition(t), n.emit("setTransition", t, e); },
      transitionStart(t = !0, e) {
        const n = this; const { params: r } = n; r.cssMode || (r.autoHeight && n.updateAutoHeight(), k({
          swiper: n, runCallbacks: t, direction: e, step: "Start",
        }));
      },
      transitionEnd(t = !0, e) {
        const n = this; const { params: r } = n; n.animating = !1, r.cssMode || (n.setTransition(0), k({
          swiper: n, runCallbacks: t, direction: e, step: "End",
        }));
      },
    },
    slide: {
      slideTo(t = 0, e = this.params.speed, n = !0, r, i) {
        if (typeof t !== "number" && typeof t !== "string") throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`); if (typeof t === "string") { const e = parseInt(t, 10); if (!isFinite(e)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`); t = e; } const o = this; let s = t; s < 0 && (s = 0); const {
          params: a, snapGrid: l, slidesGrid: u, previousIndex: c, activeIndex: d, rtlTranslate: h, wrapperEl: p, enabled: f,
        } = o; if (o.animating && a.preventInteractionOnTransition || !f && !r && !i) return !1; const m = Math.min(o.params.slidesPerGroupSkip, s); let g = m + Math.floor((s - m) / o.params.slidesPerGroup); g >= l.length && (g = l.length - 1), (d || a.initialSlide || 0) === (c || 0) && n && o.emit("beforeSlideChangeStart"); const y = -l[g]; if (o.updateProgress(y), a.normalizeSlideIndex) for (let t = 0; t < u.length; t += 1) { const e = -Math.floor(100 * y); const n = Math.floor(100 * u[t]); const r = Math.floor(100 * u[t + 1]); void 0 !== u[t + 1] ? e >= n && e < r - (r - n) / 2 ? s = t : e >= n && e < r && (s = t + 1) : e >= n && (s = t); } if (o.initialized && s !== d) { if (!o.allowSlideNext && y < o.translate && y < o.minTranslate()) return !1; if (!o.allowSlidePrev && y > o.translate && y > o.maxTranslate() && (d || 0) !== s) return !1; } let _; if (_ = s > d ? "next" : s < d ? "prev" : "reset", h && -y === o.translate || !h && y === o.translate) return o.updateActiveIndex(s), a.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), a.effect !== "slide" && o.setTranslate(y), _ !== "reset" && (o.transitionStart(n, _), o.transitionEnd(n, _)), !1; if (a.cssMode) { const t = o.isHorizontal(); const n = h ? y : -y; if (e === 0) { const e = o.virtual && o.params.virtual.enabled; e && (o.wrapperEl.style.scrollSnapType = "none", o._immediateVirtual = !0), p[t ? "scrollLeft" : "scrollTop"] = n, e && requestAnimationFrame(() => { o.wrapperEl.style.scrollSnapType = "", o._swiperImmediateVirtual = !1; }); } else { if (!o.support.smoothScroll) return v({ swiper: o, targetPosition: n, side: t ? "left" : "top" }), !0; p.scrollTo({ [t ? "left" : "top"]: n, behavior: "smooth" }); } return !0; } return e === 0 ? (o.setTransition(0), o.setTranslate(y), o.updateActiveIndex(s), o.updateSlidesClasses(), o.emit("beforeTransitionStart", e, r), o.transitionStart(n, _), o.transitionEnd(n, _)) : (o.setTransition(e), o.setTranslate(y), o.updateActiveIndex(s), o.updateSlidesClasses(), o.emit("beforeTransitionStart", e, r), o.transitionStart(n, _), o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function (t) { o && !o.destroyed && t.target === this && (o.$wrapperEl[0].removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.$wrapperEl[0].removeEventListener("webkitTransitionEnd", o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(n, _)); }), o.$wrapperEl[0].addEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.$wrapperEl[0].addEventListener("webkitTransitionEnd", o.onSlideToWrapperTransitionEnd))), !0;
      },
      slideToLoop(t = 0, e = this.params.speed, n = !0, r) { const i = this; let o = t; return i.params.loop && (o += i.loopedSlides), i.slideTo(o, e, n, r); },
      slideNext(t = this.params.speed, e = !0, n) { const r = this; const { animating: i, enabled: o, params: s } = r; if (!o) return r; let a = s.slidesPerGroup; s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (a = Math.max(r.slidesPerViewDynamic("current", !0), 1)); const l = r.activeIndex < s.slidesPerGroupSkip ? 1 : a; if (s.loop) { if (i && s.loopPreventsSlide) return !1; r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft; } return r.slideTo(r.activeIndex + l, t, e, n); },
      slidePrev(t = this.params.speed, e = !0, n) {
        const r = this; const {
          params: i, animating: o, snapGrid: s, slidesGrid: a, rtlTranslate: l, enabled: u,
        } = r; if (!u) return r; if (i.loop) { if (o && i.loopPreventsSlide) return !1; r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft; } function c(t) { return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t); } const d = c(l ? r.translate : -r.translate); const h = s.map((t) => c(t)); let p = s[h.indexOf(d) - 1]; if (void 0 === p && i.cssMode) { let t; s.forEach((e, n) => { d >= e && (t = n); }), void 0 !== t && (p = s[t > 0 ? t - 1 : t]); } let f = 0; return void 0 !== p && (f = a.indexOf(p), f < 0 && (f = r.activeIndex - 1), i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (f = f - r.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), r.slideTo(f, t, e, n);
      },
      slideReset(t = this.params.speed, e = !0, n) { return this.slideTo(this.activeIndex, t, e, n); },
      slideToClosest(t = this.params.speed, e = !0, n, r = 0.5) { const i = this; let o = i.activeIndex; const s = Math.min(i.params.slidesPerGroupSkip, o); const a = s + Math.floor((o - s) / i.params.slidesPerGroup); const l = i.rtlTranslate ? i.translate : -i.translate; if (l >= i.snapGrid[a]) { const t = i.snapGrid[a]; l - t > (i.snapGrid[a + 1] - t) * r && (o += i.params.slidesPerGroup); } else { const t = i.snapGrid[a - 1]; l - t <= (i.snapGrid[a] - t) * r && (o -= i.params.slidesPerGroup); } return o = Math.max(o, 0), o = Math.min(o, i.slidesGrid.length - 1), i.slideTo(o, t, e, n); },
      slideToClickedSlide() { const t = this; const { params: e, $wrapperEl: n } = t; const r = e.slidesPerView === "auto" ? t.slidesPerViewDynamic() : e.slidesPerView; let i; let o = t.clickedIndex; if (e.loop) { if (t.animating) return; i = parseInt(u(t.clickedSlide).attr("data-swiper-slide-index"), 10), e.centeredSlides ? o < t.loopedSlides - r / 2 || o > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), o = n.children(`.${e.slideClass}[data-swiper-slide-index="${i}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), d(() => { t.slideTo(o); })) : t.slideTo(o) : o > t.slides.length - r ? (t.loopFix(), o = n.children(`.${e.slideClass}[data-swiper-slide-index="${i}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), d(() => { t.slideTo(o); })) : t.slideTo(o); } else t.slideTo(o); },
    },
    loop: {
      loopCreate() { const t = this; const e = r(); const { params: n, $wrapperEl: i } = t; i.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove(); let o = i.children(`.${n.slideClass}`); if (n.loopFillGroupWithBlank) { const t = n.slidesPerGroup - o.length % n.slidesPerGroup; if (t !== n.slidesPerGroup) { for (let r = 0; r < t; r += 1) { const t = u(e.createElement("div")).addClass(`${n.slideClass} ${n.slideBlankClass}`); i.append(t); }o = i.children(`.${n.slideClass}`); } }n.slidesPerView !== "auto" || n.loopedSlides || (n.loopedSlides = o.length), t.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)), t.loopedSlides += n.loopAdditionalSlides, t.loopedSlides > o.length && (t.loopedSlides = o.length); const s = []; const a = []; o.each((e, n) => { const r = u(e); n < t.loopedSlides && a.push(e), n < o.length && n >= o.length - t.loopedSlides && s.push(e), r.attr("data-swiper-slide-index", n); }); for (let t = 0; t < a.length; t += 1)i.append(u(a[t].cloneNode(!0)).addClass(n.slideDuplicateClass)); for (let t = s.length - 1; t >= 0; t -= 1)i.prepend(u(s[t].cloneNode(!0)).addClass(n.slideDuplicateClass)); },
      loopFix() {
        const t = this; t.emit("beforeLoopFix"); const {
          activeIndex: e, slides: n, loopedSlides: r, allowSlidePrev: i, allowSlideNext: o, snapGrid: s, rtlTranslate: a,
        } = t; let l; t.allowSlidePrev = !0, t.allowSlideNext = !0; const u = -s[e] - t.getTranslate(); e < r ? (l = n.length - 3 * r + e, l += r, t.slideTo(l, 0, !1, !0) && u !== 0 && t.setTranslate((a ? -t.translate : t.translate) - u)) : e >= n.length - r && (l = -n.length + e + r, l += r, t.slideTo(l, 0, !1, !0) && u !== 0 && t.setTranslate((a ? -t.translate : t.translate) - u)), t.allowSlidePrev = i, t.allowSlideNext = o, t.emit("loopFix");
      },
      loopDestroy() { const { $wrapperEl: t, params: e, slides: n } = this; t.children(`.${e.slideClass}.${e.slideDuplicateClass},.${e.slideClass}.${e.slideBlankClass}`).remove(), n.removeAttr("data-swiper-slide-index"); },
    },
    grabCursor: { setGrabCursor(t) { const e = this; if (e.support.touch || !e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const n = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; n.style.cursor = "move", n.style.cursor = t ? "-webkit-grabbing" : "-webkit-grab", n.style.cursor = t ? "-moz-grabbin" : "-moz-grab", n.style.cursor = t ? "grabbing" : "grab"; }, unsetGrabCursor() { const t = this; t.support.touch || t.params.watchOverflow && t.isLocked || t.params.cssMode || (t[t.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = ""); } },
    events: { attachEvents() { const t = this; const e = r(); const { params: n, support: i } = t; t.onTouchStart = C.bind(t), t.onTouchMove = E.bind(t), t.onTouchEnd = T.bind(t), n.cssMode && (t.onScroll = A.bind(t)), t.onClick = O.bind(t), i.touch && !M && (e.addEventListener("touchstart", L), M = !0), I(t, "on"); }, detachEvents() { I(this, "off"); } },
    breakpoints: {
      setBreakpoint() {
        const t = this; const {
          activeIndex: e, initialized: n, loopedSlides: r = 0, params: i, $el: o,
        } = t; const s = i.breakpoints; if (!s || s && Object.keys(s).length === 0) return; const a = t.getBreakpoint(s, t.params.breakpointsBase, t.el); if (!a || t.currentBreakpoint === a) return; const l = (a in s ? s[a] : void 0) || t.originalParams; const u = j(t, i); const c = j(t, l); const d = i.enabled; u && !c ? (o.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), t.emitContainerClasses()) : !u && c && (o.addClass(`${i.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && i.grid.fill === "column") && o.addClass(`${i.containerModifierClass}grid-column`), t.emitContainerClasses()); const h = l.direction && l.direction !== i.direction; const p = i.loop && (l.slidesPerView !== i.slidesPerView || h); h && n && t.changeDirection(), m(t.params, l); const f = t.params.enabled; Object.assign(t, { allowTouchMove: t.params.allowTouchMove, allowSlideNext: t.params.allowSlideNext, allowSlidePrev: t.params.allowSlidePrev }), d && !f ? t.disable() : !d && f && t.enable(), t.currentBreakpoint = a, t.emit("_beforeBreakpoint", l), p && n && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - r + t.loopedSlides, 0, !1)), t.emit("breakpoint", l);
      },
      getBreakpoint(t, e = "window", n) { if (!t || e === "container" && !n) return; let r = !1; const i = o(); const s = e === "window" ? i.innerHeight : n.clientHeight; const a = Object.keys(t).map((t) => { if (typeof t === "string" && t.indexOf("@") === 0) { const e = parseFloat(t.substr(1)); return { value: s * e, point: t }; } return { value: t, point: t }; }); a.sort((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10)); for (let t = 0; t < a.length; t += 1) { const { point: o, value: s } = a[t]; e === "window" ? i.matchMedia(`(min-width: ${s}px)`).matches && (r = o) : s <= n.clientWidth && (r = o); } return r || "max"; },
    },
    checkOverflow: { checkOverflow() { const t = this; const { isLocked: e, params: n } = t; const { slidesOffsetBefore: r } = n; if (r) { const e = t.slides.length - 1; const n = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * r; t.isLocked = t.size > n; } else t.isLocked = t.snapGrid.length === 1; !0 === n.allowSlideNext && (t.allowSlideNext = !t.isLocked), !0 === n.allowSlidePrev && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock"); } },
    classes: {
      addClasses() {
        const t = this; const {
          classNames: e, params: n, rtl: r, $el: i, device: o, support: s,
        } = t; const a = (function (t, e) { const n = []; return t.forEach((t) => { typeof t === "object" ? Object.keys(t).forEach((r) => { t[r] && n.push(e + r); }) : typeof t === "string" && n.push(e + t); }), n; }(["initialized", n.direction, { "pointer-events": !s.touch }, { "free-mode": t.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: r }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column" }, { android: o.android }, { ios: o.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }], n.containerModifierClass)); e.push(...a), i.addClass([...e].join(" ")), t.emitContainerClasses();
      },
      removeClasses() { const { $el: t, classNames: e } = this; t.removeClass(e.join(" ")), this.emitContainerClasses(); },
    },
    images: { loadImage(t, e, n, r, i, s) { const a = o(); let l; function c() { s && s(); }u(t).parent("picture")[0] || t.complete && i ? c() : e ? (l = new a.Image(), l.onload = c, l.onerror = c, r && (l.sizes = r), n && (l.srcset = n), e && (l.src = e)) : c(); }, preloadImages() { const t = this; function e() { t != null && t && !t.destroyed && (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1), t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady"))); }t.imagesToLoad = t.$el.find("img"); for (let n = 0; n < t.imagesToLoad.length; n += 1) { const r = t.imagesToLoad[n]; t.loadImage(r, r.currentSrc || r.getAttribute("src"), r.srcset || r.getAttribute("srcset"), r.sizes || r.getAttribute("sizes"), !0, e); } } },
  }; const F = {}; class V {
    constructor(...t) {
      let e; let n; if (t.length === 1 && t[0].constructor && Object.prototype.toString.call(t[0]).slice(8, -1) === "Object" ? n = t[0] : [e, n] = t, n || (n = {}), n = m({}, n), e && !n.el && (n.el = e), n.el && u(n.el).length > 1) { const t = []; return u(n.el).each((e) => { const r = m({}, n, { el: e }); t.push(new V(r)); }), t; } const r = this; r.__swiper__ = !0, r.support = w(), r.device = x({ userAgent: n.userAgent }), r.browser = S(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], n.modules && Array.isArray(n.modules) && r.modules.push(...n.modules); const i = {}; r.modules.forEach((t) => {
        t({
          swiper: r, extendParams: N(n, i), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r),
        });
      }); const o = m({}, D, i); return r.params = m({}, o, F, n), r.originalParams = m({}, r.params), r.passedParams = m({}, n), r.params && r.params.on && Object.keys(r.params.on).forEach((t) => { r.on(t, r.params.on[t]); }), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = u, Object.assign(r, {
        enabled: r.params.enabled,
        el: e,
        classNames: [],
        slides: u(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal: () => r.params.direction === "horizontal",
        isVertical: () => r.params.direction === "vertical",
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        allowSlideNext: r.params.allowSlideNext,
        allowSlidePrev: r.params.allowSlidePrev,
        touchEvents: (function () {
          const t = ["touchstart", "touchmove", "touchend", "touchcancel"]; const e = ["pointerdown", "pointermove", "pointerup"]; return r.touchEventsTouch = {
            start: t[0], move: t[1], end: t[2], cancel: t[3],
          }, r.touchEventsDesktop = { start: e[0], move: e[1], end: e[2] }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop;
        }()),
        touchEventsData: {
          isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: h(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0,
        },
        allowClick: !0,
        allowTouchMove: r.params.allowTouchMove,
        touches: {
          startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0,
        },
        imagesToLoad: [],
        imagesLoaded: 0,
      }), r.emit("_swiper"), r.params.init && r.init(), r;
    }

    enable() { const t = this; t.enabled || (t.enabled = !0, t.params.grabCursor && t.setGrabCursor(), t.emit("enable")); }

    disable() { const t = this; t.enabled && (t.enabled = !1, t.params.grabCursor && t.unsetGrabCursor(), t.emit("disable")); }

    setProgress(t, e) { const n = this; t = Math.min(Math.max(t, 0), 1); const r = n.minTranslate(); const i = (n.maxTranslate() - r) * t + r; n.translateTo(i, void 0 === e ? 0 : e), n.updateActiveIndex(), n.updateSlidesClasses(); }

    emitContainerClasses() { const t = this; if (!t.params._emitClasses || !t.el) return; const e = t.el.className.split(" ").filter((e) => e.indexOf("swiper") === 0 || e.indexOf(t.params.containerModifierClass) === 0); t.emit("_containerClasses", e.join(" ")); }

    getSlideClasses(t) { const e = this; return t.className.split(" ").filter((t) => t.indexOf("swiper-slide") === 0 || t.indexOf(e.params.slideClass) === 0).join(" "); }

    emitSlidesClasses() { const t = this; if (!t.params._emitClasses || !t.el) return; const e = []; t.slides.each((n) => { const r = t.getSlideClasses(n); e.push({ slideEl: n, classNames: r }), t.emit("_slideClass", n, r); }), t.emit("_slideClasses", e); }

    slidesPerViewDynamic(t = "current", e = !1) {
      const {
        params: n, slides: r, slidesGrid: i, slidesSizesGrid: o, size: s, activeIndex: a,
      } = this; let l = 1; if (n.centeredSlides) { let t; let e = r[a].swiperSlideSize; for (let n = a + 1; n < r.length; n += 1)r[n] && !t && (e += r[n].swiperSlideSize, l += 1, e > s && (t = !0)); for (let n = a - 1; n >= 0; n -= 1)r[n] && !t && (e += r[n].swiperSlideSize, l += 1, e > s && (t = !0)); } else if (t === "current") for (let t = a + 1; t < r.length; t += 1)(e ? i[t] + o[t] - i[a] < s : i[t] - i[a] < s) && (l += 1); else for (let t = a - 1; t >= 0; t -= 1)i[a] - i[t] < s && (l += 1); return l;
    }

    update() { const t = this; if (!t || t.destroyed) return; const { snapGrid: e, params: n } = t; function r() { const e = t.rtlTranslate ? -1 * t.translate : t.translate; const n = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate()); t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses(); } let i; n.breakpoints && t.setBreakpoint(), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.params.freeMode && t.params.freeMode.enabled ? (r(), t.params.autoHeight && t.updateAutoHeight()) : (i = (t.params.slidesPerView === "auto" || t.params.slidesPerView > 1) && t.isEnd && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), i || r()), n.watchOverflow && e !== t.snapGrid && t.checkOverflow(), t.emit("update"); }

    changeDirection(t, e = !0) { const n = this; const r = n.params.direction; return t || (t = r === "horizontal" ? "vertical" : "horizontal"), t === r || t !== "horizontal" && t !== "vertical" || (n.$el.removeClass(`${n.params.containerModifierClass}${r}`).addClass(`${n.params.containerModifierClass}${t}`), n.emitContainerClasses(), n.params.direction = t, n.slides.each((e) => { t === "vertical" ? e.style.width = "" : e.style.height = ""; }), n.emit("changeDirection"), e && n.update()), n; }

    mount(t) {
      const e = this; if (e.mounted) return !0; const n = u(t || e.params.el); if (!(t = n[0])) return !1; t.swiper = e; const i = () => `.${(e.params.wrapperClass || "").trim().split(" ").join(".")}`; let o = (() => { if (t && t.shadowRoot && t.shadowRoot.querySelector) { const e = u(t.shadowRoot.querySelector(i())); return e.children = (t) => n.children(t), e; } return n.children(i()); })(); if (o.length === 0 && e.params.createElements) { const t = r().createElement("div"); o = u(t), t.className = e.params.wrapperClass, n.append(t), n.children(`.${e.params.slideClass}`).each((t) => { o.append(t); }); } return Object.assign(e, {
        $el: n, el: t, $wrapperEl: o, wrapperEl: o[0], mounted: !0, rtl: t.dir.toLowerCase() === "rtl" || n.css("direction") === "rtl", rtlTranslate: e.params.direction === "horizontal" && (t.dir.toLowerCase() === "rtl" || n.css("direction") === "rtl"), wrongRTL: o.css("display") === "-webkit-box",
      }), !0;
    }

    init(t) { const e = this; return e.initialized || !1 === e.mount(t) || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.enabled && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit, !1, !0) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit, !1, !0), e.attachEvents(), e.initialized = !0, e.emit("init"), e.emit("afterInit")), e; }

    destroy(t = !0, e = !0) {
      const n = this; const {
        params: r, $el: i, $wrapperEl: o, slides: s,
      } = n; return void 0 === n.params || n.destroyed || (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), r.loop && n.loopDestroy(), e && (n.removeClasses(), i.removeAttr("style"), o.removeAttr("style"), s && s.length && s.removeClass([r.slideVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), n.emit("destroy"), Object.keys(n.eventsListeners).forEach((t) => { n.off(t); }), !1 !== t && (n.$el[0].swiper = null, (function (t) { const e = t; Object.keys(e).forEach((t) => { try { e[t] = null; } catch (t) {} try { delete e[t]; } catch (t) {} }); }(n))), n.destroyed = !0), null;
    }

    static extendDefaults(t) { m(F, t); }

    static get extendedDefaults() { return F; }

    static get defaults() { return D; }

    static installModule(t) { V.prototype.__modules__ || (V.prototype.__modules__ = []); const e = V.prototype.__modules__; typeof t === "function" && e.indexOf(t) < 0 && e.push(t); }

    static use(t) { return Array.isArray(t) ? (t.forEach((t) => V.installModule(t)), V) : (V.installModule(t), V); }
  } function z(t, e, n, i) { const o = r(); return t.params.createElements && Object.keys(i).forEach((r) => { if (!n[r] && !0 === n.auto) { let s = t.$el.children(`.${i[r]}`)[0]; s || (s = o.createElement("div"), s.className = i[r], t.$el.append(s)), n[r] = s, e[r] = s; } }), n; } function B(t = "") { return `.${t.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`; } function q(t) { const e = this; const { $wrapperEl: n, params: r } = e; if (r.loop && e.loopDestroy(), typeof t === "object" && "length" in t) for (let e = 0; e < t.length; e += 1)t[e] && n.append(t[e]); else n.append(t); r.loop && e.loopCreate(), r.observer || e.update(); } function H(t) { const e = this; const { params: n, $wrapperEl: r, activeIndex: i } = e; n.loop && e.loopDestroy(); let o = i + 1; if (typeof t === "object" && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && r.prepend(t[e]); o = i + t.length; } else r.prepend(t); n.loop && e.loopCreate(), n.observer || e.update(), e.slideTo(o, 0, !1); } function $(t, e) { const n = this; const { $wrapperEl: r, params: i, activeIndex: o } = n; let s = o; i.loop && (s -= n.loopedSlides, n.loopDestroy(), n.slides = r.children(`.${i.slideClass}`)); const a = n.slides.length; if (t <= 0) return void n.prependSlide(e); if (t >= a) return void n.appendSlide(e); let l = s > t ? s + 1 : s; const u = []; for (let e = a - 1; e >= t; e -= 1) { const t = n.slides.eq(e); t.remove(), u.unshift(t); } if (typeof e === "object" && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && r.append(e[t]); l = s > t ? s + e.length : s; } else r.append(e); for (let t = 0; t < u.length; t += 1)r.append(u[t]); i.loop && n.loopCreate(), i.observer || n.update(), i.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1); } function U(t) { const e = this; const { params: n, $wrapperEl: r, activeIndex: i } = e; let o = i; n.loop && (o -= e.loopedSlides, e.loopDestroy(), e.slides = r.children(`.${n.slideClass}`)); let s; let a = o; if (typeof t === "object" && "length" in t) { for (let n = 0; n < t.length; n += 1)s = t[n], e.slides[s] && e.slides.eq(s).remove(), s < a && (a -= 1); a = Math.max(a, 0); } else s = t, e.slides[s] && e.slides.eq(s).remove(), s < a && (a -= 1), a = Math.max(a, 0); n.loop && e.loopCreate(), n.observer || e.update(), n.loop ? e.slideTo(a + e.loopedSlides, 0, !1) : e.slideTo(a, 0, !1); } function W() { const t = this; const e = []; for (let n = 0; n < t.slides.length; n += 1)e.push(n); t.removeSlide(e); } function G(t) {
    const {
      effect: e, swiper: n, on: r, setTranslate: i, setTransition: o, overwriteParams: s, perspective: a,
    } = t; r("beforeInit", () => { if (n.params.effect !== e) return; n.classNames.push(`${n.params.containerModifierClass}${e}`), a && a() && n.classNames.push(`${n.params.containerModifierClass}3d`); const t = s ? s() : {}; Object.assign(n.params, t), Object.assign(n.originalParams, t); }), r("setTranslate", () => { n.params.effect === e && i(); }), r("setTransition", (t, r) => { n.params.effect === e && o(r); });
  } function Y(t, e) { return t.transformEl ? e.find(t.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : e; } function Z({
    swiper: t, duration: e, transformEl: n, allSlides: r,
  }) { const { slides: i, activeIndex: o, $wrapperEl: s } = t; if (t.params.virtualTranslate && e !== 0) { let e; let a = !1; e = r ? n ? i.find(n) : i : n ? i.eq(o).find(n) : i.eq(o), e.transitionEnd(() => { if (a) return; if (!t || t.destroyed) return; a = !0, t.animating = !1; const e = ["webkitTransitionEnd", "transitionend"]; for (let t = 0; t < e.length; t += 1)s.trigger(e[t]); }); } } function K(t, e, n) { const r = `swiper-slide-shadow${n ? `-${n}` : ""}`; const i = t.transformEl ? e.find(t.transformEl) : e; let o = i.children(`.${r}`); return o.length || (o = u(`<div class="swiper-slide-shadow${n ? `-${n}` : ""}"></div>`), i.append(o)), o; }Object.keys(R).forEach((t) => { Object.keys(R[t]).forEach((e) => { V.prototype[e] = R[t][e]; }); }), V.use([function ({ swiper: t, on: e, emit: n }) { const r = o(); let i = null; const s = () => { t && !t.destroyed && t.initialized && (n("beforeResize"), n("resize")); }; const a = () => { t && !t.destroyed && t.initialized && n("orientationchange"); }; e("init", () => { t.params.resizeObserver && void 0 !== r.ResizeObserver ? t && !t.destroyed && t.initialized && (i = new ResizeObserver((e) => { const { width: n, height: r } = t; let i = n; let o = r; e.forEach(({ contentBoxSize: e, contentRect: n, target: r }) => { r && r !== t.el || (i = n ? n.width : (e[0] || e).inlineSize, o = n ? n.height : (e[0] || e).blockSize); }), i === n && o === r || s(); }), i.observe(t.el)) : (r.addEventListener("resize", s), r.addEventListener("orientationchange", a)); }), e("destroy", () => { i && i.unobserve && t.el && (i.unobserve(t.el), i = null), r.removeEventListener("resize", s), r.removeEventListener("orientationchange", a); }); }, function ({
    swiper: t, extendParams: e, on: n, emit: r,
  }) { const i = []; const s = o(); const a = (t, e = {}) => { const n = new (s.MutationObserver || s.WebkitMutationObserver)((t) => { if (t.length === 1) return void r("observerUpdate", t[0]); const e = function () { r("observerUpdate", t[0]); }; s.requestAnimationFrame ? s.requestAnimationFrame(e) : s.setTimeout(e, 0); }); n.observe(t, { attributes: void 0 === e.attributes || e.attributes, childList: void 0 === e.childList || e.childList, characterData: void 0 === e.characterData || e.characterData }), i.push(n); }; e({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), n("init", () => { if (t.params.observer) { if (t.params.observeParents) { const e = t.$el.parents(); for (let t = 0; t < e.length; t += 1)a(e[t]); }a(t.$el[0], { childList: t.params.observeSlideChildren }), a(t.$wrapperEl[0], { attributes: !1 }); } }), n("destroy", () => { i.forEach((t) => { t.disconnect(); }), i.splice(0, i.length); }); }]); const X = [function ({ swiper: t, extendParams: e, on: n }) {
    let r; function i(e, n) { const r = t.params.virtual; if (r.cache && t.virtual.cache[n]) return t.virtual.cache[n]; const i = r.renderSlide ? u(r.renderSlide.call(t, e, n)) : u(`<div class="${t.params.slideClass}" data-swiper-slide-index="${n}">${e}</div>`); return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", n), r.cache && (t.virtual.cache[n] = i), i; } function o(e) {
      const { slidesPerView: n, slidesPerGroup: r, centeredSlides: o } = t.params; const { addSlidesBefore: s, addSlidesAfter: a } = t.params.virtual; const {
        from: l, to: u, slides: c, slidesGrid: d, offset: h,
      } = t.virtual; t.params.cssMode || t.updateActiveIndex(); const p = t.activeIndex || 0; let f; let m; let g; f = t.rtlTranslate ? "right" : t.isHorizontal() ? "left" : "top", o ? (m = Math.floor(n / 2) + r + a, g = Math.floor(n / 2) + r + s) : (m = n + (r - 1) + a, g = r + s); const v = Math.max((p || 0) - g, 0); const y = Math.min((p || 0) + m, c.length - 1); const _ = (t.slidesGrid[v] || 0) - (t.slidesGrid[0] || 0); function b() { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load(); } if (Object.assign(t.virtual, {
        from: v, to: y, offset: _, slidesGrid: t.slidesGrid,
      }), l === v && u === y && !e) return t.slidesGrid !== d && _ !== h && t.slides.css(f, `${_}px`), void t.updateProgress(); if (t.params.virtual.renderExternal) {
        return t.params.virtual.renderExternal.call(t, {
          offset: _, from: v, to: y, slides: (function () { const t = []; for (let e = v; e <= y; e += 1)t.push(c[e]); return t; }()),
        }), void (t.params.virtual.renderExternalUpdate && b());
      } const w = []; const x = []; if (e)t.$wrapperEl.find(`.${t.params.slideClass}`).remove(); else for (let e = l; e <= u; e += 1)(e < v || e > y) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`).remove(); for (let t = 0; t < c.length; t += 1)t >= v && t <= y && (void 0 === u || e ? x.push(t) : (t > u && x.push(t), t < l && w.push(t))); x.forEach((e) => { t.$wrapperEl.append(i(c[e], e)); }), w.sort((t, e) => e - t).forEach((e) => { t.$wrapperEl.prepend(i(c[e], e)); }), t.$wrapperEl.children(".swiper-slide").css(f, `${_}px`), b();
    }e({
      virtual: {
        enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0,
      },
    }), t.virtual = {
      cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [],
    }, n("beforeInit", () => { t.params.virtual.enabled && (t.virtual.slides = t.params.virtual.slides, t.classNames.push(`${t.params.containerModifierClass}virtual`), t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0, t.params.initialSlide || o()); }), n("setTranslate", () => { t.params.virtual.enabled && (t.params.cssMode && !t._immediateVirtual ? (clearTimeout(r), r = setTimeout(() => { o(); }, 100)) : o()); }), n("init update resize", () => { t.params.virtual.enabled && t.params.cssMode && g(t.wrapperEl, "--swiper-virtual-size", `${t.virtualSize}px`); }), Object.assign(t.virtual, {
      appendSlide(e) { if (typeof e === "object" && "length" in e) for (let n = 0; n < e.length; n += 1)e[n] && t.virtual.slides.push(e[n]); else t.virtual.slides.push(e); o(!0); }, prependSlide(e) { const n = t.activeIndex; let r = n + 1; let i = 1; if (Array.isArray(e)) { for (let n = 0; n < e.length; n += 1)e[n] && t.virtual.slides.unshift(e[n]); r = n + e.length, i = e.length; } else t.virtual.slides.unshift(e); if (t.params.virtual.cache) { const e = t.virtual.cache; const n = {}; Object.keys(e).forEach((t) => { const r = e[t]; const o = r.attr("data-swiper-slide-index"); o && r.attr("data-swiper-slide-index", parseInt(o, 10) + i), n[parseInt(t, 10) + i] = r; }), t.virtual.cache = n; }o(!0), t.slideTo(r, 0); }, removeSlide(e) { if (e == null) return; let n = t.activeIndex; if (Array.isArray(e)) for (let r = e.length - 1; r >= 0; r -= 1)t.virtual.slides.splice(e[r], 1), t.params.virtual.cache && delete t.virtual.cache[e[r]], e[r] < n && (n -= 1), n = Math.max(n, 0); else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < n && (n -= 1), n = Math.max(n, 0); o(!0), t.slideTo(n, 0); }, removeAllSlides() { t.virtual.slides = [], t.params.virtual.cache && (t.virtual.cache = {}), o(!0), t.slideTo(0, 0); }, update: o,
    });
  }, function ({
    swiper: t, extendParams: e, on: n, emit: i,
  }) { const s = r(); const a = o(); function l(e) { if (!t.enabled) return; const { rtlTranslate: n } = t; let r = e; r.originalEvent && (r = r.originalEvent); const o = r.keyCode || r.charCode; const l = t.params.keyboard.pageUpDown; const u = l && o === 33; const c = l && o === 34; const d = o === 37; const h = o === 39; const p = o === 38; const f = o === 40; if (!t.allowSlideNext && (t.isHorizontal() && h || t.isVertical() && f || c)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && d || t.isVertical() && p || u)) return !1; if (!(r.shiftKey || r.altKey || r.ctrlKey || r.metaKey || s.activeElement && s.activeElement.nodeName && (s.activeElement.nodeName.toLowerCase() === "input" || s.activeElement.nodeName.toLowerCase() === "textarea"))) { if (t.params.keyboard.onlyInViewport && (u || c || d || h || p || f)) { let e = !1; if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && t.$el.parents(`.${t.params.slideActiveClass}`).length === 0) return; const r = t.$el; const i = r[0].clientWidth; const o = r[0].clientHeight; const s = a.innerWidth; const l = a.innerHeight; const u = t.$el.offset(); n && (u.left -= t.$el[0].scrollLeft); const c = [[u.left, u.top], [u.left + i, u.top], [u.left, u.top + o], [u.left + i, u.top + o]]; for (let t = 0; t < c.length; t += 1) { const n = c[t]; if (n[0] >= 0 && n[0] <= s && n[1] >= 0 && n[1] <= l) { if (n[0] === 0 && n[1] === 0) continue; e = !0; } } if (!e) return; }t.isHorizontal() ? ((u || c || d || h) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), ((c || h) && !n || (u || d) && n) && t.slideNext(), ((u || d) && !n || (c || h) && n) && t.slidePrev()) : ((u || c || p || f) && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), (c || f) && t.slideNext(), (u || p) && t.slidePrev()), i("keyPress", o); } } function c() { t.keyboard.enabled || (u(s).on("keydown", l), t.keyboard.enabled = !0); } function d() { t.keyboard.enabled && (u(s).off("keydown", l), t.keyboard.enabled = !1); }t.keyboard = { enabled: !1 }, e({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), n("init", () => { t.params.keyboard.enabled && c(); }), n("destroy", () => { t.keyboard.enabled && d(); }), Object.assign(t.keyboard, { enable: c, disable: d }); }, function ({
    swiper: t, extendParams: e, on: n, emit: r,
  }) {
    const i = o(); let s; e({
      mousewheel: {
        enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null,
      },
    }), t.mousewheel = { enabled: !1 }; let a; let l = h(); const c = []; function p() { t.enabled && (t.mouseEntered = !0); } function f() { t.enabled && (t.mouseEntered = !1); } function m(e) { return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && h() - l < t.params.mousewheel.thresholdTime || !(e.delta >= 6 && h() - l < 60) && (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), r("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), r("scroll", e.raw)), l = (new i.Date()).getTime(), 1)); } function g(e) {
      let n = e; let i = !0; if (!t.enabled) return; const o = t.params.mousewheel; t.params.cssMode && n.preventDefault(); let l = t.$el; if (t.params.mousewheel.eventsTarget !== "container" && (l = u(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !l[0].contains(n.target) && !o.releaseOnEdges) return !0; n.originalEvent && (n = n.originalEvent); let p = 0; const f = t.rtlTranslate ? -1 : 1; const g = (function (t) {
        let e = 0; let n = 0; let r = 0; let i = 0; return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = 10 * e, i = 10 * n, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), t.shiftKey && !r && (r = i, i = 0), (r || i) && t.deltaMode && (t.deltaMode === 1 ? (r *= 40, i *= 40) : (r *= 800, i *= 800)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
          spinX: e, spinY: n, pixelX: r, pixelY: i,
        };
      }(n)); if (o.forceToAxis) if (t.isHorizontal()) { if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0; p = -g.pixelX * f; } else { if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0; p = -g.pixelY; } else p = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * f : -g.pixelY; if (p === 0) return !0; o.invert && (p = -p); let v = t.getTranslate() + p * o.sensitivity; if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), i = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), i && t.params.nested && n.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) { const e = { time: h(), delta: Math.abs(p), direction: Math.sign(p) }; const i = a && e.time < a.time + 500 && e.delta <= a.delta && e.direction === a.direction; if (!i) { a = void 0, t.params.loop && t.loopFix(); let l = t.getTranslate() + p * o.sensitivity; const u = t.isBeginning; const h = t.isEnd; if (l >= t.minTranslate() && (l = t.minTranslate()), l <= t.maxTranslate() && (l = t.maxTranslate()), t.setTransition(0), t.setTranslate(l), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!u && t.isBeginning || !h && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) { clearTimeout(s), s = void 0, c.length >= 15 && c.shift(); const n = c.length ? c[c.length - 1] : void 0; const r = c[0]; if (c.push(e), n && (e.delta > n.delta || e.direction !== n.direction))c.splice(0); else if (c.length >= 15 && e.time - r.time < 500 && r.delta - e.delta >= 1 && e.delta <= 6) { const n = p > 0 ? 0.8 : 0.2; a = e, c.splice(0), s = d(() => { t.slideToClosest(t.params.speed, !0, void 0, n); }, 0); }s || (s = d(() => { a = e, c.splice(0), t.slideToClosest(t.params.speed, !0, void 0, 0.5); }, 500)); } if (i || r("scroll", n), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), l === t.minTranslate() || l === t.maxTranslate()) return !0; } } else {
        const n = {
          time: h(), delta: Math.abs(p), direction: Math.sign(p), raw: e,
        }; c.length >= 2 && c.shift(); const r = c.length ? c[c.length - 1] : void 0; if (c.push(n), r ? (n.direction !== r.direction || n.delta > r.delta || n.time > r.time + 150) && m(n) : m(n), (function (e) { const n = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && n.releaseOnEdges) return !0; } else if (t.isBeginning && !t.params.loop && n.releaseOnEdges) return !0; return !1; }(n))) return !0;
      } return n.preventDefault ? n.preventDefault() : n.returnValue = !1, !1;
    } function v(e) { let n = t.$el; t.params.mousewheel.eventsTarget !== "container" && (n = u(t.params.mousewheel.eventsTarget)), n[e]("mouseenter", p), n[e]("mouseleave", f), n[e]("wheel", g); } function y() { return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("on"), t.mousewheel.enabled = !0, !0); } function _() { return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("off"), t.mousewheel.enabled = !1, !0); }n("init", () => { !t.params.mousewheel.enabled && t.params.cssMode && _(), t.params.mousewheel.enabled && y(); }), n("destroy", () => { t.params.cssMode && y(), t.mousewheel.enabled && _(); }), Object.assign(t.mousewheel, { enable: y, disable: _ });
  }, function ({
    swiper: t, extendParams: e, on: n, emit: r,
  }) {
    function i(e) { let n; return e && (n = u(e), t.params.uniqueNavElements && typeof e === "string" && n.length > 1 && t.$el.find(e).length === 1 && (n = t.$el.find(e))), n; } function o(e, n) { const r = t.params.navigation; e && e.length > 0 && (e[n ? "addClass" : "removeClass"](r.disabledClass), e[0] && e[0].tagName === "BUTTON" && (e[0].disabled = n), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](r.lockClass)); } function s() { if (t.params.loop) return; const { $nextEl: e, $prevEl: n } = t.navigation; o(n, t.isBeginning), o(e, t.isEnd); } function a(e) { e.preventDefault(), t.isBeginning && !t.params.loop || t.slidePrev(); } function l(e) { e.preventDefault(), t.isEnd && !t.params.loop || t.slideNext(); } function c() {
      const e = t.params.navigation; if (t.params.navigation = z(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; const n = i(e.nextEl); const r = i(e.prevEl); n && n.length > 0 && n.on("click", l), r && r.length > 0 && r.on("click", a), Object.assign(t.navigation, {
        $nextEl: n, nextEl: n && n[0], $prevEl: r, prevEl: r && r[0],
      }), t.enabled || (n && n.addClass(e.lockClass), r && r.addClass(e.lockClass));
    } function d() { const { $nextEl: e, $prevEl: n } = t.navigation; e && e.length && (e.off("click", l), e.removeClass(t.params.navigation.disabledClass)), n && n.length && (n.off("click", a), n.removeClass(t.params.navigation.disabledClass)); }e({
      navigation: {
        nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock",
      },
    }), t.navigation = {
      nextEl: null, $nextEl: null, prevEl: null, $prevEl: null,
    }, n("init", () => { c(), s(); }), n("toEdge fromEdge lock unlock", () => { s(); }), n("destroy", () => { d(); }), n("enable disable", () => { const { $nextEl: e, $prevEl: n } = t.navigation; e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), n && n[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass); }), n("click", (e, n) => { const { $nextEl: i, $prevEl: o } = t.navigation; const s = n.target; if (t.params.navigation.hideOnClick && !u(s).is(o) && !u(s).is(i)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === s || t.pagination.el.contains(s))) return; let e; i ? e = i.hasClass(t.params.navigation.hiddenClass) : o && (e = o.hasClass(t.params.navigation.hiddenClass)), r(!0 === e ? "navigationShow" : "navigationHide"), i && i.toggleClass(t.params.navigation.hiddenClass), o && o.toggleClass(t.params.navigation.hiddenClass); } }), Object.assign(t.navigation, { update: s, init: c, destroy: d });
  }, function ({
    swiper: t, extendParams: e, on: n, emit: r,
  }) {
    const i = "swiper-pagination"; let o; e({
      pagination: {
        el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: (t) => t, formatFractionTotal: (t) => t, bulletClass: `${i}-bullet`, bulletActiveClass: `${i}-bullet-active`, modifierClass: `${i}-`, currentClass: `${i}-current`, totalClass: `${i}-total`, hiddenClass: `${i}-hidden`, progressbarFillClass: `${i}-progressbar-fill`, progressbarOppositeClass: `${i}-progressbar-opposite`, clickableClass: `${i}-clickable`, lockClass: `${i}-lock`, horizontalClass: `${i}-horizontal`, verticalClass: `${i}-vertical`,
      },
    }), t.pagination = { el: null, $el: null, bullets: [] }; let s = 0; function a() { return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || t.pagination.$el.length === 0; } function l(e, n) { const { bulletActiveClass: r } = t.params.pagination; e[n]().addClass(`${r}-${n}`)[n]().addClass(`${r}-${n}-${n}`); } function c() { const e = t.rtl; const n = t.params.pagination; if (a()) return; const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length; const c = t.pagination.$el; let d; const h = t.params.loop ? Math.ceil((i - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (d = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), d > i - 1 - 2 * t.loopedSlides && (d -= i - 2 * t.loopedSlides), d > h - 1 && (d -= h), d < 0 && t.params.paginationType !== "bullets" && (d = h + d)) : d = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, n.type === "bullets" && t.pagination.bullets && t.pagination.bullets.length > 0) { const r = t.pagination.bullets; let i; let a; let h; if (n.dynamicBullets && (o = r.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(t.isHorizontal() ? "width" : "height", `${o * (n.dynamicMainBullets + 4)}px`), n.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (s += d - t.previousIndex, s > n.dynamicMainBullets - 1 ? s = n.dynamicMainBullets - 1 : s < 0 && (s = 0)), i = d - s, a = i + (Math.min(r.length, n.dynamicMainBullets) - 1), h = (a + i) / 2), r.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((t) => `${n.bulletActiveClass}${t}`).join(" ")), c.length > 1)r.each((t) => { const e = u(t); const r = e.index(); r === d && e.addClass(n.bulletActiveClass), n.dynamicBullets && (r >= i && r <= a && e.addClass(`${n.bulletActiveClass}-main`), r === i && l(e, "prev"), r === a && l(e, "next")); }); else { const e = r.eq(d); const o = e.index(); if (e.addClass(n.bulletActiveClass), n.dynamicBullets) { const e = r.eq(i); const s = r.eq(a); for (let t = i; t <= a; t += 1)r.eq(t).addClass(`${n.bulletActiveClass}-main`); if (t.params.loop) if (o >= r.length - n.dynamicMainBullets) { for (let t = n.dynamicMainBullets; t >= 0; t -= 1)r.eq(r.length - t).addClass(`${n.bulletActiveClass}-main`); r.eq(r.length - n.dynamicMainBullets - 1).addClass(`${n.bulletActiveClass}-prev`); } else l(e, "prev"), l(s, "next"); else l(e, "prev"), l(s, "next"); } } if (n.dynamicBullets) { const i = Math.min(r.length, n.dynamicMainBullets + 4); const s = (o * i - o) / 2 - h * o; const a = e ? "right" : "left"; r.css(t.isHorizontal() ? a : "top", `${s}px`); } } if (n.type === "fraction" && (c.find(B(n.currentClass)).text(n.formatFractionCurrent(d + 1)), c.find(B(n.totalClass)).text(n.formatFractionTotal(h))), n.type === "progressbar") { let e; e = n.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical"; const r = (d + 1) / h; let i = 1; let o = 1; e === "horizontal" ? i = r : o = r, c.find(B(n.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${o})`).transition(t.params.speed); }n.type === "custom" && n.renderCustom ? (c.html(n.renderCustom(t, d + 1, h)), r("paginationRender", c[0])) : r("paginationUpdate", c[0]), t.params.watchOverflow && t.enabled && c[t.isLocked ? "addClass" : "removeClass"](n.lockClass); } function d() { const e = t.params.pagination; if (a()) return; const n = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length; const i = t.pagination.$el; let o = ""; if (e.type === "bullets") { let r = t.params.loop ? Math.ceil((n - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && r > n && (r = n); for (let n = 0; n < r; n += 1)e.renderBullet ? o += e.renderBullet.call(t, n, e.bulletClass) : o += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`; i.html(o), t.pagination.bullets = i.find(B(e.bulletClass)); }e.type === "fraction" && (o = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, i.html(o)), e.type === "progressbar" && (o = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, i.html(o)), e.type !== "custom" && r("paginationRender", t.pagination.$el[0]); } function h() { t.params.pagination = z(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const e = t.params.pagination; if (!e.el) return; let n = u(e.el); n.length !== 0 && (t.params.uniqueNavElements && typeof e.el === "string" && n.length > 1 && (n = t.$el.find(e.el), n.length > 1 && (n = n.filter((e) => u(e).parents(".swiper")[0] === t.el))), e.type === "bullets" && e.clickable && n.addClass(e.clickableClass), n.addClass(e.modifierClass + e.type), n.addClass(e.modifierClass + t.params.direction), e.type === "bullets" && e.dynamicBullets && (n.addClass(`${e.modifierClass}${e.type}-dynamic`), s = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), e.type === "progressbar" && e.progressbarOpposite && n.addClass(e.progressbarOppositeClass), e.clickable && n.on("click", B(e.bulletClass), (function (e) { e.preventDefault(); let n = u(this).index() * t.params.slidesPerGroup; t.params.loop && (n += t.loopedSlides), t.slideTo(n); })), Object.assign(t.pagination, { $el: n, el: n[0] }), t.enabled || n.addClass(e.lockClass)); } function p() { const e = t.params.pagination; if (a()) return; const n = t.pagination.$el; n.removeClass(e.hiddenClass), n.removeClass(e.modifierClass + e.type), n.removeClass(e.modifierClass + t.params.direction), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && n.off("click", B(e.bulletClass)); }n("init", () => { h(), d(), c(); }), n("activeIndexChange", () => { (t.params.loop || void 0 === t.snapIndex) && c(); }), n("snapIndexChange", () => { t.params.loop || c(); }), n("slidesLengthChange", () => { t.params.loop && (d(), c()); }), n("snapGridLengthChange", () => { t.params.loop || (d(), c()); }), n("destroy", () => { p(); }), n("enable disable", () => { const { $el: e } = t.pagination; e && e[t.enabled ? "removeClass" : "addClass"](t.params.pagination.lockClass); }), n("lock unlock", () => { c(); }), n("click", (e, n) => { const i = n.target; const { $el: o } = t.pagination; if (t.params.pagination.el && t.params.pagination.hideOnClick && o.length > 0 && !u(i).hasClass(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && i === t.navigation.nextEl || t.navigation.prevEl && i === t.navigation.prevEl)) return; const e = o.hasClass(t.params.pagination.hiddenClass); r(!0 === e ? "paginationShow" : "paginationHide"), o.toggleClass(t.params.pagination.hiddenClass); } }), Object.assign(t.pagination, {
      render: d, update: c, init: h, destroy: p,
    });
  }, function ({
    swiper: t, extendParams: e, on: n, emit: i,
  }) {
    const o = r(); let s; let a; let l; let c; let h = !1; let p = null; let f = null; function m() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e, rtlTranslate: n, progress: r } = t; const { $dragEl: i, $el: o } = e; const s = t.params.scrollbar; let u = a; let c = (l - a) * r; n ? (c = -c, c > 0 ? (u = a - c, c = 0) : -c + a > l && (u = l + c)) : c < 0 ? (u = a + c, c = 0) : c + a > l && (u = l - c), t.isHorizontal() ? (i.transform(`translate3d(${c}px, 0, 0)`), i[0].style.width = `${u}px`) : (i.transform(`translate3d(0px, ${c}px, 0)`), i[0].style.height = `${u}px`), s.hide && (clearTimeout(p), o[0].style.opacity = 1, p = setTimeout(() => { o[0].style.opacity = 0, o.transition(400); }, 1e3)); } function g() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e } = t; const { $dragEl: n, $el: r } = e; n[0].style.width = "", n[0].style.height = "", l = t.isHorizontal() ? r[0].offsetWidth : r[0].offsetHeight, c = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), a = t.params.scrollbar.dragSize === "auto" ? l * c : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? n[0].style.width = `${a}px` : n[0].style.height = `${a}px`, r[0].style.display = c >= 1 ? "none" : "", t.params.scrollbar.hide && (r[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass); } function v(e) { return t.isHorizontal() ? e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientX : e.clientX : e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientY : e.clientY; } function y(e) { const { scrollbar: n, rtlTranslate: r } = t; const { $el: i } = n; let o; o = (v(e) - i.offset()[t.isHorizontal() ? "left" : "top"] - (s !== null ? s : a / 2)) / (l - a), o = Math.max(Math.min(o, 1), 0), r && (o = 1 - o); const u = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * o; t.updateProgress(u), t.setTranslate(u), t.updateActiveIndex(), t.updateSlidesClasses(); } function _(e) { const n = t.params.scrollbar; const { scrollbar: r, $wrapperEl: o } = t; const { $el: a, $dragEl: l } = r; h = !0, s = e.target === l[0] || e.target === l ? v(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), o.transition(100), l.transition(100), y(e), clearTimeout(f), a.transition(0), n.hide && a.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), i("scrollbarDragStart", e); } function b(e) { const { scrollbar: n, $wrapperEl: r } = t; const { $el: o, $dragEl: s } = n; h && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, y(e), r.transition(0), o.transition(0), s.transition(0), i("scrollbarDragMove", e)); } function w(e) { const n = t.params.scrollbar; const { scrollbar: r, $wrapperEl: o } = t; const { $el: s } = r; h && (h = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), o.transition("")), n.hide && (clearTimeout(f), f = d(() => { s.css("opacity", 0), s.transition(400); }, 1e3)), i("scrollbarDragEnd", e), n.snapOnRelease && t.slideToClosest()); } function x(e) {
      const {
        scrollbar: n, touchEventsTouch: r, touchEventsDesktop: i, params: s, support: a,
      } = t; const l = n.$el[0]; const u = !(!a.passiveListener || !s.passiveListeners) && { passive: !1, capture: !1 }; const c = !(!a.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; if (!l) return; const d = e === "on" ? "addEventListener" : "removeEventListener"; a.touch ? (l[d](r.start, _, u), l[d](r.move, b, u), l[d](r.end, w, c)) : (l[d](i.start, _, u), o[d](i.move, b, u), o[d](i.end, w, c));
    } function S() {
      const { scrollbar: e, $el: n } = t; t.params.scrollbar = z(t, t.originalParams.scrollbar, t.params.scrollbar, { el: "swiper-scrollbar" }); const r = t.params.scrollbar; if (!r.el) return; let i = u(r.el); t.params.uniqueNavElements && typeof r.el === "string" && i.length > 1 && n.find(r.el).length === 1 && (i = n.find(r.el)); let o = i.find(`.${t.params.scrollbar.dragClass}`); o.length === 0 && (o = u(`<div class="${t.params.scrollbar.dragClass}"></div>`), i.append(o)), Object.assign(e, {
        $el: i, el: i[0], $dragEl: o, dragEl: o[0],
      }), r.draggable && t.params.scrollbar.el && x("on"), i && i[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass);
    } function k() { t.params.scrollbar.el && x("off"); }e({
      scrollbar: {
        el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag",
      },
    }), t.scrollbar = {
      el: null, dragEl: null, $el: null, $dragEl: null,
    }, n("init", () => { S(), g(), m(); }), n("update resize observerUpdate lock unlock", () => { g(); }), n("setTranslate", () => { m(); }), n("setTransition", (e, n) => { !(function (e) { t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e); }(n)); }), n("enable disable", () => { const { $el: e } = t.scrollbar; e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass); }), n("destroy", () => { k(); }), Object.assign(t.scrollbar, {
      updateSize: g, setTranslate: m, init: S, destroy: k,
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({ parallax: { enabled: !1 } }); const r = (e, n) => { const { rtl: r } = t; const i = u(e); const o = r ? -1 : 1; const s = i.attr("data-swiper-parallax") || "0"; let a = i.attr("data-swiper-parallax-x"); let l = i.attr("data-swiper-parallax-y"); const c = i.attr("data-swiper-parallax-scale"); const d = i.attr("data-swiper-parallax-opacity"); if (a || l ? (a = a || "0", l = l || "0") : t.isHorizontal() ? (a = s, l = "0") : (l = s, a = "0"), a = a.indexOf("%") >= 0 ? `${parseInt(a, 10) * n * o}%` : `${a * n * o}px`, l = l.indexOf("%") >= 0 ? `${parseInt(l, 10) * n}%` : `${l * n}px`, d != null) { const t = d - (d - 1) * (1 - Math.abs(n)); i[0].style.opacity = t; } if (c == null)i.transform(`translate3d(${a}, ${l}, 0px)`); else { const t = c - (c - 1) * (1 - Math.abs(n)); i.transform(`translate3d(${a}, ${l}, 0px) scale(${t})`); } }; const i = () => {
      const {
        $el: e, slides: n, progress: i, snapGrid: o,
      } = t; e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t) => { r(t, i); }), n.each((e, n) => { let s = e.progress; t.params.slidesPerGroup > 1 && t.params.slidesPerView !== "auto" && (s += Math.ceil(n / 2) - i * (o.length - 1)), s = Math.min(Math.max(s, -1), 1), u(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t) => { r(t, s); }); });
    }; n("beforeInit", () => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0); }), n("init", () => { t.params.parallax.enabled && i(); }), n("setTranslate", () => { t.params.parallax.enabled && i(); }), n("setTransition", (e, n) => { t.params.parallax.enabled && ((e = t.params.speed) => { const { $el: n } = t; n.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t) => { const n = u(t); let r = parseInt(n.attr("data-swiper-parallax-duration"), 10) || e; e === 0 && (r = 0), n.transition(r); }); })(n); });
  }, function ({
    swiper: t, extendParams: e, on: n, emit: r,
  }) {
    const i = o(); e({
      zoom: {
        enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed",
      },
    }), t.zoom = { enabled: !1 }; let s; let a; let l; let c = 1; let d = !1; const h = {
      $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3,
    }; const f = {
      isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {},
    }; const m = {
      x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0,
    }; let g = 1; function v(t) { if (t.targetTouches.length < 2) return 1; const e = t.targetTouches[0].pageX; const n = t.targetTouches[0].pageY; const r = t.targetTouches[1].pageX; const i = t.targetTouches[1].pageY; return Math.sqrt((r - e) ** 2 + (i - n) ** 2); } function y(e) { const n = t.support; const r = t.params.zoom; if (a = !1, l = !1, !n.gestures) { if (e.type !== "touchstart" || e.type === "touchstart" && e.targetTouches.length < 2) return; a = !0, h.scaleStart = v(e); }h.$slideEl && h.$slideEl.length || (h.$slideEl = u(e.target).closest(`.${t.params.slideClass}`), h.$slideEl.length === 0 && (h.$slideEl = t.slides.eq(t.activeIndex)), h.$imageEl = h.$slideEl.find(`.${r.containerClass}`).eq(0).find("img, svg, canvas, picture, .swiper-zoom-target"), h.$imageWrapEl = h.$imageEl.parent(`.${r.containerClass}`), h.maxRatio = h.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio, h.$imageWrapEl.length !== 0) ? (h.$imageEl && h.$imageEl.transition(0), d = !0) : h.$imageEl = void 0; } function _(e) { const n = t.support; const r = t.params.zoom; const i = t.zoom; if (!n.gestures) { if (e.type !== "touchmove" || e.type === "touchmove" && e.targetTouches.length < 2) return; l = !0, h.scaleMove = v(e); }h.$imageEl && h.$imageEl.length !== 0 ? (n.gestures ? i.scale = e.scale * c : i.scale = h.scaleMove / h.scaleStart * c, i.scale > h.maxRatio && (i.scale = h.maxRatio - 1 + (i.scale - h.maxRatio + 1) ** 0.5), i.scale < r.minRatio && (i.scale = r.minRatio + 1 - (r.minRatio - i.scale + 1) ** 0.5), h.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : e.type === "gesturechange" && y(e); } function b(e) { const n = t.device; const r = t.support; const i = t.params.zoom; const o = t.zoom; if (!r.gestures) { if (!a || !l) return; if (e.type !== "touchend" || e.type === "touchend" && e.changedTouches.length < 2 && !n.android) return; a = !1, l = !1; }h.$imageEl && h.$imageEl.length !== 0 && (o.scale = Math.max(Math.min(o.scale, h.maxRatio), i.minRatio), h.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${o.scale})`), c = o.scale, d = !1, o.scale === 1 && (h.$slideEl = void 0)); } function w(e) { const n = t.zoom; if (!h.$imageEl || h.$imageEl.length === 0) return; if (t.allowClick = !1, !f.isTouched || !h.$slideEl) return; f.isMoved || (f.width = h.$imageEl[0].offsetWidth, f.height = h.$imageEl[0].offsetHeight, f.startX = p(h.$imageWrapEl[0], "x") || 0, f.startY = p(h.$imageWrapEl[0], "y") || 0, h.slideWidth = h.$slideEl[0].offsetWidth, h.slideHeight = h.$slideEl[0].offsetHeight, h.$imageWrapEl.transition(0)); const r = f.width * n.scale; const i = f.height * n.scale; if (!(r < h.slideWidth && i < h.slideHeight)) { if (f.minX = Math.min(h.slideWidth / 2 - r / 2, 0), f.maxX = -f.minX, f.minY = Math.min(h.slideHeight / 2 - i / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX, f.touchesCurrent.y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY, !f.isMoved && !d) { if (t.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) return void (f.isTouched = !1); if (!t.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) return void (f.isTouched = !1); }e.cancelable && e.preventDefault(), e.stopPropagation(), f.isMoved = !0, f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX, f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY, f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** 0.8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** 0.8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** 0.8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** 0.8), m.prevPositionX || (m.prevPositionX = f.touchesCurrent.x), m.prevPositionY || (m.prevPositionY = f.touchesCurrent.y), m.prevTime || (m.prevTime = Date.now()), m.x = (f.touchesCurrent.x - m.prevPositionX) / (Date.now() - m.prevTime) / 2, m.y = (f.touchesCurrent.y - m.prevPositionY) / (Date.now() - m.prevTime) / 2, Math.abs(f.touchesCurrent.x - m.prevPositionX) < 2 && (m.x = 0), Math.abs(f.touchesCurrent.y - m.prevPositionY) < 2 && (m.y = 0), m.prevPositionX = f.touchesCurrent.x, m.prevPositionY = f.touchesCurrent.y, m.prevTime = Date.now(), h.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`); } } function x() { const e = t.zoom; h.$slideEl && t.previousIndex !== t.activeIndex && (h.$imageEl && h.$imageEl.transform("translate3d(0,0,0) scale(1)"), h.$imageWrapEl && h.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, c = 1, h.$slideEl = void 0, h.$imageEl = void 0, h.$imageWrapEl = void 0); } function S(e) { const n = t.zoom; const r = t.params.zoom; if (h.$slideEl || (e && e.target && (h.$slideEl = u(e.target).closest(`.${t.params.slideClass}`)), h.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? h.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : h.$slideEl = t.slides.eq(t.activeIndex)), h.$imageEl = h.$slideEl.find(`.${r.containerClass}`).eq(0).find("img, svg, canvas, picture, .swiper-zoom-target"), h.$imageWrapEl = h.$imageEl.parent(`.${r.containerClass}`)), !h.$imageEl || h.$imageEl.length === 0 || !h.$imageWrapEl || h.$imageWrapEl.length === 0) return; let o; let s; let a; let l; let d; let p; let m; let g; let v; let y; let _; let b; let w; let x; let S; let k; let C; let E; t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), h.$slideEl.addClass(`${r.zoomedSlideClass}`), void 0 === f.touchesStart.x && e ? (o = e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX, s = e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY) : (o = f.touchesStart.x, s = f.touchesStart.y), n.scale = h.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio, c = h.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio, e ? (C = h.$slideEl[0].offsetWidth, E = h.$slideEl[0].offsetHeight, a = h.$slideEl.offset().left + i.scrollX, l = h.$slideEl.offset().top + i.scrollY, d = a + C / 2 - o, p = l + E / 2 - s, v = h.$imageEl[0].offsetWidth, y = h.$imageEl[0].offsetHeight, _ = v * n.scale, b = y * n.scale, w = Math.min(C / 2 - _ / 2, 0), x = Math.min(E / 2 - b / 2, 0), S = -w, k = -x, m = d * n.scale, g = p * n.scale, m < w && (m = w), m > S && (m = S), g < x && (g = x), g > k && (g = k)) : (m = 0, g = 0), h.$imageWrapEl.transition(300).transform(`translate3d(${m}px, ${g}px,0)`), h.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${n.scale})`); } function k() { const e = t.zoom; const n = t.params.zoom; h.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? h.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : h.$slideEl = t.slides.eq(t.activeIndex), h.$imageEl = h.$slideEl.find(`.${n.containerClass}`).eq(0).find("img, svg, canvas, picture, .swiper-zoom-target"), h.$imageWrapEl = h.$imageEl.parent(`.${n.containerClass}`)), h.$imageEl && h.$imageEl.length !== 0 && h.$imageWrapEl && h.$imageWrapEl.length !== 0 && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, c = 1, h.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), h.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), h.$slideEl.removeClass(`${n.zoomedSlideClass}`), h.$slideEl = void 0); } function C(e) { const n = t.zoom; n.scale && n.scale !== 1 ? k() : S(e); } function E() { const e = t.support; return { passiveListener: !(t.touchEvents.start !== "touchstart" || !e.passiveListener || !t.params.passiveListeners) && { passive: !0, capture: !1 }, activeListenerWithCapture: !e.passiveListener || { passive: !1, capture: !0 } }; } function T() { return `.${t.params.slideClass}`; } function P(e) { const { passiveListener: n } = E(); const r = T(); t.$wrapperEl[e]("gesturestart", r, y, n), t.$wrapperEl[e]("gesturechange", r, _, n), t.$wrapperEl[e]("gestureend", r, b, n); } function O() { s || (s = !0, P("on")); } function A() { s && (s = !1, P("off")); } function M() { const e = t.zoom; if (e.enabled) return; e.enabled = !0; const n = t.support; const { passiveListener: r, activeListenerWithCapture: i } = E(); const o = T(); n.gestures ? (t.$wrapperEl.on(t.touchEvents.start, O, r), t.$wrapperEl.on(t.touchEvents.end, A, r)) : t.touchEvents.start === "touchstart" && (t.$wrapperEl.on(t.touchEvents.start, o, y, r), t.$wrapperEl.on(t.touchEvents.move, o, _, i), t.$wrapperEl.on(t.touchEvents.end, o, b, r), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, o, b, r)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, w, i); } function L() { const e = t.zoom; if (!e.enabled) return; const n = t.support; e.enabled = !1; const { passiveListener: r, activeListenerWithCapture: i } = E(); const o = T(); n.gestures ? (t.$wrapperEl.off(t.touchEvents.start, O, r), t.$wrapperEl.off(t.touchEvents.end, A, r)) : t.touchEvents.start === "touchstart" && (t.$wrapperEl.off(t.touchEvents.start, o, y, r), t.$wrapperEl.off(t.touchEvents.move, o, _, i), t.$wrapperEl.off(t.touchEvents.end, o, b, r), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, o, b, r)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, w, i); }Object.defineProperty(t.zoom, "scale", { get: () => g, set(t) { if (g !== t) { const e = h.$imageEl ? h.$imageEl[0] : void 0; const n = h.$slideEl ? h.$slideEl[0] : void 0; r("zoomChange", t, e, n); }g = t; } }), n("init", () => { t.params.zoom.enabled && M(); }), n("destroy", () => { L(); }), n("touchStart", (e, n) => { t.zoom.enabled && (function (e) { const n = t.device; h.$imageEl && h.$imageEl.length !== 0 && (f.isTouched || (n.android && e.cancelable && e.preventDefault(), f.isTouched = !0, f.touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX, f.touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY)); }(n)); }), n("touchEnd", (e, n) => { t.zoom.enabled && (function () { const e = t.zoom; if (!h.$imageEl || h.$imageEl.length === 0) return; if (!f.isTouched || !f.isMoved) return f.isTouched = !1, void (f.isMoved = !1); f.isTouched = !1, f.isMoved = !1; let n = 300; let r = 300; const i = m.x * n; const o = f.currentX + i; const s = m.y * r; const a = f.currentY + s; m.x !== 0 && (n = Math.abs((o - f.currentX) / m.x)), m.y !== 0 && (r = Math.abs((a - f.currentY) / m.y)); const l = Math.max(n, r); f.currentX = o, f.currentY = a; const u = f.width * e.scale; const c = f.height * e.scale; f.minX = Math.min(h.slideWidth / 2 - u / 2, 0), f.maxX = -f.minX, f.minY = Math.min(h.slideHeight / 2 - c / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), h.$imageWrapEl.transition(l).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`); }()); }), n("doubleTap", (e, n) => { !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && C(n); }), n("transitionEnd", () => { t.zoom.enabled && t.params.zoom.enabled && x(); }), n("slideChange", () => { t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && x(); }), Object.assign(t.zoom, {
      enable: M, disable: L, in: S, out: k, toggle: C,
    });
  }, function ({
    swiper: t, extendParams: e, on: n, emit: r,
  }) {
    e({
      lazy: {
        checkInView: !1, enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, scrollingElement: "", elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader",
      },
    }), t.lazy = {}; let i = !1; let s = !1; function a(e, n = !0) { const i = t.params.lazy; if (void 0 === e) return; if (t.slides.length === 0) return; const o = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`) : t.slides.eq(e); const s = o.find(`.${i.elementClass}:not(.${i.loadedClass}):not(.${i.loadingClass})`); !o.hasClass(i.elementClass) || o.hasClass(i.loadedClass) || o.hasClass(i.loadingClass) || s.push(o[0]), s.length !== 0 && s.each((e) => { const s = u(e); s.addClass(i.loadingClass); const l = s.attr("data-background"); const c = s.attr("data-src"); const d = s.attr("data-srcset"); const h = s.attr("data-sizes"); const p = s.parent("picture"); t.loadImage(s[0], c || l, d, h, !1, () => { if (t != null && t && (!t || t.params) && !t.destroyed) { if (l ? (s.css("background-image", `url("${l}")`), s.removeAttr("data-background")) : (d && (s.attr("srcset", d), s.removeAttr("data-srcset")), h && (s.attr("sizes", h), s.removeAttr("data-sizes")), p.length && p.children("source").each((t) => { const e = u(t); e.attr("data-srcset") && (e.attr("srcset", e.attr("data-srcset")), e.removeAttr("data-srcset")); }), c && (s.attr("src", c), s.removeAttr("data-src"))), s.addClass(i.loadedClass).removeClass(i.loadingClass), o.find(`.${i.preloaderClass}`).remove(), t.params.loop && n) { const e = o.attr("data-swiper-slide-index"); o.hasClass(t.params.slideDuplicateClass) ? a(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(), !1) : a(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(), !1); }r("lazyImageReady", o[0], s[0]), t.params.autoHeight && t.updateAutoHeight(); } }), r("lazyImageLoad", o[0], s[0]); }); } function l() {
      const {
        $wrapperEl: e, params: n, slides: r, activeIndex: i,
      } = t; const o = t.virtual && n.virtual.enabled; const l = n.lazy; let c = n.slidesPerView; function d(t) { if (o) { if (e.children(`.${n.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0; } else if (r[t]) return !0; return !1; } function h(t) { return o ? u(t).attr("data-swiper-slide-index") : u(t).index(); } if (c === "auto" && (c = 0), s || (s = !0), t.params.watchSlidesProgress)e.children(`.${n.slideVisibleClass}`).each((t) => { a(o ? u(t).attr("data-swiper-slide-index") : u(t).index()); }); else if (c > 1) for (let t = i; t < i + c; t += 1)d(t) && a(t); else a(i); if (l.loadPrevNext) if (c > 1 || l.loadPrevNextAmount && l.loadPrevNextAmount > 1) { const t = l.loadPrevNextAmount; const e = c; const n = Math.min(i + e + Math.max(t, e), r.length); const o = Math.max(i - Math.max(e, t), 0); for (let t = i + c; t < n; t += 1)d(t) && a(t); for (let t = o; t < i; t += 1)d(t) && a(t); } else { const t = e.children(`.${n.slideNextClass}`); t.length > 0 && a(h(t)); const r = e.children(`.${n.slidePrevClass}`); r.length > 0 && a(h(r)); }
    } function c() { const e = o(); if (!t || t.destroyed) return; const n = t.params.lazy.scrollingElement ? u(t.params.lazy.scrollingElement) : u(e); const r = n[0] === e; const s = r ? e.innerWidth : n[0].offsetWidth; const a = r ? e.innerHeight : n[0].offsetHeight; const d = t.$el.offset(); const { rtlTranslate: h } = t; let p = !1; h && (d.left -= t.$el[0].scrollLeft); const f = [[d.left, d.top], [d.left + t.width, d.top], [d.left, d.top + t.height], [d.left + t.width, d.top + t.height]]; for (let t = 0; t < f.length; t += 1) { const e = f[t]; if (e[0] >= 0 && e[0] <= s && e[1] >= 0 && e[1] <= a) { if (e[0] === 0 && e[1] === 0) continue; p = !0; } } const m = !(t.touchEvents.start !== "touchstart" || !t.support.passiveListener || !t.params.passiveListeners) && { passive: !0, capture: !1 }; p ? (l(), n.off("scroll", c, m)) : i || (i = !0, n.on("scroll", c, m)); }n("beforeInit", () => { t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1); }), n("init", () => { t.params.lazy.enabled && (t.params.lazy.checkInView ? c() : l()); }), n("scroll", () => { t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && l(); }), n("scrollbarDragMove resize _freeModeNoMomentumRelease", () => { t.params.lazy.enabled && (t.params.lazy.checkInView ? c() : l()); }), n("transitionStart", () => { t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !s) && (t.params.lazy.checkInView ? c() : l()); }), n("transitionEnd", () => { t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? c() : l()); }), n("slideChange", () => {
      const {
        lazy: e, cssMode: n, watchSlidesProgress: r, touchReleaseOnEdges: i, resistanceRatio: o,
      } = t.params; e.enabled && (n || r && (i || o === 0)) && l();
    }), Object.assign(t.lazy, { load: l, loadInSlide: a });
  }, function ({ swiper: t, extendParams: e, on: n }) { function r(t, e) { const n = (function () { let t; let e; let n; return (r, i) => { for (e = -1, t = r.length; t - e > 1;)n = t + e >> 1, r[n] <= i ? e = n : t = n; return t; }; }()); let r; let i; return this.x = t, this.y = e, this.lastIndex = t.length - 1, this.interpolate = function (t) { return t ? (i = n(this.x, t), r = i - 1, (t - this.x[r]) * (this.y[i] - this.y[r]) / (this.x[i] - this.x[r]) + this.y[r]) : 0; }, this; } function i() { t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline); }e({ controller: { control: void 0, inverse: !1, by: "slide" } }), t.controller = { control: void 0 }, n("beforeInit", () => { t.controller.control = t.params.controller.control; }), n("update", () => { i(); }), n("resize", () => { i(); }), n("observerUpdate", () => { i(); }), n("setTranslate", (e, n, r) => { t.controller.control && t.controller.setTranslate(n, r); }), n("setTransition", (e, n, r) => { t.controller.control && t.controller.setTransition(n, r); }), Object.assign(t.controller, { setTranslate(e, n) { const i = t.controller.control; let o; let s; const a = t.constructor; function l(e) { const n = t.rtlTranslate ? -t.translate : t.translate; t.params.controller.by === "slide" && ((function (e) { t.controller.spline || (t.controller.spline = t.params.loop ? new r(t.slidesGrid, e.slidesGrid) : new r(t.snapGrid, e.snapGrid)); }(e)), s = -t.controller.spline.interpolate(-n)), s && t.params.controller.by !== "container" || (o = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), s = (n - t.minTranslate()) * o + e.minTranslate()), t.params.controller.inverse && (s = e.maxTranslate() - s), e.updateProgress(s), e.setTranslate(s, t), e.updateActiveIndex(), e.updateSlidesClasses(); } if (Array.isArray(i)) for (let t = 0; t < i.length; t += 1)i[t] !== n && i[t] instanceof a && l(i[t]); else i instanceof a && n !== i && l(i); }, setTransition(e, n) { const r = t.constructor; const i = t.controller.control; let o; function s(n) { n.setTransition(e, t), e !== 0 && (n.transitionStart(), n.params.autoHeight && d(() => { n.updateAutoHeight(); }), n.$wrapperEl.transitionEnd(() => { i && (n.params.loop && t.params.controller.by === "slide" && n.loopFix(), n.transitionEnd()); })); } if (Array.isArray(i)) for (o = 0; o < i.length; o += 1)i[o] !== n && i[o] instanceof r && s(i[o]); else i instanceof r && n !== i && s(i); } }); }, function ({ swiper: t, extendParams: e, on: n }) {
    e({
      a11y: {
        enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group",
      },
    }); let r = null; function i(t) { const e = r; e.length !== 0 && (e.html(""), e.html(t)); } function o(t) { t.attr("tabIndex", "0"); } function s(t) { t.attr("tabIndex", "-1"); } function a(t, e) { t.attr("role", e); } function l(t, e) { t.attr("aria-roledescription", e); } function c(t, e) { t.attr("aria-label", e); } function d(t) { t.attr("aria-disabled", !0); } function h(t) { t.attr("aria-disabled", !1); } function p(e) { if (e.keyCode !== 13 && e.keyCode !== 32) return; const n = t.params.a11y; const r = u(e.target); t.navigation && t.navigation.$nextEl && r.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? i(n.lastSlideMessage) : i(n.nextSlideMessage)), t.navigation && t.navigation.$prevEl && r.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? i(n.firstSlideMessage) : i(n.prevSlideMessage)), t.pagination && r.is(B(t.params.pagination.bulletClass)) && r[0].click(); } function f() { if (t.params.loop || !t.navigation) return; const { $nextEl: e, $prevEl: n } = t.navigation; n && n.length > 0 && (t.isBeginning ? (d(n), s(n)) : (h(n), o(n))), e && e.length > 0 && (t.isEnd ? (d(e), s(e)) : (h(e), o(e))); } function m() { return t.pagination && t.params.pagination.clickable && t.pagination.bullets && t.pagination.bullets.length; } const g = (t, e, n) => { o(t), t[0].tagName !== "BUTTON" && (a(t, "button"), t.on("keydown", p)), c(t, n), (function (t, e) { t.attr("aria-controls", e); }(t, e)); }; n("beforeInit", () => { r = u(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`); }), n("afterInit", () => { t.params.a11y.enabled && ((function () { const e = t.params.a11y; t.$el.append(r); const n = t.$el; e.containerRoleDescriptionMessage && l(n, e.containerRoleDescriptionMessage), e.containerMessage && c(n, e.containerMessage); const i = t.$wrapperEl; const o = i.attr("id") || `swiper-wrapper-${(function (t = 16) { return "x".repeat(t).replace(/x/g, () => Math.round(16 * Math.random()).toString(16)); }(16))}`; const s = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite"; let d; d = o, i.attr("id", d), (function (t, e) { t.attr("aria-live", e); }(i, s)), e.itemRoleDescriptionMessage && l(u(t.slides), e.itemRoleDescriptionMessage), a(u(t.slides), e.slideRole); const h = t.params.loop ? t.slides.filter((e) => !e.classList.contains(t.params.slideDuplicateClass)).length : t.slides.length; let f; let v; t.slides.each((n, r) => { const i = u(n); const o = t.params.loop ? parseInt(i.attr("data-swiper-slide-index"), 10) : r; c(i, e.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, h)); }), t.navigation && t.navigation.$nextEl && (f = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (v = t.navigation.$prevEl), f && f.length && g(f, o, e.nextSlideMessage), v && v.length && g(v, o, e.prevSlideMessage), m() && t.pagination.$el.on("keydown", B(t.params.pagination.bulletClass), p); }()), f()); }), n("toEdge", () => { t.params.a11y.enabled && f(); }), n("fromEdge", () => { t.params.a11y.enabled && f(); }), n("paginationUpdate", () => { t.params.a11y.enabled && (function () { const e = t.params.a11y; m() && t.pagination.bullets.each((n) => { const r = u(n); o(r), t.params.pagination.renderBullet || (a(r, "button"), c(r, e.paginationBulletMessage.replace(/\{\{index\}\}/, r.index() + 1))); }); }()); }), n("destroy", () => { t.params.a11y.enabled && (function () { let e; let n; r && r.length > 0 && r.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (n = t.navigation.$prevEl), e && e.off("keydown", p), n && n.off("keydown", p), m() && t.pagination.$el.off("keydown", B(t.params.pagination.bulletClass), p); }()); });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({
      history: {
        enabled: !1, root: "", replaceState: !1, key: "slides",
      },
    }); let r = !1; let i = {}; const s = (t) => t.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-")
      .replace(/^-+/, "")
      .replace(/-+$/, ""); const a = (t) => { const e = o(); let n; n = t ? new URL(t) : e.location; const r = n.pathname.slice(1).split("/").filter((t) => t !== ""); const i = r.length; return { key: r[i - 2], value: r[i - 1] }; }; const l = (e, n) => { const i = o(); if (!r || !t.params.history.enabled) return; let a; a = t.params.url ? new URL(t.params.url) : i.location; const l = t.slides.eq(n); let u = s(l.attr("data-history")); if (t.params.history.root.length > 0) { let n = t.params.history.root; n[n.length - 1] === "/" && (n = n.slice(0, n.length - 1)), u = `${n}/${e}/${u}`; } else a.pathname.includes(e) || (u = `${e}/${u}`); const c = i.history.state; c && c.value === u || (t.params.history.replaceState ? i.history.replaceState({ value: u }, null, u) : i.history.pushState({ value: u }, null, u)); }; const u = (e, n, r) => { if (n) for (let i = 0, o = t.slides.length; i < o; i += 1) { const o = t.slides.eq(i); if (s(o.attr("data-history")) === n && !o.hasClass(t.params.slideDuplicateClass)) { const n = o.index(); t.slideTo(n, e, r); } } else t.slideTo(0, e, r); }; const c = () => { i = a(t.params.url), u(t.params.speed, t.paths.value, !1); }; n("init", () => { t.params.history.enabled && (() => { const e = o(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); r = !0, i = a(t.params.url), (i.key || i.value) && (u(0, i.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", c)); } })(); }), n("destroy", () => { t.params.history.enabled && (() => { const e = o(); t.params.history.replaceState || e.removeEventListener("popstate", c); })(); }), n("transitionEnd _freeModeNoMomentumRelease", () => { r && l(t.params.history.key, t.activeIndex); }), n("slideChange", () => { r && t.params.cssMode && l(t.params.history.key, t.activeIndex); });
  }, function ({
    swiper: t, extendParams: e, emit: n, on: i,
  }) { let s = !1; const a = r(); const l = o(); e({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }); const c = () => { n("hashChange"); const e = a.location.hash.replace("#", ""); if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) { const n = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index(); if (void 0 === n) return; t.slideTo(n); } }; const d = () => { if (s && t.params.hashNavigation.enabled) if (t.params.hashNavigation.replaceState && l.history && l.history.replaceState)l.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr("data-hash")}` || ""), n("hashSet"); else { const e = t.slides.eq(t.activeIndex); const r = e.attr("data-hash") || e.attr("data-history"); a.location.hash = r || "", n("hashSet"); } }; i("init", () => { t.params.hashNavigation.enabled && (() => { if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return; s = !0; const e = a.location.hash.replace("#", ""); if (e) { const n = 0; for (let r = 0, i = t.slides.length; r < i; r += 1) { const i = t.slides.eq(r); if ((i.attr("data-hash") || i.attr("data-history")) === e && !i.hasClass(t.params.slideDuplicateClass)) { const e = i.index(); t.slideTo(e, n, t.params.runCallbacksOnInit, !0); } } }t.params.hashNavigation.watchState && u(l).on("hashchange", c); })(); }), i("destroy", () => { t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && u(l).off("hashchange", c); }), i("transitionEnd _freeModeNoMomentumRelease", () => { s && d(); }), i("slideChange", () => { s && t.params.cssMode && d(); }); }, function ({
    swiper: t, extendParams: e, on: n, emit: i,
  }) {
    let o; function s() { const e = t.slides.eq(t.activeIndex); let n = t.params.autoplay.delay; e.attr("data-swiper-autoplay") && (n = e.attr("data-swiper-autoplay") || t.params.autoplay.delay), clearTimeout(o), o = d(() => { let e; t.params.autoplay.reverseDirection ? t.params.loop ? (t.loopFix(), e = t.slidePrev(t.params.speed, !0, !0), i("autoplay")) : t.isBeginning ? t.params.autoplay.stopOnLastSlide ? l() : (e = t.slideTo(t.slides.length - 1, t.params.speed, !0, !0), i("autoplay")) : (e = t.slidePrev(t.params.speed, !0, !0), i("autoplay")) : t.params.loop ? (t.loopFix(), e = t.slideNext(t.params.speed, !0, !0), i("autoplay")) : t.isEnd ? t.params.autoplay.stopOnLastSlide ? l() : (e = t.slideTo(0, t.params.speed, !0, !0), i("autoplay")) : (e = t.slideNext(t.params.speed, !0, !0), i("autoplay")), (t.params.cssMode && t.autoplay.running || !1 === e) && s(); }, n); } function a() { return void 0 === o && !t.autoplay.running && (t.autoplay.running = !0, i("autoplayStart"), s(), !0); } function l() { return !!t.autoplay.running && void 0 !== o && (o && (clearTimeout(o), o = void 0), t.autoplay.running = !1, i("autoplayStop"), !0); } function u(e) { t.autoplay.running && (t.autoplay.paused || (o && clearTimeout(o), t.autoplay.paused = !0, e !== 0 && t.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e) => { t.$wrapperEl[0].addEventListener(e, h); }) : (t.autoplay.paused = !1, s()))); } function c() { const e = r(); e.visibilityState === "hidden" && t.autoplay.running && u(), e.visibilityState === "visible" && t.autoplay.paused && (s(), t.autoplay.paused = !1); } function h(e) { t && !t.destroyed && t.$wrapperEl && e.target === t.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e) => { t.$wrapperEl[0].removeEventListener(e, h); }), t.autoplay.paused = !1, t.autoplay.running ? s() : l()); } function p() { t.params.autoplay.disableOnInteraction ? l() : u(), ["transitionend", "webkitTransitionEnd"].forEach((e) => { t.$wrapperEl[0].removeEventListener(e, h); }); } function f() { t.params.autoplay.disableOnInteraction || (t.autoplay.paused = !1, s()); }t.autoplay = { running: !1, paused: !1 }, e({
      autoplay: {
        enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1,
      },
    }), n("init", () => { t.params.autoplay.enabled && (a(), r().addEventListener("visibilitychange", c), t.params.autoplay.pauseOnMouseEnter && (t.$el.on("mouseenter", p), t.$el.on("mouseleave", f))); }), n("beforeTransitionStart", (e, n, r) => { t.autoplay.running && (r || !t.params.autoplay.disableOnInteraction ? t.autoplay.pause(n) : l()); }), n("sliderFirstMove", () => { t.autoplay.running && (t.params.autoplay.disableOnInteraction ? l() : u()); }), n("touchEnd", () => { t.params.cssMode && t.autoplay.paused && !t.params.autoplay.disableOnInteraction && s(); }), n("destroy", () => { t.$el.off("mouseenter", p), t.$el.off("mouseleave", f), t.autoplay.running && l(), r().removeEventListener("visibilitychange", c); }), Object.assign(t.autoplay, {
      pause: u, run: s, start: a, stop: l,
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({
      thumbs: {
        swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs",
      },
    }); let r = !1; let i = !1; function o() { const e = t.thumbs.swiper; if (!e) return; const n = e.clickedIndex; const r = e.clickedSlide; if (r && u(r).hasClass(t.params.thumbs.slideThumbActiveClass)) return; if (n == null) return; let i; if (i = e.params.loop ? parseInt(u(e.clickedSlide).attr("data-swiper-slide-index"), 10) : n, t.params.loop) { let e = t.activeIndex; t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex); const n = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(); const r = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(); i = void 0 === n ? r : void 0 === r ? n : r - e < e - n ? r : n; }t.slideTo(i); } function s() { const { thumbs: e } = t.params; if (r) return !1; r = !0; const n = t.constructor; if (e.swiper instanceof n)t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (f(e.swiper)) { const r = { ...e.swiper }; Object.assign(r, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new n(r), i = !0; } return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", o), !0; } function a(e) { const n = t.thumbs.swiper; if (!n) return; const r = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : n.params.slidesPerView; const i = t.params.thumbs.autoScrollOffset; const o = i && !n.params.loop; if (t.realIndex !== n.realIndex || o) { let s; let a; let l = n.activeIndex; if (n.params.loop) { n.slides.eq(l).hasClass(n.params.slideDuplicateClass) && (n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft, l = n.activeIndex); const e = n.slides.eq(l).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); const r = n.slides.eq(l).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); s = void 0 === e ? r : void 0 === r ? e : r - l == l - e ? n.params.slidesPerGroup > 1 ? r : l : r - l < l - e ? r : e, a = t.activeIndex > t.previousIndex ? "next" : "prev"; } else s = t.realIndex, a = s > t.previousIndex ? "next" : "prev"; o && (s += a === "next" ? i : -1 * i), n.visibleSlidesIndexes && n.visibleSlidesIndexes.indexOf(s) < 0 && (n.params.centeredSlides ? s = s > l ? s - Math.floor(r / 2) + 1 : s + Math.floor(r / 2) - 1 : s > l && n.params.slidesPerGroup, n.slideTo(s, e ? 0 : void 0)); } let s = 1; const a = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (s = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (s = 1), s = Math.floor(s), n.slides.removeClass(a), n.params.loop || n.params.virtual && n.params.virtual.enabled) for (let e = 0; e < s; e += 1)n.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(a); else for (let e = 0; e < s; e += 1)n.slides.eq(t.realIndex + e).addClass(a); }t.thumbs = { swiper: null }, n("beforeInit", () => { const { thumbs: e } = t.params; e && e.swiper && (s(), a(!0)); }), n("slideChange update resize observerUpdate", () => { t.thumbs.swiper && a(); }), n("setTransition", (e, n) => { const r = t.thumbs.swiper; r && r.setTransition(n); }), n("beforeDestroy", () => { const e = t.thumbs.swiper; e && i && e && e.destroy(); }), Object.assign(t.thumbs, { init: s, update: a });
  }, function ({
    swiper: t, extendParams: e, emit: n, once: r,
  }) {
    e({
      freeMode: {
        enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: 0.02,
      },
    }), Object.assign(t, {
      freeMode: {
        onTouchMove() { const { touchEventsData: e, touches: n } = t; e.velocities.length === 0 && e.velocities.push({ position: n[t.isHorizontal() ? "startX" : "startY"], time: e.touchStartTime }), e.velocities.push({ position: n[t.isHorizontal() ? "currentX" : "currentY"], time: h() }); },
        onTouchEnd({ currentPos: e }) {
          const {
            params: i, $wrapperEl: o, rtlTranslate: s, snapGrid: a, touchEventsData: l,
          } = t; const u = h() - l.touchStartTime; if (e < -t.minTranslate())t.slideTo(t.activeIndex); else if (e > -t.maxTranslate())t.slides.length < a.length ? t.slideTo(a.length - 1) : t.slideTo(t.slides.length - 1); else { if (i.freeMode.momentum) { if (l.velocities.length > 1) { const e = l.velocities.pop(); const n = l.velocities.pop(); const r = e.position - n.position; const o = e.time - n.time; t.velocity = r / o, t.velocity /= 2, Math.abs(t.velocity) < i.freeMode.minimumVelocity && (t.velocity = 0), (o > 150 || h() - e.time > 300) && (t.velocity = 0); } else t.velocity = 0; t.velocity *= i.freeMode.momentumVelocityRatio, l.velocities.length = 0; let e = 1e3 * i.freeMode.momentumRatio; const u = t.velocity * e; let c = t.translate + u; s && (c = -c); let d; let p = !1; const f = 20 * Math.abs(t.velocity) * i.freeMode.momentumBounceRatio; let m; if (c < t.maxTranslate())i.freeMode.momentumBounce ? (c + t.maxTranslate() < -f && (c = t.maxTranslate() - f), d = t.maxTranslate(), p = !0, l.allowMomentumBounce = !0) : c = t.maxTranslate(), i.loop && i.centeredSlides && (m = !0); else if (c > t.minTranslate())i.freeMode.momentumBounce ? (c - t.minTranslate() > f && (c = t.minTranslate() + f), d = t.minTranslate(), p = !0, l.allowMomentumBounce = !0) : c = t.minTranslate(), i.loop && i.centeredSlides && (m = !0); else if (i.freeMode.sticky) { let e; for (let t = 0; t < a.length; t += 1) if (a[t] > -c) { e = t; break; }c = Math.abs(a[e] - c) < Math.abs(a[e - 1] - c) || t.swipeDirection === "next" ? a[e] : a[e - 1], c = -c; } if (m && r("transitionEnd", () => { t.loopFix(); }), t.velocity !== 0) { if (e = s ? Math.abs((-c - t.translate) / t.velocity) : Math.abs((c - t.translate) / t.velocity), i.freeMode.sticky) { const n = Math.abs((s ? -c : c) - t.translate); const r = t.slidesSizesGrid[t.activeIndex]; e = n < r ? i.speed : n < 2 * r ? 1.5 * i.speed : 2.5 * i.speed; } } else if (i.freeMode.sticky) return void t.slideToClosest(); i.freeMode.momentumBounce && p ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating = !0, o.transitionEnd(() => { t && !t.destroyed && l.allowMomentumBounce && (n("momentumBounce"), t.setTransition(i.speed), setTimeout(() => { t.setTranslate(d), o.transitionEnd(() => { t && !t.destroyed && t.transitionEnd(); }); }, 0)); })) : t.velocity ? (n("_freeModeNoMomentumRelease"), t.updateProgress(c), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, o.transitionEnd(() => { t && !t.destroyed && t.transitionEnd(); }))) : t.updateProgress(c), t.updateActiveIndex(), t.updateSlidesClasses(); } else { if (i.freeMode.sticky) return void t.slideToClosest(); i.freeMode && n("_freeModeNoMomentumRelease"); }(!i.freeMode.momentum || u >= i.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()); }
        },
      },
    });
  }, function ({ swiper: t, extendParams: e }) { let n; let r; let i; e({ grid: { rows: 1, fill: "column" } }), t.grid = { initSlides: (e) => { const { slidesPerView: o } = t.params; const { rows: s, fill: a } = t.params.grid; r = n / s, i = Math.floor(e / s), n = Math.floor(e / s) === e / s ? e : Math.ceil(e / s) * s, o !== "auto" && a === "row" && (n = Math.max(n, o * s)); }, updateSlide: (e, o, s, a) => { const { slidesPerGroup: l, spaceBetween: u } = t.params; const { rows: c, fill: d } = t.params.grid; let h; let p; let f; if (d === "row" && l > 1) { const t = Math.floor(e / (l * c)); const r = e - c * l * t; const i = t === 0 ? l : Math.min(Math.ceil((s - t * c * l) / c), l); f = Math.floor(r / i), p = r - f * i + t * l, h = p + f * n / c, o.css({ "-webkit-order": h, order: h }); } else d === "column" ? (p = Math.floor(e / c), f = e - p * c, (p > i || p === i && f === c - 1) && (f += 1, f >= c && (f = 0, p += 1))) : (f = Math.floor(e / r), p = e - f * r); o.css(a("margin-top"), f !== 0 ? u && `${u}px` : ""); }, updateWrapperSize: (e, r, i) => { const { spaceBetween: o, centeredSlides: s, roundLengths: a } = t.params; const { rows: l } = t.params.grid; if (t.virtualSize = (e + o) * n, t.virtualSize = Math.ceil(t.virtualSize / l) - o, t.$wrapperEl.css({ [i("width")]: `${t.virtualSize + o}px` }), s) { r.splice(0, r.length); const e = []; for (let n = 0; n < r.length; n += 1) { let i = r[n]; a && (i = Math.floor(i)), r[n] < t.virtualSize + r[0] && e.push(i); }r.push(...e); } } }; }, function ({ swiper: t }) {
    Object.assign(t, {
      appendSlide: q.bind(t), prependSlide: H.bind(t), addSlide: $.bind(t), removeSlide: U.bind(t), removeAllSlides: W.bind(t),
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({ fadeEffect: { crossFade: !1, transformEl: null } }), G({
      effect: "fade",
      swiper: t,
      on: n,
      setTranslate: () => { const { slides: e } = t; const n = t.params.fadeEffect; for (let r = 0; r < e.length; r += 1) { const e = t.slides.eq(r); let i = -e[0].swiperSlideOffset; t.params.virtualTranslate || (i -= t.translate); let o = 0; t.isHorizontal() || (o = i, i = 0); const s = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0); Y(n, e).css({ opacity: s }).transform(`translate3d(${i}px, ${o}px, 0px)`); } },
      setTransition: (e) => {
        const { transformEl: n } = t.params.fadeEffect; (n ? t.slides.find(n) : t.slides).transition(e), Z({
          swiper: t, duration: e, transformEl: n, allSlides: !0,
        });
      },
      overwriteParams: () => ({
        slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode,
      }),
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({
      cubeEffect: {
        slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94,
      },
    }), G({
      effect: "cube",
      swiper: t,
      on: n,
      setTranslate: () => {
        const {
          $el: e, $wrapperEl: n, slides: r, width: i, height: o, rtlTranslate: s, size: a, browser: l,
        } = t; const c = t.params.cubeEffect; const d = t.isHorizontal(); const h = t.virtual && t.params.virtual.enabled; let p; let f = 0; c.shadow && (d ? (p = n.find(".swiper-cube-shadow"), p.length === 0 && (p = u('<div class="swiper-cube-shadow"></div>'), n.append(p)), p.css({ height: `${i}px` })) : (p = e.find(".swiper-cube-shadow"), p.length === 0 && (p = u('<div class="swiper-cube-shadow"></div>'), e.append(p)))); for (let t = 0; t < r.length; t += 1) { const e = r.eq(t); let n = t; h && (n = parseInt(e.attr("data-swiper-slide-index"), 10)); let i = 90 * n; let o = Math.floor(i / 360); s && (i = -i, o = Math.floor(-i / 360)); const l = Math.max(Math.min(e[0].progress, 1), -1); let p = 0; let m = 0; let g = 0; n % 4 == 0 ? (p = 4 * -o * a, g = 0) : (n - 1) % 4 == 0 ? (p = 0, g = 4 * -o * a) : (n - 2) % 4 == 0 ? (p = a + 4 * o * a, g = a) : (n - 3) % 4 == 0 && (p = -a, g = 3 * a + 4 * a * o), s && (p = -p), d || (m = p, p = 0); const v = `rotateX(${d ? 0 : -i}deg) rotateY(${d ? i : 0}deg) translate3d(${p}px, ${m}px, ${g}px)`; if (l <= 1 && l > -1 && (f = 90 * n + 90 * l, s && (f = 90 * -n - 90 * l)), e.transform(v), c.slideShadows) { let t = d ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"); let n = d ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); t.length === 0 && (t = u(`<div class="swiper-slide-shadow-${d ? "left" : "top"}"></div>`), e.append(t)), n.length === 0 && (n = u(`<div class="swiper-slide-shadow-${d ? "right" : "bottom"}"></div>`), e.append(n)), t.length && (t[0].style.opacity = Math.max(-l, 0)), n.length && (n[0].style.opacity = Math.max(l, 0)); } } if (n.css({ "-webkit-transform-origin": `50% 50% -${a / 2}px`, "transform-origin": `50% 50% -${a / 2}px` }), c.shadow) if (d)p.transform(`translate3d(0px, ${i / 2 + c.shadowOffset}px, ${-i / 2}px) rotateX(90deg) rotateZ(0deg) scale(${c.shadowScale})`); else { const t = Math.abs(f) - 90 * Math.floor(Math.abs(f) / 90); const e = 1.5 - (Math.sin(2 * t * Math.PI / 360) / 2 + Math.cos(2 * t * Math.PI / 360) / 2); const n = c.shadowScale; const r = c.shadowScale / e; const i = c.shadowOffset; p.transform(`scale3d(${n}, 1, ${r}) translate3d(0px, ${o / 2 + i}px, ${-o / 2 / r}px) rotateX(-90deg)`); } const m = l.isSafari || l.isWebView ? -a / 2 : 0; n.transform(`translate3d(0px,0,${m}px) rotateX(${t.isHorizontal() ? 0 : f}deg) rotateY(${t.isHorizontal() ? -f : 0}deg)`);
      },
      setTransition: (e) => { const { $el: n, slides: r } = t; r.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && n.find(".swiper-cube-shadow").transition(e); },
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0,
      }),
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({ flipEffect: { slideShadows: !0, limitRotation: !0, transformEl: null } }), G({
      effect: "flip",
      swiper: t,
      on: n,
      setTranslate: () => { const { slides: e, rtlTranslate: n } = t; const r = t.params.flipEffect; for (let i = 0; i < e.length; i += 1) { const o = e.eq(i); let s = o[0].progress; t.params.flipEffect.limitRotation && (s = Math.max(Math.min(o[0].progress, 1), -1)); const a = o[0].swiperSlideOffset; let l = -180 * s; let u = 0; let c = t.params.cssMode ? -a - t.translate : -a; let d = 0; if (t.isHorizontal() ? n && (l = -l) : (d = c, c = 0, u = -l, l = 0), o[0].style.zIndex = -Math.abs(Math.round(s)) + e.length, r.slideShadows) { let e = t.isHorizontal() ? o.find(".swiper-slide-shadow-left") : o.find(".swiper-slide-shadow-top"); let n = t.isHorizontal() ? o.find(".swiper-slide-shadow-right") : o.find(".swiper-slide-shadow-bottom"); e.length === 0 && (e = K(r, o, t.isHorizontal() ? "left" : "top")), n.length === 0 && (n = K(r, o, t.isHorizontal() ? "right" : "bottom")), e.length && (e[0].style.opacity = Math.max(-s, 0)), n.length && (n[0].style.opacity = Math.max(s, 0)); } const h = `translate3d(${c}px, ${d}px, 0px) rotateX(${u}deg) rotateY(${l}deg)`; Y(r, o).transform(h); } },
      setTransition: (e) => { const { transformEl: n } = t.params.flipEffect; (n ? t.slides.find(n) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), Z({ swiper: t, duration: e, transformEl: n }); },
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode,
      }),
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({
      coverflowEffect: {
        rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0, transformEl: null,
      },
    }), G({
      effect: "coverflow",
      swiper: t,
      on: n,
      setTranslate: () => {
        const {
          width: e, height: n, slides: r, slidesSizesGrid: i,
        } = t; const o = t.params.coverflowEffect; const s = t.isHorizontal(); const a = t.translate; const l = s ? e / 2 - a : n / 2 - a; const u = s ? o.rotate : -o.rotate; const c = o.depth; for (let t = 0, e = r.length; t < e; t += 1) { const e = r.eq(t); const n = i[t]; const a = (l - e[0].swiperSlideOffset - n / 2) / n * o.modifier; let d = s ? u * a : 0; let h = s ? 0 : u * a; let p = -c * Math.abs(a); let f = o.stretch; typeof f === "string" && f.indexOf("%") !== -1 && (f = parseFloat(o.stretch) / 100 * n); let m = s ? 0 : f * a; let g = s ? f * a : 0; let v = 1 - (1 - o.scale) * Math.abs(a); Math.abs(g) < 0.001 && (g = 0), Math.abs(m) < 0.001 && (m = 0), Math.abs(p) < 0.001 && (p = 0), Math.abs(d) < 0.001 && (d = 0), Math.abs(h) < 0.001 && (h = 0), Math.abs(v) < 0.001 && (v = 0); const y = `translate3d(${g}px,${m}px,${p}px)  rotateX(${h}deg) rotateY(${d}deg) scale(${v})`; if (Y(o, e).transform(y), e[0].style.zIndex = 1 - Math.abs(Math.round(a)), o.slideShadows) { let t = s ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"); let n = s ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); t.length === 0 && (t = K(o, e, s ? "left" : "top")), n.length === 0 && (n = K(o, e, s ? "right" : "bottom")), t.length && (t[0].style.opacity = a > 0 ? a : 0), n.length && (n[0].style.opacity = -a > 0 ? -a : 0); } }
      },
      setTransition: (e) => { const { transformEl: n } = t.params.coverflowEffect; (n ? t.slides.find(n) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e); },
      perspective: () => !0,
      overwriteParams: () => ({ watchSlidesProgress: !0 }),
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({
      creativeEffect: {
        transformEl: null,
        limitProgress: 1,
        shadowPerProgress: !1,
        progressMultiplier: 1,
        perspective: !0,
        prev: {
          translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1,
        },
        next: {
          translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1,
        },
      },
    }); const r = (t) => (typeof t === "string" ? t : `${t}px`); G({
      effect: "creative",
      swiper: t,
      on: n,
      setTranslate: () => {
        const { slides: e } = t; const n = t.params.creativeEffect; const { progressMultiplier: i } = n; for (let o = 0; o < e.length; o += 1) {
          const s = e.eq(o); const a = s[0].progress; const l = Math.min(Math.max(s[0].progress, -n.limitProgress), n.limitProgress); const u = s[0].swiperSlideOffset; const c = [t.params.cssMode ? -u - t.translate : -u, 0, 0]; const d = [0, 0, 0]; let h = !1; t.isHorizontal() || (c[1] = c[0], c[0] = 0); let p = {
            translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1,
          }; l < 0 ? (p = n.next, h = !0) : l > 0 && (p = n.prev, h = !0), c.forEach((t, e) => { c[e] = `calc(${t}px + (${r(p.translate[e])} * ${Math.abs(l * i)}))`; }), d.forEach((t, e) => { d[e] = p.rotate[e] * Math.abs(l * i); }), s[0].style.zIndex = -Math.abs(Math.round(a)) + e.length; const f = c.join(", "); const m = `rotateX(${d[0]}deg) rotateY(${d[1]}deg) rotateZ(${d[2]}deg)`; const g = l < 0 ? `scale(${1 + (1 - p.scale) * l * i})` : `scale(${1 - (1 - p.scale) * l * i})`; const v = l < 0 ? 1 + (1 - p.opacity) * l * i : 1 - (1 - p.opacity) * l * i; const y = `translate3d(${f}) ${m} ${g}`; if (h && p.shadow || !h) { let t = s.children(".swiper-slide-shadow"); if (t.length === 0 && p.shadow && (t = K(n, s)), t.length) { const e = n.shadowPerProgress ? l * (1 / n.limitProgress) : l; t[0].style.opacity = Math.min(Math.max(Math.abs(e), 0), 1); } } const _ = Y(n, s); _.transform(y).css({ opacity: v }), p.origin && _.css("transform-origin", p.origin);
        }
      },
      setTransition: (e) => {
        const { transformEl: n } = t.params.creativeEffect; (n ? t.slides.find(n) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), Z({
          swiper: t, duration: e, transformEl: n, allSlides: !0,
        });
      },
      perspective: () => t.params.creativeEffect.perspective,
      overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }),
    });
  }, function ({ swiper: t, extendParams: e, on: n }) {
    e({ cardsEffect: { slideShadows: !0, transformEl: null } }), G({
      effect: "cards", swiper: t, on: n, setTranslate: () => { const { slides: e, activeIndex: n } = t; const r = t.params.cardsEffect; const { startTranslate: i, isTouched: o } = t.touchEventsData; const s = t.translate; for (let a = 0; a < e.length; a += 1) { const l = e.eq(a); const u = l[0].progress; const c = Math.min(Math.max(u, -4), 4); let d = l[0].swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (d -= e[0].swiperSlideOffset); let h = t.params.cssMode ? -d - t.translate : -d; let p = 0; const f = -100 * Math.abs(c); let m = 1; let g = -2 * c; let v = 8 - 0.75 * Math.abs(c); const y = (a === n || a === n - 1) && c > 0 && c < 1 && (o || t.params.cssMode) && s < i; const _ = (a === n || a === n + 1) && c < 0 && c > -1 && (o || t.params.cssMode) && s > i; if (y || _) { const t = (1 - Math.abs((Math.abs(c) - 0.5) / 0.5)) ** 0.5; g += -28 * c * t, m += -0.5 * t, v += 96 * t, p = `${-25 * t * Math.abs(c)}%`; } if (h = c < 0 ? `calc(${h}px + (${v * Math.abs(c)}%))` : c > 0 ? `calc(${h}px + (-${v * Math.abs(c)}%))` : `${h}px`, !t.isHorizontal()) { const t = p; p = h, h = t; } const b = `\n        translate3d(${h}, ${p}, ${f}px)\n        rotateZ(${g}deg)\n        scale(${c < 0 ? `${1 + (1 - m) * c}` : `${1 - (1 - m) * c}`})\n      `; if (r.slideShadows) { let t = l.find(".swiper-slide-shadow"); t.length === 0 && (t = K(r, l)), t.length && (t[0].style.opacity = Math.min(Math.max((Math.abs(c) - 0.5) / 0.5, 0), 1)); }l[0].style.zIndex = -Math.abs(Math.round(u)) + e.length, Y(r, l).transform(b); } }, setTransition: (e) => { const { transformEl: n } = t.params.cardsEffect; (n ? t.slides.find(n) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), Z({ swiper: t, duration: e, transformEl: n }); }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }),
    });
  }]; return V.use(X), V;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSStickyBlock = e() : t.HSStickyBlock = e(); }(window, (() => {
  return d = {
    "./src/js/hs-sticky-block.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSStickyBlock; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*\n* HSStickyBlock Plugin\n* @version: 3.0.0 (Wed, 24 Nov 2021)\n* @author: HtmlStream\n* @event-namespace: .HSStickyBlock\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\nvar isNumeric = function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n},\n    offset = function offset(el) {\n  el = _typeof(el) === "object" ? el : document.querySelector(el);\n  return {\n    top: el ? window.pageYOffset + el.getBoundingClientRect().top : 0,\n    left: el ? el.getBoundingClientRect().left : 0\n  };\n},\n    css = function css(el, style) {\n  el = _typeof(el) === "object" ? el : document.querySelector(el);\n\n  for (var property in style) {\n    el.style[property] = style[property];\n  }\n};\n\nvar dataAttributeName = \'data-hs-sticky-block-options\';\nvar defaults = {\n  parentSelector: null,\n  parentWidth: null,\n  parentPaddingLeft: null,\n  parentOffsetLeft: null,\n  targetSelector: null,\n  targetHeight: 0,\n  stickyHeight: null,\n  stickyOffsetTop: 0,\n  stickyOffsetBottom: 0,\n  windowOffsetTop: 0,\n  startPoint: null,\n  endPoint: null,\n  resolutionsList: {\n    xs: 0,\n    sm: 576,\n    md: 768,\n    lg: 992,\n    xl: 1200\n  },\n  breakpoint: \'lg\',\n  styles: {\n    position: \'fixed\'\n  },\n  classMap: {\n    kill: \'hs-kill-sticky\'\n  }\n};\n\nvar HSStickyBlock = /*#__PURE__*/function () {\n  function HSStickyBlock(el, options, id) {\n    _classCallCheck(this, HSStickyBlock);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSStickyBlock, [{\n    key: "_init",\n    value: function _init() {\n      var _this = this;\n\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        Array(\'resize\', \'scroll\').forEach(function (evt) {\n          return window.addEventListener(evt, function () {\n            return _this.update(_$el, _options);\n          }, false);\n        });\n        that.collection[i].$initializedEl = _options;\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "update",\n    value: function update($el, settings) {\n      var that = this;\n\n      that._setRules($el, settings);\n    }\n  }, {\n    key: "_updateOptions",\n    value: function _updateOptions($el, settings) {\n      var parentSelector = document.querySelector(settings.parentSelector),\n          targetSelector = document.querySelector(settings.targetSelector);\n      settings.windowOffsetTop = window.pageYOffset;\n      settings.startPointPos = offset(settings.startPoint).top;\n      settings.endPointPos = offset(settings.endPoint).top;\n      settings.parentWidth = parentSelector ? parentSelector.clientWidth : 0;\n      settings.parentPaddingLeft = parentSelector ? parseInt(window.getComputedStyle(parentSelector).paddingLeft) : 0;\n      settings.parentOffsetLeft = offset(parentSelector).left;\n      settings.targetHeight = targetSelector ? targetSelector.offsetHeight : 0;\n      settings.stickyHeight = $el.offsetHeight;\n    }\n  }, {\n    key: "_setRules",\n    value: function _setRules($el, settings) {\n      var that = this;\n\n      that._kill($el, settings);\n\n      that._updateOptions($el, settings);\n\n      if (!$el.classList.contains(settings.classMap.kill)) {\n        if (settings.windowOffsetTop >= settings.startPointPos - settings.targetHeight - settings.stickyOffsetTop && settings.windowOffsetTop <= settings.endPointPos - settings.targetHeight - settings.stickyOffsetTop) {\n          that._add($el, settings);\n\n          that._top($el, settings);\n\n          that._parentSetHeight($el, settings);\n        } else {\n          that._reset($el);\n\n          that._parentRemoveHeight($el, settings);\n        }\n\n        if (settings.windowOffsetTop >= settings.endPointPos - settings.targetHeight - settings.stickyHeight - settings.stickyOffsetTop - settings.stickyOffsetBottom) {\n          that._bottom($el, settings);\n        }\n      }\n    }\n  }, {\n    key: "_add",\n    value: function _add($el, settings) {\n      css($el, {\n        position: settings.styles.position,\n        left: settings.parentOffsetLeft + settings.parentPaddingLeft + \'px\',\n        width: settings.parentWidth + \'px\'\n      });\n    }\n  }, {\n    key: "_top",\n    value: function _top($el, settings) {\n      css($el, {\n        top: settings.stickyOffsetTop + settings.targetHeight + \'px\'\n      });\n    }\n  }, {\n    key: "_bottom",\n    value: function _bottom($el, settings) {\n      css($el, {\n        top: settings.endPointPos - settings.windowOffsetTop - settings.stickyHeight - settings.stickyOffsetBottom + \'px\'\n      });\n    }\n  }, {\n    key: "_reset",\n    value: function _reset($el, settings) {\n      css($el, {\n        position: \'\',\n        top: \'\',\n        bottom: \'\',\n        left: \'\',\n        width: \'\'\n      });\n    }\n  }, {\n    key: "_kill",\n    value: function _kill($el, settings) {\n      var that = this;\n\n      if (window.innerWidth < settings.resolutionsList[settings.breakpoint]) {\n        $el.classList.add(settings.classMap.kill);\n\n        that._reset($el);\n\n        that._parentRemoveHeight($el, settings);\n      } else {\n        $el.classList.remove(settings.classMap.kill);\n      }\n    }\n  }, {\n    key: "_parentSetHeight",\n    value: function _parentSetHeight($el, settings) {\n      css(settings.parentSelector, {\n        height: settings.stickyHeight + \'px\'\n      });\n    }\n  }, {\n    key: "_parentRemoveHeight",\n    value: function _parentRemoveHeight($el, settings) {\n      css(settings.parentSelector, {\n        height: \'\'\n      });\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSStickyBlock;\n}();\n\n\n\n//# sourceURL=webpack://HSStickyBlock/./src/js/hs-sticky-block.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-sticky-block.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))),
/*!
 *
 *   typed.js - A JavaScript Typing Animation Library
 *   Author: Matt Boldt <me@mattboldt.com>
 *   Version: v2.0.12
 *   Url: https://github.com/mattboldt/typed.js
 *   License(s): MIT
 *
 */
(function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.Typed = e() : t.Typed = e(); }(this, (() => (function (t) { function e(r) { if (n[r]) return n[r].exports; const i = n[r] = { exports: {}, id: r, loaded: !1 }; return t[r].call(i.exports, i, i.exports, e), i.loaded = !0, i.exports; } var n = {}; return e.m = t, e.c = n, e.p = "", e(0); }([function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const i = n(1); const o = n(3); const s = (function () { function t(e, n) { (function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), i.initializer.load(this, n, e), this.begin(); } return r(t, [{ key: "toggle", value() { this.pause.status ? this.start() : this.stop(); } }, { key: "stop", value() { this.typingComplete || this.pause.status || (this.toggleBlinking(!0), this.pause.status = !0, this.options.onStop(this.arrayPos, this)); } }, { key: "start", value() { this.typingComplete || this.pause.status && (this.pause.status = !1, this.pause.typewrite ? this.typewrite(this.pause.curString, this.pause.curStrPos) : this.backspace(this.pause.curString, this.pause.curStrPos), this.options.onStart(this.arrayPos, this)); } }, { key: "destroy", value() { this.reset(!1), this.options.onDestroy(this); } }, { key: "reset", value() { const t = arguments.length <= 0 || void 0 === arguments[0] || arguments[0]; clearInterval(this.timeout), this.replaceText(""), this.cursor && this.cursor.parentNode && (this.cursor.parentNode.removeChild(this.cursor), this.cursor = null), this.strPos = 0, this.arrayPos = 0, this.curLoop = 0, t && (this.insertCursor(), this.options.onReset(this), this.begin()); } }, { key: "begin", value() { const t = this; this.options.onBegin(this), this.typingComplete = !1, this.shuffleStringsIfNeeded(this), this.insertCursor(), this.bindInputFocusEvents && this.bindFocusEvents(), this.timeout = setTimeout((() => { t.currentElContent && t.currentElContent.length !== 0 ? t.backspace(t.currentElContent, t.currentElContent.length) : t.typewrite(t.strings[t.sequence[t.arrayPos]], t.strPos); }), this.startDelay); } }, { key: "typewrite", value(t, e) { const n = this; this.fadeOut && this.el.classList.contains(this.fadeOutClass) && (this.el.classList.remove(this.fadeOutClass), this.cursor && this.cursor.classList.remove(this.fadeOutClass)); const r = this.humanizer(this.typeSpeed); let i = 1; return !0 === this.pause.status ? void this.setPauseStatus(t, e, !0) : void (this.timeout = setTimeout((() => { e = o.htmlParser.typeHtmlChars(t, e, n); let r = 0; let s = t.substr(e); if (s.charAt(0) === "^" && /^\^\d+/.test(s)) { let a = 1; a += (s = /\d+/.exec(s)[0]).length, r = parseInt(s), n.temporaryPause = !0, n.options.onTypingPaused(n.arrayPos, n), t = t.substring(0, e) + t.substring(e + a), n.toggleBlinking(!0); } if (s.charAt(0) === "`") { for (;t.substr(e + i).charAt(0) !== "`" && (i++, !(e + i > t.length)););const l = t.substring(0, e); const u = t.substring(l.length + 1, e + i); const c = t.substring(e + i + 1); t = l + u + c, i--; }n.timeout = setTimeout((() => { n.toggleBlinking(!1), e >= t.length ? n.doneTyping(t, e) : n.keepTyping(t, e, i), n.temporaryPause && (n.temporaryPause = !1, n.options.onTypingResumed(n.arrayPos, n)); }), r); }), r)); } }, { key: "keepTyping", value(t, e, n) { e === 0 && (this.toggleBlinking(!1), this.options.preStringTyped(this.arrayPos, this)), e += n; const r = t.substr(0, e); this.replaceText(r), this.typewrite(t, e); } }, { key: "doneTyping", value(t, e) { const n = this; this.options.onStringTyped(this.arrayPos, this), this.toggleBlinking(!0), this.arrayPos === this.strings.length - 1 && (this.complete(), !1 === this.loop || this.curLoop === this.loopCount) || (this.timeout = setTimeout((() => { n.backspace(t, e); }), this.backDelay)); } }, { key: "backspace", value(t, e) { const n = this; if (!0 !== this.pause.status) { if (this.fadeOut) return this.initFadeOut(); this.toggleBlinking(!1); const r = this.humanizer(this.backSpeed); this.timeout = setTimeout((() => { e = o.htmlParser.backSpaceHtmlChars(t, e, n); const r = t.substr(0, e); if (n.replaceText(r), n.smartBackspace) { const i = n.strings[n.arrayPos + 1]; i && r === i.substr(0, e) ? n.stopNum = e : n.stopNum = 0; }e > n.stopNum ? (e--, n.backspace(t, e)) : e <= n.stopNum && (n.arrayPos++, n.arrayPos === n.strings.length ? (n.arrayPos = 0, n.options.onLastStringBackspaced(), n.shuffleStringsIfNeeded(), n.begin()) : n.typewrite(n.strings[n.sequence[n.arrayPos]], e)); }), r); } else this.setPauseStatus(t, e, !1); } }, { key: "complete", value() { this.options.onComplete(this), this.loop ? this.curLoop++ : this.typingComplete = !0; } }, { key: "setPauseStatus", value(t, e, n) { this.pause.typewrite = n, this.pause.curString = t, this.pause.curStrPos = e; } }, { key: "toggleBlinking", value(t) { this.cursor && (this.pause.status || this.cursorBlinking !== t && (this.cursorBlinking = t, t ? this.cursor.classList.add("typed-cursor--blink") : this.cursor.classList.remove("typed-cursor--blink"))); } }, { key: "humanizer", value(t) { return Math.round(Math.random() * t / 2) + t; } }, { key: "shuffleStringsIfNeeded", value() { this.shuffle && (this.sequence = this.sequence.sort((() => Math.random() - 0.5))); } }, { key: "initFadeOut", value() { const t = this; return this.el.className += ` ${this.fadeOutClass}`, this.cursor && (this.cursor.className += ` ${this.fadeOutClass}`), setTimeout((() => { t.arrayPos++, t.replaceText(""), t.strings.length > t.arrayPos ? t.typewrite(t.strings[t.sequence[t.arrayPos]], 0) : (t.typewrite(t.strings[0], 0), t.arrayPos = 0); }), this.fadeOutDelay); } }, { key: "replaceText", value(t) { this.attr ? this.el.setAttribute(this.attr, t) : this.isInput ? this.el.value = t : this.contentType === "html" ? this.el.innerHTML = t : this.el.textContent = t; } }, { key: "bindFocusEvents", value() { const t = this; this.isInput && (this.el.addEventListener("focus", ((e) => { t.stop(); })), this.el.addEventListener("blur", ((e) => { t.el.value && t.el.value.length !== 0 || t.start(); }))); } }, { key: "insertCursor", value() { this.showCursor && (this.cursor || (this.cursor = document.createElement("span"), this.cursor.className = "typed-cursor", this.cursor.setAttribute("aria-hidden", !0), this.cursor.innerHTML = this.cursorChar, this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling))); } }]), t; }()); e.default = s, t.exports = e.default;
}, function (t, e, n) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const r = Object.assign || function (t) { for (let e = 1; e < arguments.length; e++) { const n = arguments[e]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]); } return t; }; const i = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const o = (function (t) { return t && t.__esModule ? t : { default: t }; }(n(2))); const s = (function () {
    function t() { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)); } return i(t, [{
      key: "load",
      value(t, e, n) {
        if (t.el = typeof n === "string" ? document.querySelector(n) : n, t.options = { ...o.default, ...e }, t.isInput = t.el.tagName.toLowerCase() === "input", t.attr = t.options.attr, t.bindInputFocusEvents = t.options.bindInputFocusEvents, t.showCursor = !t.isInput && t.options.showCursor, t.cursorChar = t.options.cursorChar, t.cursorBlinking = !0, t.elContent = t.attr ? t.el.getAttribute(t.attr) : t.el.textContent, t.contentType = t.options.contentType, t.typeSpeed = t.options.typeSpeed, t.startDelay = t.options.startDelay, t.backSpeed = t.options.backSpeed, t.smartBackspace = t.options.smartBackspace, t.backDelay = t.options.backDelay, t.fadeOut = t.options.fadeOut, t.fadeOutClass = t.options.fadeOutClass, t.fadeOutDelay = t.options.fadeOutDelay, t.isPaused = !1, t.strings = t.options.strings.map(((t) => t.trim())), typeof t.options.stringsElement === "string" ? t.stringsElement = document.querySelector(t.options.stringsElement) : t.stringsElement = t.options.stringsElement, t.stringsElement) { t.strings = [], t.stringsElement.style.display = "none"; const i = Array.prototype.slice.apply(t.stringsElement.children); const s = i.length; if (s) for (var a = 0; a < s; a += 1) { const l = i[a]; t.strings.push(l.innerHTML.trim()); } } for (var a in t.strPos = 0, t.arrayPos = 0, t.stopNum = 0, t.loop = t.options.loop, t.loopCount = t.options.loopCount, t.curLoop = 0, t.shuffle = t.options.shuffle, t.sequence = [], t.pause = {
          status: !1, typewrite: !0, curString: "", curStrPos: 0,
        }, t.typingComplete = !1, t.strings)t.sequence[a] = a; t.currentElContent = this.getCurrentElContent(t), t.autoInsertCss = t.options.autoInsertCss, this.appendAnimationCss(t);
      }, 
    }, { key: "getCurrentElContent", value(t) { return t.attr ? t.el.getAttribute(t.attr) : t.isInput ? t.el.value : t.contentType === "html" ? t.el.innerHTML : t.el.textContent; } }, { key: "appendAnimationCss", value(t) { const e = "data-typed-js-css"; if (t.autoInsertCss && (t.showCursor || t.fadeOut) && !document.querySelector(`[${e}]`)) { const n = document.createElement("style"); n.type = "text/css", n.setAttribute(e, !0); let r = ""; t.showCursor && (r += "\n        .typed-cursor{\n          opacity: 1;\n        }\n        .typed-cursor.typed-cursor--blink{\n          animation: typedjsBlink 0.7s infinite;\n          -webkit-animation: typedjsBlink 0.7s infinite;\n                  animation: typedjsBlink 0.7s infinite;\n        }\n        @keyframes typedjsBlink{\n          50% { opacity: 0.0; }\n        }\n        @-webkit-keyframes typedjsBlink{\n          0% { opacity: 1; }\n          50% { opacity: 0.0; }\n          100% { opacity: 1; }\n        }\n      "), t.fadeOut && (r += "\n        .typed-fade-out{\n          opacity: 0;\n          transition: opacity .25s;\n        }\n        .typed-cursor.typed-cursor--blink.typed-fade-out{\n          -webkit-animation: 0;\n          animation: 0;\n        }\n      "), n.length !== 0 && (n.innerHTML = r, document.body.appendChild(n)); } } }]), t;
  }()); e.default = s; const a = new s(); e.initializer = a;
}, function (t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }); e.default = {
    strings: ["These are the default values...", "You know what you should do?", "Use your own!", "Have a great day!"], stringsElement: null, typeSpeed: 0, startDelay: 0, backSpeed: 0, smartBackspace: !0, shuffle: !1, backDelay: 700, fadeOut: !1, fadeOutClass: "typed-fade-out", fadeOutDelay: 500, loop: !1, loopCount: 1 / 0, showCursor: !0, cursorChar: "|", autoInsertCss: !0, attr: null, bindInputFocusEvents: !1, contentType: "html", onBegin(t) {}, onComplete(t) {}, preStringTyped(t, e) {}, onStringTyped(t, e) {}, onLastStringBackspaced(t) {}, onTypingPaused(t, e) {}, onTypingResumed(t, e) {}, onReset(t) {}, onStop(t, e) {}, onStart(t, e) {}, onDestroy(t) {},
  }, t.exports = e.default;
}, function (t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }); const n = (function () { function t(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e; }; }()); const r = (function () { function t() { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)); } return n(t, [{ key: "typeHtmlChars", value(t, e, n) { if (n.contentType !== "html") return e; const r = t.substr(e).charAt(0); if (r === "<" || r === "&") { let i; for (i = r === "<" ? ">" : ";"; t.substr(e + 1).charAt(0) !== i && !(++e + 1 > t.length););e++; } return e; } }, { key: "backSpaceHtmlChars", value(t, e, n) { if (n.contentType !== "html") return e; const r = t.substr(e).charAt(0); if (r === ">" || r === ";") { let i; for (i = r === ">" ? "<" : "&"; t.substr(e - 1).charAt(0) !== i && !(--e < 0););e--; } return e; } }]), t; }()); e.default = r; const i = new r(); e.htmlParser = i;
}]))))), (function (t, e) { if (typeof exports === "object" && typeof module === "object")module.exports = e(); else if (typeof define === "function" && define.amd)define([], e); else { const n = e(); for (const r in n)(typeof exports === "object" ? exports : t)[r] = n[r]; } }(window, (() => (function (t) { const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const i in t)n.d(r, i, ((e) => t[e]).bind(null, i)); return r; }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return n.d(e, "a", e), e; }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.p = "", n(n.s = 0); }([function (t, e, n) {
  n.r(e); let r; const i = "fslightbox-"; const o = "".concat(i, "styles"); const s = "".concat(i, "cursor-grabbing"); const a = "".concat(i, "full-dimension"); const l = "".concat(i, "flex-centered"); const u = "".concat(i, "open"); const c = "".concat(i, "transform-transition"); const d = "".concat(i, "absoluted"); const h = "".concat(i, "slide-btn"); const p = "".concat(h, "-container"); const f = "".concat(i, "fade-in"); const m = "".concat(i, "fade-out"); const g = `${f}-strong`; const v = `${m}-strong`; const y = "".concat(i, "opacity-"); const _ = "".concat(y, "1"); const b = "".concat(i, "source"); function w(t) { return (w = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; })(t); } function x(t) { let e; const n = t.props; let r = 0; const i = {}; this.getSourceTypeFromLocalStorageByUrl = function (t) { return e[t] ? e[t] : o(t); }, this.handleReceivedSourceTypeForUrl = function (t, n) { !1 === i[n] && (r--, t !== "invalid" ? i[n] = t : delete i[n], r === 0 && ((function (t, e) { for (const n in e)t[n] = e[n]; }(e, i)), localStorage.setItem("fslightbox-types", JSON.stringify(e)))); }; var o = function (t) { r++, i[t] = !1; }; n.disableLocalStorage ? (this.getSourceTypeFromLocalStorageByUrl = function () {}, this.handleReceivedSourceTypeForUrl = function () {}) : (e = JSON.parse(localStorage.getItem("fslightbox-types"))) || (e = {}, this.getSourceTypeFromLocalStorageByUrl = o); } function S(t, e, n, r) { const i = t.data; const o = t.elements.sources; const s = n / r; let a = 0; this.adjustSize = function () { if ((a = i.maxSourceWidth / s) < i.maxSourceHeight) return n < i.maxSourceWidth && (a = r), l(); a = r > i.maxSourceHeight ? i.maxSourceHeight : r, l(); }; var l = function () { o[e].style.width = `${a * s}px`, o[e].style.height = `${a}px`; }; } function k(t, e) { const n = this; const r = t.collections.sourceSizers; const i = t.elements; const o = i.sourceAnimationWrappers; const s = i.sourceMainWrappers; const a = i.sources; const l = t.resolve; function u(t, n) { r[e] = l(S, [e, t, n]), r[e].adjustSize(); } this.runActions = function (t, r) { a[e].classList.add(_), o[e].classList.add(g), s[e].removeChild(s[e].firstChild), u(t, r), n.runActions = u; }; } function C(t, e) { let n; const r = this; const i = t.elements.sources; const o = t.props; const s = (0, t.resolve)(k, [e]); this.handleImageLoad = function (t) { const e = t.target; const n = e.naturalWidth; const r = e.naturalHeight; s.runActions(n, r); }, this.handleVideoLoad = function (t) { const e = t.target; const r = e.videoWidth; const i = e.videoHeight; n = !0, s.runActions(r, i); }, this.handleNotMetaDatedVideoLoad = function () { n || r.handleYoutubeLoad(); }, this.handleYoutubeLoad = function () { let t = 1920; let e = 1080; o.maxYoutubeDimensions && (t = o.maxYoutubeDimensions.width, e = o.maxYoutubeDimensions.height), s.runActions(t, e); }, this.handleCustomLoad = function () { setTimeout((() => { const t = i[e]; s.runActions(t.offsetWidth, t.offsetHeight); })); }; } function E(t, e, n) { const r = t.elements.sources; const i = t.props.customClasses; const o = i[e] ? i[e] : ""; r[e].className = `${n} ${o}`; } function T(t, e) { const n = t.elements.sources; const r = t.props.customAttributes; for (const i in r[e])n[e].setAttribute(i, r[e][i]); } function P(t, e) { const n = t.collections.sourceLoadHandlers; const r = t.elements; const i = r.sources; const o = r.sourceAnimationWrappers; const s = t.props.sources; i[e] = document.createElement("img"), E(t, e, b), i[e].src = s[e], i[e].onload = n[e].handleImageLoad, T(t, e), o[e].appendChild(i[e]); } function O(t, e) { const n = t.collections.sourceLoadHandlers; const r = t.elements; const i = r.sources; const o = r.sourceAnimationWrappers; const s = t.props; const a = s.sources; const l = s.videosPosters; i[e] = document.createElement("video"), E(t, e, b), i[e].src = a[e], i[e].onloadedmetadata = function (t) { n[e].handleVideoLoad(t); }, i[e].controls = !0, T(t, e), l[e] && (i[e].poster = l[e]); const u = document.createElement("source"); u.src = a[e], i[e].appendChild(u), setTimeout(n[e].handleNotMetaDatedVideoLoad, 3e3), o[e].appendChild(i[e]); } function A(t, e) { const n = t.collections.sourceLoadHandlers; const r = t.elements; const o = r.sources; const s = r.sourceAnimationWrappers; const a = t.props.sources; o[e] = document.createElement("iframe"), E(t, e, "".concat(b, " ").concat(i, "youtube-iframe")), o[e].src = "https://www.youtube.com/embed/".concat(a[e].match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/)[2], "?enablejsapi=1"), o[e].allowFullscreen = !0, T(t, e), s[e].appendChild(o[e]), n[e].handleYoutubeLoad(); } function M(t, e) { const n = t.collections.sourceLoadHandlers; const r = t.elements; const i = r.sources; const o = r.sourceAnimationWrappers; const s = t.props.sources; i[e] = s[e], E(t, e, "".concat(i[e].className, " ").concat(b)), o[e].appendChild(i[e]), n[e].handleCustomLoad(); } function L(t, e) { const n = t.elements; const r = n.sources; const o = n.sourceAnimationWrappers; const s = n.sourceMainWrappers; t.props.sources, r[e] = document.createElement("div"), r[e].className = "".concat(i, "invalid-file-wrapper ").concat(l), r[e].innerHTML = "Invalid source", o[e].classList.add(g), o[e].appendChild(r[e]), s[e].removeChild(s[e].firstChild); } function I(t) { const e = t.collections; const n = e.sourceLoadHandlers; const r = e.sourcesRenderFunctions; const i = t.core.sourceDisplayFacade; const o = t.resolve; this.runActionsForSourceTypeAndIndex = function (e, s) { let a; switch (e !== "invalid" && (n[s] = o(C, [s])), e) { case "image": a = P; break; case "video": a = O; break; case "youtube": a = A; break; case "custom": a = M; break; default: a = L; }r[s] = function () { return a(t, s); }, i.displaySourcesWhichShouldBeDisplayed(); }; } function j() { let t; let e; let n; const r = function (t) { const e = document.createElement("a"); return e.href = t, e.hostname === "www.youtube.com"; }; const i = function (t) { return t.slice(0, t.indexOf("/")); }; function o() { if (n.readyState !== 4) { if (n.readyState === 2) { let t; switch (i(n.getResponseHeader("content-type"))) { case "image": t = "image"; break; case "video": t = "video"; break; default: t = "invalid"; }n.onreadystatechange = null, n.abort(), e(t); } } else e("invalid"); } this.setUrlToCheck = function (e) { t = e; }, this.getSourceType = function (i) { if (r(t)) return i("youtube"); e = i, (n = new XMLHttpRequest()).onreadystatechange = o, n.open("GET", t, !0), n.send(); }; } function D(t, e, n) { const r = t.props; const i = r.types; const o = r.type; const s = r.sources; const a = t.resolve; this.getTypeSetByClientForIndex = function (t) { let e; return i && i[t] ? e = i[t] : o && (e = o), e; }, this.retrieveTypeWithXhrForIndex = function (t) { const r = a(j); r.setUrlToCheck(s[t]), r.getSourceType(((r) => { e.handleReceivedSourceTypeForUrl(r, s[t]), n.runActionsForSourceTypeAndIndex(r, t); })); }; } function N(t, e) { const n = t.componentsServices.hideSourceLoaderIfNotYetCollection; const r = t.elements; const i = r.sourceWrappersContainer; const o = r.sourceMainWrappers; o[e] = document.createElement("div"), o[e].className = "".concat(d, " ").concat(a, " ").concat(l), o[e].innerHTML = '<div class="fslightbox-loader"><div></div><div></div><div></div><div></div></div>'; const s = o[e].firstChild; n[e] = function () { o[e].contains(s) && o[e].removeChild(s); }, i.appendChild(o[e]), (function (t, e) { const n = t.elements; const r = n.sourceMainWrappers; const i = n.sourceAnimationWrappers; i[e] = document.createElement("div"), r[e].appendChild(i[e]); }(t, e)); } function R(t, e, n, r) { const o = document.createElementNS("http://www.w3.org/2000/svg", "svg"); o.setAttributeNS(null, "width", e), o.setAttributeNS(null, "height", e), o.setAttributeNS(null, "viewBox", n); const s = document.createElementNS("http://www.w3.org/2000/svg", "path"); return s.setAttributeNS(null, "class", "".concat(i, "svg-path")), s.setAttributeNS(null, "d", r), o.appendChild(s), t.appendChild(o), o; } function F(t, e) { const n = document.createElement("div"); return n.className = "".concat(i, "toolbar-button ").concat(l), n.title = e, t.appendChild(n), n; } function V(t) { const e = t.props.sources; const n = t.elements.container; const r = document.createElement("div"); r.className = "".concat(i, "nav"), n.appendChild(r), (function (t, e) { const n = document.createElement("div"); n.className = "".concat(i, "toolbar"), e.appendChild(n), (function (t, e) { const n = t.componentsServices; const r = t.core.fullscreenToggler; const i = t.data; const o = "M4.5 11H3v4h4v-1.5H4.5V11zM3 7h1.5V4.5H7V3H3v4zm10.5 6.5H11V15h4v-4h-1.5v2.5zM11 3v1.5h2.5V7H15V3h-4z"; const s = F(e); s.title = "Enter fullscreen"; const a = R(s, "20px", "0 0 18 18", o); n.enterFullscreen = function () { i.isFullscreenOpen = !0, s.title = "Exit fullscreen", a.setAttributeNS(null, "width", "24px"), a.setAttributeNS(null, "height", "24px"), a.setAttributeNS(null, "viewBox", "0 0 950 1024"), a.firstChild.setAttributeNS(null, "d", "M682 342h128v84h-212v-212h84v128zM598 810v-212h212v84h-128v128h-84zM342 342v-128h84v212h-212v-84h128zM214 682v-84h212v212h-84v-128h-128z"); }, n.exitFullscreen = function () { i.isFullscreenOpen = !1, s.title = "Enter fullscreen", a.setAttributeNS(null, "width", "20px"), a.setAttributeNS(null, "height", "20px"), a.setAttributeNS(null, "viewBox", "0 0 18 18"), a.firstChild.setAttributeNS(null, "d", o); }, s.onclick = function () { i.isFullscreenOpen ? r.exitFullscreen() : r.enterFullscreen(); }; }(t, n)), (function (t, e) { const n = F(e, "Close"); n.onclick = t.core.lightboxCloser.closeLightbox, R(n, "20px", "0 0 24 24", "M 4.7070312 3.2929688 L 3.2929688 4.7070312 L 10.585938 12 L 3.2929688 19.292969 L 4.7070312 20.707031 L 12 13.414062 L 19.292969 20.707031 L 20.707031 19.292969 L 13.414062 12 L 20.707031 4.7070312 L 19.292969 3.2929688 L 12 10.585938 L 4.7070312 3.2929688 z"); }(t, n)); }(t, r)), e.length > 1 && (function (t, e) { const n = t.componentsServices; const r = t.props.sources; const o = (t.stageIndexes, document.createElement("div")); o.className = "".concat(i, "slide-number-container"); const s = document.createElement("div"); s.className = l; const a = document.createElement("span"); n.setSlideNumber = function (t) { return a.innerHTML = t; }; const u = document.createElement("span"); u.className = "".concat(i, "slash"); const c = document.createElement("div"); c.innerHTML = r.length, o.appendChild(s), s.appendChild(a), s.appendChild(u), s.appendChild(c), e.appendChild(o), setTimeout((() => { s.offsetWidth > 55 && (o.style.justifyContent = "flex-start"); })); }(t, r)); } function z(t, e) { const n = this; const r = t.elements.sourceMainWrappers; const i = t.props; let o = 0; this.byValue = function (t) { return o = t, n; }, this.negative = function () { s(-a()); }, this.zero = function () { s(0); }, this.positive = function () { s(a()); }; var s = function (t) { r[e].style.transform = "translateX(".concat(t + o, "px)"), o = 0; }; var a = function () { return (1 + i.slideDistance) * innerWidth; }; } function B(t, e, n, r) { const i = t.elements.container; const o = n.charAt(0).toUpperCase() + n.slice(1); const s = document.createElement("div"); s.className = "".concat(p, " ").concat(p, "-").concat(n), s.title = "".concat(o, " slide"), s.onclick = e, (function (t, e) { const n = document.createElement("div"); n.className = "".concat(h, " ").concat(l), R(n, "20px", "0 0 20 20", e), t.appendChild(n); }(s, r)), i.appendChild(s); } function q(t, e) { const n = t.classList; n.contains(e) && n.remove(e); } function H(t) { const e = this; const n = t.core; const r = n.eventsDispatcher; const i = n.fullscreenToggler; const o = n.globalEventsController; const s = n.scrollbarRecompensor; const a = t.data; const l = t.elements; const c = t.props; const d = t.sourcePointerProps; this.isLightboxFadingOut = !1, this.runActions = function () { e.isLightboxFadingOut = !0, l.container.classList.add(v), o.removeListeners(), c.exitFullscreenOnClose && a.isFullscreenOpen && i.exitFullscreen(), setTimeout((() => { e.isLightboxFadingOut = !1, d.isPointering = !1, l.container.classList.remove(v), document.documentElement.classList.remove(u), s.removeRecompense(), document.body.removeChild(l.container), r.dispatch("onClose"); }), 270); }; } function $(t) { const e = t.core; const n = e.lightboxCloser; const r = e.fullscreenToggler; const i = e.slideChangeFacade; this.listener = function (t) { switch (t.key) { case "Escape": n.closeLightbox(); break; case "ArrowLeft": i.changeToPrevious(); break; case "ArrowRight": i.changeToNext(); break; case "F11": t.preventDefault(), r.enterFullscreen(); } }; } function U(t) { const e = t.collections.sourceMainWrappersTransformers; const n = t.elements; const r = t.sourcePointerProps; const i = t.stageIndexes; function o(t, n) { e[t].byValue(r.swipedX)[n](); } this.runActionsForEvent = function (t) { let e; let a; let l; n.container.contains(n.slideSwipingHoverer) || n.container.appendChild(n.slideSwipingHoverer), e = n.container, a = s, (l = e.classList).contains(a) || l.add(a), r.swipedX = t.screenX - r.downScreenX, o(i.current, "zero"), void 0 !== i.previous && r.swipedX > 0 ? o(i.previous, "negative") : void 0 !== i.next && r.swipedX < 0 && o(i.next, "positive"); }; } function W(t) { const e = t.props.sources; const n = t.resolve; const r = t.sourcePointerProps; const i = n(U); e.length === 1 ? this.listener = function () { r.swipedX = 1; } : this.listener = function (t) { r.isPointering && i.runActionsForEvent(t); }; } function G(t) { const e = t.collections.sourceMainWrappersTransformers; const n = t.core.slideIndexChanger; const r = t.elements.sourceMainWrappers; const i = t.stageIndexes; this.runPositiveSwipedXActions = function () { void 0 === i.previous || (o("positive"), n.changeTo(i.previous)), o("zero"); }, this.runNegativeSwipedXActions = function () { void 0 === i.next || (o("negative"), n.changeTo(i.next)), o("zero"); }; var o = function (t) { r[i.current].classList.add(c), e[i.current][t](); }; } function Y(t, e) { t.contains(e) && t.removeChild(e); } function Z(t) { const e = t.core.lightboxCloser; const n = t.elements; const r = t.resolve; const i = t.sourcePointerProps; const o = r(G); this.runNoSwipeActions = function () { Y(n.container, n.slideSwipingHoverer), i.isSourceDownEventTarget || e.closeLightbox(), i.isPointering = !1; }, this.runActions = function () { i.swipedX > 0 ? o.runPositiveSwipedXActions() : o.runNegativeSwipedXActions(), Y(n.container, n.slideSwipingHoverer), n.container.classList.remove(s), i.isPointering = !1; }; } function K(t) { const e = t.resolve; const n = t.sourcePointerProps; const r = e(Z); this.listener = function () { n.isPointering && (n.swipedX ? r.runActions() : r.runNoSwipeActions()); }; } function X(t) { let e; let n; let r; n = (e = t).core.classFacade, r = e.elements, n.removeFromEachElementClassIfContains = function (t, e) { for (let n = 0; n < r[t].length; n++)q(r[t][n], e); }, (function (t) { const e = t.core.eventsDispatcher; const n = t.props; e.dispatch = function (t) { n[t] && n[t](); }; }(t)), (function (t) { const e = t.componentsServices; const n = t.core.fullscreenToggler; n.enterFullscreen = function () { e.enterFullscreen(); const t = document.documentElement; t.requestFullscreen ? t.requestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.msRequestFullscreen && t.msRequestFullscreen(); }, n.exitFullscreen = function () { e.exitFullscreen(), document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen(); }; }(t)), (function (t) { const e = t.core; const n = e.globalEventsController; const r = e.windowResizeActioner; const i = t.resolve; const o = i($); const s = i(W); const a = i(K); n.attachListeners = function () { document.addEventListener("pointermove", s.listener), document.addEventListener("pointerup", a.listener), addEventListener("resize", r.runActions), document.addEventListener("keydown", o.listener); }, n.removeListeners = function () { document.removeEventListener("pointermove", s.listener), document.removeEventListener("pointerup", a.listener), removeEventListener("resize", r.runActions), document.removeEventListener("keydown", o.listener); }; }(t)), (function (t) { const e = t.core.lightboxCloser; const n = (0, t.resolve)(H); e.closeLightbox = function () { n.isLightboxFadingOut || n.runActions(); }; }(t)), J(t), (function (t) { const e = t.data; const n = t.core.scrollbarRecompensor; n.addRecompense = function () { document.readyState === "complete" ? r() : addEventListener("load", (() => { r(), n.addRecompense = r; })); }; var r = function () { document.body.offsetHeight > innerHeight && (document.body.style.marginRight = `${e.scrollbarWidth}px`); }; n.removeRecompense = function () { document.body.style.removeProperty("margin-right"); }; }(t)), (function (t) { const e = t.core; const n = e.slideChangeFacade; const r = e.slideIndexChanger; const i = e.stageManager; t.props.sources.length > 1 ? (n.changeToPrevious = function () { r.jumpTo(i.getPreviousSlideIndex()); }, n.changeToNext = function () { r.jumpTo(i.getNextSlideIndex()); }) : (n.changeToPrevious = function () {}, n.changeToNext = function () {}); }(t)), (function (t) { let e; let n; const r = t.collections.sourceMainWrappersTransformers; const i = t.componentsServices; const o = t.core; const s = o.classFacade; const a = o.slideIndexChanger; const l = o.sourceDisplayFacade; const u = o.stageManager; const d = t.elements.sourceAnimationWrappers; const h = t.stageIndexes; const p = (e = function () { s.removeFromEachElementClassIfContains("sourceAnimationWrappers", m); }, 300, n = [], function () { n.push(!0), setTimeout((() => { n.pop(), n.length || e(); }), 300); }); a.changeTo = function (t) { h.current = t, u.updateStageIndexes(), i.setSlideNumber(t + 1), l.displaySourcesWhichShouldBeDisplayed(); }, a.jumpTo = function (t) { const e = h.current; a.changeTo(t), s.removeFromEachElementClassIfContains("sourceMainWrappers", c), q(d[e], g), q(d[e], f), d[e].classList.add(m), q(d[t], g), q(d[t], m), d[t].classList.add(f), p(), r[t].zero(), setTimeout((() => { e !== h.current && r[e].negative(); }), 270); }; }(t)), (function (t) { const e = t.core; const n = e.classFacade; const r = e.sourcesPointerDown; const i = t.elements.sources; const o = t.sourcePointerProps; const s = t.stageIndexes; r.listener = function (t) { t.target.tagName !== "VIDEO" && t.preventDefault(), o.isPointering = !0, o.downScreenX = t.screenX, o.swipedX = 0; const e = i[s.current]; e && e.contains(t.target) ? o.isSourceDownEventTarget = !0 : o.isSourceDownEventTarget = !1, n.removeFromEachElementClassIfContains("sourceMainWrappers", c); }; }(t)), (function (t) { const e = t.collections.sourcesRenderFunctions; const n = t.core.sourceDisplayFacade; const r = t.props; const i = t.stageIndexes; function o(t) { e[t] && (e[t](), delete e[t]); }n.displaySourcesWhichShouldBeDisplayed = function () { if (r.loadOnlyCurrentSource)o(i.current); else for (const t in i)o(i[t]); }; }(t)), (function (t) { const e = t.stageIndexes; const n = t.core.stageManager; const r = t.props.sources.length - 1; n.getPreviousSlideIndex = function () { return e.current === 0 ? r : e.current - 1; }, n.getNextSlideIndex = function () { return e.current === r ? 0 : e.current + 1; }, n.updateStageIndexes = r === 0 ? function () {} : r === 1 ? function () { e.current === 0 ? (e.next = 1, delete e.previous) : (e.previous = 0, delete e.next); } : function () { e.previous = n.getPreviousSlideIndex(), e.next = n.getNextSlideIndex(); }, n.isSourceInStage = r <= 2 ? function () { return !0; } : function (t) { const n = e.current; if (n === 0 && t === r || n === r && t === 0) return !0; const i = n - t; return i === -1 || i === 0 || i === 1; }; }(t)), (function (t) { const e = t.collections; const n = e.sourceMainWrappersTransformers; const r = e.sourceSizers; const i = t.core.windowResizeActioner; const o = t.data; const s = t.elements.sourceMainWrappers; const a = t.props; const l = t.stageIndexes; i.runActions = function () { innerWidth < 992 ? o.maxSourceWidth = innerWidth : o.maxSourceWidth = 0.9 * innerWidth, o.maxSourceHeight = 0.9 * innerHeight; for (let t = 0; t < a.sources.length; t++)q(s[t], c), t !== l.current && n[t].negative(), r[t] && r[t].adjustSize(); }; }(t)); } function Q(t) { const e = t.core.eventsDispatcher; const n = t.data; const r = t.elements; const o = t.props.sources; n.isInitialized = !0, n.scrollbarWidth = (function (t) { const e = t.props.disableLocalStorage; if (!e) { const n = localStorage.getItem("fslightbox-scrollbar-width"); if (n) return n; } const r = (function () { const t = document.createElement("div"); const e = t.style; return e.visibility = "hidden", e.width = "100px", e.msOverflowStyle = "scrollbar", e.overflow = "scroll", t; }()); const i = (function () { const t = document.createElement("div"); return t.style.width = "100%", t; }()); document.body.appendChild(r); const o = r.offsetWidth; r.appendChild(i); const s = i.offsetWidth; document.body.removeChild(r); const a = o - s; return e || localStorage.setItem("fslightbox-scrollbar-width", a.toString()), a; }(t)), (function (t) { for (let e = t.collections.sourceMainWrappersTransformers, n = t.props.sources, r = t.resolve, i = 0; i < n.length; i++)e[i] = r(z, [i]); }(t)), X(t), r.container = document.createElement("div"), r.container.className = "".concat(i, "container ").concat(a, " ").concat(g), (function (t) { const e = t.elements; e.slideSwipingHoverer = document.createElement("div"), e.slideSwipingHoverer.className = "".concat(i, "slide-swiping-hoverer ").concat(a, " ").concat(d); }(t)), V(t), (function (t) { const e = t.core.sourcesPointerDown; const n = t.elements; const r = t.props.sources; const i = document.createElement("div"); i.className = "".concat(d, " ").concat(a), n.container.appendChild(i), i.addEventListener("pointerdown", e.listener), n.sourceWrappersContainer = i; for (let o = 0; o < r.length; o++)N(t, o); }(t)), o.length > 1 && (function (t) { const e = t.core.slideChangeFacade; B(t, e.changeToPrevious, "previous", "M18.271,9.212H3.615l4.184-4.184c0.306-0.306,0.306-0.801,0-1.107c-0.306-0.306-0.801-0.306-1.107,0L1.21,9.403C1.194,9.417,1.174,9.421,1.158,9.437c-0.181,0.181-0.242,0.425-0.209,0.66c0.005,0.038,0.012,0.071,0.022,0.109c0.028,0.098,0.075,0.188,0.142,0.271c0.021,0.026,0.021,0.061,0.045,0.085c0.015,0.016,0.034,0.02,0.05,0.033l5.484,5.483c0.306,0.307,0.801,0.307,1.107,0c0.306-0.305,0.306-0.801,0-1.105l-4.184-4.185h14.656c0.436,0,0.788-0.353,0.788-0.788S18.707,9.212,18.271,9.212z"), B(t, e.changeToNext, "next", "M1.729,9.212h14.656l-4.184-4.184c-0.307-0.306-0.307-0.801,0-1.107c0.305-0.306,0.801-0.306,1.106,0l5.481,5.482c0.018,0.014,0.037,0.019,0.053,0.034c0.181,0.181,0.242,0.425,0.209,0.66c-0.004,0.038-0.012,0.071-0.021,0.109c-0.028,0.098-0.075,0.188-0.143,0.271c-0.021,0.026-0.021,0.061-0.045,0.085c-0.015,0.016-0.034,0.02-0.051,0.033l-5.483,5.483c-0.306,0.307-0.802,0.307-1.106,0c-0.307-0.305-0.307-0.801,0-1.105l4.184-4.185H1.729c-0.436,0-0.788-0.353-0.788-0.788S1.293,9.212,1.729,9.212z"); }(t)), (function (t) { for (let e = t.props.sources, n = t.resolve, r = n(x), i = n(I), o = n(D, [r, i]), s = 0; s < e.length; s++) if (typeof e[s] === "string") { const a = o.getTypeSetByClientForIndex(s); if (a)i.runActionsForSourceTypeAndIndex(a, s); else { const l = r.getSourceTypeFromLocalStorageByUrl(e[s]); l ? i.runActionsForSourceTypeAndIndex(l, s) : o.retrieveTypeWithXhrForIndex(s); } } else i.runActionsForSourceTypeAndIndex("custom", s); }(t)), e.dispatch("onInit"); } function J(t) { const e = t.collections.sourceMainWrappersTransformers; const n = t.componentsServices; const r = t.core; const i = r.eventsDispatcher; const o = r.lightboxOpener; const s = r.globalEventsController; const a = r.scrollbarRecompensor; const l = r.sourceDisplayFacade; const c = r.stageManager; const d = r.windowResizeActioner; const h = t.data; const p = t.elements; const f = t.stageIndexes; o.open = function () { const r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; f.current = r, h.isInitialized ? i.dispatch("onShow") : Q(t), c.updateStageIndexes(), l.displaySourcesWhichShouldBeDisplayed(), n.setSlideNumber(r + 1), document.body.appendChild(p.container), document.documentElement.classList.add(u), a.addRecompense(), s.attachListeners(), d.runActions(), e[f.current].zero(), i.dispatch("onOpen"); }; } function tt(t, e, n) { return (tt = et() ? Reflect.construct : function (t, e, n) { const r = [null]; r.push.apply(r, e); const i = new (Function.bind.apply(t, r))(); return n && nt(i, n.prototype), i; }).apply(null, arguments); } function et() { if (typeof Reflect === "undefined" || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (t) { return !1; } } function nt(t, e) { return (nt = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function rt(t) { return (function (t) { if (Array.isArray(t)) return it(t); }(t)) || (function (t) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(t)) return Array.from(t); }(t)) || (function (t, e) { if (t) { if (typeof t === "string") return it(t, e); let n = Object.prototype.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? it(t, e) : void 0; } }(t)) || (function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }()); } function it(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r; } function ot() { for (var t = document.getElementsByTagName("a"), e = function (e) { if (!t[e].hasAttribute("data-fslightbox")) return "continue"; const n = t[e].getAttribute("data-fslightbox"); const r = t[e].getAttribute("href"); fsLightboxInstances[n] || (fsLightboxInstances[n] = new FsLightbox()); let i; i = r.charAt(0) === "#" ? document.getElementById(r.substring(1)) : r, fsLightboxInstances[n].props.sources.push(i), fsLightboxInstances[n].elements.a.push(t[e]); const o = fsLightboxInstances[n].props.sources.length - 1; t[e].onclick = function (t) { t.preventDefault(), fsLightboxInstances[n].open(o); }, d("types", "data-type"), d("videosPosters", "data-video-poster"), d("customClasses", "data-class"), d("customClasses", "data-custom-class"); for (let s = ["href", "data-fslightbox", "data-type", "data-video-poster", "data-class", "data-custom-class"], a = t[e].attributes, l = fsLightboxInstances[n].props.customAttributes, u = 0; u < a.length; u++) if (s.indexOf(a[u].name) === -1 && a[u].name.substr(0, 5) === "data-") { l[o] || (l[o] = {}); const c = a[u].name.substr(5); l[o][c] = a[u].value; } function d(r, i) { t[e].hasAttribute(i) && (fsLightboxInstances[n].props[r][o] = t[e].getAttribute(i)); } }, n = 0; n < t.length; n++)e(n); const r = Object.keys(fsLightboxInstances); window.fsLightbox = fsLightboxInstances[r[r.length - 1]]; }(typeof document === "undefined" ? "undefined" : w(document)) === "object" && ((r = document.createElement("style")).className = o, r.appendChild(document.createTextNode(".fslightbox-absoluted{position:absolute;top:0;left:0}.fslightbox-fade-in{animation:fslightbox-fade-in .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out{animation:fslightbox-fade-out .3s ease}.fslightbox-fade-in-strong{animation:fslightbox-fade-in-strong .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out-strong{animation:fslightbox-fade-out-strong .3s ease}@keyframes fslightbox-fade-in{from{opacity:.65}to{opacity:1}}@keyframes fslightbox-fade-out{from{opacity:.35}to{opacity:0}}@keyframes fslightbox-fade-in-strong{from{opacity:.3}to{opacity:1}}@keyframes fslightbox-fade-out-strong{from{opacity:1}to{opacity:0}}.fslightbox-cursor-grabbing{cursor:grabbing}.fslightbox-full-dimension{width:100%;height:100%}.fslightbox-open{overflow:hidden;height:100%}.fslightbox-flex-centered{display:flex;justify-content:center;align-items:center}.fslightbox-opacity-0{opacity:0!important}.fslightbox-opacity-1{opacity:1!important}.fslightbox-scrollbarfix{padding-right:17px}.fslightbox-transform-transition{transition:transform .3s}.fslightbox-container{font-family:Arial,sans-serif;position:fixed;top:0;left:0;background:linear-gradient(rgba(30,30,30,.9),#000 1810%);touch-action:none;z-index:1000000000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.fslightbox-container *{box-sizing:border-box}.fslightbox-svg-path{transition:fill .15s ease;fill:#ddd}.fslightbox-nav{height:45px;width:100%;position:absolute;top:0;left:0}.fslightbox-slide-number-container{display:flex;justify-content:center;align-items:center;position:relative;height:100%;font-size:15px;color:#d7d7d7;z-index:0;max-width:55px;text-align:left}.fslightbox-slide-number-container .fslightbox-flex-centered{height:100%}.fslightbox-slash{display:block;margin:0 5px;width:1px;height:12px;transform:rotate(15deg);background:#fff}.fslightbox-toolbar{position:absolute;z-index:3;right:0;top:0;height:100%;display:flex;background:rgba(35,35,35,.65)}.fslightbox-toolbar-button{height:100%;width:45px;cursor:pointer}.fslightbox-toolbar-button:hover .fslightbox-svg-path{fill:#fff}.fslightbox-slide-btn-container{display:flex;align-items:center;padding:12px 12px 12px 6px;position:absolute;top:50%;cursor:pointer;z-index:3;transform:translateY(-50%)}@media (min-width:476px){.fslightbox-slide-btn-container{padding:22px 22px 22px 6px}}@media (min-width:768px){.fslightbox-slide-btn-container{padding:30px 30px 30px 6px}}.fslightbox-slide-btn-container:hover .fslightbox-svg-path{fill:#f1f1f1}.fslightbox-slide-btn{padding:9px;font-size:26px;background:rgba(35,35,35,.65)}@media (min-width:768px){.fslightbox-slide-btn{padding:10px}}@media (min-width:1600px){.fslightbox-slide-btn{padding:11px}}.fslightbox-slide-btn-container-previous{left:0}@media (max-width:475.99px){.fslightbox-slide-btn-container-previous{padding-left:3px}}.fslightbox-slide-btn-container-next{right:0;padding-left:12px;padding-right:3px}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-left:22px}}@media (min-width:768px){.fslightbox-slide-btn-container-next{padding-left:30px}}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-right:6px}}.fslightbox-down-event-detector{position:absolute;z-index:1}.fslightbox-slide-swiping-hoverer{z-index:4}.fslightbox-invalid-file-wrapper{font-size:22px;color:#eaebeb;margin:auto}.fslightbox-video{object-fit:cover}.fslightbox-youtube-iframe{border:0}.fslightbox-loader{display:block;margin:auto;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:67px;height:67px}.fslightbox-loader div{box-sizing:border-box;display:block;position:absolute;width:54px;height:54px;margin:6px;border:5px solid;border-color:#999 transparent transparent transparent;border-radius:50%;animation:fslightbox-loader 1.2s cubic-bezier(.5,0,.5,1) infinite}.fslightbox-loader div:nth-child(1){animation-delay:-.45s}.fslightbox-loader div:nth-child(2){animation-delay:-.3s}.fslightbox-loader div:nth-child(3){animation-delay:-.15s}@keyframes fslightbox-loader{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.fslightbox-source{position:relative;z-index:2;opacity:0}")), document.head.appendChild(r)), window.FsLightbox = function () {
    const t = this; this.props = {
      sources: [], customAttributes: [], customClasses: [], types: [], videosPosters: [], slideDistance: 0.3,
    }, this.data = {
      isInitialized: !1, isFullscreenOpen: !1, maxSourceWidth: 0, maxSourceHeight: 0, scrollbarWidth: 0,
    }, this.sourcePointerProps = {
      downScreenX: null, isPointering: !1, isSourceDownEventTarget: !1, swipedX: 0,
    }, this.stageIndexes = {}, this.elements = {
      a: [], container: null, slideSwipingHoverer: null, sourceWrappersContainer: null, sources: [], sourceMainWrappers: [], sourceAnimationWrappers: [],
    }, this.componentsServices = {
      enterFullscreen: null, exitFullscreen: null, hideSourceLoaderIfNotYetCollection: [], setSlideNumber() {},
    }, this.resolve = function (e) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; return n.unshift(t), tt(e, rt(n)); }, this.collections = {
      sourceMainWrappersTransformers: [], sourceLoadHandlers: [], sourcesRenderFunctions: [], sourceSizers: [],
    }, this.core = {
      classFacade: {}, eventsDispatcher: {}, fullscreenToggler: {}, globalEventsController: {}, lightboxCloser: {}, lightboxOpener: {}, lightboxUpdater: {}, scrollbarRecompensor: {}, slideChangeFacade: {}, slideIndexChanger: {}, sourcesPointerDown: {}, sourceDisplayFacade: {}, stageManager: {}, windowResizeActioner: {},
    }, J(this), this.open = function (e) { return t.core.lightboxOpener.open(e); }, this.close = function () { return t.core.lightboxCloser.closeLightbox(); };
  }, window.fsLightboxInstances = {}, ot(), window.refreshFsLightbox = function () { for (const t in fsLightboxInstances) { const e = fsLightboxInstances[t].props; fsLightboxInstances[t] = new FsLightbox(), fsLightboxInstances[t].props = e, fsLightboxInstances[t].props.sources = [], fsLightboxInstances[t].elements.a = []; }ot(); };
}]))))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSSwitchText = e() : t.HSSwitchText = e(); }(window, (() => (function (t) { const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const i in t)n.d(r, i, ((e) => t[e]).bind(null, i)); return r; }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return n.d(e, "a", e), e; }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.p = "", n(n.s = "./src/js/hs-switch-text.js"); }({
  "./src/js/hs-switch-text.js":
  /*! **********************************!*\
  !*** ./src/js/hs-switch-text.js ***!
  \********************************* */
  /*! exports provided: default */function (t, e, n) {
    function r(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } }n.r(e), n.d(e, "default", (() => o)); const i = {
      target: null, eventType: "change", afterChange: null, startUpdateOnChange: !1,
    }; var o = (function () { function t(e, n, r) { let i; !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.collection = [], i = e instanceof HTMLElement ? [e] : e instanceof Object ? e : document.querySelectorAll(e); for (let o = 0; o < i.length; o += 1) this.addToCollection(i[o], n, r || i[o].id); return !!this.collection.length && (this._init(), this); } let e; let n; return e = t, (n = [{ key: "_init", value() { for (var t = this, e = function (e) { let n = void 0; let r = void 0; if (t.collection[e].hasOwnProperty("$initializedEl")) return "continue"; n = t.collection[e].$el, r = t.collection[e].options, n.addEventListener(r.eventType, (() => { for (let t = 0; t < r.target.length; t++)document.querySelector(r.target[t].selector).innerHTML = r.target[t].text; typeof r.afterChange === "function" && r.afterChange(); })), t.collection[e].$initializedEl = r; }, n = 0; n < t.collection.length; n += 1)e(n); } }, { key: "addToCollection", value(t, e, n) { this.collection.push({ $el: t, id: n || null, options: { ...i, ...(t.hasAttribute("data-hs-switch-text-options") ? JSON.parse(t.getAttribute("data-hs-switch-text-options")) : {}), ...e } }); } }, { key: "getItem", value(t) { return typeof t === "number" ? this.collection[t].$initializedEl : this.collection.find(((e) => e.id === t)).$initializedEl; } }]) && r(e.prototype, n), t; }());
  },
})).default))), (function (t, e) { typeof exports === "object" && void 0 !== module ? e(exports) : typeof define === "function" && define.amd ? define(["exports"], e) : e((t = typeof globalThis !== "undefined" ? globalThis : t || self).noUiSlider = {}); }(this, ((t) => {
  function e(t) { return typeof t === "object" && typeof t.to === "function"; } function n(t) { t.parentElement.removeChild(t); } function r(t) { return t != null; } function i(t) { t.preventDefault(); } function o(t) { return typeof t === "number" && !isNaN(t) && isFinite(t); } function s(t, e, n) { n > 0 && (c(t, e), setTimeout((() => { d(t, e); }), n)); } function a(t) { return Math.max(Math.min(t, 100), 0); } function l(t) { return Array.isArray(t) ? t : [t]; } function u(t) { return (t = (t = String(t)).split(".")).length > 1 ? t[1].length : 0; } function c(t, e) { t.classList && !/\s/.test(e) ? t.classList.add(e) : t.className += ` ${e}`; } function d(t, e) { t.classList && !/\s/.test(e) ? t.classList.remove(e) : t.className = t.className.replace(new RegExp(`(^|\\b)${e.split(" ").join("|")}(\\b|$)`, "gi"), " "); } function h(t) { const e = void 0 !== window.pageXOffset; const n = (t.compatMode || "") === "CSS1Compat"; return { x: e ? window.pageXOffset : (n ? t.documentElement : t.body).scrollLeft, y: e ? window.pageYOffset : (n ? t.documentElement : t.body).scrollTop }; } function p(t, e) { return 100 / (e - t); } function f(t, e, n) { return 100 * e / (t[n + 1] - t[n]); } function m(t, e) { for (var n = 1; t >= e[n];)n += 1; return n; }t.PipsMode = void 0, (Z = t.PipsMode || (t.PipsMode = {})).Range = "range", Z.Steps = "steps", Z.Positions = "positions", Z.Count = "count", Z.Values = "values", t.PipsType = void 0, (Z = t.PipsType || (t.PipsType = {}))[Z.None = -1] = "None", Z[Z.NoValue = 0] = "NoValue", Z[Z.LargeValue = 1] = "LargeValue", Z[Z.SmallValue = 2] = "SmallValue"; const g = (v.prototype.getDistance = function (t) { for (var e = [], n = 0; n < this.xNumSteps.length - 1; n++) { const r = this.xNumSteps[n]; if (r && t / r % 1 != 0) throw new Error(`noUiSlider: 'limit', 'margin' and 'padding' of ${this.xPct[n]}% range must be divisible by step.`); e[n] = f(this.xVal, t, n); } return e; }, v.prototype.getAbsoluteDistance = function (t, e, n) { let r = 0; if (t < this.xPct[this.xPct.length - 1]) for (;t > this.xPct[r + 1];)r++; else t === this.xPct[this.xPct.length - 1] && (r = this.xPct.length - 2); n || t !== this.xPct[r + 1] || r++; for (var i, o = 1, s = (e = e === null ? [] : e)[r], a = 0, l = 0, u = 0, c = n ? (t - this.xPct[r]) / (this.xPct[r + 1] - this.xPct[r]) : (this.xPct[r + 1] - t) / (this.xPct[r + 1] - this.xPct[r]); s > 0;)i = this.xPct[r + 1 + u] - this.xPct[r + u], e[r + u] * o + 100 - 100 * c > 100 ? (a = i * c, o = (s - 100 * c) / e[r + u], c = 1) : (a = e[r + u] * i / 100 * o, o = 0), n ? (l -= a, this.xPct.length + u >= 1 && u--) : (l += a, this.xPct.length - u >= 1 && u++), s = e[r + u] * o; return t + l; }, v.prototype.toStepping = function (t) { return (function (t, e, n) { if (n >= t.slice(-1)[0]) return 100; const r = t[(o = m(n, t)) - 1]; let i = t[o]; var o = (t = e[o - 1], e[o]); return t + (n = n, f(i = [r, i], i[0] < 0 ? n + Math.abs(i[0]) : n - i[0], 0) / p(t, o)); }(this.xVal, this.xPct, t)); }, v.prototype.fromStepping = function (t) { return (function (t, e, n) { if (n >= 100) return t.slice(-1)[0]; let r; const i = t[(r = m(n, e)) - 1]; let o = t[r]; return (n - (t = e[r - 1])) * p(t, r = e[r]) * ((o = [i, o])[1] - o[0]) / 100 + o[0]; }(this.xVal, this.xPct, t)); }, v.prototype.getStep = function (t) { return (function (t, e, n, r) { if (r === 100) return r; let i = m(r, t); const o = t[i - 1]; const s = t[i]; return n ? (s - o) / 2 < r - o ? s : o : e[i - 1] ? t[i - 1] + (t = r - t[i - 1], i = e[i - 1], Math.round(t / i) * i) : r; }(this.xPct, this.xSteps, this.snap, t)); }, v.prototype.getDefaultStep = function (t, e, n) { let r = m(t, this.xPct); return (t === 100 || e && t === this.xPct[r - 1]) && (r = Math.max(r - 1, 1)), (this.xVal[r] - this.xVal[r - 1]) / n; }, v.prototype.getNearbySteps = function (t) { return t = m(t, this.xPct), { stepBefore: { startValue: this.xVal[t - 2], step: this.xNumSteps[t - 2], highestStep: this.xHighestCompleteStep[t - 2] }, thisStep: { startValue: this.xVal[t - 1], step: this.xNumSteps[t - 1], highestStep: this.xHighestCompleteStep[t - 1] }, stepAfter: { startValue: this.xVal[t], step: this.xNumSteps[t], highestStep: this.xHighestCompleteStep[t] } }; }, v.prototype.countStepDecimals = function () { const t = this.xNumSteps.map(u); return Math.max.apply(null, t); }, v.prototype.hasNoSize = function () { return this.xVal[0] === this.xVal[this.xVal.length - 1]; }, v.prototype.convert = function (t) { return this.getStep(this.toStepping(t)); }, v.prototype.handleEntryPoint = function (t, e) { if (!o(t = t === "min" ? 0 : t === "max" ? 100 : parseFloat(t)) || !o(e[0])) throw new Error("noUiSlider: 'range' value isn't numeric."); this.xPct.push(t), this.xVal.push(e[0]), e = Number(e[1]), t ? this.xSteps.push(!isNaN(e) && e) : isNaN(e) || (this.xSteps[0] = e), this.xHighestCompleteStep.push(0); }, v.prototype.handleStepPoint = function (t, e) { e && (this.xVal[t] !== this.xVal[t + 1] ? (this.xSteps[t] = f([this.xVal[t], this.xVal[t + 1]], e, 0) / p(this.xPct[t], this.xPct[t + 1]), e = (this.xVal[t + 1] - this.xVal[t]) / this.xNumSteps[t], e = Math.ceil(Number(e.toFixed(3)) - 1), e = this.xVal[t] + this.xNumSteps[t] * e, this.xHighestCompleteStep[t] = e) : this.xSteps[t] = this.xHighestCompleteStep[t] = this.xVal[t]); }, v); function v(t, e, n) { let r; this.xPct = [], this.xVal = [], this.xSteps = [], this.xNumSteps = [], this.xHighestCompleteStep = [], this.xSteps = [n || !1], this.xNumSteps = [!1], this.snap = e; const i = []; for (Object.keys(t).forEach(((e) => { i.push([l(t[e]), e]); })), i.sort(((t, e) => t[0][0] - e[0][0])), r = 0; r < i.length; r++) this.handleEntryPoint(i[r][1], i[r][0]); for (this.xNumSteps = this.xSteps.slice(0), r = 0; r < this.xNumSteps.length; r++) this.handleStepPoint(r, this.xNumSteps[r]); } const y = { to(t) { return void 0 === t ? "" : t.toFixed(2); }, from: Number }; const _ = {
    target: "target", base: "base", origin: "origin", handle: "handle", handleLower: "handle-lower", handleUpper: "handle-upper", touchArea: "touch-area", horizontal: "horizontal", vertical: "vertical", background: "background", connect: "connect", connects: "connects", ltr: "ltr", rtl: "rtl", textDirectionLtr: "txt-dir-ltr", textDirectionRtl: "txt-dir-rtl", draggable: "draggable", drag: "state-drag", tap: "state-tap", active: "active", tooltip: "tooltip", pips: "pips", pipsHorizontal: "pips-horizontal", pipsVertical: "pips-vertical", marker: "marker", markerHorizontal: "marker-horizontal", markerVertical: "marker-vertical", markerNormal: "marker-normal", markerLarge: "marker-large", markerSub: "marker-sub", value: "value", valueHorizontal: "value-horizontal", valueVertical: "value-vertical", valueNormal: "value-normal", valueLarge: "value-large", valueSub: "value-sub",
  }; const b = ".__tooltips"; const w = ".__aria"; function x(t, e) { if (!o(e)) throw new Error("noUiSlider: 'step' is not numeric."); t.singleStep = e; } function S(t, e) { if (!o(e)) throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric."); t.keyboardPageMultiplier = e; } function k(t, e) { if (!o(e)) throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric."); t.keyboardMultiplier = e; } function C(t, e) { if (!o(e)) throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric."); t.keyboardDefaultStep = e; } function E(t, e) { if (typeof e !== "object" || Array.isArray(e)) throw new Error("noUiSlider: 'range' is not an object."); if (void 0 === e.min || void 0 === e.max) throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'."); t.spectrum = new g(e, t.snap || !1, t.singleStep); } function T(t, e) { if (e = l(e), !Array.isArray(e) || !e.length) throw new Error("noUiSlider: 'start' option is incorrect."); t.handles = e.length, t.start = e; } function P(t, e) { if (typeof e !== "boolean") throw new Error("noUiSlider: 'snap' option must be a boolean."); t.snap = e; } function O(t, e) { if (typeof e !== "boolean") throw new Error("noUiSlider: 'animate' option must be a boolean."); t.animate = e; } function A(t, e) { if (typeof e !== "number") throw new Error("noUiSlider: 'animationDuration' option must be a number."); t.animationDuration = e; } function M(t, e) { let n; let r = [!1]; if (e === "lower" ? e = [!0, !1] : e === "upper" && (e = [!1, !0]), !0 === e || !1 === e) { for (n = 1; n < t.handles; n++)r.push(e); r.push(!1); } else { if (!Array.isArray(e) || !e.length || e.length !== t.handles + 1) throw new Error("noUiSlider: 'connect' option doesn't match handle count."); r = e; }t.connect = r; } function L(t, e) { switch (e) { case "horizontal": t.ort = 0; break; case "vertical": t.ort = 1; break; default: throw new Error("noUiSlider: 'orientation' option is invalid."); } } function I(t, e) { if (!o(e)) throw new Error("noUiSlider: 'margin' option must be numeric."); e !== 0 && (t.margin = t.spectrum.getDistance(e)); } function j(t, e) { if (!o(e)) throw new Error("noUiSlider: 'limit' option must be numeric."); if (t.limit = t.spectrum.getDistance(e), !t.limit || t.handles < 2) throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles."); } function D(t, e) { let n; if (!o(e) && !Array.isArray(e)) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers."); if (Array.isArray(e) && e.length !== 2 && !o(e[0]) && !o(e[1])) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers."); if (e !== 0) { for (Array.isArray(e) || (e = [e, e]), t.padding = [t.spectrum.getDistance(e[0]), t.spectrum.getDistance(e[1])], n = 0; n < t.spectrum.xNumSteps.length - 1; n++) if (t.padding[0][n] < 0 || t.padding[1][n] < 0) throw new Error("noUiSlider: 'padding' option must be a positive number(s)."); const r = e[0] + e[1]; e = t.spectrum.xVal[0]; if (r / (t.spectrum.xVal[t.spectrum.xVal.length - 1] - e) > 1) throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range."); } } function N(t, e) { switch (e) { case "ltr": t.dir = 0; break; case "rtl": t.dir = 1; break; default: throw new Error("noUiSlider: 'direction' option was not recognized."); } } function R(t, e) {
    if (typeof e !== "string") throw new Error("noUiSlider: 'behaviour' must be a string containing options."); const n = e.indexOf("tap") >= 0; const r = e.indexOf("drag") >= 0; const i = e.indexOf("fixed") >= 0; const o = e.indexOf("snap") >= 0; const s = e.indexOf("hover") >= 0; const a = e.indexOf("unconstrained") >= 0; e = e.indexOf("drag-all") >= 0; if (i) { if (t.handles !== 2) throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles"); I(t, t.start[1] - t.start[0]); } if (a && (t.margin || t.limit)) throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit"); t.events = {
      tap: n || o, drag: r, dragAll: e, fixed: i, snap: o, hover: s, unconstrained: a,
    };
  } function F(t, n) { if (!1 !== n) if (!0 === n || e(n)) { t.tooltips = []; for (let r = 0; r < t.handles; r++)t.tooltips.push(n); } else { if ((n = l(n)).length !== t.handles) throw new Error("noUiSlider: must pass a formatter for all handles."); n.forEach(((t) => { if (typeof t !== "boolean" && !e(t)) throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'."); })), t.tooltips = n; } } function V(t, e) { if (e.length !== t.handles) throw new Error("noUiSlider: must pass a attributes for all handles."); t.handleAttributes = e; } function z(t, n) { if (!e(n)) throw new Error("noUiSlider: 'ariaFormat' requires 'to' method."); t.ariaFormat = n; } function B(t, n) { if (!e(r = n) || typeof r.from !== "function") throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods."); let r; t.format = n; } function q(t, e) { if (typeof e !== "boolean") throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean."); t.keyboardSupport = e; } function H(t, e) { t.documentElement = e; } function $(t, e) { if (typeof e !== "string" && !1 !== e) throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`."); t.cssPrefix = e; } function U(t, e) { if (typeof e !== "object") throw new Error("noUiSlider: 'cssClasses' must be an object."); typeof t.cssPrefix === "string" ? (t.cssClasses = {}, Object.keys(e).forEach(((n) => { t.cssClasses[n] = t.cssPrefix + e[n]; }))) : t.cssClasses = e; } function W(t) {
    const e = {
      margin: null, limit: null, padding: null, animate: !0, animationDuration: 300, ariaFormat: y, format: y,
    }; const n = {
      step: { r: !1, t: x }, keyboardPageMultiplier: { r: !1, t: S }, keyboardMultiplier: { r: !1, t: k }, keyboardDefaultStep: { r: !1, t: C }, start: { r: !0, t: T }, connect: { r: !0, t: M }, direction: { r: !0, t: N }, snap: { r: !1, t: P }, animate: { r: !1, t: O }, animationDuration: { r: !1, t: A }, range: { r: !0, t: E }, orientation: { r: !1, t: L }, margin: { r: !1, t: I }, limit: { r: !1, t: j }, padding: { r: !1, t: D }, behaviour: { r: !0, t: R }, ariaFormat: { r: !1, t: z }, format: { r: !1, t: B }, tooltips: { r: !1, t: F }, keyboardSupport: { r: !0, t: q }, documentElement: { r: !1, t: H }, cssPrefix: { r: !0, t: $ }, cssClasses: { r: !0, t: U }, handleAttributes: { r: !1, t: V },
    }; const i = {
      connect: !1, direction: "ltr", behaviour: "tap", orientation: "horizontal", keyboardSupport: !0, cssPrefix: "noUi-", cssClasses: _, keyboardPageMultiplier: 5, keyboardMultiplier: 1, keyboardDefaultStep: 10,
    }; t.format && !t.ariaFormat && (t.ariaFormat = t.format), Object.keys(n).forEach(((o) => { if (r(t[o]) || void 0 !== i[o])n[o].t(e, (r(t[o]) ? t : i)[o]); else if (n[o].r) throw new Error(`noUiSlider: '${o}' is required.`); })), e.pips = t.pips; const o = void 0 !== (s = document.createElement("div")).style.msTransform; var s = void 0 !== s.style.transform; return e.transformRule = s ? "transform" : o ? "msTransform" : "webkitTransform", e.style = [["left", "top"], ["right", "bottom"]][e.dir][e.ort], e;
  } function G(e, o, u) {
    let p; let f; let m; let g; let v; let y; let _; const x = window.navigator.pointerEnabled ? { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled ? { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" } : { start: "mousedown touchstart", move: "mousemove touchmove", end: "mouseup touchend" }; const S = window.CSS && CSS.supports && CSS.supports("touch-action", "none") && (function () { let t = !1; try { const e = Object.defineProperty({}, "passive", { get() { t = !0; } }); window.addEventListener("test", null, e); } catch (t) {} return t; }()); const k = e; let C = o.spectrum; const E = []; let T = []; const P = []; let O = 0; const A = {}; const M = e.ownerDocument; const L = o.documentElement || M.documentElement; const I = M.body; const j = M.dir === "rtl" || o.ort === 1 ? 0 : 100; function D(t, e) { const n = M.createElement("div"); return e && c(n, e), t.appendChild(n), n; } function N(t, e) { t = D(t, o.cssClasses.origin); let n; const r = D(t, o.cssClasses.handle); return D(r, o.cssClasses.touchArea), r.setAttribute("data-handle", String(e)), o.keyboardSupport && (r.setAttribute("tabindex", "0"), r.addEventListener("keydown", ((t) => (function (t, e) { if (V() || z(e)) return !1; let n = ["Left", "Right"]; let r = ["Down", "Up"]; let i = ["PageDown", "PageUp"]; let s = ["Home", "End"]; o.dir && !o.ort ? n.reverse() : o.ort && !o.dir && (r.reverse(), i.reverse()); const a = t.key.replace("Arrow", ""); const l = a === i[0]; const u = a === i[1]; i = a === r[0] || a === n[0] || l, r = a === r[1] || a === n[1] || u, n = a === s[0], s = a === s[1]; if (!(i || r || n || s)) return !0; if (t.preventDefault(), r || i) { var c = i ? 0 : 1; if ((c = pt(e)[c]) === null) return !1; !1 === c && (c = C.getDefaultStep(T[e], i, o.keyboardDefaultStep)), c *= u || l ? o.keyboardPageMultiplier : o.keyboardMultiplier, c = Math.max(c, 1e-7), c *= i ? -1 : 1, c = E[e] + c; } else c = s ? o.spectrum.xVal[o.spectrum.xVal.length - 1] : o.spectrum.xVal[0]; return lt(e, C.toStepping(c), !0, !0), nt("slide", e), nt("update", e), nt("change", e), nt("set", e), !1; }(t, e))))), void 0 !== o.handleAttributes && (n = o.handleAttributes[e], Object.keys(n).forEach(((t) => { r.setAttribute(t, n[t]); }))), r.setAttribute("role", "slider"), r.setAttribute("aria-orientation", o.ort ? "vertical" : "horizontal"), e === 0 ? c(r, o.cssClasses.handleLower) : e === o.handles - 1 && c(r, o.cssClasses.handleUpper), t; } function R(t, e) { return !!e && D(t, o.cssClasses.connect); } function F(t, e) { return !(!o.tooltips || !o.tooltips[e]) && D(t.firstChild, o.cssClasses.tooltip); } function V() { return k.hasAttribute("disabled"); } function z(t) { return f[t].hasAttribute("disabled"); } function B() { v && (et(`update${b}`), v.forEach(((t) => { t && n(t); })), v = null); } function q() { B(), v = f.map(F), tt(`update${b}`, ((t, e, n) => { v && o.tooltips && !1 !== v[e] && (t = t[e], !0 !== o.tooltips[e] && (t = o.tooltips[e].to(n[e])), v[e].innerHTML = t); })); } function H(t, e) { return t.map(((t) => C.fromStepping(e ? C.getStep(t) : t))); } function $() { g && (n(g), g = null); } function U(e) { $(); const n = (function (e) { let n = (function (e) { if (e.mode === t.PipsMode.Range || e.mode === t.PipsMode.Steps) return C.xVal; if (e.mode !== t.PipsMode.Count) return e.mode === t.PipsMode.Positions ? H(e.values, e.stepped) : e.mode === t.PipsMode.Values ? e.stepped ? e.values.map(((t) => C.fromStepping(C.getStep(C.toStepping(t))))) : e.values : []; if (e.values < 2) throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'."); for (var n = e.values - 1, r = 100 / n, i = []; n--;)i[n] = n * r; return i.push(100), H(i, e.stepped); }(e)); const r = {}; const i = C.xVal[0]; const o = C.xVal[C.xVal.length - 1]; let s = !1; let a = !1; let l = 0; return (n = n.slice().sort(((t, e) => t - e)).filter((function (t) { return !this[t] && (this[t] = !0); }), {}))[0] !== i && (n.unshift(i), s = !0), n[n.length - 1] !== o && (n.push(o), a = !0), n.forEach(((i, o) => { i = i; let u; let c; let d; let h; let p; let f; let m; let g; let v = n[o + 1]; const y = e.mode === t.PipsMode.Steps; var _ = (_ = y ? C.xNumSteps[o] : _) || v - i; for (void 0 === v && (v = i), _ = Math.max(_, 1e-7), u = i; u <= v; u = Number((u + _).toFixed(7))) { for (f = (h = (d = C.toStepping(u)) - l) / (e.density || 1), g = h / (m = Math.round(f)), c = 1; c <= m; c += 1)r[(p = l + c * g).toFixed(5)] = [C.fromStepping(p), 0]; f = n.indexOf(u) > -1 ? t.PipsType.LargeValue : y ? t.PipsType.SmallValue : t.PipsType.NoValue, !o && s && u !== v && (f = 0), u === v && a || (r[d.toFixed(5)] = [u, f]), l = d; } })), r; }(e)); const r = e.filter; e = e.format || { to(t) { return String(Math.round(t)); } }; return g = k.appendChild(function (e, n, r) { let i; const s = M.createElement("div"); const a = ((i = {})[t.PipsType.None] = "", i[t.PipsType.NoValue] = o.cssClasses.valueNormal, i[t.PipsType.LargeValue] = o.cssClasses.valueLarge, i[t.PipsType.SmallValue] = o.cssClasses.valueSub, i); const l = ((i = {})[t.PipsType.None] = "", i[t.PipsType.NoValue] = o.cssClasses.markerNormal, i[t.PipsType.LargeValue] = o.cssClasses.markerLarge, i[t.PipsType.SmallValue] = o.cssClasses.markerSub, i); const u = [o.cssClasses.valueHorizontal, o.cssClasses.valueVertical]; const d = [o.cssClasses.markerHorizontal, o.cssClasses.markerVertical]; function h(t, e) { const n = e === o.cssClasses.value; return `${e} ${(n ? u : d)[o.ort]} ${(n ? a : l)[t]}`; } return c(s, o.cssClasses.pips), c(s, o.ort === 0 ? o.cssClasses.pipsHorizontal : o.cssClasses.pipsVertical), Object.keys(e).forEach(((i) => { let a; let l; let u; l = e[a = i][0], u = e[i][1], (u = n ? n(l, u) : u) !== t.PipsType.None && ((i = D(s, !1)).className = h(u, o.cssClasses.marker), i.style[o.style] = `${a}%`, u > t.PipsType.NoValue && ((i = D(s, !1)).className = h(u, o.cssClasses.value), i.setAttribute("data-value", String(l)), i.style[o.style] = `${a}%`, i.innerHTML = String(r.to(l)))); })), s; }(n, r, e)); } function G() { const t = p.getBoundingClientRect(); const e = `offset${["Width", "Height"][o.ort]}`; return o.ort === 0 ? t.width || p[e] : t.height || p[e]; } function Y(t, e, n, r) { function i(i) { let s; const a = (function (t, e, n) { let r = t.type.indexOf("touch") === 0; const i = t.type.indexOf("mouse") === 0; let o = t.type.indexOf("pointer") === 0; let s = 0; let a = 0; if (t.type.indexOf("MSPointer") === 0 && (o = !0), t.type === "mousedown" && !t.buttons && !t.touches) return !1; if (r) { let l = function (e) { return (e = e.target) === n || n.contains(e) || t.composed && t.composedPath().shift() === n; }; if (t.type === "touchstart") { if ((r = Array.prototype.filter.call(t.touches, l)).length > 1) return !1; s = r[0].pageX, a = r[0].pageY; } else { if (!(l = Array.prototype.find.call(t.changedTouches, l))) return !1; s = l.pageX, a = l.pageY; } } return e = e || h(M), (i || o) && (s = t.clientX + e.x, a = t.clientY + e.y), t.pageOffset = e, t.points = [s, a], t.cursor = i || o, t; }(i, r.pageOffset, r.target || e)); return !!a && !(V() && !r.doNotReject) && (s = k, i = o.cssClasses.tap, !((s.classList ? s.classList.contains(i) : new RegExp(`\\b${i}\\b`).test(s.className)) && !r.doNotReject) && !(t === x.start && void 0 !== a.buttons && a.buttons > 1) && (!r.hover || !a.buttons) && (S || a.preventDefault(), a.calcPoint = a.points[o.ort], void n(a, r))); } const s = []; return t.split(" ").forEach(((t) => { e.addEventListener(t, i, !!S && { passive: !0 }), s.push([t, i]); })), s; } function Z(t) { let e; let n; var r = a(r = 100 * (t - (r = p, e = o.ort, n = r.getBoundingClientRect(), r = (t = r.ownerDocument).documentElement, t = h(t), /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (t.x = 0), e ? n.top + t.y - r.clientTop : n.left + t.x - r.clientLeft)) / G()); return o.dir ? 100 - r : r; } function K(t, e) { t.type === "mouseout" && t.target.nodeName === "HTML" && t.relatedTarget === null && Q(t, e); } function X(t, e) { if (navigator.appVersion.indexOf("MSIE 9") === -1 && t.buttons === 0 && e.buttonsProperty !== 0) return Q(t, e); ot((t = (o.dir ? -1 : 1) * (t.calcPoint - e.startCalcPoint)) > 0, 100 * t / e.baseSize, e.locations, e.handleNumbers, e.connect); } function Q(t, e) { e.handle && (d(e.handle, o.cssClasses.active), --O), e.listeners.forEach(((t) => { L.removeEventListener(t[0], t[1]); })), O === 0 && (d(k, o.cssClasses.drag), at(), t.cursor && (I.style.cursor = "", I.removeEventListener("selectstart", i))), e.handleNumbers.forEach(((t) => { nt("change", t), nt("set", t), nt("end", t); })); } function J(t, e) {
      let n; let r; let s; let a; e.handleNumbers.some(z) || (e.handleNumbers.length === 1 && (a = f[e.handleNumbers[0]].children[0], O += 1, c(a, o.cssClasses.active)), t.stopPropagation(), r = Y(x.move, L, X, {
        target: t.target, handle: a, connect: e.connect, listeners: n = [], startCalcPoint: t.calcPoint, baseSize: G(), pageOffset: t.pageOffset, handleNumbers: e.handleNumbers, buttonsProperty: t.buttons, locations: T.slice(),
      }), s = Y(x.end, L, Q, {
        target: t.target, handle: a, listeners: n, doNotReject: !0, handleNumbers: e.handleNumbers,
      }), a = Y("mouseout", L, K, {
        target: t.target, handle: a, listeners: n, doNotReject: !0, handleNumbers: e.handleNumbers,
      }), n.push.apply(n, r.concat(s, a)), t.cursor && (I.style.cursor = getComputedStyle(t.target).cursor, f.length > 1 && c(k, o.cssClasses.drag), I.addEventListener("selectstart", i, !1)), e.handleNumbers.forEach(((t) => { nt("start", t); })));
    } function tt(t, e) { A[t] = A[t] || [], A[t].push(e), t.split(".")[0] === "update" && f.forEach(((t, e) => { nt("update", e); })); } function et(t) { const e = t && t.split(".")[0]; const n = e ? t.substring(e.length) : t; Object.keys(A).forEach(((t) => { let r = t.split(".")[0]; const i = t.substring(r.length); e && e !== r || n && n !== i || ((r = i) !== w && r !== b || n === i) && delete A[t]; })); } function nt(t, e, n) { Object.keys(A).forEach(((r) => { const i = r.split(".")[0]; t === i && A[r].forEach(((t) => { t.call(ft, E.map(o.format.to), e, E.slice(), n || !1, T.slice(), ft); })); })); } function rt(t, e, n, r, i, s) { let l; return f.length > 1 && !o.events.unconstrained && (r && e > 0 && (l = C.getAbsoluteDistance(t[e - 1], o.margin, !1), n = Math.max(n, l)), i && e < f.length - 1 && (l = C.getAbsoluteDistance(t[e + 1], o.margin, !0), n = Math.min(n, l))), f.length > 1 && o.limit && (r && e > 0 && (l = C.getAbsoluteDistance(t[e - 1], o.limit, !1), n = Math.min(n, l)), i && e < f.length - 1 && (l = C.getAbsoluteDistance(t[e + 1], o.limit, !0), n = Math.max(n, l))), o.padding && (e === 0 && (l = C.getAbsoluteDistance(0, o.padding[0], !1), n = Math.max(n, l)), e === f.length - 1 && (l = C.getAbsoluteDistance(100, o.padding[1], !0), n = Math.min(n, l))), !((n = a(n = C.getStep(n))) === t[e] && !s) && n; } function it(t, e) { const n = o.ort; return `${n ? e : t}, ${n ? t : e}`; } function ot(t, e, n, r, i) { const o = n.slice(); const s = r[0]; let a = [!t, t]; let l = [t, !t]; r = r.slice(), t && r.reverse(), r.length > 1 ? r.forEach(((t, n) => { !1 === (n = rt(o, t, o[t] + e, a[n], l[n], !1)) ? e = 0 : (e = n - o[t], o[t] = n); })) : a = l = [!0]; let u = !1; r.forEach(((t, r) => { u = lt(t, n[t] + e, a[r], l[r]) || u; })), u && (r.forEach(((t) => { nt("update", t), nt("slide", t); })), i != null && nt("drag", s)); } function st(t, e) { return o.dir ? 100 - t - e : t; } function at() { P.forEach(((t) => { let e = T[t] > 50 ? -1 : 1; e = 3 + (f.length + e * t); f[t].style.zIndex = String(e); })); } function lt(t, e, n, r, i) { return !1 !== (e = i ? e : rt(T, t, e, n, r, !1)) && (e = e, T[t = t] = e, E[t] = C.fromStepping(e), e = `translate(${it(`${10 * (st(e, 0) - j)}%`, "0")})`, f[t].style[o.transformRule] = e, ut(t), ut(t + 1), !0); } function ut(t) { let e; let n; m[t] && (n = 100, e = `translate(${it(`${st(e = (e = 0) !== t ? T[t - 1] : e, n = (n = t !== m.length - 1 ? T[t] : n) - e)}%`, "0")})`, n = `scale(${it(n / 100, "1")})`, m[t].style[o.transformRule] = `${e} ${n}`); } function ct(t, e) { return t === null || !1 === t || void 0 === t ? T[e] : (typeof t === "number" && (t = String(t)), !1 === (t = !1 !== (t = o.format.from(t)) ? C.toStepping(t) : t) || isNaN(t) ? T[e] : t); } function dt(t, e, n) { const r = l(t); t = void 0 === T[0]; e = void 0 === e || e, o.animate && !t && s(k, o.cssClasses.tap, o.animationDuration), P.forEach(((t) => { lt(t, ct(r[t], t), !0, !1, n); })); let i; let a = P.length === 1 ? 0 : 1; for (t && C.hasNoSize() && (n = !0, T[0] = 0, P.length > 1 && (i = 100 / (P.length - 1), P.forEach(((t) => { T[t] = t * i; })))); a < P.length; ++a)P.forEach(((t) => { lt(t, T[t], !0, !0, n); })); at(), P.forEach(((t) => { nt("update", t), r[t] !== null && e && nt("set", t); })); } function ht(t) { return (t = void 0 !== t && t) ? E.length === 1 ? E[0] : E.slice(0) : (t = E.map(o.format.to)).length === 1 ? t[0] : t; } function pt(t) { let e = T[t]; const n = C.getNearbySteps(e); const r = E[t]; let i = n.thisStep.step; t = null; return o.snap ? [r - n.stepBefore.startValue || null, n.stepAfter.startValue - r || null] : (!1 !== i && r + i > n.stepAfter.startValue && (i = n.stepAfter.startValue - r), t = r > n.thisStep.startValue ? n.thisStep.step : !1 !== n.stepBefore.step && r - n.stepBefore.highestStep, e === 100 ? i = null : e === 0 && (t = null), e = C.countStepDecimals(), i !== null && !1 !== i && (i = Number(i.toFixed(e))), [t = t !== null && !1 !== t ? Number(t.toFixed(e)) : t, i]); }c(y = k, o.cssClasses.target), o.dir === 0 ? c(y, o.cssClasses.ltr) : c(y, o.cssClasses.rtl), o.ort === 0 ? c(y, o.cssClasses.horizontal) : c(y, o.cssClasses.vertical), c(y, getComputedStyle(y).direction === "rtl" ? o.cssClasses.textDirectionRtl : o.cssClasses.textDirectionLtr), p = D(y, o.cssClasses.base), (function (t, e) { const n = D(e, o.cssClasses.connects); f = [], (m = []).push(R(n, t[0])); for (let r = 0; r < o.handles; r++)f.push(N(e, r)), P[r] = r, m.push(R(n, t[r + 1])); }(o.connect, p)), (_ = o.events).fixed || f.forEach(((t, e) => { Y(x.start, t.children[0], J, { handleNumbers: [e] }); })), _.tap && Y(x.start, p, ((t) => { t.stopPropagation(); let e; let n; let r; const i = Z(t.calcPoint); const a = (e = i, r = !(n = 100), f.forEach(((t, i) => { let o; let s; z(i) || (o = T[i], ((s = Math.abs(o - e)) < n || s <= n && o < e || s === 100 && n === 100) && (r = i, n = s)); })), r); !1 !== a && (o.events.snap || s(k, o.cssClasses.tap, o.animationDuration), lt(a, i, !0, !0), at(), nt("slide", a, !0), nt("update", a, !0), o.events.snap ? J(t, { handleNumbers: [a] }) : (nt("change", a, !0), nt("set", a, !0))); }), {}), _.hover && Y(x.move, p, ((t) => { t = Z(t.calcPoint), t = C.getStep(t); const e = C.fromStepping(t); Object.keys(A).forEach(((t) => { t.split(".")[0] === "hover" && A[t].forEach(((t) => { t.call(ft, e); })); })); }), { hover: !0 }), _.drag && m.forEach(((t, e) => { let n; let r; let i; let s; let a; !1 !== t && e !== 0 && e !== m.length - 1 && (n = f[e - 1], r = f[e], i = [t], s = [n, r], a = [e - 1, e], c(t, o.cssClasses.draggable), _.fixed && (i.push(n.children[0]), i.push(r.children[0])), _.dragAll && (s = f, a = P), i.forEach(((e) => { Y(x.start, e, J, { handles: s, handleNumbers: a, connect: t }); }))); })), dt(o.start), o.pips && U(o.pips), o.tooltips && q(), et(`update${w}`), tt(`update${w}`, ((t, e, n, r, i) => { P.forEach(((t) => { const e = f[t]; let r = rt(T, t, 0, !0, !0, !0); let s = rt(T, t, 100, !0, !0, !0); let a = i[t]; t = String(o.ariaFormat.to(n[t])), r = C.fromStepping(r).toFixed(1), s = C.fromStepping(s).toFixed(1), a = C.fromStepping(a).toFixed(1); e.children[0].setAttribute("aria-valuemin", r), e.children[0].setAttribute("aria-valuemax", s), e.children[0].setAttribute("aria-valuenow", a), e.children[0].setAttribute("aria-valuetext", t); })); })); var ft = {
      destroy() { for (et(w), et(b), Object.keys(o.cssClasses).forEach(((t) => { d(k, o.cssClasses[t]); })); k.firstChild;)k.removeChild(k.firstChild); delete k.noUiSlider; }, steps() { return P.map(pt); }, on: tt, off: et, get: ht, set: dt, setHandle(t, e, n, r) { if (!((t = Number(t)) >= 0 && t < P.length)) throw new Error(`noUiSlider: invalid handle number, got: ${t}`); lt(t, ct(e, t), !0, !0, r), nt("update", t), n && nt("set", t); }, reset(t) { dt(o.start, t); }, __moveHandles(t, e, n) { ot(t, e, T, n); }, options: u, updateOptions(t, e) { const n = ht(); const i = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"]; i.forEach(((e) => { void 0 !== t[e] && (u[e] = t[e]); })); const s = W(u); i.forEach(((e) => { void 0 !== t[e] && (o[e] = s[e]); })), C = s.spectrum, o.margin = s.margin, o.limit = s.limit, o.padding = s.padding, o.pips ? U(o.pips) : $(), (o.tooltips ? q : B)(), T = [], dt(r(t.start) ? t.start : n, e); }, target: k, removePips: $, removeTooltips: B, getPositions() { return T.slice(); }, getTooltips() { return v; }, getOrigins() { return f; }, pips: U,
    }; return ft;
  } function Y(t, e) { if (!t || !t.nodeName) throw new Error(`noUiSlider: create requires a single element, got: ${t}`); if (t.noUiSlider) throw new Error("noUiSlider: Slider was already initialized."); return e = G(t, W(e), e), t.noUiSlider = e; } var Z = { __spectrum: g, cssClasses: _, create: Y }; t.create = Y, t.cssClasses = _, t.default = Z, Object.defineProperty(t, "__esModule", { value: !0 });
}))), appear = (function () {
  let t = null; let e = 0; const n = {}; return addEventListener("scroll", (() => { const r = window.scrollY || window.pageYOffset; t != null && (n.velocity = r - t, n.delta = n.velocity >= 0 ? n.velocity : -1 * n.velocity), t = r, e && clearTimeout(e), e = setTimeout((() => { t = null; }), 30); }), !1), function (t) {
    return (function () {
      function t() { n.delta < m.delta.speed && (l || (l = !0, i(), setTimeout((() => { l = !1; }), m.delta.timeout))), (function (t, e) { return function () { const n = this; const r = arguments; clearTimeout(a), a = setTimeout((() => { t.apply(n, r); }), e); }; }((() => { i(); }), m.debounce))(); } function e() { i(), addEventListener("scroll", t, !1), addEventListener("resize", t, !1); } function r() { removeEventListener("scroll", t, !1), removeEventListener("resize", t, !1); } function i() { u || (d.forEach(((t, e) => { t && (function (t, e) { const n = t.getBoundingClientRect(); return n.top + n.height >= 0 && n.left + n.width >= 0 && n.bottom - n.height <= (window.innerHeight || document.documentElement.clientHeight) + e && n.right - n.width <= (window.innerWidth || document.documentElement.clientWidth) + e; }(t, m.bounds)) ? h[e] && (h[e] = !1, p++, m.appear && m.appear(t), m.disappear || m.reappear || (d[e] = null)) : (!1 === h[e] && (m.disappear && m.disappear(t), f++, m.reappear || (d[e] = null)), h[e] = !0); })), m.reappear || m.appear && (!m.appear || p !== s) || m.disappear && (!m.disappear || f !== s) || (u = !0, r(), m.done && m.done())); } function o() { let t; if (!c && (c = !0, m.init && m.init(), t = typeof m.elements === "function" ? m.elements() : m.elements)) { s = t.length; for (let n = 0; s > n; n += 1)d.push(t[n]), h.push(!0); e(); } } let s; let a; let l; let u; var c = !1; var d = []; var h = []; var p = 0; var f = 0; var m = {}; return function (t) {
        return m = {
          init: (t = t || {}).init, elements: t.elements, appear: t.appear, disappear: t.disappear, done: t.done, reappear: t.reappear, bounds: t.bounds || 0, debounce: t.debounce || 50, delta: { speed: t.deltaSpeed || 50, timeout: t.deltaTimeout || 500 },
        }, addEventListener("DOMContentLoaded", o, !1), (document.readyState === "complete" || document.readyState === "loaded" || document.readyState === "interactive") && o(), {
          trigger() { i(); }, pause() { r(); }, resume() { e(); }, destroy() { d = [], a && clearTimeout(a), r(); },
        };
      };
    }())(t);
  };
}()), (function (t, e) { typeof exports === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : t.Circles = e(); }(this, (() => {
  const t = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { setTimeout(t, 1e3 / 60); }; const e = function (t) { const e = t.id; if (this._el = document.getElementById(e), this._el !== null) { this._radius = t.radius || 10, this._duration = void 0 === t.duration ? 500 : t.duration, this._value = 1e-7, this._maxValue = t.maxValue || 100, this._text = void 0 === t.text ? function (t) { return this.htmlifyNumber(t); } : t.text, this._strokeWidth = t.width || 10, this._colors = t.colors || ["#EEE", "#F00"], this._svg = null, this._movingPath = null, this._wrapContainer = null, this._textContainer = null, this._wrpClass = t.wrpClass || "circles-wrp", this._textClass = t.textClass || "circles-text", this._valClass = t.valueStrokeClass || "circles-valueStroke", this._maxValClass = t.maxValueStrokeClass || "circles-maxValueStroke", this._styleWrapper = !1 !== t.styleWrapper, this._styleText = !1 !== t.styleText; const n = Math.PI / 180 * 270; this._start = -Math.PI / 180 * 90, this._startPrecise = this._precise(this._start), this._circ = n - this._start, this._generate().update(t.value || 0); } }; return e.prototype = {
    VERSION: "0.0.6",
    _generate() { return this._svgSize = 2 * this._radius, this._radiusAdjusted = this._radius - this._strokeWidth / 2, this._generateSvg()._generateText()._generateWrapper(), this._el.innerHTML = "", this._el.appendChild(this._wrapContainer), this; },
    _setPercentage(t) { this._movingPath.setAttribute("d", this._calculatePath(t, !0)), this._textContainer.innerHTML = this._getText(this.getValueFromPercent(t)); },
    _generateWrapper() { return this._wrapContainer = document.createElement("div"), this._wrapContainer.className = this._wrpClass, this._styleWrapper && (this._wrapContainer.style.position = "relative", this._wrapContainer.style.display = "inline-block"), this._wrapContainer.appendChild(this._svg), this._wrapContainer.appendChild(this._textContainer), this; },
    _generateText() {
      if (this._textContainer = document.createElement("div"), this._textContainer.className = this._textClass, this._styleText) {
        const t = {
          position: "absolute", top: 0, left: 0, textAlign: "center", width: "100%", fontSize: `${0.7 * this._radius}px`, height: `${this._svgSize}px`, lineHeight: `${this._svgSize}px`,
        }; for (const e in t) this._textContainer.style[e] = t[e];
      } return this._textContainer.innerHTML = this._getText(0), this;
    },
    _getText(t) { return this._text ? (void 0 === t && (t = this._value), t = parseFloat(t.toFixed(2)), typeof this._text === "function" ? this._text.call(this, t) : this._text) : ""; },
    _generateSvg() { return this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._svg.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this._svg.setAttribute("width", this._svgSize), this._svg.setAttribute("height", this._svgSize), this._generatePath(100, !1, this._colors[0], this._maxValClass)._generatePath(1, !0, this._colors[1], this._valClass), this._movingPath = this._svg.getElementsByTagName("path")[1], this; },
    _generatePath(t, e, n, r) { const i = document.createElementNS("http://www.w3.org/2000/svg", "path"); return i.setAttribute("fill", "transparent"), i.setAttribute("stroke", n), i.setAttribute("stroke-width", this._strokeWidth), i.setAttribute("d", this._calculatePath(t, e)), i.setAttribute("class", r), this._svg.appendChild(i), this; },
    _calculatePath(t, e) { const n = this._start + t / 100 * this._circ; const r = this._precise(n); return this._arc(r, e); },
    _arc(t, e) { const n = t - 0.001; const r = t - this._startPrecise < Math.PI ? 0 : 1; return ["M", this._radius + this._radiusAdjusted * Math.cos(this._startPrecise), this._radius + this._radiusAdjusted * Math.sin(this._startPrecise), "A", this._radiusAdjusted, this._radiusAdjusted, 0, r, 1, this._radius + this._radiusAdjusted * Math.cos(n), this._radius + this._radiusAdjusted * Math.sin(n), e ? "" : "Z"].join(" "); },
    _precise(t) { return Math.round(1e3 * t) / 1e3; },
    htmlifyNumber(t, e, n) { e = e || "circles-integer", n = n || "circles-decimals"; const r = (`${t}`).split("."); let i = `<span class="${e}">${r[0]}</span>`; return r.length > 1 && (i += `.<span class="${n}">${r[1].substring(0, 2)}</span>`), i; },
    updateRadius(t) { return this._radius = t, this._generate().update(!0); },
    updateWidth(t) { return this._strokeWidth = t, this._generate().update(!0); },
    updateColors(t) { this._colors = t; const e = this._svg.getElementsByTagName("path"); return e[0].setAttribute("stroke", t[0]), e[1].setAttribute("stroke", t[1]), this; },
    getPercent() { return 100 * this._value / this._maxValue; },
    getValueFromPercent(t) { return this._maxValue * t / 100; },
    getValue() { return this._value; },
    getMaxValue() { return this._maxValue; },
    update(e, n) { if (!0 === e) return this._setPercentage(this.getPercent()), this; if (this._value == e || isNaN(e)) return this; void 0 === n && (n = this._duration); let r; let i; let o; let s; const a = this; let l = a.getPercent(); let u = 1; return this._value = Math.min(this._maxValue, Math.max(0, e)), n ? (r = a.getPercent(), i = r > l, u += r % 1, o = Math.floor(Math.abs(r - l) / u), s = n / o, (function e(n) { if (i ? l += u : l -= u, i && l >= r || !i && l <= r)t((() => { a._setPercentage(r); })); else { t((() => { a._setPercentage(l); })); const o = Date.now(); const c = o - n; c >= s ? e(o) : setTimeout((() => { e(Date.now()); }), s - c); } }(Date.now())), this) : (this._setPercentage(this.getPercent()), this); },
  }, e.create = function (t) { return new e(t); }, e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSVideoBg = e() : t.HSVideoBg = e(); }(window, (() => {
  return d = {
    "./src/js/hs-video-bg.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HSVideoBg; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/js/utils/index.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSVideoBg Plugin\n* @version: 3.0.0 (Wed, 17 Mar 2021)\n* @author: HtmlStream\n* @event-namespace: .HSVideoBg\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\n\n\nvar HSVideoBg = /*#__PURE__*/function () {\n  function HSVideoBg(el, settings) {\n    _classCallCheck(this, HSVideoBg);\n\n    this.$el = typeof el === \"string\" ? document.querySelector(el) : el;\n    this.defaults = {\n      type: 'default',\n      videoId: null,\n      isLoop: true,\n      ratio: 1.5\n    };\n    this.dataSettings = this.$el.hasAttribute('data-hs-video-bg-options') ? JSON.parse(this.$el.getAttribute('data-hs-video-bg-options')) : {};\n    this.settings = Object.assign({}, this.defaults, this.dataSettings, settings);\n  }\n\n  _createClass(HSVideoBg, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this._prepareObject();\n\n      if (this.settings.type === 'you-tube') {\n        this._APICreating('//www.youtube.com/player_api', 'YT', 'YTDetect').then(function () {\n          var newYT;\n\n          if (typeof window.onYouTubeIframeAPIReady === 'function') {\n            setTimeout(function () {\n              newYT = new YT.Player(_this.$el.querySelector('.hs-video-bg-video > div'), {\n                videoId: _this.settings.videoId,\n                playerVars: {\n                  autoplay: true,\n                  controls: 0,\n                  showinfo: 0,\n                  enablejsapi: 1,\n                  modestbranding: 1,\n                  iv_load_policy: 3,\n                  loop: _this.settings.isLoop,\n                  playlist: _this.settings.videoId,\n                  origin: window.location.origin\n                },\n                events: {\n                  onReady: function onReady(e) {\n                    e.target.mute();\n\n                    _this._ratioCalc();\n\n                    window.addEventListener('resize', function () {\n                      _this._ratioCalc();\n                    });\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"fadeOut\"])(_this.$el.querySelector('.hs-video-bg-preview'), 400);\n                  }\n                }\n              });\n            }, 100);\n          } else {\n            window.onYouTubeIframeAPIReady = function () {\n              newYT = new YT.Player(_this.$el.querySelector('.hs-video-bg-video > div'), {\n                videoId: _this.settings.videoId,\n                playerVars: {\n                  autoplay: true,\n                  controls: 0,\n                  showinfo: 0,\n                  enablejsapi: 1,\n                  modestbranding: 1,\n                  iv_load_policy: 3,\n                  loop: _this.settings.isLoop,\n                  playlist: _this.settings.videoId,\n                  origin: window.location.origin\n                },\n                events: {\n                  onReady: function onReady(e) {\n                    e.target.mute();\n\n                    _this._ratioCalc();\n\n                    window.addEventListener('resize', function () {\n                      _this._ratioCalc();\n                    });\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"fadeOut\"])(_this.$el.querySelector('.hs-video-bg-preview'), 400);\n                  }\n                }\n              });\n            };\n          }\n        });\n      } else if (this.settings.type === 'vimeo') {\n        this._APICreating('//player.vimeo.com/api/player.js', 'Vimeo', 'VimeoDetect').then(function () {\n          var newVimeo = new Vimeo.Player(_this.$el.querySelector('.hs-video-bg-video'), {\n            id: _this.settings.videoId,\n            loop: _this.settings.isLoop,\n            title: false,\n            portrait: false,\n            byline: false,\n            autoplay: true,\n            autopause: false,\n            muted: true\n          });\n          newVimeo.play().then(function () {\n            _this._ratioCalc();\n\n            window.addEventListener('resize', function () {\n              _this._ratioCalc();\n            });\n            Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"fadeOut\"])(_this.$el.querySelector('.hs-video-bg-preview'), 400);\n          });\n        });\n      } else {\n        window.addEventListener('resize', function () {\n          _this._ratioCalc();\n        });\n        setTimeout(function () {\n          _this._ratioCalc();\n        });\n      }\n    }\n  }, {\n    key: \"_prepareObject\",\n    value: function _prepareObject() {\n      var _this2 = this;\n\n      this.$el.style.position = 'relative';\n\n      if (this.settings.type === 'you-tube') {\n        this.$el.insertAdjacentHTML('beforeend', '<div class=\"hs-video-bg-video\"><div></div></div>');\n      } else if (this.settings.type === 'vimeo') {\n        this.$el.insertAdjacentHTML('beforeend', '<div class=\"hs-video-bg-video\"></div>');\n      } else {\n        this.$el.insertAdjacentHTML('beforeend', \"\\n\\t\\t\\t\\t<div class=\\\"hs-video-bg-video\\\">\\n\\t\\t\\t\\t\\t<video poster=\\\"\\\" autoplay muted \".concat(this.settings.isLoop ? 'loop' : '', \">\\n\\t\\t\\t\\t\\t\\t<source src=\\\"\").concat(this.settings.videoId, \".mp4\\\" type=\\\"video/mp4\\\">\\n\\t\\t\\t\\t\\t\\t<source src=\\\"\").concat(this.settings.videoId, \".webm\\\" type=\\\"video/webm\\\">\\n\\t\\t\\t\\t\\t\\t<source src=\\\"\").concat(this.settings.videoId, \".ogv\\\" type=\\\"video/ogg\\\">\\n\\t\\t\\t\\t\\t\\tYour browser doesn't support HTML5 video.\\n\\t\\t\\t\\t\\t</video>\\n        </div>\\n\\t\\t\\t\"));\n      }\n\n      if (this.settings.type === 'you-tube') {\n        this.$el.insertAdjacentHTML('beforeend', \"<div class=\\\"hs-video-bg-preview\\\" style=\\\"background-image: url(//img.youtube.com/vi/\".concat(this.settings.videoId, \"/maxresdefault.jpg);\\\"></div>\"));\n      } else if (this.settings.type === 'vimeo') {\n        fetch(\"//www.vimeo.com/api/v2/video/\".concat(this.settings.videoId, \".json?callback=?\")).then(function (data) {\n          _this2.$el.insertAdjacentHTML('beforeend', \"<div class=\\\"hs-video-bg-preview\\\" style=\\\"background-image: url(\".concat(data[0].thumbnail_large, \");\\\"></div>\"));\n        });\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"_ratioCalc\",\n    value: function _ratioCalc() {\n      var _ratio = this.$el.clientWidth / this.$el.clientHeight;\n\n      var $videoBg = this.$el.querySelector('.hs-video-bg-video');\n      if (!$videoBg) return false;\n\n      if (this.settings.type === 'you-tube' || this.settings.type === 'vimeo') {\n        if (this.$el.clientHeight < this.$el.clientWidth && window.innerWidth > 768) {\n          $videoBg.style.width = _ratio * this.$el.clientWidth * this.settings.ratio;\n          $videoBg.style.height = _ratio * this.$el.clientHeight * this.settings.ratio;\n        } else {\n          $videoBg.style.width = _ratio * this.$el.clientWidth;\n          $videoBg.style.height = '130%';\n        }\n      }\n    }\n  }, {\n    key: \"_APICreating\",\n    value: function _APICreating(scriptUrl, globalName, globalNameDetect) {\n      if (window[globalNameDetect]) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        var script = document.createElement('script'),\n            before = document.querySelector('script');\n        script.src = scriptUrl;\n        before.parentNode.insertBefore(script, before);\n\n        script.onload = function () {\n          !globalName || window[globalName] ? resolve() : reject(Error('window.' + globalName + ' undefined'));\n        };\n\n        script.onerror = function () {\n          reject(Error('Error loading ' + globalName || false));\n        };\n      });\n    }\n  }]);\n\n  return HSVideoBg;\n}();\n\n\n\n//# sourceURL=webpack://HSVideoBg/./src/js/hs-video-bg.js?");
    },
    "./src/js/utils/index.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeOut\", function() { return fadeOut; });\nfunction fadeOut(el, time) {\n  if (!el || el.offsetParent === null) return el;\n\n  if (!time) {\n    return el.style.display = 'none';\n  }\n\n  var intervalID = setInterval(function () {\n    if (!el.style.opacity) {\n      el.style.opacity = 1;\n    }\n\n    if (el.style.opacity > 0) {\n      el.style.opacity -= 0.1;\n    } else {\n      clearInterval(intervalID);\n      el.style.display = 'none';\n    }\n  }, time / 10);\n}\n\n//# sourceURL=webpack://HSVideoBg/./src/js/utils/index.js?");
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-video-bg.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSToggleSwitch = e() : t.HSToggleSwitch = e(); }(window, (() => {
  return d = {
    "./node_modules/countup.js/dist/countUp.min.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CountUp", function() { return CountUp; });\nvar __assign=undefined&&undefined.__assign||function(){return(__assign=Object.assign||function(t){for(var i,a=1,s=arguments.length;a<s;a++)for(var n in i=arguments[a])Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n]);return t}).apply(this,arguments)},CountUp=function(){function t(t,i,a){var s=this;this.target=t,this.endVal=i,this.options=a,this.version="2.0.7",this.defaults={startVal:0,decimalPlaces:0,duration:2,useEasing:!0,useGrouping:!0,smartEasingThreshold:999,smartEasingAmount:333,separator:",",decimal:".",prefix:"",suffix:""},this.finalEndVal=null,this.useEasing=!0,this.countDown=!1,this.error="",this.startVal=0,this.paused=!0,this.count=function(t){s.startTime||(s.startTime=t);var i=t-s.startTime;s.remaining=s.duration-i,s.useEasing?s.countDown?s.frameVal=s.startVal-s.easingFn(i,0,s.startVal-s.endVal,s.duration):s.frameVal=s.easingFn(i,s.startVal,s.endVal-s.startVal,s.duration):s.countDown?s.frameVal=s.startVal-(s.startVal-s.endVal)*(i/s.duration):s.frameVal=s.startVal+(s.endVal-s.startVal)*(i/s.duration),s.countDown?s.frameVal=s.frameVal<s.endVal?s.endVal:s.frameVal:s.frameVal=s.frameVal>s.endVal?s.endVal:s.frameVal,s.frameVal=Number(s.frameVal.toFixed(s.options.decimalPlaces)),s.printValue(s.frameVal),i<s.duration?s.rAF=requestAnimationFrame(s.count):null!==s.finalEndVal?s.update(s.finalEndVal):s.callback&&s.callback()},this.formatNumber=function(t){var i,a,n,e,r,o=t<0?"-":"";if(i=Math.abs(t).toFixed(s.options.decimalPlaces),n=(a=(i+="").split("."))[0],e=a.length>1?s.options.decimal+a[1]:"",s.options.useGrouping){r="";for(var l=0,h=n.length;l<h;++l)0!==l&&l%3==0&&(r=s.options.separator+r),r=n[h-l-1]+r;n=r}return s.options.numerals&&s.options.numerals.length&&(n=n.replace(/[0-9]/g,function(t){return s.options.numerals[+t]}),e=e.replace(/[0-9]/g,function(t){return s.options.numerals[+t]})),o+s.options.prefix+n+e+s.options.suffix},this.easeOutExpo=function(t,i,a,s){return a*(1-Math.pow(2,-10*t/s))*1024/1023+i},this.options=__assign(__assign({},this.defaults),a),this.formattingFn=this.options.formattingFn?this.options.formattingFn:this.formatNumber,this.easingFn=this.options.easingFn?this.options.easingFn:this.easeOutExpo,this.startVal=this.validateValue(this.options.startVal),this.frameVal=this.startVal,this.endVal=this.validateValue(i),this.options.decimalPlaces=Math.max(this.options.decimalPlaces),this.resetDuration(),this.options.separator=String(this.options.separator),this.useEasing=this.options.useEasing,""===this.options.separator&&(this.options.useGrouping=!1),this.el="string"==typeof t?document.getElementById(t):t,this.el?this.printValue(this.startVal):this.error="[CountUp] target is null or undefined"}return t.prototype.determineDirectionAndSmartEasing=function(){var t=this.finalEndVal?this.finalEndVal:this.endVal;this.countDown=this.startVal>t;var i=t-this.startVal;if(Math.abs(i)>this.options.smartEasingThreshold){this.finalEndVal=t;var a=this.countDown?1:-1;this.endVal=t+a*this.options.smartEasingAmount,this.duration=this.duration/2}else this.endVal=t,this.finalEndVal=null;this.finalEndVal?this.useEasing=!1:this.useEasing=this.options.useEasing},t.prototype.start=function(t){this.error||(this.callback=t,this.duration>0?(this.determineDirectionAndSmartEasing(),this.paused=!1,this.rAF=requestAnimationFrame(this.count)):this.printValue(this.endVal))},t.prototype.pauseResume=function(){this.paused?(this.startTime=null,this.duration=this.remaining,this.startVal=this.frameVal,this.determineDirectionAndSmartEasing(),this.rAF=requestAnimationFrame(this.count)):cancelAnimationFrame(this.rAF),this.paused=!this.paused},t.prototype.reset=function(){cancelAnimationFrame(this.rAF),this.paused=!0,this.resetDuration(),this.startVal=this.validateValue(this.options.startVal),this.frameVal=this.startVal,this.printValue(this.startVal)},t.prototype.update=function(t){cancelAnimationFrame(this.rAF),this.startTime=null,this.endVal=this.validateValue(t),this.endVal!==this.frameVal&&(this.startVal=this.frameVal,this.finalEndVal||this.resetDuration(),this.finalEndVal=null,this.determineDirectionAndSmartEasing(),this.rAF=requestAnimationFrame(this.count))},t.prototype.printValue=function(t){var i=this.formattingFn(t);"INPUT"===this.el.tagName?this.el.value=i:"text"===this.el.tagName||"tspan"===this.el.tagName?this.el.textContent=i:this.el.innerHTML=i},t.prototype.ensureNumber=function(t){return"number"==typeof t&&!isNaN(t)},t.prototype.validateValue=function(t){var i=Number(t);return this.ensureNumber(i)?i:(this.error="[CountUp] invalid start or end value: "+t,null)},t.prototype.resetDuration=function(){this.startTime=null,this.duration=1e3*Number(this.options.duration),this.remaining=this.duration},t}();\n\n//# sourceURL=webpack://HSToggleSwitch/./node_modules/countup.js/dist/countUp.min.js?');
    },
    "./src/js/hs-toggle-switch.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSToggleSwitch; });\n/* harmony import */ var countup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! countup.js */ "./node_modules/countup.js/dist/countUp.min.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSToggleSwitch Plugin\n* @version: 1.0.0 (Mon, 12 Dec 2019)\n* @requires: countup.js v2.0.4\n* @author: HtmlStream\n* @event-namespace: .HSToggleSwitch\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2019 Htmlstream\n*/\n\nvar dataAttributeName = \'data-hs-toggle-switch-options\';\nvar dataAttributeItemName = \'data-hs-toggle-switch-item-options\';\nvar defaults = {\n  mode: \'toggle-count\',\n  targetSelector: undefined,\n  isChecked: false,\n  eventType: \'change\'\n};\n\nvar HSToggleSwitch = /*#__PURE__*/function () {\n  function HSToggleSwitch(el, options, id) {\n    _classCallCheck(this, HSToggleSwitch);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSToggleSwitch, [{\n    key: "_init",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        _options.isChecked = _$el.checked;\n        _options.$targets = document.querySelectorAll(_options.targetSelector);\n\n        if (_options.mode === \'toggle-count\') {\n          if (_options.isChecked) {\n            _options.isChecked = true;\n\n            _options.$targets.forEach(function ($target) {\n              var currentDataSettings = $target.hasAttribute(dataAttributeItemName) ? JSON.parse($target.getAttribute(dataAttributeItemName)) : {};\n              $target.innerHTML = currentDataSettings.max;\n            });\n          }\n\n          _$el.addEventListener(_options.eventType, function () {\n            return that._toggleCount(_options);\n          });\n        }\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    } // Toggle Count\n\n  }, {\n    key: "_toggleCount",\n    value: function _toggleCount(settings) {\n      if (settings.isChecked) {\n        this._countDownEach(settings);\n      } else {\n        this._countUpEach(settings);\n      }\n    }\n  }, {\n    key: "_countUpEach",\n    value: function _countUpEach(settings) {\n      var _this = this;\n\n      settings.isChecked = true;\n      settings.$targets.forEach(function ($target) {\n        var currentDataSettings = $target.hasAttribute(dataAttributeItemName) ? JSON.parse($target.getAttribute(dataAttributeItemName)) : {};\n        var currentDefaults = {\n          duration: .5,\n          useEasing: false\n        },\n            currentOptions = {};\n        currentOptions = Object.assign({}, currentDefaults, currentDataSettings);\n\n        _this._countUp($target, currentOptions);\n      });\n    }\n  }, {\n    key: "_countDownEach",\n    value: function _countDownEach(settings) {\n      var _this2 = this;\n\n      settings.isChecked = false;\n      settings.$targets.forEach(function ($target) {\n        var currentDataSettings = $target.hasAttribute(dataAttributeItemName) ? JSON.parse($target.getAttribute(dataAttributeItemName)) : {};\n        var currentDefaults = {\n          duration: .5,\n          useEasing: false\n        },\n            currentOptions = {};\n        currentOptions = Object.assign({}, currentDefaults, currentDataSettings);\n\n        _this2._countDown($target, currentOptions);\n      });\n    }\n  }, {\n    key: "_countUp",\n    value: function _countUp(el, data) {\n      var defaults = {\n        startVal: data.min\n      };\n      var options = Object.assign({}, defaults, data);\n      var countUp = new countup_js__WEBPACK_IMPORTED_MODULE_0__["CountUp"](el, data.max, options);\n      countUp.start();\n    }\n  }, {\n    key: "_countDown",\n    value: function _countDown(el, data) {\n      var defaults = {\n        startVal: data.max\n      };\n      var options = Object.assign({}, defaults, data);\n      var countUp = new countup_js__WEBPACK_IMPORTED_MODULE_0__["CountUp"](el, data.min, options);\n      countUp.start();\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSToggleSwitch;\n}();\n\n\n\n//# sourceURL=webpack://HSToggleSwitch/./src/js/hs-toggle-switch.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-toggle-switch.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSScrollspy = e() : t.HSScrollspy = e(); }(window, (() => {
  return d = {
    "./src/js/hs-scrollspy.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSScrollspy; });\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\r\n* HSScrollspy Plugin\r\n* @version: 1.0.0 (Wed, 24 Nov 2021)\r\n* @author: HtmlStream\r\n* @event-namespace: .HSScrollspy\r\n* @license: Htmlstream Libraries (https://htmlstream.com/)\r\n* Copyright 2021 Htmlstream\r\n*/\nvar HSScrollspy = /*#__PURE__*/function () {\n  function HSScrollspy(elem, settings) {\n    _classCallCheck(this, HSScrollspy);\n\n    this.$el = typeof elem === \'string\' ? document.querySelector(elem) : elem;\n    this.defaults = {\n      disableCollapse: null,\n      scrollOffset: 0,\n      collapsibleNav: null,\n      resolutionsList: {\n        xs: 0,\n        sm: 576,\n        md: 768,\n        lg: 992,\n        xl: 1200\n      },\n      resetOffset: null,\n      breakpoint: \'lg\',\n      scrollspyContainer: document.body\n    };\n    this.dataSettings = this.$el.hasAttribute(\'data-hs-scrollspy-options\') ? JSON.parse(this.$el.getAttribute(\'data-hs-scrollspy-options\')) : {}, this.settings = Object.assign({}, this.defaults, this.dataSettings, settings);\n    this.init();\n  }\n\n  _createClass(HSScrollspy, [{\n    key: "init",\n    value: function init() {\n      var _this = this;\n\n      this.scrollSpyInstance = bootstrap.ScrollSpy.getInstance(this.settings.scrollspyContainer);\n      var nav = _typeof(this.scrollSpyInstance._config.target) === \'object\' ? this.scrollSpyInstance._config.target : document.querySelector(this.scrollSpyInstance._config.target);\n\n      if (this.settings.disableCollapse === null && this.$el.classList.contains(\'collapse\')) {\n        this.settings.disableCollapse = false;\n      }\n\n      nav.addEventListener(\'click\', function (e) {\n        if (!e.target.closest(\'a:not([href="#"]):not([href="#0"])\')) return;\n        e.preventDefault();\n\n        if (_this.settings.disableCollapse === false && window.innerWidth < _this.settings.resolutionsList[_this.settings.breakpoint]) {\n          new bootstrap.Collapse(_this.$el).hide();\n          return _this.$el.addEventListener(\'hidden.bs.collapse\', function () {\n            _this.smoothScroll(e);\n          });\n        } else {\n          _this.smoothScroll(e);\n        }\n      });\n    }\n  }, {\n    key: "smoothScroll",\n    value: function smoothScroll(e) {\n      var offset = this.settings.resetOffset && window.innerWidth < this.settings.resolutionsList[this.settings.resetOffset] ? 0 : this.scrollSpyInstance._config.offset;\n      window.scroll({\n        top: document.querySelector(e.target.hash).offsetTop - offset - this.settings.scrollOffset,\n        left: 0,\n        behavior: \'smooth\'\n      });\n    }\n  }]);\n\n  return HSScrollspy;\n}();\n\n\n\n//# sourceURL=webpack://HSScrollspy/./src/js/hs-scrollspy.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-scrollspy.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && void 0 !== module ? e(exports) : typeof define === "function" && define.amd ? define(["exports"], e) : e(t.L = {}); }(this, ((t) => {
  function e(t) { for (var e, n, r = 1, i = arguments.length; r < i; r++) for (e in n = arguments[r])t[e] = n[e]; return t; } const n = Object.create || function (t) { return r.prototype = t, new r(); }; function r() {} function i(t, e) { const n = Array.prototype.slice; if (t.bind) return t.bind.apply(t, n.call(arguments, 1)); const r = n.call(arguments, 2); return function () { return t.apply(e, r.length ? r.concat(n.call(arguments)) : arguments); }; } let o = 0; function s(t) { return t._leaflet_id = t._leaflet_id || ++o, t._leaflet_id; } function a(t, e, n) { let r; let i; const o = function () { r = !1, i && (s.apply(n, i), i = !1); }; var s = function () { r ? i = arguments : (t.apply(n, arguments), setTimeout(o, e), r = !0); }; return s; } function l(t, e, n) { const r = e[1]; const i = e[0]; const o = r - i; return t === r && n ? t : ((t - i) % o + o) % o + i; } function u() { return !1; } function c(t, e) { const n = 10 ** (void 0 === e ? 6 : e); return Math.round(t * n) / n; } function d(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, ""); } function h(t) { return d(t).split(/\s+/); } function p(t, e) { for (const r in Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? n(t.options) : {}), e)t.options[r] = e[r]; return t.options; } function f(t, e, n) { const r = []; for (const i in t)r.push(`${encodeURIComponent(n ? i.toUpperCase() : i)}=${encodeURIComponent(t[i])}`); return (e && e.indexOf("?") !== -1 ? "&" : "?") + r.join("&"); } const m = /\{ *([\w_-]+) *\}/g; function g(t, e) { return t.replace(m, ((t, n) => { let r = e[n]; if (void 0 === r) throw new Error(`No value provided for variable ${t}`); return typeof r === "function" && (r = r(e)), r; })); } const v = Array.isArray || function (t) { return Object.prototype.toString.call(t) === "[object Array]"; }; function y(t, e) { for (let n = 0; n < t.length; n++) if (t[n] === e) return n; return -1; } const _ = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="; function b(t) { return window[`webkit${t}`] || window[`moz${t}`] || window[`ms${t}`]; } let w = 0; function x(t) {
    const e = +new Date(); const
      n = Math.max(0, 16 - (e - w)); return w = e + n, window.setTimeout(t, n);
  } const S = window.requestAnimationFrame || b("RequestAnimationFrame") || x; const k = window.cancelAnimationFrame || b("CancelAnimationFrame") || b("CancelRequestAnimationFrame") || function (t) { window.clearTimeout(t); }; function C(t, e, n) { if (!n || S !== x) return S.call(window, i(t, e)); t.call(e); } function E(t) { t && k.call(window, t); } const T = {
    extend: e, create: n, bind: i, lastId: o, stamp: s, throttle: a, wrapNum: l, falseFn: u, formatNum: c, trim: d, splitWords: h, setOptions: p, getParamString: f, template: g, isArray: v, indexOf: y, emptyImageUrl: _, requestFn: S, cancelFn: k, requestAnimFrame: C, cancelAnimFrame: E,
  }; function P() {}P.extend = function (t) { function r() { this.initialize && this.initialize.apply(this, arguments), this.callInitHooks(); } const i = r.__super__ = this.prototype; const o = n(i); for (const s in (o.constructor = r).prototype = o, this)Object.prototype.hasOwnProperty.call(this, s) && s !== "prototype" && s !== "__super__" && (r[s] = this[s]); return t.statics && (e(r, t.statics), delete t.statics), t.includes && ((function (t) { if (typeof L !== "undefined" && L && L.Mixin) { t = v(t) ? t : [t]; for (let e = 0; e < t.length; e++)t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error()).stack); } }(t.includes)), e.apply(null, [o].concat(t.includes)), delete t.includes), o.options && (t.options = e(n(o.options), t.options)), e(o, t), o._initHooks = [], o.callInitHooks = function () { if (!this._initHooksCalled) { i.callInitHooks && i.callInitHooks.call(this), this._initHooksCalled = !0; for (let t = 0, e = o._initHooks.length; t < e; t++)o._initHooks[t].call(this); } }, r; }, P.include = function (t) { return e(this.prototype, t), this; }, P.mergeOptions = function (t) { return e(this.prototype.options, t), this; }, P.addInitHook = function (t) { const e = Array.prototype.slice.call(arguments, 1); const n = typeof t === "function" ? t : function () { this[t].apply(this, e); }; return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(n), this; }; const O = {
    on(t, e, n) { if (typeof t === "object") for (const r in t) this._on(r, t[r], e); else for (let i = 0, o = (t = h(t)).length; i < o; i++) this._on(t[i], e, n); return this; }, off(t, e, n) { if (t) if (typeof t === "object") for (const r in t) this._off(r, t[r], e); else for (let i = 0, o = (t = h(t)).length; i < o; i++) this._off(t[i], e, n); else delete this._events; return this; }, _on(t, e, n) { this._events = this._events || {}; let r = this._events[t]; r || (r = [], this._events[t] = r), n === this && (n = void 0); for (var i = { fn: e, ctx: n }, o = r, s = 0, a = o.length; s < a; s++) if (o[s].fn === e && o[s].ctx === n) return; o.push(i); }, _off(t, e, n) { let r; let i; let o; if (this._events && (r = this._events[t])) if (e) { if (n === this && (n = void 0), r) for (i = 0, o = r.length; i < o; i++) { const s = r[i]; if (s.ctx === n && s.fn === e) return s.fn = u, this._firingCount && (this._events[t] = r = r.slice()), void r.splice(i, 1); } } else { for (i = 0, o = r.length; i < o; i++)r[i].fn = u; delete this._events[t]; } }, fire(t, n, r) { if (!this.listens(t, r)) return this; const i = e({}, n, { type: t, target: this, sourceTarget: n && n.sourceTarget || this }); if (this._events) { const o = this._events[t]; if (o) { this._firingCount = this._firingCount + 1 || 1; for (let s = 0, a = o.length; s < a; s++) { const l = o[s]; l.fn.call(l.ctx || this, i); } this._firingCount--; } } return r && this._propagateEvent(i), this; }, listens(t, e) { const n = this._events && this._events[t]; if (n && n.length) return !0; if (e) for (const r in this._eventParents) if (this._eventParents[r].listens(t, e)) return !0; return !1; }, once(t, e, n) { if (typeof t === "object") { for (const r in t) this.once(r, t[r], e); return this; } var o = i((function () { this.off(t, e, n).off(t, o, n); }), this); return this.on(t, e, n).on(t, o, n); }, addEventParent(t) { return this._eventParents = this._eventParents || {}, this._eventParents[s(t)] = t, this; }, removeEventParent(t) { return this._eventParents && delete this._eventParents[s(t)], this; }, _propagateEvent(t) { for (const n in this._eventParents) this._eventParents[n].fire(t.type, e({ layer: t.target, propagatedFrom: t.target }, t), !0); },
  }; O.addEventListener = O.on, O.removeEventListener = O.clearAllEventListeners = O.off, O.addOneTimeEventListener = O.once, O.fireEvent = O.fire, O.hasEventListeners = O.listens; const A = P.extend(O); function M(t, e, n) { this.x = n ? Math.round(t) : t, this.y = n ? Math.round(e) : e; } const I = Math.trunc || function (t) { return t > 0 ? Math.floor(t) : Math.ceil(t); }; function j(t, e, n) { return t instanceof M ? t : v(t) ? new M(t[0], t[1]) : t == null ? t : typeof t === "object" && "x" in t && "y" in t ? new M(t.x, t.y) : new M(t, e, n); } function D(t, e) { if (t) for (let n = e ? [t, e] : t, r = 0, i = n.length; r < i; r++) this.extend(n[r]); } function N(t, e) { return !t || t instanceof D ? t : new D(t, e); } function R(t, e) { if (t) for (let n = e ? [t, e] : t, r = 0, i = n.length; r < i; r++) this.extend(n[r]); } function F(t, e) { return t instanceof R ? t : new R(t, e); } function V(t, e, n) { if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LatLng object: (${t}, ${e})`); this.lat = +t, this.lng = +e, void 0 !== n && (this.alt = +n); } function z(t, e, n) { return t instanceof V ? t : v(t) && typeof t[0] !== "object" ? t.length === 3 ? new V(t[0], t[1], t[2]) : t.length === 2 ? new V(t[0], t[1]) : null : t == null ? t : typeof t === "object" && "lat" in t ? new V(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new V(t, e, n); }M.prototype = {
    clone() { return new M(this.x, this.y); }, add(t) { return this.clone()._add(j(t)); }, _add(t) { return this.x += t.x, this.y += t.y, this; }, subtract(t) { return this.clone()._subtract(j(t)); }, _subtract(t) { return this.x -= t.x, this.y -= t.y, this; }, divideBy(t) { return this.clone()._divideBy(t); }, _divideBy(t) { return this.x /= t, this.y /= t, this; }, multiplyBy(t) { return this.clone()._multiplyBy(t); }, _multiplyBy(t) { return this.x *= t, this.y *= t, this; }, scaleBy(t) { return new M(this.x * t.x, this.y * t.y); }, unscaleBy(t) { return new M(this.x / t.x, this.y / t.y); }, round() { return this.clone()._round(); }, _round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this; }, floor() { return this.clone()._floor(); }, _floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this; }, ceil() { return this.clone()._ceil(); }, _ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this; }, trunc() { return this.clone()._trunc(); }, _trunc() { return this.x = I(this.x), this.y = I(this.y), this; }, distanceTo(t) { const e = (t = j(t)).x - this.x; const n = t.y - this.y; return Math.sqrt(e * e + n * n); }, equals(t) { return (t = j(t)).x === this.x && t.y === this.y; }, contains(t) { return t = j(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y); }, toString() { return `Point(${c(this.x)}, ${c(this.y)})`; },
  }, D.prototype = {
    extend(t) { return t = j(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this; }, getCenter(t) { return new M((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t); }, getBottomLeft() { return new M(this.min.x, this.max.y); }, getTopRight() { return new M(this.max.x, this.min.y); }, getTopLeft() { return this.min; }, getBottomRight() { return this.max; }, getSize() { return this.max.subtract(this.min); }, contains(t) { let e; let n; return (t = (typeof t[0] === "number" || t instanceof M ? j : N)(t)) instanceof D ? (e = t.min, n = t.max) : e = n = t, e.x >= this.min.x && n.x <= this.max.x && e.y >= this.min.y && n.y <= this.max.y; }, intersects(t) { t = N(t); const e = this.min; const n = this.max; const r = t.min; const i = t.max; const o = i.x >= e.x && r.x <= n.x; const s = i.y >= e.y && r.y <= n.y; return o && s; }, overlaps(t) { t = N(t); const e = this.min; const n = this.max; const r = t.min; const i = t.max; const o = i.x > e.x && r.x < n.x; const s = i.y > e.y && r.y < n.y; return o && s; }, isValid() { return !(!this.min || !this.max); },
  }, R.prototype = {
    extend(t) { let e; let n; const r = this._southWest; const i = this._northEast; if (t instanceof V)n = e = t; else { if (!(t instanceof R)) return t ? this.extend(z(t) || F(t)) : this; if (e = t._southWest, n = t._northEast, !e || !n) return this; } return r || i ? (r.lat = Math.min(e.lat, r.lat), r.lng = Math.min(e.lng, r.lng), i.lat = Math.max(n.lat, i.lat), i.lng = Math.max(n.lng, i.lng)) : (this._southWest = new V(e.lat, e.lng), this._northEast = new V(n.lat, n.lng)), this; }, pad(t) { const e = this._southWest; const n = this._northEast; const r = Math.abs(e.lat - n.lat) * t; const i = Math.abs(e.lng - n.lng) * t; return new R(new V(e.lat - r, e.lng - i), new V(n.lat + r, n.lng + i)); }, getCenter() { return new V((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2); }, getSouthWest() { return this._southWest; }, getNorthEast() { return this._northEast; }, getNorthWest() { return new V(this.getNorth(), this.getWest()); }, getSouthEast() { return new V(this.getSouth(), this.getEast()); }, getWest() { return this._southWest.lng; }, getSouth() { return this._southWest.lat; }, getEast() { return this._northEast.lng; }, getNorth() { return this._northEast.lat; }, contains(t) { t = (typeof t[0] === "number" || t instanceof V || "lat" in t ? z : F)(t); let e; let n; const r = this._southWest; const i = this._northEast; return t instanceof R ? (e = t.getSouthWest(), n = t.getNorthEast()) : e = n = t, e.lat >= r.lat && n.lat <= i.lat && e.lng >= r.lng && n.lng <= i.lng; }, intersects(t) { t = F(t); const e = this._southWest; const n = this._northEast; const r = t.getSouthWest(); const i = t.getNorthEast(); const o = i.lat >= e.lat && r.lat <= n.lat; const s = i.lng >= e.lng && r.lng <= n.lng; return o && s; }, overlaps(t) { t = F(t); const e = this._southWest; const n = this._northEast; const r = t.getSouthWest(); const i = t.getNorthEast(); const o = i.lat > e.lat && r.lat < n.lat; const s = i.lng > e.lng && r.lng < n.lng; return o && s; }, toBBoxString() { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(","); }, equals(t, e) { return !!t && (t = F(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)); }, isValid() { return !(!this._southWest || !this._northEast); },
  }; let B; const q = {
    latLngToPoint(t, e) { const n = this.projection.project(t); const r = this.scale(e); return this.transformation._transform(n, r); },
    pointToLatLng(t, e) { const n = this.scale(e); const r = this.transformation.untransform(t, n); return this.projection.unproject(r); },
    project(t) { return this.projection.project(t); },
    unproject(t) { return this.projection.unproject(t); },
    scale(t) { return 256 * 2 ** t; },
    zoom(t) { return Math.log(t / 256) / Math.LN2; },
    getProjectedBounds(t) { if (this.infinite) return null; const e = this.projection.bounds; const n = this.scale(t); return new D(this.transformation.transform(e.min, n), this.transformation.transform(e.max, n)); },
    infinite: !(V.prototype = {
      equals(t, e) { return !!t && (t = z(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e)); }, toString(t) { return `LatLng(${c(this.lat, t)}, ${c(this.lng, t)})`; }, distanceTo(t) { return H.distance(this, z(t)); }, wrap() { return H.wrapLatLng(this); }, toBounds(t) { const e = 180 * t / 40075017; const n = e / Math.cos(Math.PI / 180 * this.lat); return F([this.lat - e, this.lng - n], [this.lat + e, this.lng + n]); }, clone() { return new V(this.lat, this.lng, this.alt); },
    }),
    wrapLatLng(t) { const e = this.wrapLng ? l(t.lng, this.wrapLng, !0) : t.lng; return new V(this.wrapLat ? l(t.lat, this.wrapLat, !0) : t.lat, e, t.alt); },
    wrapLatLngBounds(t) { const e = t.getCenter(); const n = this.wrapLatLng(e); const r = e.lat - n.lat; const i = e.lng - n.lng; if (r == 0 && i == 0) return t; const o = t.getSouthWest(); const s = t.getNorthEast(); return new R(new V(o.lat - r, o.lng - i), new V(s.lat - r, s.lng - i)); },
  }; var H = e({}, q, { wrapLng: [-180, 180], R: 6371e3, distance(t, e) { const n = Math.PI / 180; const r = t.lat * n; const i = e.lat * n; const o = Math.sin((e.lat - t.lat) * n / 2); const s = Math.sin((e.lng - t.lng) * n / 2); const a = o * o + Math.cos(r) * Math.cos(i) * s * s; const l = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return this.R * l; } }); const $ = 6378137; const U = {
    R: $, MAX_LATITUDE: 85.0511287798, project(t) { const e = Math.PI / 180; const n = this.MAX_LATITUDE; const r = Math.max(Math.min(n, t.lat), -n); const i = Math.sin(r * e); return new M(this.R * t.lng * e, this.R * Math.log((1 + i) / (1 - i)) / 2); }, unproject(t) { const e = 180 / Math.PI; return new V((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R); }, bounds: new D([-(B = $ * Math.PI), -B], [B, B]),
  }; function W(t, e, n, r) { if (v(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void (this._d = t[3]); this._a = t, this._b = e, this._c = n, this._d = r; } function G(t, e, n, r) { return new W(t, e, n, r); }W.prototype = { transform(t, e) { return this._transform(t.clone(), e); }, _transform(t, e) { return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t; }, untransform(t, e) { return e = e || 1, new M((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c); } }; let Y; const Z = e({}, H, { code: "EPSG:3857", projection: U, transformation: G(Y = 0.5 / (Math.PI * U.R), 0.5, -Y, 0.5) }); const K = e({}, Z, { code: "EPSG:900913" }); function X(t) { return document.createElementNS("http://www.w3.org/2000/svg", t); } function Q(t, e) { for (var n, r, i, o, s = "", a = 0, l = t.length; a < l; a++) { for (n = 0, r = (i = t[a]).length; n < r; n++)s += `${(n ? "L" : "M") + (o = i[n]).x} ${o.y}`; s += e ? At ? "z" : "x" : ""; } return s || "M0 0"; } const J = document.documentElement.style; const tt = "ActiveXObject" in window; const et = tt && !document.addEventListener; const nt = "msLaunchUri" in navigator && !("documentMode" in document); const rt = Lt("webkit"); const it = Lt("android"); const ot = Lt("android 2") || Lt("android 3"); const st = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); const at = it && Lt("Google") && st < 537 && !("AudioNode" in window); const lt = !!window.opera; const ut = !nt && Lt("chrome"); const ct = Lt("gecko") && !rt && !lt && !tt; const dt = !ut && Lt("safari"); const ht = Lt("phantom"); const pt = "OTransition" in J; const ft = navigator.platform.indexOf("Win") === 0; const mt = tt && "transition" in J; const gt = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !ot; const vt = "MozPerspective" in J; const yt = !window.L_DISABLE_3D && (mt || gt || vt) && !pt && !ht; const _t = typeof orientation !== "undefined" || Lt("mobile"); const bt = _t && rt; const wt = _t && gt; const xt = !window.PointerEvent && window.MSPointerEvent; const St = !(!window.PointerEvent && !xt); const kt = !window.L_NO_TOUCH && (St || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch); const Ct = _t && lt; const Et = _t && ct; const Tt = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; const Pt = (function () { let t = !1; try { const e = Object.defineProperty({}, "passive", { get() { t = !0; } }); window.addEventListener("testPassiveEventSupport", u, e), window.removeEventListener("testPassiveEventSupport", u, e); } catch (t) {} return t; }()); const Ot = !!document.createElement("canvas").getContext; var At = !(!document.createElementNS || !X("svg").createSVGRect); const Mt = !At && (function () { try { const t = document.createElement("div"); t.innerHTML = '<v:shape adj="1"/>'; const e = t.firstChild; return e.style.behavior = "url(#default#VML)", e && typeof e.adj === "object"; } catch (t) { return !1; } }()); function Lt(t) { return navigator.userAgent.toLowerCase().indexOf(t) >= 0; } const It = {
    ie: tt, ielt9: et, edge: nt, webkit: rt, android: it, android23: ot, androidStock: at, opera: lt, chrome: ut, gecko: ct, safari: dt, phantom: ht, opera12: pt, win: ft, ie3d: mt, webkit3d: gt, gecko3d: vt, any3d: yt, mobile: _t, mobileWebkit: bt, mobileWebkit3d: wt, msPointer: xt, pointer: St, touch: kt, mobileOpera: Ct, mobileGecko: Et, retina: Tt, passiveEvents: Pt, canvas: Ot, svg: At, vml: Mt,
  }; const jt = xt ? "MSPointerDown" : "pointerdown"; const Dt = xt ? "MSPointerMove" : "pointermove"; const Nt = xt ? "MSPointerUp" : "pointerup"; const Rt = xt ? "MSPointerCancel" : "pointercancel"; const Ft = {}; let Vt = !1; function zt(t, e, n, r) { function o(t) { $t(t, a); } let s; let a; let l; let u; let c; let d; let h; let p; function f(t) { t.pointerType === (t.MSPOINTER_TYPE_MOUSE || "mouse") && t.buttons === 0 || $t(t, u); } return e === "touchstart" ? (c = t, d = n, h = r, p = i(((t) => { t.MSPOINTER_TYPE_TOUCH && t.pointerType === t.MSPOINTER_TYPE_TOUCH && Re(t), $t(t, d); })), c[`_leaflet_touchstart${h}`] = p, c.addEventListener(jt, p, !1), Vt || (document.addEventListener(jt, Bt, !0), document.addEventListener(Dt, qt, !0), document.addEventListener(Nt, Ht, !0), document.addEventListener(Rt, Ht, !0), Vt = !0)) : e === "touchmove" ? (u = n, (l = t)[`_leaflet_touchmove${r}`] = f, l.addEventListener(Dt, f, !1)) : e === "touchend" && (a = n, (s = t)[`_leaflet_touchend${r}`] = o, s.addEventListener(Nt, o, !1), s.addEventListener(Rt, o, !1)), this; } function Bt(t) { Ft[t.pointerId] = t; } function qt(t) { Ft[t.pointerId] && (Ft[t.pointerId] = t); } function Ht(t) { delete Ft[t.pointerId]; } function $t(t, e) { for (const n in t.touches = [], Ft)t.touches.push(Ft[n]); t.changedTouches = [t], e(t); } let Ut; let Wt; let Gt; let Yt; let Zt; let Kt; const Xt = xt ? "MSPointerDown" : St ? "pointerdown" : "touchstart"; const Qt = xt ? "MSPointerUp" : St ? "pointerup" : "touchend"; const Jt = "_leaflet_"; const te = ge(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]); const ee = ge(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]); const ne = ee === "webkitTransition" || ee === "OTransition" ? `${ee}End` : "transitionend"; function re(t) { return typeof t === "string" ? document.getElementById(t) : t; } function ie(t, e) { let n; let r = t.style[e] || t.currentStyle && t.currentStyle[e]; return r && r !== "auto" || !document.defaultView || (r = (n = document.defaultView.getComputedStyle(t, null)) ? n[e] : null), r === "auto" ? null : r; } function oe(t, e, n) { const r = document.createElement(t); return r.className = e || "", n && n.appendChild(r), r; } function se(t) { const e = t.parentNode; e && e.removeChild(t); } function ae(t) { for (;t.firstChild;)t.removeChild(t.firstChild); } function le(t) { const e = t.parentNode; e && e.lastChild !== t && e.appendChild(t); } function ue(t) { const e = t.parentNode; e && e.firstChild !== t && e.insertBefore(t, e.firstChild); } function ce(t, e) { if (void 0 !== t.classList) return t.classList.contains(e); const n = fe(t); return n.length > 0 && new RegExp(`(^|\\s)${e}(\\s|$)`).test(n); } function de(t, e) { let n; if (void 0 !== t.classList) for (let r = h(e), i = 0, o = r.length; i < o; i++)t.classList.add(r[i]); else ce(t, e) || pe(t, ((n = fe(t)) ? `${n} ` : "") + e); } function he(t, e) { void 0 !== t.classList ? t.classList.remove(e) : pe(t, d((` ${fe(t)} `).replace(` ${e} `, " "))); } function pe(t, e) { void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e; } function fe(t) { return t.correspondingElement && (t = t.correspondingElement), void 0 === t.className.baseVal ? t.className : t.className.baseVal; } function me(t, e) { "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && (function (t, e) { let n = !1; const r = "DXImageTransform.Microsoft.Alpha"; try { n = t.filters.item(r); } catch (t) { if (e === 1) return; }e = Math.round(100 * e), n ? (n.Enabled = e !== 100, n.Opacity = e) : t.style.filter += ` progid:${r}(opacity=${e})`; }(t, e)); } function ge(t) { for (let e = document.documentElement.style, n = 0; n < t.length; n++) if (t[n] in e) return t[n]; return !1; } function ve(t, e, n) { const r = e || new M(0, 0); t.style[te] = (mt ? `translate(${r.x}px,${r.y}px)` : `translate3d(${r.x}px,${r.y}px,0)`) + (n ? ` scale(${n})` : ""); } function ye(t, e) { t._leaflet_pos = e, yt ? ve(t, e) : (t.style.left = `${e.x}px`, t.style.top = `${e.y}px`); } function _e(t) { return t._leaflet_pos || new M(0, 0); } function be() { Te(window, "dragstart", Re); } function we() { Oe(window, "dragstart", Re); } function xe(t) { for (;t.tabIndex === -1;)t = t.parentNode; t.style && (Se(), Kt = (Zt = t).style.outline, t.style.outline = "none", Te(window, "keydown", Se)); } function Se() { Zt && (Zt.style.outline = Kt, Kt = Zt = void 0, Oe(window, "keydown", Se)); } function ke(t) { for (;!((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body););return t; } function Ce(t) { const e = t.getBoundingClientRect(); return { x: e.width / t.offsetWidth || 1, y: e.height / t.offsetHeight || 1, boundingClientRect: e }; }Yt = "onselectstart" in document ? (Gt = function () { Te(window, "selectstart", Re); }, function () { Oe(window, "selectstart", Re); }) : (Wt = ge(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]), Gt = function () { let t; Wt && (t = document.documentElement.style, Ut = t[Wt], t[Wt] = "none"); }, function () { Wt && (document.documentElement.style[Wt] = Ut, Ut = void 0); }); const Ee = {
    TRANSFORM: te, TRANSITION: ee, TRANSITION_END: ne, get: re, getStyle: ie, create: oe, remove: se, empty: ae, toFront: le, toBack: ue, hasClass: ce, addClass: de, removeClass: he, setClass: pe, getClass: fe, setOpacity: me, testProp: ge, setTransform: ve, setPosition: ye, getPosition: _e, disableTextSelection: Gt, enableTextSelection: Yt, disableImageDrag: be, enableImageDrag: we, preventOutline: xe, restoreOutline: Se, getSizedParentNode: ke, getScale: Ce,
  }; function Te(t, e, n, r) { if (typeof e === "object") for (const i in e)Le(t, i, e[i], n); else for (let o = 0, s = (e = h(e)).length; o < s; o++)Le(t, e[o], n, r); return this; } const Pe = "_leaflet_events"; function Oe(t, e, n, r) { if (typeof e === "object") for (const i in e)Ie(t, i, e[i], n); else if (e) for (let o = 0, s = (e = h(e)).length; o < s; o++)Ie(t, e[o], n, r); else { for (const a in t[Pe])Ie(t, a, t[Pe][a]); delete t[Pe]; } return this; } function Ae() { return St && !nt && !dt; } const Me = { mouseenter: "mouseover", mouseleave: "mouseout", wheel: !("onwheel" in window) && "mousewheel" }; function Le(t, e, n, r) { const i = e + s(n) + (r ? `_${s(r)}` : ""); if (t[Pe] && t[Pe][i]) return this; let o; let a; let l; let u; let c; let d; let h = function (e) { return n.call(r || t, e || window.event); }; const p = h; function f(t) { if (St) { if (!t.isPrimary) return; if (t.pointerType === "mouse") return; } else if (t.touches.length > 1) return; const e = Date.now(); const n = e - (u || e); c = t.touches ? t.touches[0] : t, d = n > 0 && n <= 250, u = e; } function m(t) { if (d && !c.cancelBubble) { if (St) { if (t.pointerType === "mouse") return; let e; let n; const r = {}; for (n in c)e = c[n], r[n] = e && e.bind ? e.bind(c) : e; c = r; }c.type = "dblclick", c.button = 0, a(c), u = null; } }St && e.indexOf("touch") === 0 ? zt(t, e, h, i) : kt && e === "dblclick" && !Ae() ? (a = h, d = !1, (o = t)[Jt + Xt + (l = i)] = f, o[Jt + Qt + l] = m, o[`${Jt}dblclick${l}`] = a, o.addEventListener(Xt, f, !!Pt && { passive: !1 }), o.addEventListener(Qt, m, !!Pt && { passive: !1 }), o.addEventListener("dblclick", a, !1)) : "addEventListener" in t ? e === "touchstart" || e === "touchmove" || e === "wheel" || e === "mousewheel" ? t.addEventListener(Me[e] || e, h, !!Pt && { passive: !1 }) : e === "mouseenter" || e === "mouseleave" ? (h = function (e) { e = e || window.event, Ue(t, e) && p(e); }, t.addEventListener(Me[e], h, !1)) : t.addEventListener(e, p, !1) : "attachEvent" in t && t.attachEvent(`on${e}`, h), t[Pe] = t[Pe] || {}, t[Pe][i] = h; } function Ie(t, e, n, r) { let i; let o; let a; let l; let u; let c; let d; let h; const p = e + s(n) + (r ? `_${s(r)}` : ""); const f = t[Pe] && t[Pe][p]; if (!f) return this; St && e.indexOf("touch") === 0 ? (h = (c = t)[`_leaflet_${d = e}${p}`], d === "touchstart" ? c.removeEventListener(jt, h, !1) : d === "touchmove" ? c.removeEventListener(Dt, h, !1) : d === "touchend" && (c.removeEventListener(Nt, h, !1), c.removeEventListener(Rt, h, !1))) : kt && e === "dblclick" && !Ae() ? (a = (i = t)[Jt + Xt + (o = p)], l = i[Jt + Qt + o], u = i[`${Jt}dblclick${o}`], i.removeEventListener(Xt, a, !!Pt && { passive: !1 }), i.removeEventListener(Qt, l, !!Pt && { passive: !1 }), i.removeEventListener("dblclick", u, !1)) : "removeEventListener" in t ? t.removeEventListener(Me[e] || e, f, !1) : "detachEvent" in t && t.detachEvent(`on${e}`, f), t[Pe][p] = null; } function je(t) { return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, $e(t), this; } function De(t) { return Le(t, "wheel", je), this; } function Ne(t) { return Te(t, "mousedown touchstart dblclick", je), Le(t, "click", He), this; } function Re(t) { return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this; } function Fe(t) { return Re(t), je(t), this; } function Ve(t, e) { if (!e) return new M(t.clientX, t.clientY); const n = Ce(e); const r = n.boundingClientRect; return new M((t.clientX - r.left) / n.x - e.clientLeft, (t.clientY - r.top) / n.y - e.clientTop); } const ze = ft && ut ? 2 * window.devicePixelRatio : ct ? window.devicePixelRatio : 1; function Be(t) { return nt ? t.wheelDeltaY / 2 : t.deltaY && t.deltaMode === 0 ? -t.deltaY / ze : t.deltaY && t.deltaMode === 1 ? 20 * -t.deltaY : t.deltaY && t.deltaMode === 2 ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0; } const qe = {}; function He(t) { qe[t.type] = !0; } function $e(t) { const e = qe[t.type]; return qe[t.type] = !1, e; } function Ue(t, e) { let n = e.relatedTarget; if (!n) return !0; try { for (;n && n !== t;)n = n.parentNode; } catch (t) { return !1; } return n !== t; } const We = {
    on: Te, off: Oe, stopPropagation: je, disableScrollPropagation: De, disableClickPropagation: Ne, preventDefault: Re, stop: Fe, getMousePosition: Ve, getWheelDelta: Be, fakeStop: He, skipped: $e, isExternalTarget: Ue, addListener: Te, removeListener: Oe,
  }; const Ge = A.extend({
    run(t, e, n, r) { this.stop(), this._el = t, this._inProgress = !0, this._duration = n || 0.25, this._easeOutPower = 1 / Math.max(r || 0.5, 0.2), this._startPos = _e(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date(), this.fire("start"), this._animate(); }, stop() { this._inProgress && (this._step(!0), this._complete()); }, _animate() { this._animId = C(this._animate, this), this._step(); }, _step(t) { const e = new Date() - this._startTime; const n = 1e3 * this._duration; e < n ? this._runFrame(this._easeOut(e / n), t) : (this._runFrame(1), this._complete()); }, _runFrame(t, e) { const n = this._startPos.add(this._offset.multiplyBy(t)); e && n._round(), ye(this._el, n), this.fire("step"); }, _complete() { E(this._animId), this._inProgress = !1, this.fire("end"); }, _easeOut(t) { return 1 - (1 - t) ** this._easeOutPower; },
  }); const Ye = A.extend({
    options: {
      crs: Z, center: void 0, zoom: void 0, minZoom: void 0, maxZoom: void 0, layers: [], maxBounds: void 0, renderer: void 0, zoomAnimation: !0, zoomAnimationThreshold: 4, fadeAnimation: !0, markerZoomAnimation: !0, transform3DLimit: 8388608, zoomSnap: 1, zoomDelta: 1, trackResize: !0,
    },
    initialize(t, e) { e = p(this, e), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = i(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)), e.center && void 0 !== e.zoom && this.setView(z(e.center), e.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = ee && yt && !Ct && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Te(this._proxy, ne, this._catchTransitionEnd, this)), this._addLayers(this.options.layers); },
    setView(t, n, r) { return n = void 0 === n ? this._zoom : this._limitZoom(n), t = this._limitCenter(z(t), n, this.options.maxBounds), r = r || {}, this._stop(), this._loaded && !r.reset && !0 !== r && (void 0 !== r.animate && (r.zoom = e({ animate: r.animate }, r.zoom), r.pan = e({ animate: r.animate, duration: r.duration }, r.pan)), this._zoom !== n ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, n, r.zoom) : this._tryAnimatedPan(t, r.pan)) ? (clearTimeout(this._sizeTimer), this) : (this._resetView(t, n), this); },
    setZoom(t, e) { return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this); },
    zoomIn(t, e) { return t = t || (yt ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e); },
    zoomOut(t, e) { return t = t || (yt ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e); },
    setZoomAround(t, e, n) { const r = this.getZoomScale(e); const i = this.getSize().divideBy(2); const o = (t instanceof M ? t : this.latLngToContainerPoint(t)).subtract(i).multiplyBy(1 - 1 / r); const s = this.containerPointToLatLng(i.add(o)); return this.setView(s, e, { zoom: n }); },
    _getBoundsCenterZoom(t, e) { e = e || {}, t = t.getBounds ? t.getBounds() : F(t); const n = j(e.paddingTopLeft || e.padding || [0, 0]); const r = j(e.paddingBottomRight || e.padding || [0, 0]); let i = this.getBoundsZoom(t, !1, n.add(r)); if ((i = typeof e.maxZoom === "number" ? Math.min(e.maxZoom, i) : i) === 1 / 0) return { center: t.getCenter(), zoom: i }; const o = r.subtract(n).divideBy(2); const s = this.project(t.getSouthWest(), i); const a = this.project(t.getNorthEast(), i); return { center: this.unproject(s.add(a).divideBy(2).add(o), i), zoom: i }; },
    fitBounds(t, e) { if (!(t = F(t)).isValid()) throw new Error("Bounds are not valid."); const n = this._getBoundsCenterZoom(t, e); return this.setView(n.center, n.zoom, e); },
    fitWorld(t) { return this.fitBounds([[-90, -180], [90, 180]], t); },
    panTo(t, e) { return this.setView(t, this._zoom, { pan: e }); },
    panBy(t, e) { return e = e || {}, (t = j(t).round()).x || t.y ? (!0 === e.animate || this.getSize().contains(t) ? (this._panAnim || (this._panAnim = new Ge(), this._panAnim.on({ step: this._onPanTransitionStep, end: this._onPanTransitionEnd }, this)), e.noMoveStart || this.fire("movestart"), !1 !== e.animate ? (de(this._mapPane, "leaflet-pan-anim"), n = this._getMapPanePos().subtract(t).round(), this._panAnim.run(this._mapPane, n, e.duration || 0.25, e.easeLinearity)) : (this._rawPanBy(t), this.fire("move").fire("moveend"))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this) : this.fire("moveend"); let n; },
    flyTo(t, e, n) { if (!1 === (n = n || {}).animate || !yt) return this.setView(t, e, n); this._stop(); const r = this.project(this.getCenter()); const i = this.project(t); const o = this.getSize(); const s = this._zoom; t = z(t), e = void 0 === e ? s : e; const a = Math.max(o.x, o.y); const l = a * this.getZoomScale(s, e); const u = i.distanceTo(r) || 1; const c = 1.42; const d = c * c; function h(t) { const e = (l * l - a * a + (t ? -1 : 1) * d * d * u * u) / (2 * (t ? l : a) * d * u); const n = Math.sqrt(e * e + 1) - e; return n < 1e-9 ? -18 : Math.log(n); } function p(t) { return (Math.exp(t) - Math.exp(-t)) / 2; } function f(t) { return (Math.exp(t) + Math.exp(-t)) / 2; } const m = h(0); function g(t) { return a * (f(m) * (p(e = m + c * t) / f(e)) - p(m)) / d; let e; } const v = Date.now(); const y = (h(1) - m) / c; const _ = n.duration ? 1e3 * n.duration : 1e3 * y * 0.8; return this._moveStart(!0, n.noMoveStart), function n() { let o; let l; const d = (Date.now() - v) / _; const h = (o = d, (1 - (1 - o) ** 1.5) * y); d <= 1 ? (this._flyToFrame = C(n, this), this._move(this.unproject(r.add(i.subtract(r).multiplyBy(g(h) / u)), s), this.getScaleZoom(a / (l = h, a * (f(m) / f(m + c * l))), s), { flyTo: !0 })) : this._move(t, e)._moveEnd(!0); }.call(this), this; },
    flyToBounds(t, e) { const n = this._getBoundsCenterZoom(t, e); return this.flyTo(n.center, n.zoom, e); },
    setMaxBounds(t) { return (t = F(t)).isValid() ? (this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off("moveend", this._panInsideMaxBounds)); },
    setMinZoom(t) { const e = this.options.minZoom; return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this; },
    setMaxZoom(t) { const e = this.options.maxZoom; return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this; },
    panInsideBounds(t, e) { this._enforcingBounds = !0; const n = this.getCenter(); const r = this._limitCenter(n, this._zoom, F(t)); return n.equals(r) || this.panTo(r, e), this._enforcingBounds = !1, this; },
    panInside(t, e) { let n; let r; const i = j((e = e || {}).paddingTopLeft || e.padding || [0, 0]); const o = j(e.paddingBottomRight || e.padding || [0, 0]); const s = this.getCenter(); const a = this.project(s); const l = this.project(t); const u = this.getPixelBounds(); const c = u.getSize().divideBy(2); const d = N([u.min.add(i), u.max.subtract(o)]); return d.contains(l) || (this._enforcingBounds = !0, n = a.subtract(l), r = j(l.x + n.x, l.y + n.y), (l.x < d.min.x || l.x > d.max.x) && (r.x = a.x - n.x, n.x > 0 ? r.x += c.x - i.x : r.x -= c.x - o.x), (l.y < d.min.y || l.y > d.max.y) && (r.y = a.y - n.y, n.y > 0 ? r.y += c.y - i.y : r.y -= c.y - o.y), this.panTo(this.unproject(r), e), this._enforcingBounds = !1), this; },
    invalidateSize(t) { if (!this._loaded) return this; t = e({ animate: !1, pan: !0 }, !0 === t ? { animate: !0 } : t); const n = this.getSize(); this._sizeChanged = !0, this._lastCenter = null; const r = this.getSize(); const o = n.divideBy(2).round(); const s = r.divideBy(2).round(); const a = o.subtract(s); return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(i(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", { oldSize: n, newSize: r })) : this; },
    stop() { return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop(); },
    locate(t) { if (t = this._locateOptions = e({ timeout: 1e4, watch: !1 }, t), !("geolocation" in navigator)) return this._handleGeolocationError({ code: 0, message: "Geolocation not supported." }), this; const n = i(this._handleGeolocationResponse, this); const r = i(this._handleGeolocationError, this); return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(n, r, t) : navigator.geolocation.getCurrentPosition(n, r, t), this; },
    stopLocate() { return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this; },
    _handleGeolocationError(t) { const e = t.code; const n = t.message || (e === 1 ? "permission denied" : e === 2 ? "position unavailable" : "timeout"); this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", { code: e, message: `Geolocation error: ${n}.` }); },
    _handleGeolocationResponse(t) { let e; const n = new V(t.coords.latitude, t.coords.longitude); const r = n.toBounds(2 * t.coords.accuracy); const i = this._locateOptions; i.setView && (e = this.getBoundsZoom(r), this.setView(n, i.maxZoom ? Math.min(e, i.maxZoom) : e)); const o = { latlng: n, bounds: r, timestamp: t.timestamp }; for (const s in t.coords) typeof t.coords[s] === "number" && (o[s] = t.coords[s]); this.fire("locationfound", o); },
    addHandler(t, e) { if (!e) return this; const n = this[t] = new e(this); return this._handlers.push(n), this.options[t] && n.enable(), this; },
    remove() { if (this._initEvents(!0), this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance"); try { delete this._container._leaflet_id, delete this._containerId; } catch (t) { this._container._leaflet_id = void 0, this._containerId = void 0; } let t; for (t in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), se(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (E(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers) this._layers[t].remove(); for (t in this._panes)se(this._panes[t]); return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this; },
    createPane(t, e) { const n = oe("div", `leaflet-pane${t ? ` leaflet-${t.replace("Pane", "")}-pane` : ""}`, e || this._mapPane); return t && (this._panes[t] = n), n; },
    getCenter() { return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint()); },
    getZoom() { return this._zoom; },
    getBounds() { const t = this.getPixelBounds(); return new R(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight())); },
    getMinZoom() { return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom; },
    getMaxZoom() { return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom; },
    getBoundsZoom(t, e, n) { t = F(t), n = j(n || [0, 0]); let r = this.getZoom() || 0; const i = this.getMinZoom(); const o = this.getMaxZoom(); const s = t.getNorthWest(); const a = t.getSouthEast(); const l = this.getSize().subtract(n); const u = N(this.project(a, r), this.project(s, r)).getSize(); const c = yt ? this.options.zoomSnap : 1; const d = l.x / u.x; const h = l.y / u.y; const p = e ? Math.max(d, h) : Math.min(d, h); r = this.getScaleZoom(p, r); return c && (r = Math.round(r / (c / 100)) * (c / 100), r = e ? Math.ceil(r / c) * c : Math.floor(r / c) * c), Math.max(i, Math.min(o, r)); },
    getSize() { return this._size && !this._sizeChanged || (this._size = new M(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone(); },
    getPixelBounds(t, e) { const n = this._getTopLeftPoint(t, e); return new D(n, n.add(this.getSize())); },
    getPixelOrigin() { return this._checkIfLoaded(), this._pixelOrigin; },
    getPixelWorldBounds(t) { return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t); },
    getPane(t) { return typeof t === "string" ? this._panes[t] : t; },
    getPanes() { return this._panes; },
    getContainer() { return this._container; },
    getZoomScale(t, e) { const n = this.options.crs; return e = void 0 === e ? this._zoom : e, n.scale(t) / n.scale(e); },
    getScaleZoom(t, e) { const n = this.options.crs; e = void 0 === e ? this._zoom : e; const r = n.zoom(t * n.scale(e)); return isNaN(r) ? 1 / 0 : r; },
    project(t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.latLngToPoint(z(t), e); },
    unproject(t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.pointToLatLng(j(t), e); },
    layerPointToLatLng(t) { const e = j(t).add(this.getPixelOrigin()); return this.unproject(e); },
    latLngToLayerPoint(t) { return this.project(z(t))._round()._subtract(this.getPixelOrigin()); },
    wrapLatLng(t) { return this.options.crs.wrapLatLng(z(t)); },
    wrapLatLngBounds(t) { return this.options.crs.wrapLatLngBounds(F(t)); },
    distance(t, e) { return this.options.crs.distance(z(t), z(e)); },
    containerPointToLayerPoint(t) { return j(t).subtract(this._getMapPanePos()); },
    layerPointToContainerPoint(t) { return j(t).add(this._getMapPanePos()); },
    containerPointToLatLng(t) { const e = this.containerPointToLayerPoint(j(t)); return this.layerPointToLatLng(e); },
    latLngToContainerPoint(t) { return this.layerPointToContainerPoint(this.latLngToLayerPoint(z(t))); },
    mouseEventToContainerPoint(t) { return Ve(t, this._container); },
    mouseEventToLayerPoint(t) { return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t)); },
    mouseEventToLatLng(t) { return this.layerPointToLatLng(this.mouseEventToLayerPoint(t)); },
    _initContainer(t) { const e = this._container = re(t); if (!e) throw new Error("Map container not found."); if (e._leaflet_id) throw new Error("Map container is already initialized."); Te(e, "scroll", this._onScroll, this), this._containerId = s(e); },
    _initLayout() { const t = this._container; this._fadeAnimated = this.options.fadeAnimation && yt, de(t, `leaflet-container${kt ? " leaflet-touch" : ""}${Tt ? " leaflet-retina" : ""}${et ? " leaflet-oldie" : ""}${dt ? " leaflet-safari" : ""}${this._fadeAnimated ? " leaflet-fade-anim" : ""}`); const e = ie(t, "position"); e !== "absolute" && e !== "relative" && e !== "fixed" && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos(); },
    _initPanes() { const t = this._panes = {}; this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), ye(this._mapPane, new M(0, 0)), this.createPane("tilePane"), this.createPane("shadowPane"), this.createPane("overlayPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (de(t.markerPane, "leaflet-zoom-hide"), de(t.shadowPane, "leaflet-zoom-hide")); },
    _resetView(t, e) { ye(this._mapPane, new M(0, 0)); const n = !this._loaded; this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset"); const r = this._zoom !== e; this._moveStart(r, !1)._move(t, e)._moveEnd(r), this.fire("viewreset"), n && this.fire("load"); },
    _moveStart(t, e) { return t && this.fire("zoomstart"), e || this.fire("movestart"), this; },
    _move(t, e, n) { void 0 === e && (e = this._zoom); const r = this._zoom !== e; return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), (r || n && n.pinch) && this.fire("zoom", n), this.fire("move", n); },
    _moveEnd(t) { return t && this.fire("zoomend"), this.fire("moveend"); },
    _stop() { return E(this._flyToFrame), this._panAnim && this._panAnim.stop(), this; },
    _rawPanBy(t) { ye(this._mapPane, this._getMapPanePos().subtract(t)); },
    _getZoomSpan() { return this.getMaxZoom() - this.getMinZoom(); },
    _panInsideMaxBounds() { this._enforcingBounds || this.panInsideBounds(this.options.maxBounds); },
    _checkIfLoaded() { if (!this._loaded) throw new Error("Set map center and zoom first."); },
    _initEvents(t) { this._targets = {}; const e = t ? Oe : Te; e((this._targets[s(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), yt && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd); },
    _onResize() { E(this._resizeRequest), this._resizeRequest = C((function () { this.invalidateSize({ debounceMoveend: !0 }); }), this); },
    _onScroll() { this._container.scrollTop = 0, this._container.scrollLeft = 0; },
    _onMoveEnd() { const t = this._getMapPanePos(); Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom()); },
    _findEventTargets(t, e) { for (var n, r = [], i = e === "mouseout" || e === "mouseover", o = t.target || t.srcElement, a = !1; o;) { if ((n = this._targets[s(o)]) && (e === "click" || e === "preclick") && !t._simulated && this._draggableMoved(n)) { a = !0; break; } if (n && n.listens(e, !0)) { if (i && !Ue(o, t)) break; if (r.push(n), i) break; } if (o === this._container) break; o = o.parentNode; } return r.length || a || i || !Ue(o, t) || (r = [this]), r; },
    _handleDOMEvent(t) { let e; this._loaded && !$e(t) && ((e = t.type) !== "mousedown" && e !== "keypress" && e !== "keyup" && e !== "keydown" || xe(t.target || t.srcElement), this._fireDOMEvent(t, e)); },
    _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
    _fireDOMEvent(t, n, r) { let i; if (t.type === "click" && ((i = e({}, t)).type = "preclick", this._fireDOMEvent(i, i.type, r)), !t._stopped && (r = (r || []).concat(this._findEventTargets(t, n))).length) { const o = r[0]; n === "contextmenu" && o.listens(n, !0) && Re(t); let s; const a = { originalEvent: t }; t.type !== "keypress" && t.type !== "keydown" && t.type !== "keyup" && (s = o.getLatLng && (!o._radius || o._radius <= 10), a.containerPoint = s ? this.latLngToContainerPoint(o.getLatLng()) : this.mouseEventToContainerPoint(t), a.layerPoint = this.containerPointToLayerPoint(a.containerPoint), a.latlng = s ? o.getLatLng() : this.layerPointToLatLng(a.layerPoint)); for (let l = 0; l < r.length; l++) if (r[l].fire(n, a, !0), a.originalEvent._stopped || !1 === r[l].options.bubblingMouseEvents && y(this._mouseEvents, n) !== -1) return; } },
    _draggableMoved(t) { return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved(); },
    _clearHandlers() { for (let t = 0, e = this._handlers.length; t < e; t++) this._handlers[t].disable(); },
    whenReady(t, e) { return this._loaded ? t.call(e || this, { target: this }) : this.on("load", t, e), this; },
    _getMapPanePos() { return _e(this._mapPane) || new M(0, 0); },
    _moved() { const t = this._getMapPanePos(); return t && !t.equals([0, 0]); },
    _getTopLeftPoint(t, e) { return (t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin()).subtract(this._getMapPanePos()); },
    _getNewPixelOrigin(t, e) { const n = this.getSize()._divideBy(2); return this.project(t, e)._subtract(n)._add(this._getMapPanePos())._round(); },
    _latLngToNewLayerPoint(t, e, n) { const r = this._getNewPixelOrigin(n, e); return this.project(t, e)._subtract(r); },
    _latLngBoundsToNewLayerBounds(t, e, n) { const r = this._getNewPixelOrigin(n, e); return N([this.project(t.getSouthWest(), e)._subtract(r), this.project(t.getNorthWest(), e)._subtract(r), this.project(t.getSouthEast(), e)._subtract(r), this.project(t.getNorthEast(), e)._subtract(r)]); },
    _getCenterLayerPoint() { return this.containerPointToLayerPoint(this.getSize()._divideBy(2)); },
    _getCenterOffset(t) { return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint()); },
    _limitCenter(t, e, n) { if (!n) return t; const r = this.project(t, e); const i = this.getSize().divideBy(2); const o = new D(r.subtract(i), r.add(i)); const s = this._getBoundsOffset(o, n, e); return s.round().equals([0, 0]) ? t : this.unproject(r.add(s), e); },
    _limitOffset(t, e) { if (!e) return t; const n = this.getPixelBounds(); const r = new D(n.min.add(t), n.max.add(t)); return t.add(this._getBoundsOffset(r, e)); },
    _getBoundsOffset(t, e, n) { const r = N(this.project(e.getNorthEast(), n), this.project(e.getSouthWest(), n)); const i = r.min.subtract(t.min); const o = r.max.subtract(t.max); return new M(this._rebound(i.x, -o.x), this._rebound(i.y, -o.y)); },
    _rebound(t, e) { return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e)); },
    _limitZoom(t) { const e = this.getMinZoom(); const n = this.getMaxZoom(); const r = yt ? this.options.zoomSnap : 1; return r && (t = Math.round(t / r) * r), Math.max(e, Math.min(n, t)); },
    _onPanTransitionStep() { this.fire("move"); },
    _onPanTransitionEnd() { he(this._mapPane, "leaflet-pan-anim"), this.fire("moveend"); },
    _tryAnimatedPan(t, e) { const n = this._getCenterOffset(t)._trunc(); return !(!0 !== (e && e.animate) && !this.getSize().contains(n) || (this.panBy(n, e), 0)); },
    _createAnimProxy() { const t = this._proxy = oe("div", "leaflet-proxy leaflet-zoom-animated"); this._panes.mapPane.appendChild(t), this.on("zoomanim", (function (t) { const e = te; const n = this._proxy.style[e]; ve(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), n === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd(); }), this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this); },
    _destroyAnimProxy() { se(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy; },
    _animMoveEnd() { const t = this.getCenter(); const e = this.getZoom(); ve(this._proxy, this.project(t, e), this.getZoomScale(e, 1)); },
    _catchTransitionEnd(t) { this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd(); },
    _nothingToAnimate() { return !this._container.getElementsByClassName("leaflet-zoom-animated").length; },
    _tryAnimatedZoom(t, e, n) { if (this._animatingZoom) return !0; if (n = n || {}, !this._zoomAnimated || !1 === n.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1; const r = this.getZoomScale(e); const i = this._getCenterOffset(t)._divideBy(1 - 1 / r); return !(!0 !== n.animate && !this.getSize().contains(i) || (C((function () { this._moveStart(!0, !1)._animateZoom(t, e, !0); }), this), 0)); },
    _animateZoom(t, e, n, r) { this._mapPane && (n && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, de(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", { center: t, zoom: e, noUpdate: r }), setTimeout(i(this._onZoomTransitionEnd, this), 250)); },
    _onZoomTransitionEnd() { this._animatingZoom && (this._mapPane && he(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom), C((function () { this._moveEnd(!0); }), this)); },
  }); function Ze(t) { return new Ke(t); } var Ke = P.extend({
    options: { position: "topright" }, initialize(t) { p(this, t); }, getPosition() { return this.options.position; }, setPosition(t) { const e = this._map; return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this; }, getContainer() { return this._container; }, addTo(t) { this.remove(), this._map = t; const e = this._container = this.onAdd(t); const n = this.getPosition(); const r = t._controlCorners[n]; return de(e, "leaflet-control"), n.indexOf("bottom") !== -1 ? r.insertBefore(e, r.firstChild) : r.appendChild(e), this._map.on("unload", this.remove, this), this; }, remove() { return this._map && (se(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null), this; }, _refocusOnMap(t) { this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus(); },
  }); Ye.include({
    addControl(t) { return t.addTo(this), this; }, removeControl(t) { return t.remove(), this; }, _initControlPos() { const t = this._controlCorners = {}; const e = "leaflet-"; const n = this._controlContainer = oe("div", `${e}control-container`, this._container); function r(r, i) { const o = `${e + r} ${e}${i}`; t[r + i] = oe("div", o, n); }r("top", "left"), r("top", "right"), r("bottom", "left"), r("bottom", "right"); }, _clearControlPos() { for (const t in this._controlCorners)se(this._controlCorners[t]); se(this._controlContainer), delete this._controlCorners, delete this._controlContainer; },
  }); const Xe = Ke.extend({
    options: {
      collapsed: !0, position: "topright", autoZIndex: !0, hideSingleBase: !1, sortLayers: !1, sortFunction(t, e, n, r) { return n < r ? -1 : r < n ? 1 : 0; },
    },
    initialize(t, e, n) { for (var r in p(this, n), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, t) this._addLayer(t[r], r); for (r in e) this._addLayer(e[r], r, !0); },
    onAdd(t) { this._initLayout(), this._update(), (this._map = t).on("zoomend", this._checkDisabledLayers, this); for (let e = 0; e < this._layers.length; e++) this._layers[e].layer.on("add remove", this._onLayerChange, this); return this._container; },
    addTo(t) { return Ke.prototype.addTo.call(this, t), this._expandIfNotCollapsed(); },
    onRemove() { this._map.off("zoomend", this._checkDisabledLayers, this); for (let t = 0; t < this._layers.length; t++) this._layers[t].layer.off("add remove", this._onLayerChange, this); },
    addBaseLayer(t, e) { return this._addLayer(t, e), this._map ? this._update() : this; },
    addOverlay(t, e) { return this._addLayer(t, e, !0), this._map ? this._update() : this; },
    removeLayer(t) { t.off("add remove", this._onLayerChange, this); const e = this._getLayer(s(t)); return e && this._layers.splice(this._layers.indexOf(e), 1), this._map ? this._update() : this; },
    expand() { de(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null; const t = this._map.getSize().y - (this._container.offsetTop + 50); return t < this._section.clientHeight ? (de(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = `${t}px`) : he(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this; },
    collapse() { return he(this._container, "leaflet-control-layers-expanded"), this; },
    _initLayout() { const t = "leaflet-control-layers"; const e = this._container = oe("div", t); const n = this.options.collapsed; e.setAttribute("aria-haspopup", !0), Ne(e), De(e); const r = this._section = oe("section", `${t}-list`); n && (this._map.on("click", this.collapse, this), it || Te(e, { mouseenter: this.expand, mouseleave: this.collapse }, this)); const i = this._layersLink = oe("a", `${t}-toggle`, e); i.href = "#", i.title = "Layers", kt ? (Te(i, "click", Fe), Te(i, "click", this.expand, this)) : Te(i, "focus", this.expand, this), n || this.expand(), this._baseLayersList = oe("div", `${t}-base`, r), this._separator = oe("div", `${t}-separator`, r), this._overlaysList = oe("div", `${t}-overlays`, r), e.appendChild(r); },
    _getLayer(t) { for (let e = 0; e < this._layers.length; e++) if (this._layers[e] && s(this._layers[e].layer) === t) return this._layers[e]; },
    _addLayer(t, e, n) { this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({ layer: t, name: e, overlay: n }), this.options.sortLayers && this._layers.sort(i((function (t, e) { return this.options.sortFunction(t.layer, e.layer, t.name, e.name); }), this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed(); },
    _update() { if (!this._container) return this; ae(this._baseLayersList), ae(this._overlaysList), this._layerControlInputs = []; for (var t, e, n, r = 0, i = 0; i < this._layers.length; i++)n = this._layers[i], this._addItem(n), e = e || n.overlay, t = t || !n.overlay, r += n.overlay ? 0 : 1; return this.options.hideSingleBase && (t = t && r > 1, this._baseLayersList.style.display = t ? "" : "none"), this._separator.style.display = e && t ? "" : "none", this; },
    _onLayerChange(t) { this._handlingClick || this._update(); const e = this._getLayer(s(t.target)); const n = e.overlay ? t.type === "add" ? "overlayadd" : "overlayremove" : t.type === "add" ? "baselayerchange" : null; n && this._map.fire(n, e); },
    _createRadioElement(t, e) { const n = `<input type="radio" class="leaflet-control-layers-selector" name="${t}"${e ? ' checked="checked"' : ""}/>`; const r = document.createElement("div"); return r.innerHTML = n, r.firstChild; },
    _addItem(t) { let e; const n = document.createElement("label"); const r = this._map.hasLayer(t.layer); t.overlay ? ((e = document.createElement("input")).type = "checkbox", e.className = "leaflet-control-layers-selector", e.defaultChecked = r) : e = this._createRadioElement(`leaflet-base-layers_${s(this)}`, r), this._layerControlInputs.push(e), e.layerId = s(t.layer), Te(e, "click", this._onInputClick, this); const i = document.createElement("span"); i.innerHTML = ` ${t.name}`; const o = document.createElement("div"); return n.appendChild(o), o.appendChild(e), o.appendChild(i), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(n), this._checkDisabledLayers(), n; },
    _onInputClick() { let t; let e; const n = this._layerControlInputs; const r = []; const i = []; this._handlingClick = !0; for (var o = n.length - 1; o >= 0; o--)t = n[o], e = this._getLayer(t.layerId).layer, t.checked ? r.push(e) : t.checked || i.push(e); for (o = 0; o < i.length; o++) this._map.hasLayer(i[o]) && this._map.removeLayer(i[o]); for (o = 0; o < r.length; o++) this._map.hasLayer(r[o]) || this._map.addLayer(r[o]); this._handlingClick = !1, this._refocusOnMap(); },
    _checkDisabledLayers() { for (var t, e, n = this._layerControlInputs, r = this._map.getZoom(), i = n.length - 1; i >= 0; i--)t = n[i], e = this._getLayer(t.layerId).layer, t.disabled = void 0 !== e.options.minZoom && r < e.options.minZoom || void 0 !== e.options.maxZoom && r > e.options.maxZoom; },
    _expandIfNotCollapsed() { return this._map && !this.options.collapsed && this.expand(), this; },
    _expand() { return this.expand(); },
    _collapse() { return this.collapse(); },
  }); const Qe = Ke.extend({
    options: {
      position: "topleft", zoomInText: "+", zoomInTitle: "Zoom in", zoomOutText: "&#x2212;", zoomOutTitle: "Zoom out",
    },
    onAdd(t) { const e = "leaflet-control-zoom"; const n = oe("div", `${e} leaflet-bar`); const r = this.options; return this._zoomInButton = this._createButton(r.zoomInText, r.zoomInTitle, `${e}-in`, n, this._zoomIn), this._zoomOutButton = this._createButton(r.zoomOutText, r.zoomOutTitle, `${e}-out`, n, this._zoomOut), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), n; },
    onRemove(t) { t.off("zoomend zoomlevelschange", this._updateDisabled, this); },
    disable() { return this._disabled = !0, this._updateDisabled(), this; },
    enable() { return this._disabled = !1, this._updateDisabled(), this; },
    _zoomIn(t) { !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)); },
    _zoomOut(t) { !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)); },
    _createButton(t, e, n, r, i) { const o = oe("a", n, r); return o.innerHTML = t, o.href = "#", o.title = e, o.setAttribute("role", "button"), o.setAttribute("aria-label", e), Ne(o), Te(o, "click", Fe), Te(o, "click", i, this), Te(o, "click", this._refocusOnMap, this), o; },
    _updateDisabled() { const t = this._map; const e = "leaflet-disabled"; he(this._zoomInButton, e), he(this._zoomOutButton, e), !this._disabled && t._zoom !== t.getMinZoom() || de(this._zoomOutButton, e), !this._disabled && t._zoom !== t.getMaxZoom() || de(this._zoomInButton, e); },
  }); Ye.mergeOptions({ zoomControl: !0 }), Ye.addInitHook((function () { this.options.zoomControl && (this.zoomControl = new Qe(), this.addControl(this.zoomControl)); })); const Je = Ke.extend({
    options: {
      position: "bottomleft", maxWidth: 100, metric: !0, imperial: !0,
    },
    onAdd(t) { const e = "leaflet-control-scale"; const n = oe("div", e); const r = this.options; return this._addScales(r, `${e}-line`, n), t.on(r.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), n; },
    onRemove(t) { t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this); },
    _addScales(t, e, n) { t.metric && (this._mScale = oe("div", e, n)), t.imperial && (this._iScale = oe("div", e, n)); },
    _update() { const t = this._map; const e = t.getSize().y / 2; const n = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e])); this._updateScales(n); },
    _updateScales(t) { this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t); },
    _updateMetric(t) { const e = this._getRoundNum(t); const n = e < 1e3 ? `${e} m` : `${e / 1e3} km`; this._updateScale(this._mScale, n, e / t); },
    _updateImperial(t) { let e; let n; let r; const i = 3.2808399 * t; i > 5280 ? (e = i / 5280, n = this._getRoundNum(e), this._updateScale(this._iScale, `${n} mi`, n / e)) : (r = this._getRoundNum(i), this._updateScale(this._iScale, `${r} ft`, r / i)); },
    _updateScale(t, e, n) { t.style.width = `${Math.round(this.options.maxWidth * n)}px`, t.innerHTML = e; },
    _getRoundNum(t) { const e = 10 ** ((`${Math.floor(t)}`).length - 1); const n = t / e; return e * (n >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : 1); },
  }); const tn = Ke.extend({
    options: { position: "bottomright", prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>' }, initialize(t) { p(this, t), this._attributions = {}; }, onAdd(t) { for (const e in (t.attributionControl = this)._container = oe("div", "leaflet-control-attribution"), Ne(this._container), t._layers)t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution()); return this._update(), this._container; }, setPrefix(t) { return this.options.prefix = t, this._update(), this; }, addAttribution(t) { return t && (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update()), this; }, removeAttribution(t) { return t && this._attributions[t] && (this._attributions[t]--, this._update()), this; }, _update() { if (this._map) { const t = []; for (const e in this._attributions) this._attributions[e] && t.push(e); const n = []; this.options.prefix && n.push(this.options.prefix), t.length && n.push(t.join(", ")), this._container.innerHTML = n.join(" | "); } },
  }); Ye.mergeOptions({ attributionControl: !0 }), Ye.addInitHook((function () { this.options.attributionControl && (new tn()).addTo(this); })), Ke.Layers = Xe, Ke.Zoom = Qe, Ke.Scale = Je, Ke.Attribution = tn, Ze.layers = function (t, e, n) { return new Xe(t, e, n); }, Ze.zoom = function (t) { return new Qe(t); }, Ze.scale = function (t) { return new Je(t); }, Ze.attribution = function (t) { return new tn(t); }; const en = P.extend({
    initialize(t) { this._map = t; }, enable() { return this._enabled || (this._enabled = !0, this.addHooks()), this; }, disable() { return this._enabled && (this._enabled = !1, this.removeHooks()), this; }, enabled() { return !!this._enabled; },
  }); en.addTo = function (t, e) { return t.addHandler(e, this), this; }; let nn; const rn = { Events: O }; const on = kt ? "touchstart mousedown" : "mousedown"; const sn = {
    mousedown: "mouseup", touchstart: "touchend", pointerdown: "touchend", MSPointerDown: "touchend",
  }; const an = {
    mousedown: "mousemove", touchstart: "touchmove", pointerdown: "touchmove", MSPointerDown: "touchmove",
  }; var ln = A.extend({
    options: { clickTolerance: 3 }, initialize(t, e, n, r) { p(this, r), this._element = t, this._dragStartTarget = e || t, this._preventOutline = n; }, enable() { this._enabled || (Te(this._dragStartTarget, on, this._onDown, this), this._enabled = !0); }, disable() { this._enabled && (ln._dragging === this && this.finishDrag(), Oe(this._dragStartTarget, on, this._onDown, this), this._enabled = !1, this._moved = !1); }, _onDown(t) { let e; let n; !t._simulated && this._enabled && (this._moved = !1, ce(this._element, "leaflet-zoom-anim") || ln._dragging || t.shiftKey || t.which !== 1 && t.button !== 1 && !t.touches || ((ln._dragging = this)._preventOutline && xe(this._element), be(), Gt(), this._moving || (this.fire("down"), e = t.touches ? t.touches[0] : t, n = ke(this._element), this._startPoint = new M(e.clientX, e.clientY), this._parentScale = Ce(n), Te(document, an[t.type], this._onMove, this), Te(document, sn[t.type], this._onUp, this)))); }, _onMove(t) { let e; let n; !t._simulated && this._enabled && (t.touches && t.touches.length > 1 ? this._moved = !0 : ((n = new M((e = t.touches && t.touches.length === 1 ? t.touches[0] : t).clientX, e.clientY)._subtract(this._startPoint)).x || n.y) && (Math.abs(n.x) + Math.abs(n.y) < this.options.clickTolerance || (n.x /= this._parentScale.x, n.y /= this._parentScale.y, Re(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = _e(this._element).subtract(n), de(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), de(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(n), this._moving = !0, E(this._animRequest), this._lastEvent = t, this._animRequest = C(this._updatePosition, this, !0)))); }, _updatePosition() { const t = { originalEvent: this._lastEvent }; this.fire("predrag", t), ye(this._element, this._newPos), this.fire("drag", t); }, _onUp(t) { !t._simulated && this._enabled && this.finishDrag(); }, finishDrag() { for (const t in he(document.body, "leaflet-dragging"), this._lastTarget && (he(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), an)Oe(document, an[t], this._onMove, this), Oe(document, sn[t], this._onUp, this); we(), Yt(), this._moved && this._moving && (E(this._animRequest), this.fire("dragend", { distance: this._newPos.distanceTo(this._startPos) })), this._moving = !1, ln._dragging = !1; },
  }); function un(t, e) { if (!e || !t.length) return t.slice(); const n = e * e; return (function (t, e) { const n = t.length; const r = new (typeof Uint8Array !== `${void 0}` ? Uint8Array : Array)(n); r[0] = r[n - 1] = 1, (function t(e, n, r, i, o) { let s; let a; let l; let u = 0; for (a = i + 1; a <= o - 1; a++)u < (l = fn(e[a], e[i], e[o], !0)) && (s = a, u = l); r < u && (n[s] = 1, t(e, n, r, i, s), t(e, n, r, s, o)); }(t, r, e, 0, n - 1)); let i; const o = []; for (i = 0; i < n; i++)r[i] && o.push(t[i]); return o; }(t = (function (t, e) { for (var n = [t[0]], r = 1, i = 0, o = t.length; r < o; r++)(function (t, e) { const n = e.x - t.x; const r = e.y - t.y; return n * n + r * r; }(t[r], t[i])) > e && (n.push(t[r]), i = r); return i < o - 1 && n.push(t[o - 1]), n; }(t, n)), n)); } function cn(t, e, n) { return Math.sqrt(fn(t, e, n, !0)); } function dn(t, e, n, r, i) { let o; let s; let a; let l = r ? nn : pn(t, n); let u = pn(e, n); for (nn = u; ;) { if (!(l | u)) return [t, e]; if (l & u) return !1; a = pn(s = hn(t, e, o = l || u, n, i), n), o === l ? (t = s, l = a) : (e = s, u = a); } } function hn(t, e, n, r, i) { let o; let s; const a = e.x - t.x; const l = e.y - t.y; const u = r.min; const c = r.max; return 8 & n ? (o = t.x + a * (c.y - t.y) / l, s = c.y) : 4 & n ? (o = t.x + a * (u.y - t.y) / l, s = u.y) : 2 & n ? (o = c.x, s = t.y + l * (c.x - t.x) / a) : 1 & n && (o = u.x, s = t.y + l * (u.x - t.x) / a), new M(o, s, i); } function pn(t, e) { let n = 0; return t.x < e.min.x ? n |= 1 : t.x > e.max.x && (n |= 2), t.y < e.min.y ? n |= 4 : t.y > e.max.y && (n |= 8), n; } function fn(t, e, n, r) { let i; let o = e.x; let s = e.y; let a = n.x - o; let l = n.y - s; const u = a * a + l * l; return u > 0 && ((i = ((t.x - o) * a + (t.y - s) * l) / u) > 1 ? (o = n.x, s = n.y) : i > 0 && (o += a * i, s += l * i)), a = t.x - o, l = t.y - s, r ? a * a + l * l : new M(o, s); } function mn(t) { return !v(t[0]) || typeof t[0][0] !== "object" && void 0 !== t[0][0]; } function gn(t) { return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), mn(t); } const vn = {
    simplify: un, pointToSegmentDistance: cn, closestPointOnSegment(t, e, n) { return fn(t, e, n); }, clipSegment: dn, _getEdgeIntersection: hn, _getBitCode: pn, _sqClosestPointOnSegment: fn, isFlat: mn, _flat: gn,
  }; function yn(t, e, n) { for (var r, i, o, s, a, l, u, c = [1, 4, 2, 8], d = 0, h = t.length; d < h; d++)t[d]._code = pn(t[d], e); for (o = 0; o < 4; o++) { for (l = c[o], r = [], d = 0, i = (h = t.length) - 1; d < h; i = d++)s = t[d], a = t[i], s._code & l ? a._code & l || ((u = hn(a, s, l, e, n))._code = pn(u, e), r.push(u)) : (a._code & l && ((u = hn(a, s, l, e, n))._code = pn(u, e), r.push(u)), r.push(s)); t = r; } return t; } let _n; const bn = { clipPolygon: yn }; const wn = { project(t) { return new M(t.lng, t.lat); }, unproject(t) { return new V(t.y, t.x); }, bounds: new D([-180, -90], [180, 90]) }; const xn = {
    R: 6378137, R_MINOR: 6356752.314245179, bounds: new D([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project(t) { const e = Math.PI / 180; const n = this.R; let r = t.lat * e; const i = this.R_MINOR / n; const o = Math.sqrt(1 - i * i); const s = o * Math.sin(r); const a = Math.tan(Math.PI / 4 - r / 2) / ((1 - s) / (1 + s)) ** (o / 2); r = -n * Math.log(Math.max(a, 1e-10)); return new M(t.lng * e * n, r); }, unproject(t) { for (var e, n = 180 / Math.PI, r = this.R, i = this.R_MINOR / r, o = Math.sqrt(1 - i * i), s = Math.exp(-t.y / r), a = Math.PI / 2 - 2 * Math.atan(s), l = 0, u = 0.1; l < 15 && Math.abs(u) > 1e-7; l++)e = o * Math.sin(a), e = ((1 - e) / (1 + e)) ** (o / 2), a += u = Math.PI / 2 - 2 * Math.atan(s * e) - a; return new V(a * n, t.x * n / r); },
  }; const Sn = { LonLat: wn, Mercator: xn, SphericalMercator: U }; const kn = e({}, H, { code: "EPSG:3395", projection: xn, transformation: G(_n = 0.5 / (Math.PI * xn.R), 0.5, -_n, 0.5) }); const Cn = e({}, H, { code: "EPSG:4326", projection: wn, transformation: G(1 / 180, 1, -1 / 180, 0.5) }); const En = e({}, q, {
    projection: wn, transformation: G(1, 0, -1, 0), scale(t) { return 2 ** t; }, zoom(t) { return Math.log(t) / Math.LN2; }, distance(t, e) { const n = e.lng - t.lng; const r = e.lat - t.lat; return Math.sqrt(n * n + r * r); }, infinite: !0,
  }); q.Earth = H, q.EPSG3395 = kn, q.EPSG3857 = Z, q.EPSG900913 = K, q.EPSG4326 = Cn, q.Simple = En; const Tn = A.extend({
    options: { pane: "overlayPane", attribution: null, bubblingMouseEvents: !0 }, addTo(t) { return t.addLayer(this), this; }, remove() { return this.removeFrom(this._map || this._mapToAdd); }, removeFrom(t) { return t && t.removeLayer(this), this; }, getPane(t) { return this._map.getPane(t ? this.options[t] || t : this.options.pane); }, addInteractiveTarget(t) { return this._map._targets[s(t)] = this; }, removeInteractiveTarget(t) { return delete this._map._targets[s(t)], this; }, getAttribution() { return this.options.attribution; }, _layerAdd(t) { let e; const n = t.target; n.hasLayer(this) && (this._map = n, this._zoomAnimated = n._zoomAnimated, this.getEvents && (e = this.getEvents(), n.on(e, this), this.once("remove", (function () { n.off(e, this); }), this)), this.onAdd(n), this.getAttribution && n.attributionControl && n.attributionControl.addAttribution(this.getAttribution()), this.fire("add"), n.fire("layeradd", { layer: this })); },
  }); Ye.include({
    addLayer(t) { if (!t._layerAdd) throw new Error("The provided object is not a Layer."); const e = s(t); return this._layers[e] || ((this._layers[e] = t)._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t)), this; }, removeLayer(t) { const e = s(t); return this._layers[e] && (this._loaded && t.onRemove(this), t.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(t.getAttribution()), delete this._layers[e], this._loaded && (this.fire("layerremove", { layer: t }), t.fire("remove")), t._map = t._mapToAdd = null), this; }, hasLayer(t) { return !!t && s(t) in this._layers; }, eachLayer(t, e) { for (const n in this._layers)t.call(e, this._layers[n]); return this; }, _addLayers(t) { for (let e = 0, n = (t = t ? v(t) ? t : [t] : []).length; e < n; e++) this.addLayer(t[e]); }, _addZoomLimit(t) { !isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[s(t)] = t, this._updateZoomLevels()); }, _removeZoomLimit(t) { const e = s(t); this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels()); }, _updateZoomLevels() { let t = 1 / 0; let e = -1 / 0; const n = this._getZoomSpan(); for (const r in this._zoomBoundLayers) { const i = this._zoomBoundLayers[r].options; t = void 0 === i.minZoom ? t : Math.min(t, i.minZoom), e = void 0 === i.maxZoom ? e : Math.max(e, i.maxZoom); } this._layersMaxZoom = e === -1 / 0 ? void 0 : e, this._layersMinZoom = t === 1 / 0 ? void 0 : t, n !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom); },
  }); const Pn = Tn.extend({
    initialize(t, e) { let n; let r; if (p(this, e), this._layers = {}, t) for (n = 0, r = t.length; n < r; n++) this.addLayer(t[n]); }, addLayer(t) { const e = this.getLayerId(t); return this._layers[e] = t, this._map && this._map.addLayer(t), this; }, removeLayer(t) { const e = t in this._layers ? t : this.getLayerId(t); return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this; }, hasLayer(t) { return !!t && (typeof t === "number" ? t : this.getLayerId(t)) in this._layers; }, clearLayers() { return this.eachLayer(this.removeLayer, this); }, invoke(t) { let e; let n; const r = Array.prototype.slice.call(arguments, 1); for (e in this._layers)(n = this._layers[e])[t] && n[t].apply(n, r); return this; }, onAdd(t) { this.eachLayer(t.addLayer, t); }, onRemove(t) { this.eachLayer(t.removeLayer, t); }, eachLayer(t, e) { for (const n in this._layers)t.call(e, this._layers[n]); return this; }, getLayer(t) { return this._layers[t]; }, getLayers() { const t = []; return this.eachLayer(t.push, t), t; }, setZIndex(t) { return this.invoke("setZIndex", t); }, getLayerId: s,
  }); const On = Pn.extend({
    addLayer(t) { return this.hasLayer(t) ? this : (t.addEventParent(this), Pn.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t })); }, removeLayer(t) { return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), Pn.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this; }, setStyle(t) { return this.invoke("setStyle", t); }, bringToFront() { return this.invoke("bringToFront"); }, bringToBack() { return this.invoke("bringToBack"); }, getBounds() { const t = new R(); for (const e in this._layers) { const n = this._layers[e]; t.extend(n.getBounds ? n.getBounds() : n.getLatLng()); } return t; },
  }); const An = P.extend({
    options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0] }, initialize(t) { p(this, t); }, createIcon(t) { return this._createIcon("icon", t); }, createShadow(t) { return this._createIcon("shadow", t); }, _createIcon(t, e) { const n = this._getIconUrl(t); if (!n) { if (t === "icon") throw new Error("iconUrl not set in Icon options (see the docs)."); return null; } const r = this._createImg(n, e && e.tagName === "IMG" ? e : null); return this._setIconStyles(r, t), r; }, _setIconStyles(t, e) { const n = this.options; let r = n[`${e}Size`]; typeof r === "number" && (r = [r, r]); const i = j(r); const o = j(e === "shadow" && n.shadowAnchor || n.iconAnchor || i && i.divideBy(2, !0)); t.className = `leaflet-marker-${e} ${n.className || ""}`, o && (t.style.marginLeft = `${-o.x}px`, t.style.marginTop = `${-o.y}px`), i && (t.style.width = `${i.x}px`, t.style.height = `${i.y}px`); }, _createImg(t, e) { return (e = e || document.createElement("img")).src = t, e; }, _getIconUrl(t) { return Tt && this.options[`${t}RetinaUrl`] || this.options[`${t}Url`]; },
  }); var Mn = An.extend({
    options: {
      iconUrl: "marker-icon.png", iconRetinaUrl: "marker-icon-2x.png", shadowUrl: "marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41],
    },
    _getIconUrl(t) { return Mn.imagePath || (Mn.imagePath = this._detectIconPath()), (this.options.imagePath || Mn.imagePath) + An.prototype._getIconUrl.call(this, t); },
    _detectIconPath() { const t = oe("div", "leaflet-default-icon-path", document.body); const e = ie(t, "background-image") || ie(t, "backgroundImage"); return document.body.removeChild(t), e === null || e.indexOf("url") !== 0 ? "" : e.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, ""); },
  }); const Ln = en.extend({
    initialize(t) { this._marker = t; },
    addHooks() {
      const t = this._marker._icon; this._draggable || (this._draggable = new ln(t, t, !0)), this._draggable.on({
        dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd,
      }, this).enable(), de(t, "leaflet-marker-draggable");
    },
    removeHooks() {
      this._draggable.off({
        dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd,
      }, this).disable(), this._marker._icon && he(this._marker._icon, "leaflet-marker-draggable");
    },
    moved() { return this._draggable && this._draggable._moved; },
    _adjustPan(t) { let e; const n = this._marker; const r = n._map; const i = this._marker.options.autoPanSpeed; const o = this._marker.options.autoPanPadding; const s = _e(n._icon); const a = r.getPixelBounds(); const l = r.getPixelOrigin(); const u = N(a.min._subtract(l).add(o), a.max._subtract(l).subtract(o)); u.contains(s) || (e = j((Math.max(u.max.x, s.x) - u.max.x) / (a.max.x - u.max.x) - (Math.min(u.min.x, s.x) - u.min.x) / (a.min.x - u.min.x), (Math.max(u.max.y, s.y) - u.max.y) / (a.max.y - u.max.y) - (Math.min(u.min.y, s.y) - u.min.y) / (a.min.y - u.min.y)).multiplyBy(i), r.panBy(e, { animate: !1 }), this._draggable._newPos._add(e), this._draggable._startPos._add(e), ye(n._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = C(this._adjustPan.bind(this, t))); },
    _onDragStart() { this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart"); },
    _onPreDrag(t) { this._marker.options.autoPan && (E(this._panRequest), this._panRequest = C(this._adjustPan.bind(this, t))); },
    _onDrag(t) { const e = this._marker; const n = e._shadow; const r = _e(e._icon); const i = e._map.layerPointToLatLng(r); n && ye(n, r), e._latlng = i, t.latlng = i, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t); },
    _onDragEnd(t) { E(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t); },
  }); const In = Tn.extend({
    options: {
      icon: new Mn(), interactive: !0, keyboard: !0, title: "", alt: "", zIndexOffset: 0, opacity: 1, riseOnHover: !1, riseOffset: 250, pane: "markerPane", shadowPane: "shadowPane", bubblingMouseEvents: !1, draggable: !1, autoPan: !1, autoPanPadding: [50, 50], autoPanSpeed: 10,
    },
    initialize(t, e) { p(this, e), this._latlng = z(t); },
    onAdd(t) { this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update(); },
    onRemove(t) { this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow(); },
    getEvents() { return { zoom: this.update, viewreset: this.update }; },
    getLatLng() { return this._latlng; },
    setLatLng(t) { const e = this._latlng; return this._latlng = z(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng }); },
    setZIndexOffset(t) { return this.options.zIndexOffset = t, this.update(); },
    getIcon() { return this.options.icon; },
    setIcon(t) { return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this; },
    getElement() { return this._icon; },
    update() { let t; return this._icon && this._map && (t = this._map.latLngToLayerPoint(this._latlng).round(), this._setPos(t)), this; },
    _initIcon() { const t = this.options; const e = `leaflet-zoom-${this._zoomAnimated ? "animated" : "hide"}`; const n = t.icon.createIcon(this._icon); let r = !1; n !== this._icon && (this._icon && this._removeIcon(), r = !0, t.title && (n.title = t.title), n.tagName === "IMG" && (n.alt = t.alt || "")), de(n, e), t.keyboard && (n.tabIndex = "0"), this._icon = n, t.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }); const i = t.icon.createShadow(this._shadow); let o = !1; i !== this._shadow && (this._removeShadow(), o = !0), i && (de(i, e), i.alt = ""), this._shadow = i, t.opacity < 1 && this._updateOpacity(), r && this.getPane().appendChild(this._icon), this._initInteraction(), i && o && this.getPane(t.shadowPane).appendChild(this._shadow); },
    _removeIcon() { this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), se(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null; },
    _removeShadow() { this._shadow && se(this._shadow), this._shadow = null; },
    _setPos(t) { this._icon && ye(this._icon, t), this._shadow && ye(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex(); },
    _updateZIndex(t) { this._icon && (this._icon.style.zIndex = this._zIndex + t); },
    _animateZoom(t) { const e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round(); this._setPos(e); },
    _initInteraction() { let t; this.options.interactive && (de(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), Ln && (t = this.options.draggable, this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Ln(this), t && this.dragging.enable())); },
    setOpacity(t) { return this.options.opacity = t, this._map && this._updateOpacity(), this; },
    _updateOpacity() { const t = this.options.opacity; this._icon && me(this._icon, t), this._shadow && me(this._shadow, t); },
    _bringToFront() { this._updateZIndex(this.options.riseOffset); },
    _resetZIndex() { this._updateZIndex(0); },
    _getPopupAnchor() { return this.options.icon.options.popupAnchor; },
    _getTooltipAnchor() { return this.options.icon.options.tooltipAnchor; },
  }); const jn = Tn.extend({
    options: {
      stroke: !0, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", dashArray: null, dashOffset: null, fill: !1, fillColor: null, fillOpacity: 0.2, fillRule: "evenodd", interactive: !0, bubblingMouseEvents: !0,
    },
    beforeAdd(t) { this._renderer = t.getRenderer(this); },
    onAdd() { this._renderer._initPath(this), this._reset(), this._renderer._addPath(this); },
    onRemove() { this._renderer._removePath(this); },
    redraw() { return this._map && this._renderer._updatePath(this), this; },
    setStyle(t) { return p(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()), this; },
    bringToFront() { return this._renderer && this._renderer._bringToFront(this), this; },
    bringToBack() { return this._renderer && this._renderer._bringToBack(this), this; },
    getElement() { return this._path; },
    _reset() { this._project(), this._update(); },
    _clickTolerance() { return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance; },
  }); const Dn = jn.extend({
    options: { fill: !0, radius: 10 }, initialize(t, e) { p(this, e), this._latlng = z(t), this._radius = this.options.radius; }, setLatLng(t) { const e = this._latlng; return this._latlng = z(t), this.redraw(), this.fire("move", { oldLatLng: e, latlng: this._latlng }); }, getLatLng() { return this._latlng; }, setRadius(t) { return this.options.radius = this._radius = t, this.redraw(); }, getRadius() { return this._radius; }, setStyle(t) { const e = t && t.radius || this._radius; return jn.prototype.setStyle.call(this, t), this.setRadius(e), this; }, _project() { this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds(); }, _updateBounds() { const t = this._radius; const e = this._radiusY || t; const n = this._clickTolerance(); const r = [t + n, e + n]; this._pxBounds = new D(this._point.subtract(r), this._point.add(r)); }, _update() { this._map && this._updatePath(); }, _updatePath() { this._renderer._updateCircle(this); }, _empty() { return this._radius && !this._renderer._bounds.intersects(this._pxBounds); }, _containsPoint(t) { return t.distanceTo(this._point) <= this._radius + this._clickTolerance(); },
  }); const Nn = Dn.extend({
    initialize(t, n, r) { if (typeof n === "number" && (n = e({}, r, { radius: n })), p(this, n), this._latlng = z(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN"); this._mRadius = this.options.radius; }, setRadius(t) { return this._mRadius = t, this.redraw(); }, getRadius() { return this._mRadius; }, getBounds() { const t = [this._radius, this._radiusY || this._radius]; return new R(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t))); }, setStyle: jn.prototype.setStyle, _project() { let t; let e; let n; let r; let i; let o; let s; let a; const l = this._latlng.lng; const u = this._latlng.lat; const c = this._map; const d = c.options.crs; d.distance === H.distance ? (t = Math.PI / 180, e = this._mRadius / H.R / t, n = c.project([u + e, l]), r = c.project([u - e, l]), i = n.add(r).divideBy(2), o = c.unproject(i).lat, s = Math.acos((Math.cos(e * t) - Math.sin(u * t) * Math.sin(o * t)) / (Math.cos(u * t) * Math.cos(o * t))) / t, !isNaN(s) && s !== 0 || (s = e / Math.cos(Math.PI / 180 * u)), this._point = i.subtract(c.getPixelOrigin()), this._radius = isNaN(s) ? 0 : i.x - c.project([o, l - s]).x, this._radiusY = i.y - n.y) : (a = d.unproject(d.project(this._latlng).subtract([this._mRadius, 0])), this._point = c.latLngToLayerPoint(this._latlng), this._radius = this._point.x - c.latLngToLayerPoint(a).x), this._updateBounds(); },
  }); const Rn = jn.extend({
    options: { smoothFactor: 1, noClip: !1 }, initialize(t, e) { p(this, e), this._setLatLngs(t); }, getLatLngs() { return this._latlngs; }, setLatLngs(t) { return this._setLatLngs(t), this.redraw(); }, isEmpty() { return !this._latlngs.length; }, closestLayerPoint(t) { for (var e, n, r = 1 / 0, i = null, o = fn, s = 0, a = this._parts.length; s < a; s++) for (let l = this._parts[s], u = 1, c = l.length; u < c; u++) { const d = o(t, e = l[u - 1], n = l[u], !0); d < r && (r = d, i = o(t, e, n)); } return i && (i.distance = Math.sqrt(r)), i; }, getCenter() { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); let t; let e; let n; let r; let i; let o; let s; const a = this._rings[0]; const l = a.length; if (!l) return null; for (e = t = 0; t < l - 1; t++)e += a[t].distanceTo(a[t + 1]) / 2; if (e === 0) return this._map.layerPointToLatLng(a[0]); for (r = t = 0; t < l - 1; t++) if (i = a[t], o = a[t + 1], e < (r += n = i.distanceTo(o))) return s = (r - e) / n, this._map.layerPointToLatLng([o.x - s * (o.x - i.x), o.y - s * (o.y - i.y)]); }, getBounds() { return this._bounds; }, addLatLng(t, e) { return e = e || this._defaultShape(), t = z(t), e.push(t), this._bounds.extend(t), this.redraw(); }, _setLatLngs(t) { this._bounds = new R(), this._latlngs = this._convertLatLngs(t); }, _defaultShape() { return mn(this._latlngs) ? this._latlngs : this._latlngs[0]; }, _convertLatLngs(t) { for (var e = [], n = mn(t), r = 0, i = t.length; r < i; r++)n ? (e[r] = z(t[r]), this._bounds.extend(e[r])) : e[r] = this._convertLatLngs(t[r]); return e; }, _project() { const t = new D(); this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds()); }, _updateBounds() { const t = this._clickTolerance(); const e = new M(t, t); this._pxBounds = new D([this._rawPxBounds.min.subtract(e), this._rawPxBounds.max.add(e)]); }, _projectLatlngs(t, e, n) { let r; let i; const o = t[0] instanceof V; const s = t.length; if (o) { for (i = [], r = 0; r < s; r++)i[r] = this._map.latLngToLayerPoint(t[r]), n.extend(i[r]); e.push(i); } else for (r = 0; r < s; r++) this._projectLatlngs(t[r], e, n); }, _clipPoints() { const t = this._renderer._bounds; if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var e, n, r, i, o = this._parts, s = 0, a = 0, l = this._rings.length; s < l; s++) for (e = 0, n = (i = this._rings[s]).length; e < n - 1; e++)(r = dn(i[e], i[e + 1], t, e, !0)) && (o[a] = o[a] || [], o[a].push(r[0]), r[1] === i[e + 1] && e !== n - 2 || (o[a].push(r[1]), a++)); }, _simplifyPoints() { for (let t = this._parts, e = this.options.smoothFactor, n = 0, r = t.length; n < r; n++)t[n] = un(t[n], e); }, _update() { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath()); }, _updatePath() { this._renderer._updatePoly(this); }, _containsPoint(t, e) { let n; let r; let i; let o; let s; let a; const l = this._clickTolerance(); if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (n = 0, o = this._parts.length; n < o; n++) for (r = 0, i = (s = (a = this._parts[n]).length) - 1; r < s; i = r++) if ((e || r !== 0) && cn(t, a[i], a[r]) <= l) return !0; return !1; },
  }); Rn._flat = gn; const Fn = Rn.extend({
    options: { fill: !0 }, isEmpty() { return !this._latlngs.length || !this._latlngs[0].length; }, getCenter() { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); let t; let e; let n; let r; let i; let o; let s; let a; let l; const u = this._rings[0]; const c = u.length; if (!c) return null; for (t = o = s = a = 0, e = c - 1; t < c; e = t++)n = u[t], r = u[e], i = n.y * r.x - r.y * n.x, s += (n.x + r.x) * i, a += (n.y + r.y) * i, o += 3 * i; return l = o === 0 ? u[0] : [s / o, a / o], this._map.layerPointToLatLng(l); }, _convertLatLngs(t) { const e = Rn.prototype._convertLatLngs.call(this, t); const n = e.length; return n >= 2 && e[0] instanceof V && e[0].equals(e[n - 1]) && e.pop(), e; }, _setLatLngs(t) { Rn.prototype._setLatLngs.call(this, t), mn(this._latlngs) && (this._latlngs = [this._latlngs]); }, _defaultShape() { return mn(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]; }, _clipPoints() { let t = this._renderer._bounds; const e = this.options.weight; const n = new M(e, e); t = new D(t.min.subtract(n), t.max.add(n)); if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var r, i = 0, o = this._rings.length; i < o; i++)(r = yn(this._rings[i], t, !0)).length && this._parts.push(r); }, _updatePath() { this._renderer._updatePoly(this, !0); }, _containsPoint(t) { let e; let n; let r; let i; let o; let s; let a; let l; let u = !1; if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (i = 0, a = this._parts.length; i < a; i++) for (o = 0, s = (l = (e = this._parts[i]).length) - 1; o < l; s = o++)n = e[o], r = e[s], n.y > t.y != r.y > t.y && t.x < (r.x - n.x) * (t.y - n.y) / (r.y - n.y) + n.x && (u = !u); return u || Rn.prototype._containsPoint.call(this, t, !0); },
  }); const Vn = On.extend({
    initialize(t, e) { p(this, e), this._layers = {}, t && this.addData(t); }, addData(t) { let e; let n; let r; const i = v(t) ? t : t.features; if (i) { for (e = 0, n = i.length; e < n; e++)((r = i[e]).geometries || r.geometry || r.features || r.coordinates) && this.addData(r); return this; } const o = this.options; if (o.filter && !o.filter(t)) return this; const s = zn(t, o); return s ? (s.feature = Gn(t), s.defaultOptions = s.options, this.resetStyle(s), o.onEachFeature && o.onEachFeature(t, s), this.addLayer(s)) : this; }, resetStyle(t) { return void 0 === t ? this.eachLayer(this.resetStyle, this) : (t.options = e({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this); }, setStyle(t) { return this.eachLayer((function (e) { this._setLayerStyle(e, t); }), this); }, _setLayerStyle(t, e) { t.setStyle && (typeof e === "function" && (e = e(t.feature)), t.setStyle(e)); },
  }); function zn(t, e) { let n; let r; let i; let o; const s = t.type === "Feature" ? t.geometry : t; const a = s ? s.coordinates : null; const l = []; const u = e && e.pointToLayer; const c = e && e.coordsToLatLng || qn; if (!a && !s) return null; switch (s.type) { case "Point": return Bn(u, t, n = c(a), e); case "MultiPoint": for (i = 0, o = a.length; i < o; i++)n = c(a[i]), l.push(Bn(u, t, n, e)); return new On(l); case "LineString": case "MultiLineString": return r = Hn(a, s.type === "LineString" ? 0 : 1, c), new Rn(r, e); case "Polygon": case "MultiPolygon": return r = Hn(a, s.type === "Polygon" ? 1 : 2, c), new Fn(r, e); case "GeometryCollection": for (i = 0, o = s.geometries.length; i < o; i++) { const d = zn({ geometry: s.geometries[i], type: "Feature", properties: t.properties }, e); d && l.push(d); } return new On(l); default: throw new Error("Invalid GeoJSON object."); } } function Bn(t, e, n, r) { return t ? t(e, n) : new In(n, r && r.markersInheritOptions && r); } function qn(t) { return new V(t[1], t[0], t[2]); } function Hn(t, e, n) { for (var r, i = [], o = 0, s = t.length; o < s; o++)r = e ? Hn(t[o], e - 1, n) : (n || qn)(t[o]), i.push(r); return i; } function $n(t, e) { return e = typeof e === "number" ? e : 6, void 0 !== t.alt ? [c(t.lng, e), c(t.lat, e), c(t.alt, e)] : [c(t.lng, e), c(t.lat, e)]; } function Un(t, e, n, r) { for (var i = [], o = 0, s = t.length; o < s; o++)i.push(e ? Un(t[o], e - 1, n, r) : $n(t[o], r)); return !e && n && i.push(i[0]), i; } function Wn(t, n) { return t.feature ? e({}, t.feature, { geometry: n }) : Gn(n); } function Gn(t) { return t.type === "Feature" || t.type === "FeatureCollection" ? t : { type: "Feature", properties: {}, geometry: t }; } const Yn = { toGeoJSON(t) { return Wn(this, { type: "Point", coordinates: $n(this.getLatLng(), t) }); } }; function Zn(t, e) { return new Vn(t, e); }In.include(Yn), Nn.include(Yn), Dn.include(Yn), Rn.include({ toGeoJSON(t) { const e = !mn(this._latlngs); return Wn(this, { type: `${e ? "Multi" : ""}LineString`, coordinates: Un(this._latlngs, e ? 1 : 0, !1, t) }); } }), Fn.include({ toGeoJSON(t) { const e = !mn(this._latlngs); const n = e && !mn(this._latlngs[0]); let r = Un(this._latlngs, n ? 2 : e ? 1 : 0, !0, t); return e || (r = [r]), Wn(this, { type: `${n ? "Multi" : ""}Polygon`, coordinates: r }); } }), Pn.include({ toMultiPoint(t) { const e = []; return this.eachLayer(((n) => { e.push(n.toGeoJSON(t).geometry.coordinates); })), Wn(this, { type: "MultiPoint", coordinates: e }); }, toGeoJSON(t) { const e = this.feature && this.feature.geometry && this.feature.geometry.type; if (e === "MultiPoint") return this.toMultiPoint(t); const n = e === "GeometryCollection"; const r = []; return this.eachLayer(((e) => { let i; let o; e.toGeoJSON && (i = e.toGeoJSON(t), n ? r.push(i.geometry) : (o = Gn(i)).type === "FeatureCollection" ? r.push.apply(r, o.features) : r.push(o)); })), n ? Wn(this, { geometries: r, type: "GeometryCollection" }) : { type: "FeatureCollection", features: r }; } }); const Kn = Zn; const Xn = Tn.extend({
    options: {
      opacity: 1, alt: "", interactive: !1, crossOrigin: !1, errorOverlayUrl: "", zIndex: 1, className: "",
    },
    initialize(t, e, n) { this._url = t, this._bounds = F(e), p(this, n); },
    onAdd() { this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (de(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset(); },
    onRemove() { se(this._image), this.options.interactive && this.removeInteractiveTarget(this._image); },
    setOpacity(t) { return this.options.opacity = t, this._image && this._updateOpacity(), this; },
    setStyle(t) { return t.opacity && this.setOpacity(t.opacity), this; },
    bringToFront() { return this._map && le(this._image), this; },
    bringToBack() { return this._map && ue(this._image), this; },
    setUrl(t) { return this._url = t, this._image && (this._image.src = t), this; },
    setBounds(t) { return this._bounds = F(t), this._map && this._reset(), this; },
    getEvents() { const t = { zoom: this._reset, viewreset: this._reset }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t; },
    setZIndex(t) { return this.options.zIndex = t, this._updateZIndex(), this; },
    getBounds() { return this._bounds; },
    getElement() { return this._image; },
    _initImage() { const t = this._url.tagName === "IMG"; const e = this._image = t ? this._url : oe("img"); de(e, "leaflet-image-layer"), this._zoomAnimated && de(e, "leaflet-zoom-animated"), this.options.className && de(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onload = i(this.fire, this, "load"), e.onerror = i(this._overlayOnError, this, "error"), !this.options.crossOrigin && this.options.crossOrigin !== "" || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = e.src : (e.src = this._url, e.alt = this.options.alt); },
    _animateZoom(t) { const e = this._map.getZoomScale(t.zoom); const n = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min; ve(this._image, n, e); },
    _reset() { const t = this._image; const e = new D(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())); const n = e.getSize(); ye(t, e.min), t.style.width = `${n.x}px`, t.style.height = `${n.y}px`; },
    _updateOpacity() { me(this._image, this.options.opacity); },
    _updateZIndex() { this._image && void 0 !== this.options.zIndex && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex); },
    _overlayOnError() { this.fire("error"); const t = this.options.errorOverlayUrl; t && this._url !== t && (this._url = t, this._image.src = t); },
  }); const Qn = Xn.extend({
    options: {
      autoplay: !0, loop: !0, keepAspectRatio: !0, muted: !1,
    },
    _initImage() { const t = this._url.tagName === "VIDEO"; const e = this._image = t ? this._url : oe("video"); if (de(e, "leaflet-image-layer"), this._zoomAnimated && de(e, "leaflet-zoom-animated"), this.options.className && de(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onloadeddata = i(this.fire, this, "load"), t) { for (var n = e.getElementsByTagName("source"), r = [], o = 0; o < n.length; o++)r.push(n[o].src); this._url = n.length > 0 ? r : [e.src]; } else { v(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e.style, "objectFit") && (e.style.objectFit = "fill"), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop, e.muted = !!this.options.muted; for (let s = 0; s < this._url.length; s++) { const a = oe("source"); a.src = this._url[s], e.appendChild(a); } } },
  }); const Jn = Xn.extend({ _initImage() { const t = this._image = this._url; de(t, "leaflet-image-layer"), this._zoomAnimated && de(t, "leaflet-zoom-animated"), this.options.className && de(t, this.options.className), t.onselectstart = u, t.onmousemove = u; } }); const tr = Tn.extend({
    options: { offset: [0, 7], className: "", pane: "popupPane" }, initialize(t, e) { p(this, t), this._source = e; }, onAdd(t) { this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && me(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && me(this._container, 1), this.bringToFront(); }, onRemove(t) { t._fadeAnimated ? (me(this._container, 0), this._removeTimeout = setTimeout(i(se, void 0, this._container), 200)) : se(this._container); }, getLatLng() { return this._latlng; }, setLatLng(t) { return this._latlng = z(t), this._map && (this._updatePosition(), this._adjustPan()), this; }, getContent() { return this._content; }, setContent(t) { return this._content = t, this.update(), this; }, getElement() { return this._container; }, update() { this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan()); }, getEvents() { const t = { zoom: this._updatePosition, viewreset: this._updatePosition }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t; }, isOpen() { return !!this._map && this._map.hasLayer(this); }, bringToFront() { return this._map && le(this._container), this; }, bringToBack() { return this._map && ue(this._container), this; }, _prepareOpen(t, e, n) { if (e instanceof Tn || (n = e, e = t), e instanceof On) for (const r in t._layers) { e = t._layers[r]; break; } if (!n) if (e.getCenter)n = e.getCenter(); else { if (!e.getLatLng) throw new Error("Unable to get source layer LatLng."); n = e.getLatLng(); } return this._source = e, this.update(), n; }, _updateContent() { if (this._content) { const t = this._contentNode; const e = typeof this._content === "function" ? this._content(this._source || this) : this._content; if (typeof e === "string")t.innerHTML = e; else { for (;t.hasChildNodes();)t.removeChild(t.firstChild); t.appendChild(e); } this.fire("contentupdate"); } }, _updatePosition() { let t; let e; let n; let r; let i; this._map && (t = this._map.latLngToLayerPoint(this._latlng), e = j(this.options.offset), n = this._getAnchor(), this._zoomAnimated ? ye(this._container, t.add(n)) : e = e.add(t).add(n), r = this._containerBottom = -e.y, i = this._containerLeft = -Math.round(this._containerWidth / 2) + e.x, this._container.style.bottom = `${r}px`, this._container.style.left = `${i}px`); }, _getAnchor() { return [0, 0]; },
  }); const er = tr.extend({
    options: {
      maxWidth: 300, minWidth: 50, maxHeight: null, autoPan: !0, autoPanPaddingTopLeft: null, autoPanPaddingBottomRight: null, autoPanPadding: [5, 5], keepInView: !1, closeButton: !0, autoClose: !0, closeOnEscapeKey: !0, className: "",
    },
    openOn(t) { return t.openPopup(this), this; },
    onAdd(t) { tr.prototype.onAdd.call(this, t), t.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof jn || this._source.on("preclick", je)); },
    onRemove(t) { tr.prototype.onRemove.call(this, t), t.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof jn || this._source.off("preclick", je)); },
    getEvents() { const t = tr.prototype.getEvents.call(this); return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t; },
    _close() { this._map && this._map.closePopup(this); },
    _initLayout() { let t; const e = "leaflet-popup"; const n = this._container = oe("div", `${e} ${this.options.className || ""} leaflet-zoom-animated`); const r = this._wrapper = oe("div", `${e}-content-wrapper`, n); this._contentNode = oe("div", `${e}-content`, r), Ne(n), De(this._contentNode), Te(n, "contextmenu", je), this._tipContainer = oe("div", `${e}-tip-container`, n), this._tip = oe("div", `${e}-tip`, this._tipContainer), this.options.closeButton && ((t = this._closeButton = oe("a", `${e}-close-button`, n)).href = "#close", t.innerHTML = "&#215;", Te(t, "click", this._onCloseButtonClick, this)); },
    _updateLayout() { const t = this._contentNode; const e = t.style; e.width = "", e.whiteSpace = "nowrap"; let n = t.offsetWidth; n = Math.min(n, this.options.maxWidth); n = Math.max(n, this.options.minWidth), e.width = `${n + 1}px`, e.whiteSpace = "", e.height = ""; const r = t.offsetHeight; const i = this.options.maxHeight; const o = "leaflet-popup-scrolled"; i && i < r ? (e.height = `${i}px`, de(t, o)) : he(t, o), this._containerWidth = this._container.offsetWidth; },
    _animateZoom(t) { const e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); const n = this._getAnchor(); ye(this._container, e.add(n)); },
    _adjustPan() { let t; let e; let n; let r; let i; let o; let s; let a; let l; let u; let c; let d; this.options.autoPan && (this._map._panAnim && this._map._panAnim.stop(), t = this._map, e = parseInt(ie(this._container, "marginBottom"), 10) || 0, n = this._container.offsetHeight + e, r = this._containerWidth, (i = new M(this._containerLeft, -n - this._containerBottom))._add(_e(this._container)), o = t.layerPointToContainerPoint(i), s = j(this.options.autoPanPadding), a = j(this.options.autoPanPaddingTopLeft || s), l = j(this.options.autoPanPaddingBottomRight || s), u = t.getSize(), d = c = 0, o.x + r + l.x > u.x && (c = o.x + r - u.x + l.x), o.x - c - a.x < 0 && (c = o.x - a.x), o.y + n + l.y > u.y && (d = o.y + n - u.y + l.y), o.y - d - a.y < 0 && (d = o.y - a.y), (c || d) && t.fire("autopanstart").panBy([c, d])); },
    _onCloseButtonClick(t) { this._close(), Fe(t); },
    _getAnchor() { return j(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]); },
  }); Ye.mergeOptions({ closePopupOnClick: !0 }), Ye.include({ openPopup(t, e, n) { return t instanceof er || (t = new er(n).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : (this._popup && this._popup.options.autoClose && this.closePopup(), this._popup = t, this.addLayer(t)); }, closePopup(t) { return t && t !== this._popup || (t = this._popup, this._popup = null), t && this.removeLayer(t), this; } }), Tn.include({
    bindPopup(t, e) {
      return t instanceof er ? (p(t, e), (this._popup = t)._source = this) : (this._popup && !e || (this._popup = new er(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on({
        click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup,
      }), this._popupHandlersAdded = !0), this;
    },
    unbindPopup() {
      return this._popup && (this.off({
        click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup,
      }), this._popupHandlersAdded = !1, this._popup = null), this;
    },
    openPopup(t, e) { return this._popup && this._map && (e = this._popup._prepareOpen(this, t, e), this._map.openPopup(this._popup, e)), this; },
    closePopup() { return this._popup && this._popup._close(), this; },
    togglePopup(t) { return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(t)), this; },
    isPopupOpen() { return !!this._popup && this._popup.isOpen(); },
    setPopupContent(t) { return this._popup && this._popup.setContent(t), this; },
    getPopup() { return this._popup; },
    _openPopup(t) { const e = t.layer || t.target; this._popup && this._map && (Fe(t), e instanceof jn ? this.openPopup(t.layer || t.target, t.latlng) : this._map.hasLayer(this._popup) && this._popup._source === e ? this.closePopup() : this.openPopup(e, t.latlng)); },
    _movePopup(t) { this._popup.setLatLng(t.latlng); },
    _onKeyPress(t) { t.originalEvent.keyCode === 13 && this._openPopup(t); },
  }); const nr = tr.extend({
    options: {
      pane: "tooltipPane", offset: [0, 0], direction: "auto", permanent: !1, sticky: !1, interactive: !1, opacity: 0.9,
    },
    onAdd(t) { tr.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", { tooltip: this }), this._source && this._source.fire("tooltipopen", { tooltip: this }, !0); },
    onRemove(t) { tr.prototype.onRemove.call(this, t), t.fire("tooltipclose", { tooltip: this }), this._source && this._source.fire("tooltipclose", { tooltip: this }, !0); },
    getEvents() { const t = tr.prototype.getEvents.call(this); return kt && !this.options.permanent && (t.preclick = this._close), t; },
    _close() { this._map && this._map.closeTooltip(this); },
    _initLayout() { const t = `leaflet-tooltip ${this.options.className || ""} leaflet-zoom-${this._zoomAnimated ? "animated" : "hide"}`; this._contentNode = this._container = oe("div", t); },
    _updateLayout() {},
    _adjustPan() {},
    _setPosition(t) { let e; const n = this._map; const r = this._container; const i = n.latLngToContainerPoint(n.getCenter()); const o = n.layerPointToContainerPoint(t); let s = this.options.direction; const a = r.offsetWidth; const l = r.offsetHeight; const u = j(this.options.offset); const c = this._getAnchor(); const d = s === "top" ? (e = a / 2, l) : s === "bottom" ? (e = a / 2, 0) : (e = s === "center" ? a / 2 : s === "right" ? 0 : s === "left" ? a : o.x < i.x ? (s = "right", 0) : (s = "left", a + 2 * (u.x + c.x)), l / 2); t = t.subtract(j(e, d, !0)).add(u).add(c), he(r, "leaflet-tooltip-right"), he(r, "leaflet-tooltip-left"), he(r, "leaflet-tooltip-top"), he(r, "leaflet-tooltip-bottom"), de(r, `leaflet-tooltip-${s}`), ye(r, t); },
    _updatePosition() { const t = this._map.latLngToLayerPoint(this._latlng); this._setPosition(t); },
    setOpacity(t) { this.options.opacity = t, this._container && me(this._container, t); },
    _animateZoom(t) { const e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); this._setPosition(e); },
    _getAnchor() { return j(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]); },
  }); Ye.include({ openTooltip(t, e, n) { return t instanceof nr || (t = new nr(n).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : this.addLayer(t); }, closeTooltip(t) { return t && this.removeLayer(t), this; } }), Tn.include({
    bindTooltip(t, e) { return t instanceof nr ? (p(t, e), (this._tooltip = t)._source = this) : (this._tooltip && !e || (this._tooltip = new nr(e, this)), this._tooltip.setContent(t)), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this; }, unbindTooltip() { return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this; }, _initTooltipInteractions(t) { let e; let n; !t && this._tooltipHandlersAdded || (e = t ? "off" : "on", n = { remove: this.closeTooltip, move: this._moveTooltip }, this._tooltip.options.permanent ? n.add = this._openTooltip : (n.mouseover = this._openTooltip, n.mouseout = this.closeTooltip, this._tooltip.options.sticky && (n.mousemove = this._moveTooltip), kt && (n.click = this._openTooltip)), this[e](n), this._tooltipHandlersAdded = !t); }, openTooltip(t, e) { return this._tooltip && this._map && (e = this._tooltip._prepareOpen(this, t, e), this._map.openTooltip(this._tooltip, e), this._tooltip.options.interactive && this._tooltip._container && (de(this._tooltip._container, "leaflet-clickable"), this.addInteractiveTarget(this._tooltip._container))), this; }, closeTooltip() { return this._tooltip && (this._tooltip._close(), this._tooltip.options.interactive && this._tooltip._container && (he(this._tooltip._container, "leaflet-clickable"), this.removeInteractiveTarget(this._tooltip._container))), this; }, toggleTooltip(t) { return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this.openTooltip(t)), this; }, isTooltipOpen() { return this._tooltip.isOpen(); }, setTooltipContent(t) { return this._tooltip && this._tooltip.setContent(t), this; }, getTooltip() { return this._tooltip; }, _openTooltip(t) { const e = t.layer || t.target; this._tooltip && this._map && this.openTooltip(e, this._tooltip.options.sticky ? t.latlng : void 0); }, _moveTooltip(t) { let e; let n; let r = t.latlng; this._tooltip.options.sticky && t.originalEvent && (e = this._map.mouseEventToContainerPoint(t.originalEvent), n = this._map.containerPointToLayerPoint(e), r = this._map.layerPointToLatLng(n)), this._tooltip.setLatLng(r); },
  }); const rr = An.extend({
    options: {
      iconSize: [12, 12], html: !1, bgPos: null, className: "leaflet-div-icon",
    },
    createIcon(t) { let e; const n = t && t.tagName === "DIV" ? t : document.createElement("div"); const r = this.options; return r.html instanceof Element ? (ae(n), n.appendChild(r.html)) : n.innerHTML = !1 !== r.html ? r.html : "", r.bgPos && (e = j(r.bgPos), n.style.backgroundPosition = `${-e.x}px ${-e.y}px`), this._setIconStyles(n, "icon"), n; },
    createShadow() { return null; },
  }); An.Default = Mn; const ir = Tn.extend({
    options: {
      tileSize: 256, opacity: 1, updateWhenIdle: _t, updateWhenZooming: !0, updateInterval: 200, zIndex: 1, bounds: null, minZoom: 0, maxZoom: void 0, maxNativeZoom: void 0, minNativeZoom: void 0, noWrap: !1, pane: "tilePane", className: "", keepBuffer: 2,
    },
    initialize(t) { p(this, t); },
    onAdd() { this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(), this._update(); },
    beforeAdd(t) { t._addZoomLimit(this); },
    onRemove(t) { this._removeAllTiles(), se(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0; },
    bringToFront() { return this._map && (le(this._container), this._setAutoZIndex(Math.max)), this; },
    bringToBack() { return this._map && (ue(this._container), this._setAutoZIndex(Math.min)), this; },
    getContainer() { return this._container; },
    setOpacity(t) { return this.options.opacity = t, this._updateOpacity(), this; },
    setZIndex(t) { return this.options.zIndex = t, this._updateZIndex(), this; },
    isLoading() { return this._loading; },
    redraw() { return this._map && (this._removeAllTiles(), this._update()), this; },
    getEvents() {
      const t = {
        viewprereset: this._invalidateAll, viewreset: this._resetView, zoom: this._resetView, moveend: this._onMoveEnd,
      }; return this.options.updateWhenIdle || (this._onMove || (this._onMove = a(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
    },
    createTile() { return document.createElement("div"); },
    getTileSize() { const t = this.options.tileSize; return t instanceof M ? t : new M(t, t); },
    _updateZIndex() { this._container && void 0 !== this.options.zIndex && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex); },
    _setAutoZIndex(t) { for (var e, n = this.getPane().children, r = -t(-1 / 0, 1 / 0), i = 0, o = n.length; i < o; i++)e = n[i].style.zIndex, n[i] !== this._container && e && (r = t(r, +e)); isFinite(r) && (this.options.zIndex = r + t(-1, 1), this._updateZIndex()); },
    _updateOpacity() {
      if (this._map && !et) {
        me(this._container, this.options.opacity); const t = +new Date(); let e = !1; let
          n = !1; for (const r in this._tiles) { var i; const o = this._tiles[r]; o.current && o.loaded && (i = Math.min(1, (t - o.loaded) / 200), me(o.el, i), i < 1 ? e = !0 : (o.active ? n = !0 : this._onOpaqueTile(o), o.active = !0)); }n && !this._noPrune && this._pruneTiles(), e && (E(this._fadeFrame), this._fadeFrame = C(this._updateOpacity, this));
      }
    },
    _onOpaqueTile: u,
    _initContainer() { this._container || (this._container = oe("div", `leaflet-layer ${this.options.className || ""}`), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container)); },
    _updateLevels() { const t = this._tileZoom; const e = this.options.maxZoom; if (void 0 !== t) { for (let n in this._levels)n = Number(n), this._levels[n].el.children.length || n === t ? (this._levels[n].el.style.zIndex = e - Math.abs(t - n), this._onUpdateLevel(n)) : (se(this._levels[n].el), this._removeTilesAtZoom(n), this._onRemoveLevel(n), delete this._levels[n]); let r = this._levels[t]; const i = this._map; return r || ((r = this._levels[t] = {}).el = oe("div", "leaflet-tile-container leaflet-zoom-animated", this._container), r.el.style.zIndex = e, r.origin = i.project(i.unproject(i.getPixelOrigin()), t).round(), r.zoom = t, this._setZoomTransform(r, i.getCenter(), i.getZoom()), r.el.offsetWidth, this._onCreateLevel(r)), this._level = r; } },
    _onUpdateLevel: u,
    _onRemoveLevel: u,
    _onCreateLevel: u,
    _pruneTiles() { if (this._map) { let t; let e; let n; const r = this._map.getZoom(); if (r > this.options.maxZoom || r < this.options.minZoom) this._removeAllTiles(); else { for (t in this._tiles)(n = this._tiles[t]).retain = n.current; for (t in this._tiles)(n = this._tiles[t]).current && !n.active && (e = n.coords, this._retainParent(e.x, e.y, e.z, e.z - 5) || this._retainChildren(e.x, e.y, e.z, e.z + 2)); for (t in this._tiles) this._tiles[t].retain || this._removeTile(t); } } },
    _removeTilesAtZoom(t) { for (const e in this._tiles) this._tiles[e].coords.z === t && this._removeTile(e); },
    _removeAllTiles() { for (const t in this._tiles) this._removeTile(t); },
    _invalidateAll() { for (const t in this._levels)se(this._levels[t].el), this._onRemoveLevel(Number(t)), delete this._levels[t]; this._removeAllTiles(), this._tileZoom = void 0; },
    _retainParent(t, e, n, r) { const i = Math.floor(t / 2); const o = Math.floor(e / 2); const s = n - 1; const a = new M(+i, +o); a.z = +s; const l = this._tileCoordsToKey(a); const u = this._tiles[l]; return u && u.active ? u.retain = !0 : (u && u.loaded && (u.retain = !0), r < s && this._retainParent(i, o, s, r)); },
    _retainChildren(t, e, n, r) { for (let i = 2 * t; i < 2 * t + 2; i++) for (let o = 2 * e; o < 2 * e + 2; o++) { const s = new M(i, o); s.z = n + 1; const a = this._tileCoordsToKey(s); const l = this._tiles[a]; l && l.active ? l.retain = !0 : (l && l.loaded && (l.retain = !0), n + 1 < r && this._retainChildren(i, o, n + 1, r)); } },
    _resetView(t) { const e = t && (t.pinch || t.flyTo); this._setView(this._map.getCenter(), this._map.getZoom(), e, e); },
    _animateZoom(t) { this._setView(t.center, t.zoom, !0, t.noUpdate); },
    _clampZoom(t) { const e = this.options; return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t; },
    _setView(t, e, n, r) { let i = Math.round(e); const o = (i = void 0 !== this.options.maxZoom && i > this.options.maxZoom || void 0 !== this.options.minZoom && i < this.options.minZoom ? void 0 : this._clampZoom(i), this.options.updateWhenZooming && i !== this._tileZoom); r && !o || (this._tileZoom = i, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== i && this._update(t), n || this._pruneTiles(), this._noPrune = !!n), this._setZoomTransforms(t, e); },
    _setZoomTransforms(t, e) { for (const n in this._levels) this._setZoomTransform(this._levels[n], t, e); },
    _setZoomTransform(t, e, n) { const r = this._map.getZoomScale(n, t.zoom); const i = t.origin.multiplyBy(r).subtract(this._map._getNewPixelOrigin(e, n)).round(); yt ? ve(t.el, i, r) : ye(t.el, i); },
    _resetGrid() { const t = this._map; const e = t.options.crs; const n = this._tileSize = this.getTileSize(); const r = this._tileZoom; const i = this._map.getPixelWorldBounds(this._tileZoom); i && (this._globalTileRange = this._pxBoundsToTileRange(i)), this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], r).x / n.x), Math.ceil(t.project([0, e.wrapLng[1]], r).x / n.y)], this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], r).y / n.x), Math.ceil(t.project([e.wrapLat[1], 0], r).y / n.y)]; },
    _onMoveEnd() { this._map && !this._map._animatingZoom && this._update(); },
    _getTiledPixelBounds(t) { const e = this._map; const n = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(); const r = e.getZoomScale(n, this._tileZoom); const i = e.project(t, this._tileZoom).floor(); const o = e.getSize().divideBy(2 * r); return new D(i.subtract(o), i.add(o)); },
    _update(t) { const e = this._map; if (e) { const n = this._clampZoom(e.getZoom()); if (void 0 === t && (t = e.getCenter()), void 0 !== this._tileZoom) { const r = this._getTiledPixelBounds(t); const i = this._pxBoundsToTileRange(r); const o = i.getCenter(); const s = []; const a = this.options.keepBuffer; const l = new D(i.getBottomLeft().subtract([a, -a]), i.getTopRight().add([a, -a])); if (!(isFinite(i.min.x) && isFinite(i.min.y) && isFinite(i.max.x) && isFinite(i.max.y))) throw new Error("Attempted to load an infinite number of tiles"); for (const u in this._tiles) { const c = this._tiles[u].coords; c.z === this._tileZoom && l.contains(new M(c.x, c.y)) || (this._tiles[u].current = !1); } if (Math.abs(n - this._tileZoom) > 1) this._setView(t, n); else { for (let d = i.min.y; d <= i.max.y; d++) for (var h = i.min.x; h <= i.max.x; h++) { var p; const f = new M(h, d); f.z = this._tileZoom, this._isValidTile(f) && ((p = this._tiles[this._tileCoordsToKey(f)]) ? p.current = !0 : s.push(f)); } if (s.sort(((t, e) => t.distanceTo(o) - e.distanceTo(o))), s.length !== 0) { this._loading || (this._loading = !0, this.fire("loading")); const m = document.createDocumentFragment(); for (h = 0; h < s.length; h++) this._addTile(s[h], m); this._level.el.appendChild(m); } } } } },
    _isValidTile(t) { const e = this._map.options.crs; if (!e.infinite) { const n = this._globalTileRange; if (!e.wrapLng && (t.x < n.min.x || t.x > n.max.x) || !e.wrapLat && (t.y < n.min.y || t.y > n.max.y)) return !1; } if (!this.options.bounds) return !0; const r = this._tileCoordsToBounds(t); return F(this.options.bounds).overlaps(r); },
    _keyToBounds(t) { return this._tileCoordsToBounds(this._keyToTileCoords(t)); },
    _tileCoordsToNwSe(t) { const e = this._map; const n = this.getTileSize(); const r = t.scaleBy(n); const i = r.add(n); return [e.unproject(r, t.z), e.unproject(i, t.z)]; },
    _tileCoordsToBounds(t) { const e = this._tileCoordsToNwSe(t); let n = new R(e[0], e[1]); return this.options.noWrap || (n = this._map.wrapLatLngBounds(n)), n; },
    _tileCoordsToKey(t) { return `${t.x}:${t.y}:${t.z}`; },
    _keyToTileCoords(t) { const e = t.split(":"); const n = new M(+e[0], +e[1]); return n.z = +e[2], n; },
    _removeTile(t) { const e = this._tiles[t]; e && (se(e.el), delete this._tiles[t], this.fire("tileunload", { tile: e.el, coords: this._keyToTileCoords(t) })); },
    _initTile(t) { de(t, "leaflet-tile"); const e = this.getTileSize(); t.style.width = `${e.x}px`, t.style.height = `${e.y}px`, t.onselectstart = u, t.onmousemove = u, et && this.options.opacity < 1 && me(t, this.options.opacity), it && !ot && (t.style.WebkitBackfaceVisibility = "hidden"); },
    _addTile(t, e) { const n = this._getTilePos(t); const r = this._tileCoordsToKey(t); const o = this.createTile(this._wrapCoords(t), i(this._tileReady, this, t)); this._initTile(o), this.createTile.length < 2 && C(i(this._tileReady, this, t, null, o)), ye(o, n), this._tiles[r] = { el: o, coords: t, current: !0 }, e.appendChild(o), this.fire("tileloadstart", { tile: o, coords: t }); },
    _tileReady(t, e, n) { e && this.fire("tileerror", { error: e, tile: n, coords: t }); const r = this._tileCoordsToKey(t); (n = this._tiles[r]) && (n.loaded = +new Date(), this._map._fadeAnimated ? (me(n.el, 0), E(this._fadeFrame), this._fadeFrame = C(this._updateOpacity, this)) : (n.active = !0, this._pruneTiles()), e || (de(n.el, "leaflet-tile-loaded"), this.fire("tileload", { tile: n.el, coords: t })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), et || !this._map._fadeAnimated ? C(this._pruneTiles, this) : setTimeout(i(this._pruneTiles, this), 250))); },
    _getTilePos(t) { return t.scaleBy(this.getTileSize()).subtract(this._level.origin); },
    _wrapCoords(t) { const e = new M(this._wrapX ? l(t.x, this._wrapX) : t.x, this._wrapY ? l(t.y, this._wrapY) : t.y); return e.z = t.z, e; },
    _pxBoundsToTileRange(t) { const e = this.getTileSize(); return new D(t.min.unscaleBy(e).floor(), t.max.unscaleBy(e).ceil().subtract([1, 1])); },
    _noTilesToLoad() { for (const t in this._tiles) if (!this._tiles[t].loaded) return !1; return !0; },
  }); const or = ir.extend({
    options: {
      minZoom: 0, maxZoom: 18, subdomains: "abc", errorTileUrl: "", zoomOffset: 0, tms: !1, zoomReverse: !1, detectRetina: !1, crossOrigin: !1,
    },
    initialize(t, e) { this._url = t, (e = p(this, e)).detectRetina && Tt && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom++) : (e.zoomOffset++, e.maxZoom--), e.minZoom = Math.max(0, e.minZoom)), typeof e.subdomains === "string" && (e.subdomains = e.subdomains.split("")), it || this.on("tileunload", this._onTileRemove); },
    setUrl(t, e) { return this._url === t && void 0 === e && (e = !0), this._url = t, e || this.redraw(), this; },
    createTile(t, e) { const n = document.createElement("img"); return Te(n, "load", i(this._tileOnLoad, this, e, n)), Te(n, "error", i(this._tileOnError, this, e, n)), !this.options.crossOrigin && this.options.crossOrigin !== "" || (n.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), n.alt = "", n.setAttribute("role", "presentation"), n.src = this.getTileUrl(t), n; },
    getTileUrl(t) {
      let n; const r = {
        r: Tt ? "@2x" : "", s: this._getSubdomain(t), x: t.x, y: t.y, z: this._getZoomForUrl(),
      }; return this._map && !this._map.options.crs.infinite && (n = this._globalTileRange.max.y - t.y, this.options.tms && (r.y = n), r["-y"] = n), g(this._url, e(r, this.options));
    },
    _tileOnLoad(t, e) { et ? setTimeout(i(t, this, null, e), 0) : t(null, e); },
    _tileOnError(t, e, n) { const r = this.options.errorTileUrl; r && e.getAttribute("src") !== r && (e.src = r), t(n, e); },
    _onTileRemove(t) { t.tile.onload = null; },
    _getZoomForUrl() { let t = this._tileZoom; const e = this.options.maxZoom; return this.options.zoomReverse && (t = e - t), t + this.options.zoomOffset; },
    _getSubdomain(t) { const e = Math.abs(t.x + t.y) % this.options.subdomains.length; return this.options.subdomains[e]; },
    _abortLoading() { let t; let e; for (t in this._tiles) this._tiles[t].coords.z !== this._tileZoom && ((e = this._tiles[t].el).onload = u, e.onerror = u, e.complete || (e.src = _, se(e), delete this._tiles[t])); },
    _removeTile(t) { const e = this._tiles[t]; if (e) return at || e.el.setAttribute("src", _), ir.prototype._removeTile.call(this, t); },
    _tileReady(t, e, n) { if (this._map && (!n || n.getAttribute("src") !== _)) return ir.prototype._tileReady.call(this, t, e, n); },
  }); function sr(t, e) { return new or(t, e); } const ar = or.extend({
    defaultWmsParams: {
      service: "WMS", request: "GetMap", layers: "", styles: "", format: "image/jpeg", transparent: !1, version: "1.1.1",
    },
    options: { crs: null, uppercase: !1 },
    initialize(t, n) { this._url = t; const r = e({}, this.defaultWmsParams); for (const i in n)i in this.options || (r[i] = n[i]); const o = (n = p(this, n)).detectRetina && Tt ? 2 : 1; const s = this.getTileSize(); r.width = s.x * o, r.height = s.y * o, this.wmsParams = r; },
    onAdd(t) { this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version); const e = this._wmsVersion >= 1.3 ? "crs" : "srs"; this.wmsParams[e] = this._crs.code, or.prototype.onAdd.call(this, t); },
    getTileUrl(t) { const e = this._tileCoordsToNwSe(t); const n = this._crs; const r = N(n.project(e[0]), n.project(e[1])); const i = r.min; const o = r.max; const s = (this._wmsVersion >= 1.3 && this._crs === Cn ? [i.y, i.x, o.y, o.x] : [i.x, i.y, o.x, o.y]).join(","); const a = or.prototype.getTileUrl.call(this, t); return a + f(this.wmsParams, a, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + s; },
    setParams(t, n) { return e(this.wmsParams, t), n || this.redraw(), this; },
  }); or.WMS = ar, sr.wms = function (t, e) { return new ar(t, e); }; const lr = Tn.extend({
    options: { padding: 0.1, tolerance: 0 },
    initialize(t) { p(this, t), s(this), this._layers = this._layers || {}; },
    onAdd() { this._container || (this._initContainer(), this._zoomAnimated && de(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this); },
    onRemove() { this.off("update", this._updatePaths, this), this._destroyContainer(); },
    getEvents() {
      const t = {
        viewreset: this._reset, zoom: this._onZoom, moveend: this._update, zoomend: this._onZoomEnd,
      }; return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t;
    },
    _onAnimZoom(t) { this._updateTransform(t.center, t.zoom); },
    _onZoom() { this._updateTransform(this._map.getCenter(), this._map.getZoom()); },
    _updateTransform(t, e) { const n = this._map.getZoomScale(e, this._zoom); const r = _e(this._container); const i = this._map.getSize().multiplyBy(0.5 + this.options.padding); const o = this._map.project(this._center, e); const s = this._map.project(t, e).subtract(o); const a = i.multiplyBy(-n).add(r).add(i).subtract(s); yt ? ve(this._container, a, n) : ye(this._container, a); },
    _reset() { for (const t in this._update(), this._updateTransform(this._center, this._zoom), this._layers) this._layers[t]._reset(); },
    _onZoomEnd() { for (const t in this._layers) this._layers[t]._project(); },
    _updatePaths() { for (const t in this._layers) this._layers[t]._update(); },
    _update() { const t = this.options.padding; const e = this._map.getSize(); const n = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round(); this._bounds = new D(n, n.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom(); },
  }); const ur = lr.extend({
    getEvents() { const t = lr.prototype.getEvents.call(this); return t.viewprereset = this._onViewPreReset, t; }, _onViewPreReset() { this._postponeUpdatePaths = !0; }, onAdd() { lr.prototype.onAdd.call(this), this._draw(); }, _initContainer() { const t = this._container = document.createElement("canvas"); Te(t, "mousemove", this._onMouseMove, this), Te(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), Te(t, "mouseout", this._handleMouseOut, this), this._ctx = t.getContext("2d"); }, _destroyContainer() { E(this._redrawRequest), delete this._ctx, se(this._container), Oe(this._container), delete this._container; }, _updatePaths() { if (!this._postponeUpdatePaths) { for (const t in this._redrawBounds = null, this._layers) this._layers[t]._update(); this._redraw(); } }, _update() { let t; let e; let n; let r; this._map._animatingZoom && this._bounds || (lr.prototype._update.call(this), t = this._bounds, e = this._container, n = t.getSize(), r = Tt ? 2 : 1, ye(e, t.min), e.width = r * n.x, e.height = r * n.y, e.style.width = `${n.x}px`, e.style.height = `${n.y}px`, Tt && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update")); }, _reset() { lr.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths()); }, _initPath(t) { this._updateDashArray(t); const e = (this._layers[s(t)] = t)._order = { layer: t, prev: this._drawLast, next: null }; this._drawLast && (this._drawLast.next = e), this._drawLast = e, this._drawFirst = this._drawFirst || this._drawLast; }, _addPath(t) { this._requestRedraw(t); }, _removePath(t) { const e = t._order; const n = e.next; const r = e.prev; n ? n.prev = r : this._drawLast = r, r ? r.next = n : this._drawFirst = n, delete t._order, delete this._layers[s(t)], this._requestRedraw(t); }, _updatePath(t) { this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t); }, _updateStyle(t) { this._updateDashArray(t), this._requestRedraw(t); }, _updateDashArray(t) { if (typeof t.options.dashArray === "string") { for (var e, n = t.options.dashArray.split(/[, ]+/), r = [], i = 0; i < n.length; i++) { if (e = Number(n[i]), isNaN(e)) return; r.push(e); }t.options._dashArray = r; } else t.options._dashArray = t.options.dashArray; }, _requestRedraw(t) { this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || C(this._redraw, this)); }, _extendRedrawBounds(t) { let e; t._pxBounds && (e = (t.options.weight || 0) + 1, this._redrawBounds = this._redrawBounds || new D(), this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]))); }, _redraw() { this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null; }, _clear() { let t; const e = this._redrawBounds; e ? (t = e.getSize(), this._ctx.clearRect(e.min.x, e.min.y, t.x, t.y)) : (this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore()); }, _draw() { let t; let e; const n = this._redrawBounds; this._ctx.save(), n && (e = n.getSize(), this._ctx.beginPath(), this._ctx.rect(n.min.x, n.min.y, e.x, e.y), this._ctx.clip()), this._drawing = !0; for (let r = this._drawFirst; r; r = r.next)t = r.layer, (!n || t._pxBounds && t._pxBounds.intersects(n)) && t._updatePath(); this._drawing = !1, this._ctx.restore(); }, _updatePoly(t, e) { if (this._drawing) { let n; let r; let i; let o; const s = t._parts; const a = s.length; const l = this._ctx; if (a) { for (l.beginPath(), n = 0; n < a; n++) { for (r = 0, i = s[n].length; r < i; r++)o = s[n][r], l[r ? "lineTo" : "moveTo"](o.x, o.y); e && l.closePath(); } this._fillStroke(l, t); } } }, _updateCircle(t) { let e; let n; let r; let i; this._drawing && !t._empty() && (e = t._point, n = this._ctx, r = Math.max(Math.round(t._radius), 1), (i = (Math.max(Math.round(t._radiusY), 1) || r) / r) != 1 && (n.save(), n.scale(1, i)), n.beginPath(), n.arc(e.x, e.y / i, r, 0, 2 * Math.PI, !1), i != 1 && n.restore(), this._fillStroke(n, t)); }, _fillStroke(t, e) { const n = e.options; n.fill && (t.globalAlpha = n.fillOpacity, t.fillStyle = n.fillColor || n.color, t.fill(n.fillRule || "evenodd")), n.stroke && n.weight !== 0 && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = n.opacity, t.lineWidth = n.weight, t.strokeStyle = n.color, t.lineCap = n.lineCap, t.lineJoin = n.lineJoin, t.stroke()); }, _onClick(t) { for (var e, n, r = this._map.mouseEventToLayerPoint(t), i = this._drawFirst; i; i = i.next)(e = i.layer).options.interactive && e._containsPoint(r) && ((t.type === "click" || t.type !== "preclick") && this._map._draggableMoved(e) || (n = e)); n && (He(t), this._fireEvent([n], t)); }, _onMouseMove(t) { let e; !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e = this._map.mouseEventToLayerPoint(t), this._handleMouseHover(t, e)); }, _handleMouseOut(t) { const e = this._hoveredLayer; e && (he(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1); }, _handleMouseHover(t, e) { if (!this._mouseHoverThrottled) { for (var n, r, o = this._drawFirst; o; o = o.next)(n = o.layer).options.interactive && n._containsPoint(e) && (r = n); r !== this._hoveredLayer && (this._handleMouseOut(t), r && (de(this._container, "leaflet-interactive"), this._fireEvent([r], t, "mouseover"), this._hoveredLayer = r)), this._hoveredLayer && this._fireEvent([this._hoveredLayer], t), this._mouseHoverThrottled = !0, setTimeout(i((function () { this._mouseHoverThrottled = !1; }), this), 32); } }, _fireEvent(t, e, n) { this._map._fireDOMEvent(e, n || e.type, t); }, _bringToFront(t) { let e; let n; const r = t._order; r && (e = r.next, n = r.prev, e && ((e.prev = n) ? n.next = e : e && (this._drawFirst = e), r.prev = this._drawLast, (this._drawLast.next = r).next = null, this._drawLast = r, this._requestRedraw(t))); }, _bringToBack(t) { let e; let n; const r = t._order; r && (e = r.next, (n = r.prev) && ((n.next = e) ? e.prev = n : n && (this._drawLast = n), r.prev = null, r.next = this._drawFirst, this._drawFirst.prev = r, this._drawFirst = r, this._requestRedraw(t))); },
  }); function cr(t) { return Ot ? new ur(t) : null; } const dr = (function () { try { return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (t) { return document.createElement(`<lvml:${t} class="lvml">`); }; } catch (t) { return function (t) { return document.createElement(`<${t} xmlns="urn:schemas-microsoft.com:vml" class="lvml">`); }; } }()); const hr = {
    _initContainer() { this._container = oe("div", "leaflet-vml-container"); }, _update() { this._map._animatingZoom || (lr.prototype._update.call(this), this.fire("update")); }, _initPath(t) { const e = t._container = dr("shape"); de(e, `leaflet-vml-shape ${this.options.className || ""}`), e.coordsize = "1 1", t._path = dr("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[s(t)] = t; }, _addPath(t) { const e = t._container; this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e); }, _removePath(t) { const e = t._container; se(e), t.removeInteractiveTarget(e), delete this._layers[s(t)]; }, _updateStyle(t) { let e = t._stroke; let n = t._fill; const r = t.options; const i = t._container; i.stroked = !!r.stroke, i.filled = !!r.fill, r.stroke ? (e = e || (t._stroke = dr("stroke")), i.appendChild(e), e.weight = `${r.weight}px`, e.color = r.color, e.opacity = r.opacity, r.dashArray ? e.dashStyle = v(r.dashArray) ? r.dashArray.join(" ") : r.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = r.lineCap.replace("butt", "flat"), e.joinstyle = r.lineJoin) : e && (i.removeChild(e), t._stroke = null), r.fill ? (n = n || (t._fill = dr("fill")), i.appendChild(n), n.color = r.fillColor || r.color, n.opacity = r.fillOpacity) : n && (i.removeChild(n), t._fill = null); }, _updateCircle(t) { const e = t._point.round(); const n = Math.round(t._radius); const r = Math.round(t._radiusY || n); this._setPath(t, t._empty() ? "M0 0" : `AL ${e.x},${e.y} ${n},${r} 0,23592600`); }, _setPath(t, e) { t._path.v = e; }, _bringToFront(t) { le(t._container); }, _bringToBack(t) { ue(t._container); },
  }; const pr = Mt ? dr : X; const fr = lr.extend({
    getEvents() { const t = lr.prototype.getEvents.call(this); return t.zoomstart = this._onZoomStart, t; }, _initContainer() { this._container = pr("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = pr("g"), this._container.appendChild(this._rootGroup); }, _destroyContainer() { se(this._container), Oe(this._container), delete this._container, delete this._rootGroup, delete this._svgSize; }, _onZoomStart() { this._update(); }, _update() { let t; let e; let n; this._map._animatingZoom && this._bounds || (lr.prototype._update.call(this), e = (t = this._bounds).getSize(), n = this._container, this._svgSize && this._svgSize.equals(e) || (this._svgSize = e, n.setAttribute("width", e.x), n.setAttribute("height", e.y)), ye(n, t.min), n.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update")); }, _initPath(t) { const e = t._path = pr("path"); t.options.className && de(e, t.options.className), t.options.interactive && de(e, "leaflet-interactive"), this._updateStyle(t), this._layers[s(t)] = t; }, _addPath(t) { this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path); }, _removePath(t) { se(t._path), t.removeInteractiveTarget(t._path), delete this._layers[s(t)]; }, _updatePath(t) { t._project(), t._update(); }, _updateStyle(t) { const e = t._path; const n = t.options; e && (n.stroke ? (e.setAttribute("stroke", n.color), e.setAttribute("stroke-opacity", n.opacity), e.setAttribute("stroke-width", n.weight), e.setAttribute("stroke-linecap", n.lineCap), e.setAttribute("stroke-linejoin", n.lineJoin), n.dashArray ? e.setAttribute("stroke-dasharray", n.dashArray) : e.removeAttribute("stroke-dasharray"), n.dashOffset ? e.setAttribute("stroke-dashoffset", n.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), n.fill ? (e.setAttribute("fill", n.fillColor || n.color), e.setAttribute("fill-opacity", n.fillOpacity), e.setAttribute("fill-rule", n.fillRule || "evenodd")) : e.setAttribute("fill", "none")); }, _updatePoly(t, e) { this._setPath(t, Q(t._parts, e)); }, _updateCircle(t) { const e = t._point; const n = Math.max(Math.round(t._radius), 1); const r = `a${n},${Math.max(Math.round(t._radiusY), 1) || n} 0 1,0 `; const i = t._empty() ? "M0 0" : `M${e.x - n},${e.y}${r}${2 * n},0 ${r}${2 * -n},0 `; this._setPath(t, i); }, _setPath(t, e) { t._path.setAttribute("d", e); }, _bringToFront(t) { le(t._path); }, _bringToBack(t) { ue(t._path); },
  }); function mr(t) { return At || Mt ? new fr(t) : null; }Mt && fr.include(hr), Ye.include({ getRenderer(t) { var e = (e = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer()); return this.hasLayer(e) || this.addLayer(e), e; }, _getPaneRenderer(t) { if (t === "overlayPane" || void 0 === t) return !1; let e = this._paneRenderers[t]; return void 0 === e && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e; }, _createRenderer(t) { return this.options.preferCanvas && cr(t) || mr(t); } }); const gr = Fn.extend({ initialize(t, e) { Fn.prototype.initialize.call(this, this._boundsToLatLngs(t), e); }, setBounds(t) { return this.setLatLngs(this._boundsToLatLngs(t)); }, _boundsToLatLngs(t) { return [(t = F(t)).getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]; } }); fr.create = pr, fr.pointsToPath = Q, Vn.geometryToLayer = zn, Vn.coordsToLatLng = qn, Vn.coordsToLatLngs = Hn, Vn.latLngToCoords = $n, Vn.latLngsToCoords = Un, Vn.getFeature = Wn, Vn.asFeature = Gn, Ye.mergeOptions({ boxZoom: !0 }); const vr = en.extend({
    initialize(t) { this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this); },
    addHooks() { Te(this._container, "mousedown", this._onMouseDown, this); },
    removeHooks() { Oe(this._container, "mousedown", this._onMouseDown, this); },
    moved() { return this._moved; },
    _destroy() { se(this._pane), delete this._pane; },
    _resetState() { this._resetStateTimeout = 0, this._moved = !1; },
    _clearDeferredResetState() { this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0); },
    _onMouseDown(t) {
      if (!t.shiftKey || t.which !== 1 && t.button !== 1) return !1; this._clearDeferredResetState(), this._resetState(), Gt(), be(), this._startPoint = this._map.mouseEventToContainerPoint(t), Te(document, {
        contextmenu: Fe, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown,
      }, this);
    },
    _onMouseMove(t) { this._moved || (this._moved = !0, this._box = oe("div", "leaflet-zoom-box", this._container), de(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t); const e = new D(this._point, this._startPoint); const n = e.getSize(); ye(this._box, e.min), this._box.style.width = `${n.x}px`, this._box.style.height = `${n.y}px`; },
    _finish() {
      this._moved && (se(this._box), he(this._container, "leaflet-crosshair")), Yt(), we(), Oe(document, {
        contextmenu: Fe, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown,
      }, this);
    },
    _onMouseUp(t) { let e; t.which !== 1 && t.button !== 1 || (this._finish(), this._moved && (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(i(this._resetState, this), 0), e = new R(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(e).fire("boxzoomend", { boxZoomBounds: e }))); },
    _onKeyDown(t) { t.keyCode === 27 && this._finish(); },
  }); Ye.addInitHook("addHandler", "boxZoom", vr), Ye.mergeOptions({ doubleClickZoom: !0 }); const yr = en.extend({ addHooks() { this._map.on("dblclick", this._onDoubleClick, this); }, removeHooks() { this._map.off("dblclick", this._onDoubleClick, this); }, _onDoubleClick(t) { const e = this._map; const n = e.getZoom(); const r = e.options.zoomDelta; const i = t.originalEvent.shiftKey ? n - r : n + r; e.options.doubleClickZoom === "center" ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i); } }); Ye.addInitHook("addHandler", "doubleClickZoom", yr), Ye.mergeOptions({
    dragging: !0, inertia: !ot, inertiaDeceleration: 3400, inertiaMaxSpeed: 1 / 0, easeLinearity: 0.2, worldCopyJump: !1, maxBoundsViscosity: 0,
  }); const _r = en.extend({
    addHooks() { let t; this._draggable || (t = this._map, this._draggable = new ln(t._mapPane, t._container), this._draggable.on({ dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this))), de(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = []; },
    removeHooks() { he(this._map._container, "leaflet-grab"), he(this._map._container, "leaflet-touch-drag"), this._draggable.disable(); },
    moved() { return this._draggable && this._draggable._moved; },
    moving() { return this._draggable && this._draggable._moving; },
    _onDragStart() { let t; const e = this._map; e._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t = F(this._map.options.maxBounds), this._offsetLimit = N(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null, e.fire("movestart").fire("dragstart"), e.options.inertia && (this._positions = [], this._times = []); },
    _onDrag(t) { let e; let n; this._map.options.inertia && (e = this._lastTime = +new Date(), n = this._lastPos = this._draggable._absPos || this._draggable._newPos, this._positions.push(n), this._times.push(e), this._prunePositions(e)), this._map.fire("move", t).fire("drag", t); },
    _prunePositions(t) { for (;this._positions.length > 1 && t - this._times[0] > 50;) this._positions.shift(), this._times.shift(); },
    _onZoomEnd() { const t = this._map.getSize().divideBy(2); const e = this._map.latLngToLayerPoint([0, 0]); this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x; },
    _viscousLimit(t, e) { return t - (t - e) * this._viscosity; },
    _onPreDragLimit() { let t; let e; this._viscosity && this._offsetLimit && (t = this._draggable._newPos.subtract(this._draggable._startPos), e = this._offsetLimit, t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t)); },
    _onPreDragWrap() { const t = this._worldWidth; const e = Math.round(t / 2); const n = this._initialWorldOffset; const r = this._draggable._newPos.x; const i = (r - e + n) % t + e - n; const o = (r + e + n) % t - e - n; const s = Math.abs(i + n) < Math.abs(o + n) ? i : o; this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = s; },
    _onDragEnd(t) {
      let e; let n; let r; let i; let o; let s; let a; let l; let u; const c = this._map; const d = c.options; const h = !d.inertia || this._times.length < 2; c.fire("dragend", t), h ? c.fire("moveend") : (this._prunePositions(+new Date()), e = this._lastPos.subtract(this._positions[0]), n = (this._lastTime - this._times[0]) / 1e3, r = d.easeLinearity, o = (i = e.multiplyBy(r / n)).distanceTo([0, 0]), s = Math.min(d.inertiaMaxSpeed, o), a = i.multiplyBy(s / o), l = s / (d.inertiaDeceleration * r), (u = a.multiplyBy(-l / 2).round()).x || u.y ? (u = c._limitOffset(u, c.options.maxBounds), C((() => {
        c.panBy(u, {
          duration: l, easeLinearity: r, noMoveStart: !0, animate: !0,
        });
      }))) : c.fire("moveend"));
    },
  }); Ye.addInitHook("addHandler", "dragging", _r), Ye.mergeOptions({ keyboard: !0, keyboardPanDelta: 80 }); const br = en.extend({
    keyCodes: {
      left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 54, 173],
    },
    initialize(t) { this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta); },
    addHooks() { const t = this._map._container; t.tabIndex <= 0 && (t.tabIndex = "0"), Te(t, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this); },
    removeHooks() { this._removeHooks(), Oe(this._map._container, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this); },
    _onMouseDown() { let t; let e; let n; let r; this._focused || (t = document.body, e = document.documentElement, n = t.scrollTop || e.scrollTop, r = t.scrollLeft || e.scrollLeft, this._map._container.focus(), window.scrollTo(r, n)); },
    _onFocus() { this._focused = !0, this._map.fire("focus"); },
    _onBlur() { this._focused = !1, this._map.fire("blur"); },
    _setPanDelta(t) { for (var e = this._panKeys = {}, n = this.keyCodes, r = 0, i = n.left.length; r < i; r++)e[n.left[r]] = [-1 * t, 0]; for (r = 0, i = n.right.length; r < i; r++)e[n.right[r]] = [t, 0]; for (r = 0, i = n.down.length; r < i; r++)e[n.down[r]] = [0, t]; for (r = 0, i = n.up.length; r < i; r++)e[n.up[r]] = [0, -1 * t]; },
    _setZoomDelta(t) { for (var e = this._zoomKeys = {}, n = this.keyCodes, r = 0, i = n.zoomIn.length; r < i; r++)e[n.zoomIn[r]] = t; for (r = 0, i = n.zoomOut.length; r < i; r++)e[n.zoomOut[r]] = -t; },
    _addHooks() { Te(document, "keydown", this._onKeyDown, this); },
    _removeHooks() { Oe(document, "keydown", this._onKeyDown, this); },
    _onKeyDown(t) { if (!(t.altKey || t.ctrlKey || t.metaKey)) { let e; const n = t.keyCode; const r = this._map; if (n in this._panKeys)r._panAnim && r._panAnim._inProgress || (e = this._panKeys[n], t.shiftKey && (e = j(e).multiplyBy(3)), r.panBy(e), r.options.maxBounds && r.panInsideBounds(r.options.maxBounds)); else if (n in this._zoomKeys)r.setZoom(r.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[n]); else { if (n !== 27 || !r._popup || !r._popup.options.closeOnEscapeKey) return; r.closePopup(); }Fe(t); } },
  }); Ye.addInitHook("addHandler", "keyboard", br), Ye.mergeOptions({ scrollWheelZoom: !0, wheelDebounceTime: 40, wheelPxPerZoomLevel: 60 }); const wr = en.extend({
    addHooks() { Te(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0; }, removeHooks() { Oe(this._map._container, "wheel", this._onWheelScroll, this); }, _onWheelScroll(t) { const e = Be(t); const n = this._map.options.wheelDebounceTime; this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date()); const r = Math.max(n - (new Date() - this._startTime), 0); clearTimeout(this._timer), this._timer = setTimeout(i(this._performZoom, this), r), Fe(t); }, _performZoom() { const t = this._map; const e = t.getZoom(); const n = this._map.options.zoomSnap || 0; t._stop(); const r = this._delta / (4 * this._map.options.wheelPxPerZoomLevel); const i = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(r)))) / Math.LN2; const o = n ? Math.ceil(i / n) * n : i; const s = t._limitZoom(e + (this._delta > 0 ? o : -o)) - e; this._delta = 0, this._startTime = null, s && (t.options.scrollWheelZoom === "center" ? t.setZoom(e + s) : t.setZoomAround(this._lastMousePos, e + s)); },
  }); Ye.addInitHook("addHandler", "scrollWheelZoom", wr), Ye.mergeOptions({ tap: !0, tapTolerance: 15 }); const xr = en.extend({
    addHooks() { Te(this._map._container, "touchstart", this._onDown, this); }, removeHooks() { Oe(this._map._container, "touchstart", this._onDown, this); }, _onDown(t) { if (t.touches) { if (Re(t), this._fireClick = !0, t.touches.length > 1) return this._fireClick = !1, void clearTimeout(this._holdTimeout); const e = t.touches[0]; const n = e.target; this._startPos = this._newPos = new M(e.clientX, e.clientY), n.tagName && n.tagName.toLowerCase() === "a" && de(n, "leaflet-active"), this._holdTimeout = setTimeout(i((function () { this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", e)); }), this), 1e3), this._simulateEvent("mousedown", e), Te(document, { touchmove: this._onMove, touchend: this._onUp }, this); } }, _onUp(t) { let e; let n; clearTimeout(this._holdTimeout), Oe(document, { touchmove: this._onMove, touchend: this._onUp }, this), this._fireClick && t && t.changedTouches && ((n = (e = t.changedTouches[0]).target) && n.tagName && n.tagName.toLowerCase() === "a" && he(n, "leaflet-active"), this._simulateEvent("mouseup", e), this._isTapValid() && this._simulateEvent("click", e)); }, _isTapValid() { return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance; }, _onMove(t) { const e = t.touches[0]; this._newPos = new M(e.clientX, e.clientY), this._simulateEvent("mousemove", e); }, _simulateEvent(t, e) { const n = document.createEvent("MouseEvents"); n._simulated = !0, e.target._simulatedClick = !0, n.initMouseEvent(t, !0, !0, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(n); },
  }); !kt || St && !dt || Ye.addInitHook("addHandler", "tap", xr), Ye.mergeOptions({ touchZoom: kt && !ot, bounceAtZoomLimits: !0 }); const Sr = en.extend({
    addHooks() { de(this._map._container, "leaflet-touch-zoom"), Te(this._map._container, "touchstart", this._onTouchStart, this); }, removeHooks() { he(this._map._container, "leaflet-touch-zoom"), Oe(this._map._container, "touchstart", this._onTouchStart, this); }, _onTouchStart(t) { let e; let n; const r = this._map; !t.touches || t.touches.length !== 2 || r._animatingZoom || this._zooming || (e = r.mouseEventToContainerPoint(t.touches[0]), n = r.mouseEventToContainerPoint(t.touches[1]), this._centerPoint = r.getSize()._divideBy(2), this._startLatLng = r.containerPointToLatLng(this._centerPoint), r.options.touchZoom !== "center" && (this._pinchStartLatLng = r.containerPointToLatLng(e.add(n)._divideBy(2))), this._startDist = e.distanceTo(n), this._startZoom = r.getZoom(), this._moved = !1, this._zooming = !0, r._stop(), Te(document, "touchmove", this._onTouchMove, this), Te(document, "touchend", this._onTouchEnd, this), Re(t)); }, _onTouchMove(t) { if (t.touches && t.touches.length === 2 && this._zooming) { const e = this._map; const n = e.mouseEventToContainerPoint(t.touches[0]); const r = e.mouseEventToContainerPoint(t.touches[1]); const o = n.distanceTo(r) / this._startDist; if (this._zoom = e.getScaleZoom(o, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && o < 1 || this._zoom > e.getMaxZoom() && o > 1) && (this._zoom = e._limitZoom(this._zoom)), e.options.touchZoom === "center") { if (this._center = this._startLatLng, o == 1) return; } else { const s = n._add(r)._divideBy(2)._subtract(this._centerPoint); if (o == 1 && s.x === 0 && s.y === 0) return; this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(s), this._zoom); } this._moved || (e._moveStart(!0, !1), this._moved = !0), E(this._animRequest); const a = i(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 }); this._animRequest = C(a, this, !0), Re(t); } }, _onTouchEnd() { this._moved && this._zooming ? (this._zooming = !1, E(this._animRequest), Oe(document, "touchmove", this._onTouchMove, this), Oe(document, "touchend", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1; },
  }); Ye.addInitHook("addHandler", "touchZoom", Sr), Ye.BoxZoom = vr, Ye.DoubleClickZoom = yr, Ye.Drag = _r, Ye.Keyboard = br, Ye.ScrollWheelZoom = wr, Ye.Tap = xr, Ye.TouchZoom = Sr, t.version = "1.7.1", t.Control = Ke, t.control = Ze, t.Browser = It, t.Evented = A, t.Mixin = rn, t.Util = T, t.Class = P, t.Handler = en, t.extend = e, t.bind = i, t.stamp = s, t.setOptions = p, t.DomEvent = We, t.DomUtil = Ee, t.PosAnimation = Ge, t.Draggable = ln, t.LineUtil = vn, t.PolyUtil = bn, t.Point = M, t.point = j, t.Bounds = D, t.bounds = N, t.Transformation = W, t.transformation = G, t.Projection = Sn, t.LatLng = V, t.latLng = z, t.LatLngBounds = R, t.latLngBounds = F, t.CRS = q, t.GeoJSON = Vn, t.geoJSON = Zn, t.geoJson = Kn, t.Layer = Tn, t.LayerGroup = Pn, t.layerGroup = function (t, e) { return new Pn(t, e); }, t.FeatureGroup = On, t.featureGroup = function (t, e) { return new On(t, e); }, t.ImageOverlay = Xn, t.imageOverlay = function (t, e, n) { return new Xn(t, e, n); }, t.VideoOverlay = Qn, t.videoOverlay = function (t, e, n) { return new Qn(t, e, n); }, t.SVGOverlay = Jn, t.svgOverlay = function (t, e, n) { return new Jn(t, e, n); }, t.DivOverlay = tr, t.Popup = er, t.popup = function (t, e) { return new er(t, e); }, t.Tooltip = nr, t.tooltip = function (t, e) { return new nr(t, e); }, t.Icon = An, t.icon = function (t) { return new An(t); }, t.DivIcon = rr, t.divIcon = function (t) { return new rr(t); }, t.Marker = In, t.marker = function (t, e) { return new In(t, e); }, t.TileLayer = or, t.tileLayer = sr, t.GridLayer = ir, t.gridLayer = function (t) { return new ir(t); }, t.SVG = fr, t.svg = mr, t.Renderer = lr, t.Canvas = ur, t.canvas = cr, t.Path = jn, t.CircleMarker = Dn, t.circleMarker = function (t, e) { return new Dn(t, e); }, t.Circle = Nn, t.circle = function (t, e, n) { return new Nn(t, e, n); }, t.Polyline = Rn, t.polyline = function (t, e) { return new Rn(t, e); }, t.Polygon = Fn, t.polygon = function (t, e) { return new Fn(t, e); }, t.Rectangle = gr, t.rectangle = function (t, e) { return new gr(t, e); }, t.Map = Ye, t.map = function (t, e) { return new Ye(t, e); }; const kr = window.L; t.noConflict = function () { return window.L = kr, this; }, window.L = t;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSVideoPlayer = e() : t.HSVideoPlayer = e(); }(window, (() => (function (t) { const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const i in t)n.d(r, i, ((e) => t[e]).bind(null, i)); return r; }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return n.d(e, "a", e), e; }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.p = "", n(n.s = "./src/js/hs-video-player.js"); }({
  "./src/js/hs-video-player.js":
  /*! ***********************************!*\
  !*** ./src/js/hs-video-player.js ***!
  \********************************** */
  /*! exports provided: default */function (t, e, n) {
    function r(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } }n.r(e), n.d(e, "default", (() => o));
    /*
* HSVideoPlayer Plugin
* @version: 3.0.0 (Wed, 17 Mar 2021)
* @author: HtmlStream
* @event-namespace: .HSVideoPlayer
* @license: Htmlstream Libraries (https://htmlstream.com/)
* Copyright 2021 Htmlstream
*/
    const i = {
      parentSelector: null, targetSelector: null, classMap: { toggle: "video-player-played" }, videoType: "you-tube", videoId: null, isAutoplay: !1, isMuted: !1, youTubeAPISrc: "//www.youtube.com/player_api", isYouTubeAPICreated: !1, vimeoAPISrc: "//player.vimeo.com/api/player.js", isVimeoAPICreated: !1,
    }; var o = (function () {
      function t(e, n, r) { let i; !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, t)), this.collection = [], i = e instanceof HTMLElement ? [e] : e instanceof Object ? e : document.querySelectorAll(e); for (let o = 0; o < i.length; o += 1) this.addToCollection(i[o], n, r || i[o].id); return !!this.collection.length && (this._init(), this); } let e; let n; return e = t, (n = [{ key: "_init", value() { for (var t = this, e = function (e) { let n; let r = void 0; if (t.collection[e].hasOwnProperty("$initializedEl")) return "continue"; r = t.collection[e].$el, (n = t.collection[e].options).videoType === "you-tube" && t._youTubeAPI(r, n), n.videoType === "vimeo" && t._vimeoAPI(r, n), r.addEventListener("click", (() => { document.querySelector(n.parentSelector).classList.toggle(n.classMap.toggle), n.videoType === "vimeo" ? t._vimeoPlayer(r, n) : n.videoType === "html5" ? t._html5Player(r, n) : t._youTubePlayer(r, n); })), t.collection[e].$initializedEl = n; }, n = 0; n < t.collection.length; n += 1)e(n); } }, { key: "_youTubeAPI", value(t, e) { if (!e.isYouTubeAPICreated) { const n = document.createElement("script"); const r = document.getElementsByTagName("script")[0]; n.src = e.youTubeAPISrc, r.parentNode.insertBefore(n, r), e.isYouTubeAPICreated = !0; } } }, { key: "_vimeoAPI", value(t, e) { if (!e.isVimeoAPICreated) { const n = document.createElement("script"); const r = document.querySelector("script"); n.src = e.vimeoAPISrc, r.parentNode.insertBefore(n, r), e.isVimeoAPICreated = !0; } } }, { key: "_youTubePlayer", value(t, e) { const n = { videoId: e.videoId, playerVars: { origin: window.location.origin, autoplay: !0 === e.isAutoplay ? 1 : 0 }, ...e.specificAPIOptions }; new YT.Player(e.targetSelector.slice(1, e.targetSelector.length), n); } }, {
 key: "_vimeoPlayer",
value(t, e) {
 const n = {
        id: e.videoId, autoplay: !0 === e.isAutoplay ? 1 : 0, muted: !0 === e.isMuted ? 1 : 0, ...e.specificAPIOptions 
}; const r = document.getElementById(e.targetSelector.slice(1, e.targetSelector.length)); new Vimeo.Player(r, n).on("loaded", (() => { const t = r.querySelector("iframe"); t.style.height = "100%", t.style.width = "100%"; })); 
} 
}, {
        key: "_html5Player",
        value(t, e) {
          document.querySelector(e.targetSelector).insertAdjacentHTML("beforeend", '\n\t\t\t\t<video class="pfx-hero-bg-video__item" style="width:100%;height:100%;" playsinline '.concat(!0 === e.isAutoplay ? "autoplay " : "").concat(!0 === e.isMuted ? "muted " : "").concat(!0 === e.isLoop ? "loop" : "", '>\n\t\t\t\t\t<source src="').concat(e.videoId, '.mp4" type="video/mp4">\n\t\t\t\t\t<source src="')
            .concat(e.videoId, '.ogg" type="video/ogg">\n\t\t\t\t\t<source src="')
            .concat(e.videoId, '.webm" type="video/webm">\n\t\t\t\t\tYour browser doesn\'t support HTML5 video tag.\n\t\t\t\t</video>'));
        },
      }, { key: "addToCollection", value(t, e, n) { this.collection.push({ $el: t, id: n || null, options: { ...i, ...(t.hasAttribute("data-hs-video-player-options") ? JSON.parse(t.getAttribute("data-hs-video-player-options")) : {}), ...e } }); } }, { key: "getItem", value(t) { return typeof t === "number" ? this.collection[t].$initializedEl : this.collection.find(((e) => e.id === t)).$initializedEl; } }]) && r(e.prototype, n), t;
    }());
  },
})).default))); const countdown = (function (t) {
  const e = Math.ceil; const n = Math.floor; function r(t, e) { const n = t.getTime(); return t.setMonth(t.getMonth() + e), Math.round((t.getTime() - n) / 864e5); } function i(t) { const e = t.getTime(); const n = new Date(e); return n.setMonth(t.getMonth() + 1), Math.round((n.getTime() - e) / 864e5); } function o(t, e) { if (e = e instanceof Date || e !== null && isFinite(e) ? new Date(+e) : new Date(), !t) return e; let n = +t.value || 0; return n ? (e.setTime(e.getTime() + n), e) : ((n = +t.milliseconds || 0) && e.setMilliseconds(e.getMilliseconds() + n), (n = +t.seconds || 0) && e.setSeconds(e.getSeconds() + n), (n = +t.minutes || 0) && e.setMinutes(e.getMinutes() + n), (n = +t.hours || 0) && e.setHours(e.getHours() + n), (n = +t.weeks || 0) && (n *= 7), (n += +t.days || 0) && e.setDate(e.getDate() + n), (n = +t.months || 0) && e.setMonth(e.getMonth() + n), (n = +t.millennia || 0) && (n *= 10), (n += +t.centuries || 0) && (n *= 10), (n += +t.decades || 0) && (n *= 10), (n += +t.years || 0) && e.setFullYear(e.getFullYear() + n), e); } let s; let a; let l; let u; let c; let d; let h; let p; function f(t, e) { return h(t) + (t === 1 ? s[e] : a[e]); } function m() {} function g(t, e, n, r, o, s) { return t[n] >= 0 && (e += t[n], delete t[n]), (e /= o) + 1 <= 1 ? 0 : t[r] >= 0 ? (t[r] = +(t[r] + e).toFixed(s), (function (t, e) { switch (e) { case "seconds": if (t.seconds !== 60 || isNaN(t.minutes)) return; t.minutes++, t.seconds = 0; case "minutes": if (t.minutes !== 60 || isNaN(t.hours)) return; t.hours++, t.minutes = 0; case "hours": if (t.hours !== 24 || isNaN(t.days)) return; t.days++, t.hours = 0; case "days": if (t.days !== 7 || isNaN(t.weeks)) return; t.weeks++, t.days = 0; case "weeks": if (t.weeks !== i(t.refMonth) / 7 || isNaN(t.months)) return; t.months++, t.weeks = 0; case "months": if (t.months !== 12 || isNaN(t.years)) return; t.years++, t.months = 0; case "years": if (t.years !== 10 || isNaN(t.decades)) return; t.decades++, t.years = 0; case "decades": if (t.decades !== 10 || isNaN(t.centuries)) return; t.centuries++, t.decades = 0; case "centuries": if (t.centuries !== 10 || isNaN(t.millennia)) return; t.millennia++, t.centuries = 0; } }(t, r)), 0) : e; } function v(t, e) { let n; let r; let o; let s = g(t, 0, "milliseconds", "seconds", 1e3, e); if (s && ((s = g(t, s, "seconds", "minutes", 60, e)) && (s = g(t, s, "minutes", "hours", 60, e)) && (s = g(t, s, "hours", "days", 24, e)) && (s = g(t, s, "days", "weeks", 7, e)) && (s = g(t, s, "weeks", "months", i(t.refMonth) / 7, e)) && (s = g(t, s, "months", "years", (n = t.refMonth, r = n.getTime(), (o = new Date(r)).setFullYear(n.getFullYear() + 1), Math.round((o.getTime() - r) / 864e5) / i(t.refMonth)), e)) && (s = g(t, s, "years", "decades", 10, e)) && (s = g(t, s, "decades", "centuries", 10, e)) && (s = g(t, s, "centuries", "millennia", 10, e)))) throw new Error("Fractional unit overflow"); } function y(t, i, o, s, a, l) { const u = new Date(); if (t.start = i = i || u, t.end = o = o || u, t.units = s, t.value = o.getTime() - i.getTime(), t.value < 0) { const c = o; o = i, i = c; }t.refMonth = new Date(i.getFullYear(), i.getMonth(), 15, 12, 0, 0); try { t.millennia = 0, t.centuries = 0, t.decades = 0, t.years = o.getFullYear() - i.getFullYear(), t.months = o.getMonth() - i.getMonth(), t.weeks = 0, t.days = o.getDate() - i.getDate(), t.hours = o.getHours() - i.getHours(), t.minutes = o.getMinutes() - i.getMinutes(), t.seconds = o.getSeconds() - i.getSeconds(), t.milliseconds = o.getMilliseconds() - i.getMilliseconds(), (function (t) { let i; for (t.milliseconds < 0 ? (i = e(-t.milliseconds / 1e3), t.seconds -= i, t.milliseconds += 1e3 * i) : t.milliseconds >= 1e3 && (t.seconds += n(t.milliseconds / 1e3), t.milliseconds %= 1e3), t.seconds < 0 ? (i = e(-t.seconds / 60), t.minutes -= i, t.seconds += 60 * i) : t.seconds >= 60 && (t.minutes += n(t.seconds / 60), t.seconds %= 60), t.minutes < 0 ? (i = e(-t.minutes / 60), t.hours -= i, t.minutes += 60 * i) : t.minutes >= 60 && (t.hours += n(t.minutes / 60), t.minutes %= 60), t.hours < 0 ? (i = e(-t.hours / 24), t.days -= i, t.hours += 24 * i) : t.hours >= 24 && (t.days += n(t.hours / 24), t.hours %= 24); t.days < 0;)t.months--, t.days += r(t.refMonth, 1); t.days >= 7 && (t.weeks += n(t.days / 7), t.days %= 7), t.months < 0 ? (i = e(-t.months / 12), t.years -= i, t.months += 12 * i) : t.months >= 12 && (t.years += n(t.months / 12), t.months %= 12), t.years >= 10 && (t.decades += n(t.years / 10), t.years %= 10, t.decades >= 10 && (t.centuries += n(t.decades / 10), t.decades %= 10, t.centuries >= 10 && (t.millennia += n(t.centuries / 10), t.centuries %= 10))); }(t)), (function (t, e, i, o) { let s = 0; !(1024 & e) || s >= i ? (t.centuries += 10 * t.millennia, delete t.millennia) : t.millennia && s++, !(512 & e) || s >= i ? (t.decades += 10 * t.centuries, delete t.centuries) : t.centuries && s++, !(256 & e) || s >= i ? (t.years += 10 * t.decades, delete t.decades) : t.decades && s++, !(128 & e) || s >= i ? (t.months += 12 * t.years, delete t.years) : t.years && s++, !(64 & e) || s >= i ? (t.months && (t.days += r(t.refMonth, t.months)), delete t.months, t.days >= 7 && (t.weeks += n(t.days / 7), t.days %= 7)) : t.months && s++, !(32 & e) || s >= i ? (t.days += 7 * t.weeks, delete t.weeks) : t.weeks && s++, !(16 & e) || s >= i ? (t.hours += 24 * t.days, delete t.days) : t.days && s++, !(8 & e) || s >= i ? (t.minutes += 60 * t.hours, delete t.hours) : t.hours && s++, !(4 & e) || s >= i ? (t.seconds += 60 * t.minutes, delete t.minutes) : t.minutes && s++, !(2 & e) || s >= i ? (t.milliseconds += 1e3 * t.seconds, delete t.seconds) : t.seconds && s++, 1 & e && !(s >= i) || v(t, o); }(t, s, a, l)); } finally { delete t.refMonth; } return t; } function _(t, e, n, r, i) { let s; n = +n || 222, r = r > 0 ? r : NaN, i = i > 0 ? i < 20 ? Math.round(i) : 20 : 0; let a = null; typeof t === "function" ? (s = t, t = null) : t instanceof Date || (t !== null && isFinite(t) ? t = new Date(+t) : (typeof a === "object" && (a = t), t = null)); let l = null; if (typeof e === "function" ? (s = e, e = null) : e instanceof Date || (e !== null && isFinite(e) ? e = new Date(+e) : (typeof e === "object" && (l = e), e = null)), a && (t = o(a, e)), l && (e = o(l, t)), !t && !e) return new m(); if (!s) return y(new m(), t, e, n, r, i); let u; const c = (function (t) { return 1 & t ? 1e3 / 30 : 2 & t ? 1e3 : 4 & t ? 6e4 : 8 & t ? 36e5 : 16 & t ? 864e5 : 6048e5; }(n)); const d = function () { s(y(new m(), t, e, n, r, i), u); }; return d(), u = setInterval(d, c); }m.prototype.toString = function (t) { const e = p(this); const n = e.length; if (!n) return t ? `${t}` : c; if (n === 1) return e[0]; const r = l + e.pop(); return e.join(u) + r; }, m.prototype.toHTML = function (t, e) { t = t || "span"; const n = p(this); const r = n.length; if (!r) return (e = e || c) ? `<${t}>${e}</${t}>` : e; for (let i = 0; i < r; i++)n[i] = `<${t}>${n[i]}</${t}>`; if (r === 1) return n[0]; const o = l + n.pop(); return n.join(u) + o; }, m.prototype.addTo = function (t) { return o(this, t); }, p = function (t) { const e = []; let n = t.millennia; return n && e.push(d(n, 10)), (n = t.centuries) && e.push(d(n, 9)), (n = t.decades) && e.push(d(n, 8)), (n = t.years) && e.push(d(n, 7)), (n = t.months) && e.push(d(n, 6)), (n = t.weeks) && e.push(d(n, 5)), (n = t.days) && e.push(d(n, 4)), (n = t.hours) && e.push(d(n, 3)), (n = t.minutes) && e.push(d(n, 2)), (n = t.seconds) && e.push(d(n, 1)), (n = t.milliseconds) && e.push(d(n, 0)), e; }, _.MILLISECONDS = 1, _.SECONDS = 2, _.MINUTES = 4, _.HOURS = 8, _.DAYS = 16, _.WEEKS = 32, _.MONTHS = 64, _.YEARS = 128, _.DECADES = 256, _.CENTURIES = 512, _.MILLENNIA = 1024, _.DEFAULTS = 222, _.ALL = 2047; const b = _.setFormat = function (t) { if (t) { if ("singular" in t || "plural" in t) { let e = t.singular || []; e.split && (e = e.split("|")); let n = t.plural || []; n.split && (n = n.split("|")); for (let r = 0; r <= 10; r++)s[r] = e[r] || s[r], a[r] = n[r] || a[r]; } typeof t.last === "string" && (l = t.last), typeof t.delim === "string" && (u = t.delim), typeof t.empty === "string" && (c = t.empty), typeof t.formatNumber === "function" && (h = t.formatNumber), typeof t.formatter === "function" && (d = t.formatter); } }; const w = _.resetFormat = function () { s = " millisecond| second| minute| hour| day| week| month| year| decade| century| millennium".split("|"), a = " milliseconds| seconds| minutes| hours| days| weeks| months| years| decades| centuries| millennia".split("|"), l = " and ", u = ", ", c = "", h = function (t) { return t; }, d = f; }; return _.setLabels = function (t, e, n, r, i, o, s) {
    b({
      singular: t, plural: e, last: n, delim: r, empty: i, formatNumber: o, formatter: s,
    });
  }, _.resetLabels = w, w(), t && t.exports ? t.exports = _ : typeof window.define === "function" && void 0 !== window.define.amd && window.define("countdown", [], (() => _)), _;
}(module)); let List; !(function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSTogglePassword = e() : t.HSTogglePassword = e(); }(window, (() => (function (t) { const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const i in t)n.d(r, i, ((e) => t[e]).bind(null, i)); return r; }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return n.d(e, "a", e), e; }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.p = "", n(n.s = "./src/js/hs-toggle-password.js"); }({
  "./src/js/hs-toggle-password.js":
  /*! **************************************!*\
  !*** ./src/js/hs-toggle-password.js ***!
  \************************************* */
  /*! exports provided: default */function (module, __webpack_exports__, __webpack_require__) {
    eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _default; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSTogglePassword Plugin\n* @version: 1.0.0 (Sat, 30 Jul 2021)\n* @requires: tom-select 1.7.26\n* @author: HtmlStream\n* @event-namespace: .HSTogglePassword\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\nvar dataAttributeName = \'data-hs-toggle-password-options\';\nvar defaults = {\n  classChangeTarget: null,\n  defaultClass: null,\n  showClass: null,\n  show: false\n};\n\nvar _default = /*#__PURE__*/function () {\n  function _default(el, options, id) {\n    _classCallCheck(this, _default);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(_default, [{\n    key: "_init",\n    value: function _init() {\n      var that = this;\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          continue;\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n\n        if (Array.isArray(_options.target)) {\n          (function () {\n            var targets = [];\n\n            _options.target.forEach(function (target) {\n              targets.push(document.querySelector(target));\n            });\n\n            _options.target = targets;\n            _options.classChangeTarget = _options.classChangeTarget ? document.querySelector(_options.classChangeTarget) : _options.target;\n          })();\n        } else {\n          _options.target = document.querySelector(_options.target);\n          _options.classChangeTarget = _options.classChangeTarget ? document.querySelector(_options.classChangeTarget) : _options.target;\n        }\n\n        if (_options.show) {\n          _$el.type = "text";\n        }\n\n        that._toggleClass(_options, _options.show);\n\n        that._showPassword(_$el, _options);\n      }\n    }\n  }, {\n    key: "_showPassword",\n    value: function _showPassword(el, config) {\n      var that = this,\n          $target = config.target;\n\n      if (Array.isArray($target)) {\n        $target.forEach(function (target) {\n          target.addEventListener(\'click\', function (event) {\n            if (el.type === "password") {\n              el.type = "text";\n\n              that._toggleClass(config, true);\n            } else {\n              el.type = "password";\n\n              that._toggleClass(config, false);\n            }\n          });\n        });\n      } else {\n        $target.addEventListener(\'click\', function (event) {\n          if (el.type === "password") {\n            el.type = "text";\n\n            that._toggleClass(config, true);\n          } else {\n            el.type = "password";\n\n            that._toggleClass(config, false);\n          }\n        });\n      }\n    }\n  }, {\n    key: "_toggleClass",\n    value: function _toggleClass(config) {\n      var _this = this;\n\n      var isShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var that = this,\n          $target = config.classChangeTarget;\n\n      if (Array.isArray($target)) {\n        $target.forEach(function (target) {\n          if (isShow) {\n            _this._removeClasses(target, config.defaultClass);\n\n            _this._addClasses(target, config.showClass);\n          } else {\n            _this._removeClasses(target, config.showClass);\n\n            _this._addClasses(target, config.defaultClass);\n          }\n        });\n      } else {\n        if (isShow) {\n          this._removeClasses($target, config.defaultClass);\n\n          this._addClasses($target, config.showClass);\n        } else {\n          this._removeClasses($target, config.showClass);\n\n          this._addClasses($target, config.defaultClass);\n        }\n      }\n    }\n  }, {\n    key: "_addClasses",\n    value: function _addClasses($target, classes) {\n      if (classes && classes.trim().indexOf(\' \') != -1) {\n        var array = classes.split(\' \');\n\n        for (var i = 0, length = array.length; i < length; i++) {\n          $target.classList.add(array[i]);\n        }\n      } else {\n        $target.classList.add(classes);\n      }\n    }\n  }, {\n    key: "_removeClasses",\n    value: function _removeClasses($target, classes) {\n      if (classes && classes.trim().indexOf(\' \') != -1) {\n        var array = classes.split(\' \');\n\n        for (var i = 0, length = array.length; i < length; i++) {\n          $target.classList.remove(array[i]);\n        }\n      } else {\n        $target.classList.remove(classes);\n      }\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return _default;\n}();\n\n\n\n//# sourceURL=webpack://HSTogglePassword/./src/js/hs-toggle-password.js?');
  },
})).default))), (function (t, e) { typeof exports === "object" && void 0 !== module ? module.exports = e() : typeof define === "function" && define.amd ? define(e) : (t = typeof globalThis !== "undefined" ? globalThis : t || self).Shuffle = e(); }(this, (() => {
  function t(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function e(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } function n(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t; } function r(t) { return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } function i(t, e) { return (i = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function o(t, e) { return !e || typeof e !== "object" && typeof e !== "function" ? (function (t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; }(t)) : e; } function s(t) { const e = (function () { if (typeof Reflect === "undefined" || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (() => {}))), !0; } catch (t) { return !1; } }()); return function () { let n; const i = r(t); if (e) { const s = r(this).constructor; n = Reflect.construct(i, arguments, s); } else n = i.apply(this, arguments); return o(this, n); }; } const a = { exports: {} }; function l() {}l.prototype = {
    on(t, e, n) { const r = this.e || (this.e = {}); return (r[t] || (r[t] = [])).push({ fn: e, ctx: n }), this; }, once(t, e, n) { const r = this; function i() { r.off(t, i), e.apply(n, arguments); } return i._ = e, this.on(t, i, n); }, emit(t) { for (let e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), r = 0, i = n.length; r < i; r++)n[r].fn.apply(n[r].ctx, e); return this; }, off(t, e) { const n = this.e || (this.e = {}); const r = n[t]; const i = []; if (r && e) for (let o = 0, s = r.length; o < s; o++)r[o].fn !== e && r[o].fn._ !== e && i.push(r[o]); return i.length ? n[t] = i : delete n[t], this; },
  }, a.exports = l, a.exports.TinyEmitter = l; const u = a.exports; const c = typeof Element !== "undefined" ? Element.prototype : {}; const d = c.matches || c.matchesSelector || c.webkitMatchesSelector || c.mozMatchesSelector || c.msMatchesSelector || c.oMatchesSelector; const h = function (t, e) { if (!t || t.nodeType !== 1) return !1; if (d) return d.call(t, e); for (let n = t.parentNode.querySelectorAll(e), r = 0; r < n.length; r++) if (n[r] == t) return !0; return !1; }; const p = function (t, e) { let n; let r; let i; let o; let s = 0; return function () { n = this, r = arguments; const t = new Date() - s; return o || (t >= e ? a() : o = setTimeout(a, e - t)), i; }; function a() { o = 0, s = +new Date(), i = t.apply(n, r), n = null, r = null; } }; function f() {} function m(t) { return parseFloat(t) || 0; } const g = (function () { function e(n, r) { t(this, e), this.x = m(n), this.y = m(r); } return n(e, null, [{ key: "equals", value(t, e) { return t.x === e.x && t.y === e.y; } }]), e; }()); const v = (function () { function e(n, r, i, o, s) { t(this, e), this.id = s, this.left = n, this.top = r, this.width = i, this.height = o; } return n(e, null, [{ key: "intersects", value(t, e) { return t.left < e.left + e.width && e.left < t.left + t.width && t.top < e.top + e.height && e.top < t.top + t.height; } }]), e; }()); const y = {
    BASE: "shuffle", SHUFFLE_ITEM: "shuffle-item", VISIBLE: "shuffle-item--visible", HIDDEN: "shuffle-item--hidden",
  }; let _ = 0; const b = (function () { function e(n, r) { t(this, e), _ += 1, this.id = _, this.element = n, this.isRTL = r, this.isVisible = !0, this.isHidden = !1; } return n(e, [{ key: "show", value() { this.isVisible = !0, this.element.classList.remove(y.HIDDEN), this.element.classList.add(y.VISIBLE), this.element.removeAttribute("aria-hidden"); } }, { key: "hide", value() { this.isVisible = !1, this.element.classList.remove(y.VISIBLE), this.element.classList.add(y.HIDDEN), this.element.setAttribute("aria-hidden", !0); } }, { key: "init", value() { this.addClasses([y.SHUFFLE_ITEM, y.VISIBLE]), this.applyCss(e.Css.INITIAL), this.applyCss(this.isRTL ? e.Css.DIRECTION.rtl : e.Css.DIRECTION.ltr), this.scale = e.Scale.VISIBLE, this.point = new g(); } }, { key: "addClasses", value(t) { const e = this; t.forEach(((t) => { e.element.classList.add(t); })); } }, { key: "removeClasses", value(t) { const e = this; t.forEach(((t) => { e.element.classList.remove(t); })); } }, { key: "applyCss", value(t) { const e = this; Object.keys(t).forEach(((n) => { e.element.style[n] = t[n]; })); } }, { key: "dispose", value() { this.removeClasses([y.HIDDEN, y.VISIBLE, y.SHUFFLE_ITEM]), this.element.removeAttribute("style"), this.element = null; } }]), e; }()); b.Css = {
    INITIAL: {
      position: "absolute", top: 0, visibility: "visible", willChange: "transform",
    },
    DIRECTION: { ltr: { left: 0 }, rtl: { right: 0 } },
    VISIBLE: { before: { opacity: 1, visibility: "visible" }, after: { transitionDelay: "" } },
    HIDDEN: { before: { opacity: 0 }, after: { visibility: "hidden", transitionDelay: "" } },
  }, b.Scale = { VISIBLE: 1, HIDDEN: 0.001 }; let w = null; const x = function () { if (w !== null) return w; const t = document.body || document.documentElement; const e = document.createElement("div"); e.style.cssText = "width:10px;padding:2px;box-sizing:border-box;", t.appendChild(e); const n = window.getComputedStyle(e, null).width; return w = Math.round(m(n)) === 10, t.removeChild(e), w; }; function S(t, e) { const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : window.getComputedStyle(t, null); let r = m(n[e]); return x() || e !== "width" ? x() || e !== "height" || (r += m(n.paddingTop) + m(n.paddingBottom) + m(n.borderTopWidth) + m(n.borderBottomWidth)) : r += m(n.paddingLeft) + m(n.paddingRight) + m(n.borderLeftWidth) + m(n.borderRightWidth), r; } const k = {
    reverse: !1, by: null, compare: null, randomize: !1, key: "element",
  }; function C(t, e) { const n = { ...k, ...e }; const r = Array.from(t); let i = !1; return t.length ? n.randomize ? (function (t) { for (let e = t.length; e;) { e -= 1; const n = Math.floor(Math.random() * (e + 1)); const r = t[n]; t[n] = t[e], t[e] = r; } return t; }(t)) : (typeof n.by === "function" ? t.sort(((t, e) => { if (i) return 0; const r = n.by(t[n.key]); const o = n.by(e[n.key]); return void 0 === r && void 0 === o ? (i = !0, 0) : r < o || r === "sortFirst" || o === "sortLast" ? -1 : r > o || r === "sortLast" || o === "sortFirst" ? 1 : 0; })) : typeof n.compare === "function" && t.sort(n.compare), i ? r : (n.reverse && t.reverse(), t)) : []; } const E = {}; let T = 0; function P(t) { return !!E[t] && (E[t].element.removeEventListener("transitionend", E[t].listener), E[t] = null, !0); } function O(t, e) { const n = `transitionend${T += 1}`; const r = function (t) { t.currentTarget === t.target && (P(n), e(t)); }; return t.addEventListener("transitionend", r), E[n] = { element: t, listener: r }, n; } function A(t) { return Math.max.apply(Math, t); } function M(t, e, n, r) { let i = t / e; return Math.abs(Math.round(i) - i) < r && (i = Math.round(i)), Math.min(Math.ceil(i), n); } function L(t, e, n) { if (e === 1) return t; for (var r = [], i = 0; i <= n - e; i++)r.push(A(t.slice(i, i + e))); return r; } function I(t, e) { for (var n, r = (n = t, Math.min.apply(Math, n)), i = 0, o = t.length; i < o; i++) if (t[i] >= r - e && t[i] <= r + e) return i; return 0; } function j(t, e) { const n = {}; t.forEach(((t) => { n[t.top] ? n[t.top].push(t) : n[t.top] = [t]; })); let r = []; const i = []; const o = []; return Object.keys(n).forEach(((t) => { const s = n[t]; i.push(s); let a; const l = s[s.length - 1]; const u = l.left + l.width; const c = Math.round((e - u) / 2); let d = s; let h = !1; if (c > 0) { const p = []; (h = s.every(((t) => { const e = new v(t.left + c, t.top, t.width, t.height, t.id); const n = !r.some(((t) => v.intersects(e, t))); return p.push(e), n; }))) && (d = p); } if (!h && s.some(((t) => r.some(((e) => { const n = v.intersects(t, e); return n && (a = e), n; }))))) { const f = o.findIndex(((t) => t.includes(a))); o.splice(f, 1, i[f]); }r = r.concat(d), o.push(d); })), [].concat.apply([], o).sort(((t, e) => t.id - e.id)).map(((t) => new g(t.left, t.top))); } function D(t) { return Array.from(new Set(t)); } let N = 0; const R = (function (e) {
    !(function (t, e) { if (typeof e !== "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && i(t, e); }(o, e)); const r = s(o); function o(e) { let n; const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; t(this, o), (n = r.call(this)).options = { ...o.options, ...i }, n.options.delimeter && (n.options.delimiter = n.options.delimeter), n.lastSort = {}, n.group = o.ALL_ITEMS, n.lastFilter = o.ALL_ITEMS, n.isEnabled = !0, n.isDestroyed = !1, n.isInitialized = !1, n._transitions = [], n.isTransitioning = !1, n._queue = []; const s = n._getElementOption(e); if (!s) throw new TypeError("Shuffle needs to be initialized with an element."); return n.element = s, n.id = `shuffle_${N}`, N += 1, n._init(), n.isInitialized = !0, n; } return n(o, [{ key: "_init", value() { if (this.items = this._getItems(), this.sortedItems = this.items, this.options.sizer = this._getElementOption(this.options.sizer), this.element.classList.add(o.Classes.BASE), this._initItems(this.items), this._onResize = this._getResizeFunction(), window.addEventListener("resize", this._onResize), document.readyState !== "complete") { const t = this.layout.bind(this); window.addEventListener("load", (function e() { window.removeEventListener("load", e), t(); })); } const e = window.getComputedStyle(this.element, null); const n = o.getSize(this.element).width; this._validateStyles(e), this._setColumns(n), this.filter(this.options.group, this.options.initialSort), this.element.offsetWidth, this.setItemTransitions(this.items), this.element.style.transition = "height ".concat(this.options.speed, "ms ").concat(this.options.easing); } }, { key: "_getResizeFunction", value() { const t = this._handleResize.bind(this); return this.options.throttle ? this.options.throttle(t, this.options.throttleTime) : t; } }, { key: "_getElementOption", value(t) { return typeof t === "string" ? this.element.querySelector(t) : t && t.nodeType && t.nodeType === 1 ? t : t && t.jquery ? t[0] : null; } }, { key: "_validateStyles", value(t) { t.position === "static" && (this.element.style.position = "relative"), t.overflow !== "hidden" && (this.element.style.overflow = "hidden"); } }, { key: "_filter", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.lastFilter; const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.items; const n = this._getFilteredSets(t, e); return this._toggleFilterClasses(n), this.lastFilter = t, typeof t === "string" && (this.group = t), n; } }, { key: "_getFilteredSets", value(t, e) { const n = this; let r = []; const i = []; return t === o.ALL_ITEMS ? r = e : e.forEach(((e) => { n._doesPassFilter(t, e.element) ? r.push(e) : i.push(e); })), { visible: r, hidden: i }; } }, { key: "_doesPassFilter", value(t, e) { if (typeof t === "function") return t.call(e, e, this); const n = e.getAttribute(`data-${o.FILTER_ATTRIBUTE_KEY}`); const r = this.options.delimiter ? n.split(this.options.delimiter) : JSON.parse(n); function i(t) { return r.includes(t); } return Array.isArray(t) ? this.options.filterMode === o.FilterMode.ANY ? t.some(i) : t.every(i) : r.includes(t); } }, { key: "_toggleFilterClasses", value(t) { const e = t.visible; const n = t.hidden; e.forEach(((t) => { t.show(); })), n.forEach(((t) => { t.hide(); })); } }, { key: "_initItems", value(t) { t.forEach(((t) => { t.init(); })); } }, { key: "_disposeItems", value(t) { t.forEach(((t) => { t.dispose(); })); } }, { key: "_updateItemCount", value() { this.visibleItems = this._getFilteredItems().length; } }, { key: "setItemTransitions", value(t) { const e = this.options; const n = e.speed; const r = e.easing; const i = this.options.useTransforms ? ["transform"] : ["top", "left"]; const o = Object.keys(b.Css.HIDDEN.before).map(((t) => t.replace(/([A-Z])/g, ((t, e) => "-".concat(e.toLowerCase()))))); const s = i.concat(o).join(); t.forEach(((t) => { t.element.style.transitionDuration = `${n}ms`, t.element.style.transitionTimingFunction = r, t.element.style.transitionProperty = s; })); } }, { key: "_getItems", value() { const t = this; return Array.from(this.element.children).filter(((e) => h(e, t.options.itemSelector))).map(((e) => new b(e, t.options.isRTL))); } }, { key: "_mergeNewItems", value(t) { const e = Array.from(this.element.children); return C(this.items.concat(t), { by(t) { return e.indexOf(t); } }); } }, { key: "_getFilteredItems", value() { return this.items.filter(((t) => t.isVisible)); } }, { key: "_getConcealedItems", value() { return this.items.filter(((t) => !t.isVisible)); } }, { key: "_getColumnSize", value(t, e) { let n; return (n = typeof this.options.columnWidth === "function" ? this.options.columnWidth(t) : this.options.sizer ? o.getSize(this.options.sizer).width : this.options.columnWidth ? this.options.columnWidth : this.items.length > 0 ? o.getSize(this.items[0].element, !0).width : t) === 0 && (n = t), n + e; } }, { key: "_getGutterSize", value(t) { return typeof this.options.gutterWidth === "function" ? this.options.gutterWidth(t) : this.options.sizer ? S(this.options.sizer, "marginLeft") : this.options.gutterWidth; } }, { key: "_setColumns", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : o.getSize(this.element).width; const e = this._getGutterSize(t); const n = this._getColumnSize(t, e); let r = (t + e) / n; Math.abs(Math.round(r) - r) < this.options.columnThreshold && (r = Math.round(r)), this.cols = Math.max(Math.floor(r || 0), 1), this.containerWidth = t, this.colWidth = n; } }, { key: "_setContainerSize", value() { this.element.style.height = `${this._getContainerSize()}px`; } }, { key: "_getContainerSize", value() { return A(this.positions); } }, { key: "_getStaggerAmount", value(t) { return Math.min(t * this.options.staggerAmount, this.options.staggerAmountMax); } }, { key: "_dispatch", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.isDestroyed || (e.shuffle = this, this.emit(t, e)); } }, { key: "_resetCols", value() { let t = this.cols; for (this.positions = []; t;)t -= 1, this.positions.push(0); } }, { key: "_layout", value(t) { const e = this; const n = this._getNextPositions(t); let r = 0; t.forEach(((t, i) => { function o() { t.applyCss(b.Css.VISIBLE.after); } if (g.equals(t.point, n[i]) && !t.isHidden) return t.applyCss(b.Css.VISIBLE.before), void o(); t.point = n[i], t.scale = b.Scale.VISIBLE, t.isHidden = !1; const s = e.getStylesForTransition(t, b.Css.VISIBLE.before); s.transitionDelay = `${e._getStaggerAmount(r)}ms`, e._queue.push({ item: t, styles: s, callback: o }), r += 1; })); } }, { key: "_getNextPositions", value(t) { const e = this; if (this.options.isCentered) { const n = t.map(((t, n) => { const r = o.getSize(t.element, !0); const i = e._getItemPosition(r); return new v(i.x, i.y, r.width, r.height, n); })); return this.getTransformedPositions(n, this.containerWidth); } return t.map(((t) => e._getItemPosition(o.getSize(t.element, !0)))); } }, {
      key: "_getItemPosition",
      value(t) {
        return (function (t) { for (var e = t.itemSize, n = t.positions, r = t.gridSize, i = t.total, o = t.threshold, s = t.buffer, a = M(e.width, r, i, o), l = L(n, a, i), u = I(l, s), c = new g(r * u, l[u]), d = l[u] + e.height, h = 0; h < a; h++)n[u + h] = d; return c; }({
          itemSize: t, positions: this.positions, gridSize: this.colWidth, total: this.cols, threshold: this.options.columnThreshold, buffer: this.options.buffer,
        }));
      },
    }, { key: "getTransformedPositions", value(t, e) { return j(t, e); } }, { key: "_shrink", value() { const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._getConcealedItems(); let n = 0; e.forEach(((e) => { function r() { e.applyCss(b.Css.HIDDEN.after); } if (e.isHidden) return e.applyCss(b.Css.HIDDEN.before), void r(); e.scale = b.Scale.HIDDEN, e.isHidden = !0; const i = t.getStylesForTransition(e, b.Css.HIDDEN.before); i.transitionDelay = `${t._getStaggerAmount(n)}ms`, t._queue.push({ item: e, styles: i, callback: r }), n += 1; })); } }, { key: "_handleResize", value() { this.isEnabled && !this.isDestroyed && this.update(); } }, { key: "getStylesForTransition", value(t, e) { const n = { ...e }; if (this.options.useTransforms) { const r = this.options.isRTL ? "-" : ""; const i = this.options.roundTransforms ? Math.round(t.point.x) : t.point.x; const o = this.options.roundTransforms ? Math.round(t.point.y) : t.point.y; n.transform = "translate(".concat(r).concat(i, "px, ").concat(o, "px) scale(").concat(t.scale, ")"); } else this.options.isRTL ? n.right = `${t.point.x}px` : n.left = `${t.point.x}px`, n.top = `${t.point.y}px`; return n; } }, { key: "_whenTransitionDone", value(t, e, n) { const r = O(t, ((t) => { e(), n(null, t); })); this._transitions.push(r); } }, { key: "_getTransitionFunction", value(t) { const e = this; return function (n) { t.item.applyCss(t.styles), e._whenTransitionDone(t.item.element, t.callback, n); }; } }, { key: "_processQueue", value() { this.isTransitioning && this._cancelMovement(); const t = this.options.speed > 0; const e = this._queue.length > 0; e && t && this.isInitialized ? this._startTransitions(this._queue) : e ? (this._styleImmediately(this._queue), this._dispatch(o.EventType.LAYOUT)) : this._dispatch(o.EventType.LAYOUT), this._queue.length = 0; } }, { key: "_startTransitions", value(t) { const e = this; this.isTransitioning = !0, (function (t, e, n) { n || (typeof e === "function" ? (n = e, e = null) : n = f); let r = t && t.length; if (!r) return n(null, []); let i = !1; const o = new Array(r); function s(t) { return function (e, s) { if (!i) { if (e) return n(e, o), void (i = !0); o[t] = s, --r || n(null, o); } }; }t.forEach(e ? (t, n) => { t.call(e, s(n)); } : (t, e) => { t(s(e)); }); }(t.map(((t) => e._getTransitionFunction(t))), this._movementFinished.bind(this))); } }, { key: "_cancelMovement", value() { this._transitions.forEach(P), this._transitions.length = 0, this.isTransitioning = !1; } }, { key: "_styleImmediately", value(t) { if (t.length) { const e = t.map(((t) => t.item.element)); o._skipTransitions(e, (() => { t.forEach(((t) => { t.item.applyCss(t.styles), t.callback(); })); })); } } }, { key: "_movementFinished", value() { this._transitions.length = 0, this.isTransitioning = !1, this._dispatch(o.EventType.LAYOUT); } }, { key: "filter", value(t, e) { this.isEnabled && ((!t || t && t.length === 0) && (t = o.ALL_ITEMS), this._filter(t), this._shrink(), this._updateItemCount(), this.sort(e)); } }, { key: "sort", value() { const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.lastSort; if (this.isEnabled) { this._resetCols(); const e = C(this._getFilteredItems(), t); this.sortedItems = e, this._layout(e), this._processQueue(), this._setContainerSize(), this.lastSort = t; } } }, { key: "update", value() { const t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; this.isEnabled && (t || this._setColumns(), this.sort()); } }, { key: "layout", value() { this.update(!0); } }, { key: "add", value(t) { const e = this; const n = D(t).map(((t) => new b(t, e.options.isRTL))); this._initItems(n), this._resetCols(); const r = C(this._mergeNewItems(n), this.lastSort); const i = this._filter(this.lastFilter, r); const o = function (t) { return n.includes(t); }; const s = function (t) { t.scale = b.Scale.HIDDEN, t.isHidden = !0, t.applyCss(b.Css.HIDDEN.before), t.applyCss(b.Css.HIDDEN.after); }; const a = this._getNextPositions(i.visible); i.visible.forEach(((t, n) => { o(t) && (t.point = a[n], s(t), t.applyCss(e.getStylesForTransition(t, {}))); })), i.hidden.forEach(((t) => { o(t) && s(t); })), this.element.offsetWidth, this.setItemTransitions(n), this.items = this._mergeNewItems(n), this.filter(this.lastFilter); } }, { key: "disable", value() { this.isEnabled = !1; } }, { key: "enable", value() { const t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; this.isEnabled = !0, t && this.update(); } }, { key: "remove", value(t) { const e = this; if (t.length) { const n = D(t); const r = n.map(((t) => e.getItemByElement(t))).filter(((t) => !!t)); this._toggleFilterClasses({ visible: [], hidden: r }), this._shrink(r), this.sort(), this.items = this.items.filter(((t) => !r.includes(t))), this._updateItemCount(), this.once(o.EventType.LAYOUT, (() => { e._disposeItems(r), n.forEach(((t) => { t.parentNode.removeChild(t); })), e._dispatch(o.EventType.REMOVED, { collection: n }); })); } } }, { key: "getItemByElement", value(t) { return this.items.find(((e) => e.element === t)); } }, { key: "resetItems", value() { const t = this; this._disposeItems(this.items), this.isInitialized = !1, this.items = this._getItems(), this._initItems(this.items), this.once(o.EventType.LAYOUT, (() => { t.setItemTransitions(t.items), t.isInitialized = !0; })), this.filter(this.lastFilter); } }, { key: "destroy", value() { this._cancelMovement(), window.removeEventListener("resize", this._onResize), this.element.classList.remove("shuffle"), this.element.removeAttribute("style"), this._disposeItems(this.items), this.items.length = 0, this._transitions.length = 0, this.options.sizer = null, this.element = null, this.isDestroyed = !0, this.isEnabled = !1; } }], [{ key: "getSize", value(t) { const e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = window.getComputedStyle(t, null); let r = S(t, "width", n); let i = S(t, "height", n); if (e) { const o = S(t, "marginLeft", n); const s = S(t, "marginRight", n); const a = S(t, "marginTop", n); const l = S(t, "marginBottom", n); r += o + s, i += a + l; } return { width: r, height: i }; } }, { key: "_skipTransitions", value(t, e) { const n = t.map(((t) => { const e = t.style; const n = e.transitionDuration; const r = e.transitionDelay; return e.transitionDuration = "0ms", e.transitionDelay = "0ms", { duration: n, delay: r }; })); e(), t[0].offsetWidth, t.forEach(((t, e) => { t.style.transitionDuration = n[e].duration, t.style.transitionDelay = n[e].delay; })); } }]), o;
  }(u)); return R.ShuffleItem = b, R.ALL_ITEMS = "all", R.FILTER_ATTRIBUTE_KEY = "groups", R.EventType = { LAYOUT: "shuffle:layout", REMOVED: "shuffle:removed" }, R.Classes = y, R.FilterMode = { ANY: "any", ALL: "all" }, R.options = {
    group: R.ALL_ITEMS, speed: 250, easing: "cubic-bezier(0.4, 0.0, 0.2, 1)", itemSelector: "*", sizer: null, gutterWidth: 0, columnWidth: 0, delimiter: null, buffer: 0, columnThreshold: 0.01, initialSort: null, throttle: p, throttleTime: 300, staggerAmount: 15, staggerAmountMax: 150, useTransforms: !0, filterMode: R.FilterMode.ANY, isCentered: !1, isRTL: !1, roundTransforms: !0,
  }, R.Point = g, R.Rect = v, R.__sorter = C, R.__getColumnSpan = M, R.__getAvailablePositions = L, R.__getShortColumn = I, R.__getCenteredPositions = j, R;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSCountCharacters = e() : t.HSCountCharacters = e(); }(window, (() => (function (t) { const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { i: r, l: !1, exports: {} }; return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports; } return n.m = t, n.c = e, n.d = function (t, e, r) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r }); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const r = Object.create(null); if (n.r(r), Object.defineProperty(r, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const i in t)n.d(r, i, ((e) => t[e]).bind(null, i)); return r; }, n.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return n.d(e, "a", e), e; }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.p = "", n(n.s = "./src/js/hs-count-characters.js"); }({
  "./src/js/hs-count-characters.js":
  /*! ***************************************!*\
  !*** ./src/js/hs-count-characters.js ***!
  \************************************** */
  /*! exports provided: default */function (module, __webpack_exports__, __webpack_require__) {
    eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSCountCharacters; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSCountCharacters Plugin\n* @version: 1.0.1 (Sun, 1 Aug 2021)\n* @author: HtmlStream\n* @event-namespace: .HSCountCharacters\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\nvar dataAttributeName = \'data-hs-count-characters-options\';\nvar defaults = {};\n\nvar HSCountCharacters = /*#__PURE__*/function () {\n  function HSCountCharacters(el, options, id) {\n    _classCallCheck(this, HSCountCharacters);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSCountCharacters, [{\n    key: "_init",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        _options.output = document.querySelector(_options.output);\n        _options.maxLength = _$el.hasAttribute(\'maxlength\') ? \'/ \' + _$el.getAttribute(\'maxlength\') : \'\';\n\n        that._updateOutput(_$el, _options);\n\n        _$el.addEventListener(\'input\', function () {\n          that._updateOutput(_$el, _options);\n        });\n\n        that.collection[i].$initializedEl = _options;\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "_updateOutput",\n    value: function _updateOutput($el, settings) {\n      settings.output.innerHTML = "".concat($el.value.length, " ").concat(settings.maxLength);\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSCountCharacters;\n}();\n\n\n\n//# sourceURL=webpack://HSCountCharacters/./src/js/hs-count-characters.js?');
  },
})).default))), (function (t, e) { if (typeof exports === "object" && typeof module === "object")module.exports = e(); else if (typeof define === "function" && define.amd)define([], e); else { const n = e(); for (const r in n)(typeof exports === "object" ? exports : t)[r] = n[r]; } }(self, (() => (function () {
  const t = {
    3099(t) { t.exports = function (t) { if (typeof t !== "function") throw TypeError(`${String(t)} is not a function`); return t; }; },
    6077(t, e, n) { const r = n(111); t.exports = function (t) { if (!r(t) && t !== null) throw TypeError(`Can't set ${String(t)} as a prototype`); return t; }; },
    1223(t, e, n) { const r = n(5112); const i = n(30); const o = n(3070); const s = r("unscopables"); const a = Array.prototype; a[s] == null && o.f(a, s, { configurable: !0, value: i(null) }), t.exports = function (t) { a[s][t] = !0; }; },
    1530(t, e, n) {
      const r = n(8710).charAt; t.exports = function (t, e, n) { return e + (n ? r(t, e).length : 1); };
    },
    5787(t) { t.exports = function (t, e, n) { if (!(t instanceof e)) throw TypeError(`Incorrect ${n ? `${n} ` : ""}invocation`); return t; }; },
    9670(t, e, n) { const r = n(111); t.exports = function (t) { if (!r(t)) throw TypeError(`${String(t)} is not an object`); return t; }; },
    4019(t) { t.exports = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined"; },
    260(t, e, n) {
      let r; const i = n(4019); const o = n(9781); const s = n(7854); const a = n(111); const l = n(6656); const u = n(648); const c = n(8880); const d = n(1320); const h = n(3070).f; const p = n(9518); const f = n(7674); const m = n(5112); const g = n(9711); const v = s.Int8Array; const y = v && v.prototype; const _ = s.Uint8ClampedArray; const b = _ && _.prototype; let w = v && p(v); let x = y && p(y); const S = Object.prototype; const k = S.isPrototypeOf; const C = m("toStringTag"); const E = g("TYPED_ARRAY_TAG"); let T = i && !!f && u(s.opera) !== "Opera"; let P = !1; const O = {
        Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8, 
      }; const A = { BigInt64Array: 8, BigUint64Array: 8 }; const M = function (t) { if (!a(t)) return !1; const e = u(t); return l(O, e) || l(A, e); }; for (r in O)s[r] || (T = !1); if ((!T || typeof w !== "function" || w === Function.prototype) && (w = function () { throw TypeError("Incorrect invocation"); }, T)) for (r in O)s[r] && f(s[r], w); if ((!T || !x || x === S) && (x = w.prototype, T)) for (r in O)s[r] && f(s[r].prototype, x); if (T && p(b) !== x && f(b, x), o && !l(x, C)) for (r in P = !0, h(x, C, { get() { return a(this) ? this[E] : void 0; } }), O)s[r] && c(s[r], E, r); t.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: T, TYPED_ARRAY_TAG: P && E, aTypedArray(t) { if (M(t)) return t; throw TypeError("Target is not a typed array"); }, aTypedArrayConstructor(t) { if (f) { if (k.call(w, t)) return t; } else for (const e in O) if (l(O, r)) { const n = s[e]; if (n && (t === n || k.call(n, t))) return t; } throw TypeError("Target is not a typed array constructor"); }, exportTypedArrayMethod(t, e, n) { if (o) { if (n) for (const r in O) { const i = s[r]; i && l(i.prototype, t) && delete i.prototype[t]; }x[t] && !n || d(x, t, n ? e : T && y[t] || e); } }, exportTypedArrayStaticMethod(t, e, n) { let r; let i; if (o) { if (f) { if (n) for (r in O)(i = s[r]) && l(i, t) && delete i[t]; if (w[t] && !n) return; try { return d(w, t, n ? e : T && v[t] || e); } catch (t) {} } for (r in O)!(i = s[r]) || i[t] && !n || d(i, t, e); } }, isView(t) { if (!a(t)) return !1; const e = u(t); return e === "DataView" || l(O, e) || l(A, e); }, isTypedArray: M, TypedArray: w, TypedArrayPrototype: x,
      };
    },
    3331(t, e, n) {
      const r = n(7854); const i = n(9781); const o = n(4019); const s = n(8880); const a = n(2248); const l = n(7293); const u = n(5787); const c = n(9958); const d = n(7466); const h = n(7067); const p = n(1179); const f = n(9518); const m = n(7674); const g = n(8006).f; const v = n(3070).f; const y = n(1285); const _ = n(8003); const b = n(9909); const w = b.get; const x = b.set; const S = "ArrayBuffer"; const k = "DataView"; const C = "Wrong index"; const E = r.ArrayBuffer; let T = E; let P = r.DataView; const O = P && P.prototype; const A = Object.prototype; const M = r.RangeError; const L = p.pack; const I = p.unpack; const j = function (t) { return [255 & t]; }; const D = function (t) { return [255 & t, t >> 8 & 255]; }; const N = function (t) { return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]; }; const R = function (t) { return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]; }; const F = function (t) { return L(t, 23, 4); }; const V = function (t) { return L(t, 52, 8); }; const z = function (t, e) { v(t.prototype, e, { get() { return w(this)[e]; } }); }; const B = function (t, e, n, r) { const i = h(n); const o = w(t); if (i + e > o.byteLength) throw M(C); const s = w(o.buffer).bytes; const a = i + o.byteOffset; const l = s.slice(a, a + e); return r ? l : l.reverse(); }; const q = function (t, e, n, r, i, o) { const s = h(n); const a = w(t); if (s + e > a.byteLength) throw M(C); for (let l = w(a.buffer).bytes, u = s + a.byteOffset, c = r(+i), d = 0; d < e; d++)l[u + d] = c[o ? d : e - d - 1]; }; if (o) { if (!l((() => { E(1); })) || !l((() => { new E(-1); })) || l((() => (new E(), new E(1.5), new E(NaN), E.name != S)))) { for (var H, $ = (T = function (t) { return u(this, T), new E(h(t)); }).prototype = E.prototype, U = g(E), W = 0; U.length > W;)(H = U[W++]) in T || s(T, H, E[H]); $.constructor = T; }m && f(O) !== A && m(O, A); const G = new P(new T(2)); const Y = O.setInt8; G.setInt8(0, 2147483648), G.setInt8(1, 2147483649), !G.getInt8(0) && G.getInt8(1) || a(O, { setInt8(t, e) { Y.call(this, t, e << 24 >> 24); }, setUint8(t, e) { Y.call(this, t, e << 24 >> 24); } }, { unsafe: !0 }); } else {
 T = function (t) { u(this, T, S); const e = h(t); x(this, { bytes: y.call(new Array(e), 0), byteLength: e }), i || (this.byteLength = e); }, P = function (t, e, n) { u(this, P, k), u(t, T, k); const r = w(t).byteLength; const o = c(e); if (o < 0 || o > r) throw M("Wrong offset"); if (o + (n = void 0 === n ? r - o : d(n)) > r) throw M("Wrong length"); x(this, { buffer: t, byteLength: n, byteOffset: o }), i || (this.buffer = t, this.byteLength = n, this.byteOffset = o); }, i && (z(T, "byteLength"), z(P, "buffer"), z(P, "byteLength"), z(P, "byteOffset")), a(P.prototype, {
        getInt8(t) { return B(this, 1, t)[0] << 24 >> 24; }, getUint8(t) { return B(this, 1, t)[0]; }, getInt16(t) { const e = B(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return (e[1] << 8 | e[0]) << 16 >> 16; }, getUint16(t) { const e = B(this, 2, t, arguments.length > 1 ? arguments[1] : void 0); return e[1] << 8 | e[0]; }, getInt32(t) { return R(B(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)); }, getUint32(t) { return R(B(this, 4, t, arguments.length > 1 ? arguments[1] : void 0)) >>> 0; }, getFloat32(t) { return I(B(this, 4, t, arguments.length > 1 ? arguments[1] : void 0), 23); }, getFloat64(t) { return I(B(this, 8, t, arguments.length > 1 ? arguments[1] : void 0), 52); }, setInt8(t, e) { q(this, 1, t, j, e); }, setUint8(t, e) { q(this, 1, t, j, e); }, setInt16(t, e) { q(this, 2, t, D, e, arguments.length > 2 ? arguments[2] : void 0); }, setUint16(t, e) { q(this, 2, t, D, e, arguments.length > 2 ? arguments[2] : void 0); }, setInt32(t, e) { q(this, 4, t, N, e, arguments.length > 2 ? arguments[2] : void 0); }, setUint32(t, e) { q(this, 4, t, N, e, arguments.length > 2 ? arguments[2] : void 0); }, setFloat32(t, e) { q(this, 4, t, F, e, arguments.length > 2 ? arguments[2] : void 0); }, setFloat64(t, e) { q(this, 8, t, V, e, arguments.length > 2 ? arguments[2] : void 0); },
      }); 
} _(T, S), _(P, k), t.exports = { ArrayBuffer: T, DataView: P };
    },
    1048(t, e, n) {
      const r = n(7908); const i = n(1400); const o = n(7466); const s = Math.min; t.exports = [].copyWithin || function (t, e) { const n = r(this); const a = o(n.length); let l = i(t, a); let u = i(e, a); const c = arguments.length > 2 ? arguments[2] : void 0; let d = s((void 0 === c ? a : i(c, a)) - u, a - l); let h = 1; for (u < l && l < u + d && (h = -1, u += d - 1, l += d - 1); d-- > 0;)u in n ? n[l] = n[u] : delete n[l], l += h, u += h; return n; };
    },
    1285(t, e, n) {
      const r = n(7908); const i = n(1400); const o = n(7466); t.exports = function (t) { for (var e = r(this), n = o(e.length), s = arguments.length, a = i(s > 1 ? arguments[1] : void 0, n), l = s > 2 ? arguments[2] : void 0, u = void 0 === l ? n : i(l, n); u > a;)e[a++] = t; return e; };
    },
    8533(t, e, n) {
      const r = n(2092).forEach; const i = n(9341)("forEach"); t.exports = i ? [].forEach : function (t) { return r(this, t, arguments.length > 1 ? arguments[1] : void 0); };
    },
    8457(t, e, n) {
      const r = n(9974); const i = n(7908); const o = n(3411); const s = n(7659); const a = n(7466); const l = n(6135); const u = n(1246); t.exports = function (t) { let e; let n; let c; let d; let h; let p; const f = i(t); const m = typeof this === "function" ? this : Array; const g = arguments.length; let v = g > 1 ? arguments[1] : void 0; const y = void 0 !== v; const _ = u(f); let b = 0; if (y && (v = r(v, g > 2 ? arguments[2] : void 0, 2)), _ == null || m == Array && s(_)) for (n = new m(e = a(f.length)); e > b; b++)p = y ? v(f[b], b) : f[b], l(n, b, p); else for (h = (d = _.call(f)).next, n = new m(); !(c = h.call(d)).done; b++)p = y ? o(d, v, [c.value, b], !0) : c.value, l(n, b, p); return n.length = b, n; };
    },
    1318(t, e, n) { const r = n(5656); const i = n(7466); const o = n(1400); const s = function (t) { return function (e, n, s) { let a; const l = r(e); const u = i(l.length); let c = o(s, u); if (t && n != n) { for (;u > c;) if ((a = l[c++]) != a) return !0; } else for (;u > c; c++) if ((t || c in l) && l[c] === n) return t || c || 0; return !t && -1; }; }; t.exports = { includes: s(!0), indexOf: s(!1) }; },
    2092(t, e, n) {
      const r = n(9974); const i = n(8361); const o = n(7908); const s = n(7466); const a = n(5417); const l = [].push; const u = function (t) { const e = t == 1; const n = t == 2; const u = t == 3; const c = t == 4; const d = t == 6; const h = t == 7; const p = t == 5 || d; return function (f, m, g, v) { for (var y, _, b = o(f), w = i(b), x = r(m, g, 3), S = s(w.length), k = 0, C = v || a, E = e ? C(f, S) : n || h ? C(f, 0) : void 0; S > k; k++) if ((p || k in w) && (_ = x(y = w[k], k, b), t)) if (e)E[k] = _; else if (_) switch (t) { case 3: return !0; case 5: return y; case 6: return k; case 2: l.call(E, y); } else switch (t) { case 4: return !1; case 7: l.call(E, y); } return d ? -1 : u || c ? c : E; }; }; t.exports = {
        forEach: u(0), map: u(1), filter: u(2), some: u(3), every: u(4), find: u(5), findIndex: u(6), filterOut: u(7),
      };
    },
    6583(t, e, n) {
      const r = n(5656); const i = n(9958); const o = n(7466); const s = n(9341); const a = Math.min; const l = [].lastIndexOf; const u = !!l && 1 / [1].lastIndexOf(1, -0) < 0; const c = s("lastIndexOf"); const d = u || !c; t.exports = d ? function (t) { if (u) return l.apply(this, arguments) || 0; const e = r(this); const n = o(e.length); let s = n - 1; for (arguments.length > 1 && (s = a(s, i(arguments[1]))), s < 0 && (s = n + s); s >= 0; s--) if (s in e && e[s] === t) return s || 0; return -1; } : l;
    },
    1194(t, e, n) { const r = n(7293); const i = n(5112); const o = n(7392); const s = i("species"); t.exports = function (t) { return o >= 51 || !r((() => { const e = []; return (e.constructor = {})[s] = function () { return { foo: 1 }; }, e[t](Boolean).foo !== 1; })); }; },
    9341(t, e, n) {
      const r = n(7293); t.exports = function (t, e) { const n = [][t]; return !!n && r((() => { n.call(null, e || (() => { throw 1; }), 1); })); };
    },
    3671(t, e, n) { const r = n(3099); const i = n(7908); const o = n(8361); const s = n(7466); const a = function (t) { return function (e, n, a, l) { r(n); const u = i(e); const c = o(u); const d = s(u.length); let h = t ? d - 1 : 0; const p = t ? -1 : 1; if (a < 2) for (;;) { if (h in c) { l = c[h], h += p; break; } if (h += p, t ? h < 0 : d <= h) throw TypeError("Reduce of empty array with no initial value"); } for (;t ? h >= 0 : d > h; h += p)h in c && (l = n(l, c[h], h, u)); return l; }; }; t.exports = { left: a(!1), right: a(!0) }; },
    5417(t, e, n) { const r = n(111); const i = n(3157); const o = n(5112)("species"); t.exports = function (t, e) { let n; return i(t) && (typeof (n = t.constructor) !== "function" || n !== Array && !i(n.prototype) ? r(n) && (n = n[o]) === null && (n = void 0) : n = void 0), new (void 0 === n ? Array : n)(e === 0 ? 0 : e); }; },
    3411(t, e, n) { const r = n(9670); const i = n(9212); t.exports = function (t, e, n, o) { try { return o ? e(r(n)[0], n[1]) : e(n); } catch (e) { throw i(t), e; } }; },
    7072(t, e, n) { const r = n(5112)("iterator"); let i = !1; try { let o = 0; const s = { next() { return { done: !!o++ }; }, return() { i = !0; } }; s[r] = function () { return this; }, Array.from(s, (() => { throw 2; })); } catch (t) {}t.exports = function (t, e) { if (!e && !i) return !1; let n = !1; try { const o = {}; o[r] = function () { return { next() { return { done: n = !0 }; } }; }, t(o); } catch (t) {} return n; }; },
    4326(t) { const e = {}.toString; t.exports = function (t) { return e.call(t).slice(8, -1); }; },
    648(t, e, n) { const r = n(1694); const i = n(4326); const o = n(5112)("toStringTag"); const s = i(function () { return arguments; }()) == "Arguments"; t.exports = r ? i : function (t) { let e; let n; let r; return void 0 === t ? "Undefined" : t === null ? "Null" : typeof (n = (function (t, e) { try { return t[e]; } catch (t) {} }(e = Object(t), o))) === "string" ? n : s ? i(e) : (r = i(e)) == "Object" && typeof e.callee === "function" ? "Arguments" : r; }; },
    9920(t, e, n) { const r = n(6656); const i = n(3887); const o = n(1236); const s = n(3070); t.exports = function (t, e) { for (let n = i(e), a = s.f, l = o.f, u = 0; u < n.length; u++) { const c = n[u]; r(t, c) || a(t, c, l(e, c)); } }; },
    8544(t, e, n) { const r = n(7293); t.exports = !r((() => { function t() {} return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype; })); },
    4994(t, e, n) {
      const r = n(3383).IteratorPrototype; const i = n(30); const o = n(9114); const s = n(8003); const a = n(7497); const l = function () { return this; }; t.exports = function (t, e, n) { const u = `${e} Iterator`; return t.prototype = i(r, { next: o(1, n) }), s(t, u, !1, !0), a[u] = l, t; };
    },
    8880(t, e, n) { const r = n(9781); const i = n(3070); const o = n(9114); t.exports = r ? function (t, e, n) { return i.f(t, e, o(1, n)); } : function (t, e, n) { return t[e] = n, t; }; },
    9114(t) {
      t.exports = function (t, e) {
        return {
          enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e,
        };
      };
    },
    6135(t, e, n) {
      const r = n(7593); const i = n(3070); const o = n(9114); t.exports = function (t, e, n) { const s = r(e); s in t ? i.f(t, s, o(0, n)) : t[s] = n; };
    },
    654(t, e, n) {
      const r = n(2109); const i = n(4994); const o = n(9518); const s = n(7674); const a = n(8003); const l = n(8880); const u = n(1320); const c = n(5112); const d = n(1913); const h = n(7497); const p = n(3383); const f = p.IteratorPrototype; const m = p.BUGGY_SAFARI_ITERATORS; const g = c("iterator"); const v = "keys"; const y = "values"; const _ = "entries"; const b = function () { return this; }; t.exports = function (t, e, n, c, p, w, x) { i(n, e, c); let S; let k; let C; const E = function (t) { if (t === p && M) return M; if (!m && t in O) return O[t]; switch (t) { case v: case y: case _: return function () { return new n(this, t); }; } return function () { return new n(this); }; }; const T = `${e } Iterator`; let P = !1; var O = t.prototype; const A = O[g] || O["@@iterator"] || p && O[p]; var M = !m && A || E(p); const L = e == "Array" && O.entries || A; if (L && (S = o(L.call(new t())), f !== Object.prototype && S.next && (d || o(S) === f || (s ? s(S, f) : typeof S[g] !== "function" && l(S, g, b)), a(S, T, !0, !0), d && (h[T] = b))), p == y && A && A.name !== y && (P = !0, M = function () { return A.call(this); }), d && !x || O[g] === M || l(O, g, M), h[e] = M, p) if (k = { values: E(y), keys: w ? M : E(v), entries: E(_) }, x) for (C in k)(m || P || !(C in O)) && u(O, C, k[C]); else r({ target: e, proto: !0, forced: m || P }, k); return k; };
    },
    9781(t, e, n) { const r = n(7293); t.exports = !r((() => Object.defineProperty({}, 1, { get() { return 7; } })[1] != 7)); },
    317(t, e, n) { const r = n(7854); const i = n(111); const o = r.document; const s = i(o) && i(o.createElement); t.exports = function (t) { return s ? o.createElement(t) : {}; }; },
    8324(t) {
      t.exports = {
        CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0,
      };
    },
    8113(t, e, n) { const r = n(5005); t.exports = r("navigator", "userAgent") || ""; },
    7392(t, e, n) { let r; let i; const o = n(7854); const s = n(8113); const a = o.process; const l = a && a.versions; const u = l && l.v8; u ? i = (r = u.split("."))[0] + r[1] : s && (!(r = s.match(/Edge\/(\d+)/)) || r[1] >= 74) && (r = s.match(/Chrome\/(\d+)/)) && (i = r[1]), t.exports = i && +i; },
    748(t) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]; },
    2109(t, e, n) { const r = n(7854); const i = n(1236).f; const o = n(8880); const s = n(1320); const a = n(3505); const l = n(9920); const u = n(4705); t.exports = function (t, e) { let n; let c; let d; let h; let p; const f = t.target; const m = t.global; const g = t.stat; if (n = m ? r : g ? r[f] || a(f, {}) : (r[f] || {}).prototype) for (c in e) { if (h = e[c], d = t.noTargetGet ? (p = i(n, c)) && p.value : n[c], !u(m ? c : f + (g ? "." : "#") + c, t.forced) && void 0 !== d) { if (typeof h === typeof d) continue; l(h, d); }(t.sham || d && d.sham) && o(h, "sham", !0), s(n, c, h, t); } }; },
    7293(t) { t.exports = function (t) { try { return !!t(); } catch (t) { return !0; } }; },
    7007(t, e, n) {
      n(4916); const r = n(1320); const i = n(7293); const o = n(5112); const s = n(2261); const a = n(8880); const l = o("species"); const u = !i((() => { const t = /./; return t.exec = function () { const t = []; return t.groups = { a: "7" }, t; }, "".replace(t, "$<a>") !== "7"; })); const c = "a".replace(/./, "$0") === "$0"; const d = o("replace"); const h = !!/./[d] && /./[d]("a", "$0") === ""; const p = !i((() => { const t = /(?:)/; const e = t.exec; t.exec = function () { return e.apply(this, arguments); }; const n = "ab".split(t); return n.length !== 2 || n[0] !== "a" || n[1] !== "b"; })); t.exports = function (t, e, n, d) { const f = o(t); const m = !i((() => { const e = {}; return e[f] = function () { return 7; }, ""[t](e) != 7; })); const g = m && !i((() => { let e = !1; let n = /a/; return t === "split" && ((n = {}).constructor = {}, n.constructor[l] = function () { return n; }, n.flags = "", n[f] = /./[f]), n.exec = function () { return e = !0, null; }, n[f](""), !e; })); if (!m || !g || t === "replace" && (!u || !c || h) || t === "split" && !p) { const v = /./[f]; const y = n(f, ""[t], ((t, e, n, r, i) => (e.exec === s ? m && !i ? { done: !0, value: v.call(e, n, r) } : { done: !0, value: t.call(n, e, r) } : { done: !1 })), { REPLACE_KEEPS_$0: c, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: h }); const _ = y[0]; const b = y[1]; r(String.prototype, t, _), r(RegExp.prototype, f, e == 2 ? function (t, e) { return b.call(t, this, e); } : function (t) { return b.call(t, this); }); }d && a(RegExp.prototype[f], "sham", !0); };
    },
    9974(t, e, n) { const r = n(3099); t.exports = function (t, e, n) { if (r(t), void 0 === e) return t; switch (n) { case 0: return function () { return t.call(e); }; case 1: return function (n) { return t.call(e, n); }; case 2: return function (n, r) { return t.call(e, n, r); }; case 3: return function (n, r, i) { return t.call(e, n, r, i); }; } return function () { return t.apply(e, arguments); }; }; },
    5005(t, e, n) { const r = n(857); const i = n(7854); const o = function (t) { return typeof t === "function" ? t : void 0; }; t.exports = function (t, e) { return arguments.length < 2 ? o(r[t]) || o(i[t]) : r[t] && r[t][e] || i[t] && i[t][e]; }; },
    1246(t, e, n) { const r = n(648); const i = n(7497); const o = n(5112)("iterator"); t.exports = function (t) { if (t != null) return t[o] || t["@@iterator"] || i[r(t)]; }; },
    8554(t, e, n) { const r = n(9670); const i = n(1246); t.exports = function (t) { const e = i(t); if (typeof e !== "function") throw TypeError(`${String(t)} is not iterable`); return r(e.call(t)); }; },
    647(t, e, n) { const r = n(7908); const i = Math.floor; const o = "".replace; const s = /\$([$&'`]|\d\d?|<[^>]*>)/g; const a = /\$([$&'`]|\d\d?)/g; t.exports = function (t, e, n, l, u, c) { const d = n + t.length; const h = l.length; let p = a; return void 0 !== u && (u = r(u), p = s), o.call(c, p, ((r, o) => { let s; switch (o.charAt(0)) { case "$": return "$"; case "&": return t; case "`": return e.slice(0, n); case "'": return e.slice(d); case "<": s = u[o.slice(1, -1)]; break; default: var a = +o; if (a === 0) return r; if (a > h) { const c = i(a / 10); return c === 0 ? r : c <= h ? void 0 === l[c - 1] ? o.charAt(1) : l[c - 1] + o.charAt(1) : r; }s = l[a - 1]; } return void 0 === s ? "" : s; })); }; },
    7854(t, e, n) { const r = function (t) { return t && t.Math == Math && t; }; t.exports = r(typeof globalThis === "object" && globalThis) || r(typeof window === "object" && window) || r(typeof self === "object" && self) || r(typeof n.g === "object" && n.g) || (function () { return this; }()) || Function("return this")(); },
    6656(t) { const e = {}.hasOwnProperty; t.exports = function (t, n) { return e.call(t, n); }; },
    3501(t) { t.exports = {}; },
    490(t, e, n) { const r = n(5005); t.exports = r("document", "documentElement"); },
    4664(t, e, n) { const r = n(9781); const i = n(7293); const o = n(317); t.exports = !r && !i((() => Object.defineProperty(o("div"), "a", { get() { return 7; } }).a != 7)); },
    1179(t) { const e = Math.abs; const n = Math.pow; const r = Math.floor; const i = Math.log; const o = Math.LN2; t.exports = { pack(t, s, a) { let l; let u; let c; const d = new Array(a); let h = 8 * a - s - 1; const p = (1 << h) - 1; const f = p >> 1; const m = s === 23 ? 2**-24 - 2**-77 : 0; const g = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; let v = 0; for ((t = e(t)) != t || t === 1 / 0 ? (u = t != t ? 1 : 0, l = p) : (l = r(i(t) / o), t * (c = 2 ** -l) < 1 && (l--, c *= 2), (t += l + f >= 1 ? m / c : m * 2 ** (1 - f)) * c >= 2 && (l++, c /= 2), l + f >= p ? (u = 0, l = p) : l + f >= 1 ? (u = (t * c - 1) * 2 ** s, l += f) : (u = t * 2 ** (f - 1) * 2 ** s, l = 0)); s >= 8; d[v++] = 255 & u, u /= 256, s -= 8);for (l = l << s | u, h += s; h > 0; d[v++] = 255 & l, l /= 256, h -= 8);return d[--v] |= 128 * g, d; }, unpack(t, e) { let r; const i = t.length; const o = 8 * i - e - 1; const s = (1 << o) - 1; const a = s >> 1; let l = o - 7; let u = i - 1; let c = t[u--]; let d = 127 & c; for (c >>= 7; l > 0; d = 256 * d + t[u], u--, l -= 8);for (r = d & (1 << -l) - 1, d >>= -l, l += e; l > 0; r = 256 * r + t[u], u--, l -= 8);if (d === 0)d = 1 - a; else { if (d === s) return r ? NaN : c ? -1 / 0 : 1 / 0; r += 2 ** e, d -= a; } return (c ? -1 : 1) * r * 2 ** (d - e); } }; },
    8361(t, e, n) { const r = n(7293); const i = n(4326); const o = "".split; t.exports = r((() => !Object("z").propertyIsEnumerable(0))) ? function (t) { return i(t) == "String" ? o.call(t, "") : Object(t); } : Object; },
    9587(t, e, n) { const r = n(111); const i = n(7674); t.exports = function (t, e, n) { let o; let s; return i && typeof (o = e.constructor) === "function" && o !== n && r(s = o.prototype) && s !== n.prototype && i(t, s), t; }; },
    2788(t, e, n) { const r = n(5465); const i = Function.toString; typeof r.inspectSource !== "function" && (r.inspectSource = function (t) { return i.call(t); }), t.exports = r.inspectSource; },
    9909(t, e, n) {
      let r; let i; let o; const s = n(8536); const a = n(7854); const l = n(111); const u = n(8880); const c = n(6656); const d = n(5465); const h = n(6200); const p = n(3501); const f = a.WeakMap; if (s) { const m = d.state || (d.state = new f()); const g = m.get; const v = m.has; const y = m.set; r = function (t, e) { return e.facade = t, y.call(m, t, e), e; }, i = function (t) { return g.call(m, t) || {}; }, o = function (t) { return v.call(m, t); }; } else { const _ = h("state"); p[_] = !0, r = function (t, e) { return e.facade = t, u(t, _, e), e; }, i = function (t) { return c(t, _) ? t[_] : {}; }, o = function (t) { return c(t, _); }; }t.exports = {
        set: r, get: i, has: o, enforce(t) { return o(t) ? i(t) : r(t, {}); }, getterFor(t) { return function (e) { let n; if (!l(e) || (n = i(e)).type !== t) throw TypeError(`Incompatible receiver, ${t} required`); return n; }; },
      };
    },
    7659(t, e, n) { const r = n(5112); const i = n(7497); const o = r("iterator"); const s = Array.prototype; t.exports = function (t) { return void 0 !== t && (i.Array === t || s[o] === t); }; },
    3157(t, e, n) { const r = n(4326); t.exports = Array.isArray || function (t) { return r(t) == "Array"; }; },
    4705(t, e, n) { const r = n(7293); const i = /#|\.prototype\./; const o = function (t, e) { const n = a[s(t)]; return n == u || n != l && (typeof e === "function" ? r(e) : !!e); }; var s = o.normalize = function (t) { return String(t).replace(i, ".").toLowerCase(); }; var a = o.data = {}; var l = o.NATIVE = "N"; var u = o.POLYFILL = "P"; t.exports = o; },
    111(t) { t.exports = function (t) { return typeof t === "object" ? t !== null : typeof t === "function"; }; },
    1913(t) { t.exports = !1; },
    7850(t, e, n) { const r = n(111); const i = n(4326); const o = n(5112)("match"); t.exports = function (t) { let e; return r(t) && (void 0 !== (e = t[o]) ? !!e : i(t) == "RegExp"); }; },
    9212(t, e, n) { const r = n(9670); t.exports = function (t) { const e = t.return; if (void 0 !== e) return r(e.call(t)).value; }; },
    3383(t, e, n) {
      let r; let i; let o; const s = n(7293); const a = n(9518); const l = n(8880); const u = n(6656); const c = n(5112); const d = n(1913); const h = c("iterator"); let p = !1; [].keys && ("next" in (o = [].keys()) ? (i = a(a(o))) !== Object.prototype && (r = i) : p = !0); const f = r == null || s((() => { const t = {}; return r[h].call(t) !== t; })); f && (r = {}), d && !f || u(r, h) || l(r, h, (function () { return this; })), t.exports = { IteratorPrototype: r, BUGGY_SAFARI_ITERATORS: p };
    },
    7497(t) { t.exports = {}; },
    133(t, e, n) { const r = n(7293); t.exports = !!Object.getOwnPropertySymbols && !r((() => !String(Symbol()))); },
    590(t, e, n) { const r = n(7293); const i = n(5112); const o = n(1913); const s = i("iterator"); t.exports = !r((() => { const t = new URL("b?a=1&b=2&c=3", "http://a"); const e = t.searchParams; let n = ""; return t.pathname = "c%20d", e.forEach(((t, r) => { e.delete("b"), n += r + t; })), o && !t.toJSON || !e.sort || t.href !== "http://a/c%20d?a=1&c=3" || e.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !e[s] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://").host !== "xn--e1aybc" || new URL("http://a#").hash !== "#%D0%B1" || n !== "a1c3" || new URL("http://x", void 0).host !== "x"; })); },
    8536(t, e, n) { const r = n(7854); const i = n(2788); const o = r.WeakMap; t.exports = typeof o === "function" && /native code/.test(i(o)); },
    1574(t, e, n) {
      const r = n(9781); const i = n(7293); const o = n(1956); const s = n(5181); const a = n(5296); const l = n(7908); const u = n(8361); const c = Object.assign; const d = Object.defineProperty; t.exports = !c || i((() => { if (r && ({ b: 1, ...c(d({}, "a", { enumerable: !0, get() { d(this, "b", { value: 3, enumerable: !1 }); } }), { b: 2 }) }).b !== 1) return !0; const t = {}; const e = {}; const n = Symbol(); const i = "abcdefghijklmnopqrst"; return t[n] = 7, i.split("").forEach(((t) => { e[t] = t; })), ({ ...t })[n] != 7 || o({ ...e }).join("") != i; })) ? function (t, e) { for (var n = l(t), i = arguments.length, c = 1, d = s.f, h = a.f; i > c;) for (var p, f = u(arguments[c++]), m = d ? o(f).concat(d(f)) : o(f), g = m.length, v = 0; g > v;)p = m[v++], r && !h.call(f, p) || (n[p] = f[p]); return n; } : c;
    },
    30(t, e, n) { let r; const i = n(9670); const o = n(6048); const s = n(748); const a = n(3501); const l = n(490); const u = n(317); const c = n(6200)("IE_PROTO"); const d = function () {}; const h = function (t) { return `<script>${ t }<\/script>`; }; var p = function () { try { r = document.domain && new ActiveXObject("htmlfile"); } catch (t) {} let t; let e; p = r ? (function (t) { t.write(h("")), t.close(); const e = t.parentWindow.Object; return t = null, e; }(r)) : ((e = u("iframe")).style.display = "none", l.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(h("document.F=Object")), t.close(), t.F); for (let n = s.length; n--;) delete p.prototype[s[n]]; return p(); }; a[c] = !0, t.exports = Object.create || function (t, e) { let n; return t !== null ? (d.prototype = i(t), n = new d(), d.prototype = null, n[c] = t) : n = p(), void 0 === e ? n : o(n, e); }; },
    6048(t, e, n) { const r = n(9781); const i = n(3070); const o = n(9670); const s = n(1956); t.exports = r ? Object.defineProperties : function (t, e) { o(t); for (var n, r = s(e), a = r.length, l = 0; a > l;)i.f(t, n = r[l++], e[n]); return t; }; },
    3070(t, e, n) { const r = n(9781); const i = n(4664); const o = n(9670); const s = n(7593); const a = Object.defineProperty; e.f = r ? a : function (t, e, n) { if (o(t), e = s(e, !0), o(n), i) try { return a(t, e, n); } catch (t) {} if ("get" in n || "set" in n) throw TypeError("Accessors not supported"); return "value" in n && (t[e] = n.value), t; }; },
    1236(t, e, n) { const r = n(9781); const i = n(5296); const o = n(9114); const s = n(5656); const a = n(7593); const l = n(6656); const u = n(4664); const c = Object.getOwnPropertyDescriptor; e.f = r ? c : function (t, e) { if (t = s(t), e = a(e, !0), u) try { return c(t, e); } catch (t) {} if (l(t, e)) return o(!i.f.call(t, e), t[e]); }; },
    8006(t, e, n) { const r = n(6324); const i = n(748).concat("length", "prototype"); e.f = Object.getOwnPropertyNames || function (t) { return r(t, i); }; },
    5181(t, e) { e.f = Object.getOwnPropertySymbols; },
    9518(t, e, n) { const r = n(6656); const i = n(7908); const o = n(6200); const s = n(8544); const a = o("IE_PROTO"); const l = Object.prototype; t.exports = s ? Object.getPrototypeOf : function (t) { return t = i(t), r(t, a) ? t[a] : typeof t.constructor === "function" && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? l : null; }; },
    6324(t, e, n) { const r = n(6656); const i = n(5656); const o = n(1318).indexOf; const s = n(3501); t.exports = function (t, e) { let n; const a = i(t); let l = 0; const u = []; for (n in a)!r(s, n) && r(a, n) && u.push(n); for (;e.length > l;)r(a, n = e[l++]) && (~o(u, n) || u.push(n)); return u; }; },
    1956(t, e, n) { const r = n(6324); const i = n(748); t.exports = Object.keys || function (t) { return r(t, i); }; },
    5296(t, e) {
      const n = {}.propertyIsEnumerable; const r = Object.getOwnPropertyDescriptor; const i = r && !n.call({ 1: 2 }, 1); e.f = i ? function (t) { const e = r(this, t); return !!e && e.enumerable; } : n;
    },
    7674(t, e, n) { const r = n(9670); const i = n(6077); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function () { let t; let e = !1; const n = {}; try { (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), e = n instanceof Array; } catch (t) {} return function (n, o) { return r(n), i(o), e ? t.call(n, o) : n.__proto__ = o, n; }; }()) : void 0); },
    288(t, e, n) {
      const r = n(1694); const i = n(648); t.exports = r ? {}.toString : function () { return `[object ${i(this)}]`; };
    },
    3887(t, e, n) { const r = n(5005); const i = n(8006); const o = n(5181); const s = n(9670); t.exports = r("Reflect", "ownKeys") || function (t) { const e = i.f(s(t)); const n = o.f; return n ? e.concat(n(t)) : e; }; },
    857(t, e, n) { const r = n(7854); t.exports = r; },
    2248(t, e, n) { const r = n(1320); t.exports = function (t, e, n) { for (const i in e)r(t, i, e[i], n); return t; }; },
    1320(t, e, n) { const r = n(7854); const i = n(8880); const o = n(6656); const s = n(3505); const a = n(2788); const l = n(9909); const u = l.get; const c = l.enforce; const d = String(String).split("String"); (t.exports = function (t, e, n, a) { let l; const u = !!a && !!a.unsafe; let h = !!a && !!a.enumerable; const p = !!a && !!a.noTargetGet; typeof n === "function" && (typeof e !== "string" || o(n, "name") || i(n, "name", e), (l = c(n)).source || (l.source = d.join(typeof e === "string" ? e : ""))), t !== r ? (u ? !p && t[e] && (h = !0) : delete t[e], h ? t[e] = n : i(t, e, n)) : h ? t[e] = n : s(e, n); })(Function.prototype, "toString", (function () { return typeof this === "function" && u(this).source || a(this); })); },
    7651(t, e, n) { const r = n(4326); const i = n(2261); t.exports = function (t, e) { const n = t.exec; if (typeof n === "function") { const o = n.call(t, e); if (typeof o !== "object") throw TypeError("RegExp exec method returned something other than an Object or null"); return o; } if (r(t) !== "RegExp") throw TypeError("RegExp#exec called on incompatible receiver"); return i.call(t, e); }; },
    2261(t, e, n) {
      let r; let i; const o = n(7066); const s = n(2999); const a = RegExp.prototype.exec; const l = String.prototype.replace; let u = a; const c = (r = /a/, i = /b*/g, a.call(r, "a"), a.call(i, "a"), r.lastIndex !== 0 || i.lastIndex !== 0); const d = s.UNSUPPORTED_Y || s.BROKEN_CARET; const h = void 0 !== /()??/.exec("")[1]; (c || h || d) && (u = function (t) { let e; let n; let r; let i; const s = this; const u = d && s.sticky; let p = o.call(s); let f = s.source; let m = 0; let g = t; return u && ((p = p.replace("y", "")).indexOf("g") === -1 && (p += "g"), g = String(t).slice(s.lastIndex), s.lastIndex > 0 && (!s.multiline || s.multiline && t[s.lastIndex - 1] !== "\n") && (f = `(?: ${f})`, g = ` ${g}`, m++), n = new RegExp(`^(?:${f})`, p)), h && (n = new RegExp(`^${f}$(?!\\s)`, p)), c && (e = s.lastIndex), r = a.call(u ? n : s, g), u ? r ? (r.input = r.input.slice(m), r[0] = r[0].slice(m), r.index = s.lastIndex, s.lastIndex += r[0].length) : s.lastIndex = 0 : c && r && (s.lastIndex = s.global ? r.index + r[0].length : e), h && r && r.length > 1 && l.call(r[0], n, (function () { for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (r[i] = void 0); })), r; }), t.exports = u;
    },
    7066(t, e, n) {
      const r = n(9670); t.exports = function () { const t = r(this); let e = ""; return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e; };
    },
    2999(t, e, n) {
      const r = n(7293); function i(t, e) { return RegExp(t, e); }e.UNSUPPORTED_Y = r((() => { const t = i("a", "y"); return t.lastIndex = 2, t.exec("abcd") != null; })), e.BROKEN_CARET = r((() => { const t = i("^r", "gy"); return t.lastIndex = 2, t.exec("str") != null; }));
    },
    4488(t) { t.exports = function (t) { if (t == null) throw TypeError(`Can't call method on ${t}`); return t; }; },
    3505(t, e, n) { const r = n(7854); const i = n(8880); t.exports = function (t, e) { try { i(r, t, e); } catch (n) { r[t] = e; } return e; }; },
    6340(t, e, n) {
      const r = n(5005); const i = n(3070); const o = n(5112); const s = n(9781); const a = o("species"); t.exports = function (t) { const e = r(t); const n = i.f; s && e && !e[a] && n(e, a, { configurable: !0, get() { return this; } }); };
    },
    8003(t, e, n) { const r = n(3070).f; const i = n(6656); const o = n(5112)("toStringTag"); t.exports = function (t, e, n) { t && !i(t = n ? t : t.prototype, o) && r(t, o, { configurable: !0, value: e }); }; },
    6200(t, e, n) { const r = n(2309); const i = n(9711); const o = r("keys"); t.exports = function (t) { return o[t] || (o[t] = i(t)); }; },
    5465(t, e, n) { const r = n(7854); const i = n(3505); const o = "__core-js_shared__"; const s = r[o] || i(o, {}); t.exports = s; },
    2309(t, e, n) { const r = n(1913); const i = n(5465); (t.exports = function (t, e) { return i[t] || (i[t] = void 0 !== e ? e : {}); })("versions", []).push({ version: "3.9.0", mode: r ? "pure" : "global", copyright: " 2021 Denis Pushkarev (zloirock.ru)" }); },
    6707(t, e, n) { const r = n(9670); const i = n(3099); const o = n(5112)("species"); t.exports = function (t, e) { let n; const s = r(t).constructor; return void 0 === s || (n = r(s)[o]) == null ? e : i(n); }; },
    8710(t, e, n) { const r = n(9958); const i = n(4488); const o = function (t) { return function (e, n) { let o; let s; const a = String(i(e)); const l = r(n); const u = a.length; return l < 0 || l >= u ? t ? "" : void 0 : (o = a.charCodeAt(l)) < 55296 || o > 56319 || l + 1 === u || (s = a.charCodeAt(l + 1)) < 56320 || s > 57343 ? t ? a.charAt(l) : o : t ? a.slice(l, l + 2) : s - 56320 + (o - 55296 << 10) + 65536; }; }; t.exports = { codeAt: o(!1), charAt: o(!0) }; },
    3197(t) {
      const e = 2147483647; const n = /[^\0-\u007E]/; const r = /[.\u3002\uFF0E\uFF61]/g; const i = "Overflow: input needs wider integers to process"; const o = Math.floor; const s = String.fromCharCode; const a = function (t) { return t + 22 + 75 * (t < 26); }; const l = function (t, e, n) { let r = 0; for (t = n ? o(t / 700) : t >> 1, t += o(t / e); t > 455; r += 36)t = o(t / 35); return o(r + 36 * t / (t + 38)); }; const u = function (t) { let n; let r; const u = []; const c = (t = (function (t) { for (var e = [], n = 0, r = t.length; n < r;) { var i = t.charCodeAt(n++); if (i >= 55296 && i <= 56319 && n < r) { var o = t.charCodeAt(n++); 56320 == (64512 & o) ? e.push(((1023 & i) << 10) + (1023 & o) + 65536) : (e.push(i), n--) } else e.push(i) } return e }(t))).length; let d = 128; let h = 0; let p = 72; for (n = 0; n < t.length; n++)(r = t[n]) < 128 && u.push(s(r)); const f = u.length; let m = f; for (f && u.push("-"); m < c;) { let g = e; for (n = 0; n < t.length; n++)(r = t[n]) >= d && r < g && (g = r); const v = m + 1; if (g - d > o((e - h) / v)) throw RangeError(i); for (h += (g - d) * v, d = g, n = 0; n < t.length; n++) { if ((r = t[n]) < d && ++h > e) throw RangeError(i); if (r == d) { for (var y = h, _ = 36; ;_ += 36) { const b = _ <= p ? 1 : _ >= p + 26 ? 26 : _ - p; if (y < b) break; const w = y - b; const x = 36 - b; u.push(s(a(b + w % x))), y = o(w / x); }u.push(s(a(y))), p = l(h, v, m == f), h = 0, ++m; } }++h, ++d; } return u.join(""); }; t.exports = function (t) { let e; let i; const o = []; const s = t.toLowerCase().replace(r, ".").split("."); for (e = 0; e < s.length; e++)i = s[e], o.push(n.test(i) ? `xn--${u(i)}` : i); return o.join("."); };
    },
    6091(t, e, n) { const r = n(7293); const i = n(1361); t.exports = function (t) { return r((() => !!i[t]() || ""[t]() != "" || i[t].name !== t)); }; },
    3111(t, e, n) { const r = n(4488); const i = `[${ n(1361) }]`; const o = RegExp(`^${i}${i}*`); const s = RegExp(`${i + i}*$`); const a = function (t) { return function (e) { let n = String(r(e)); return 1 & t && (n = n.replace(o, "")), 2 & t && (n = n.replace(s, "")), n; }; }; t.exports = { start: a(1), end: a(2), trim: a(3) }; },
    1400(t, e, n) { const r = n(9958); const i = Math.max; const o = Math.min; t.exports = function (t, e) { const n = r(t); return n < 0 ? i(n + e, 0) : o(n, e); }; },
    7067(t, e, n) { const r = n(9958); const i = n(7466); t.exports = function (t) { if (void 0 === t) return 0; const e = r(t); const n = i(e); if (e !== n) throw RangeError("Wrong length or index"); return n; }; },
    5656(t, e, n) { const r = n(8361); const i = n(4488); t.exports = function (t) { return r(i(t)); }; },
    9958(t) { const e = Math.ceil; const n = Math.floor; t.exports = function (t) { return isNaN(t = +t) ? 0 : (t > 0 ? n : e)(t); }; },
    7466(t, e, n) { const r = n(9958); const i = Math.min; t.exports = function (t) { return t > 0 ? i(r(t), 9007199254740991) : 0; }; },
    7908(t, e, n) { const r = n(4488); t.exports = function (t) { return Object(r(t)); }; },
    4590(t, e, n) { const r = n(3002); t.exports = function (t, e) { const n = r(t); if (n % e) throw RangeError("Wrong offset"); return n; }; },
    3002(t, e, n) { const r = n(9958); t.exports = function (t) { const e = r(t); if (e < 0) throw RangeError("The argument can't be less than 0"); return e; }; },
    7593(t, e, n) { const r = n(111); t.exports = function (t, e) { if (!r(t)) return t; let n; let i; if (e && typeof (n = t.toString) === "function" && !r(i = n.call(t))) return i; if (typeof (n = t.valueOf) === "function" && !r(i = n.call(t))) return i; if (!e && typeof (n = t.toString) === "function" && !r(i = n.call(t))) return i; throw TypeError("Can't convert object to primitive value"); }; },
    1694(t, e, n) { const r = {}; r[n(5112)("toStringTag")] = "z", t.exports = String(r) === "[object z]"; },
    9843(t, e, n) {
      const r = n(2109); const i = n(7854); const o = n(9781); const s = n(3832); const a = n(260); const l = n(3331); const u = n(5787); const c = n(9114); const d = n(8880); const h = n(7466); const p = n(7067); const f = n(4590); const m = n(7593); const g = n(6656); const v = n(648); const y = n(111); const _ = n(30); const b = n(7674); const w = n(8006).f; const x = n(7321); const S = n(2092).forEach; const k = n(6340); const C = n(3070); const E = n(1236); const T = n(9909); const P = n(9587); const O = T.get; const A = T.set; const M = C.f; const L = E.f; const I = Math.round; const j = i.RangeError; const D = l.ArrayBuffer; const N = l.DataView; const R = a.NATIVE_ARRAY_BUFFER_VIEWS; const F = a.TYPED_ARRAY_TAG; const V = a.TypedArray; const z = a.TypedArrayPrototype; const B = a.aTypedArrayConstructor; const q = a.isTypedArray; const H = "BYTES_PER_ELEMENT"; const $ = "Wrong length"; const U = function (t, e) { for (var n = 0, r = e.length, i = new (B(t))(r); r > n;)i[n] = e[n++]; return i; }; const W = function (t, e) { M(t, e, { get() { return O(this)[e]; } }); }; const G = function (t) { let e; return t instanceof D || (e = v(t)) == "ArrayBuffer" || e == "SharedArrayBuffer"; }; const Y = function (t, e) { return q(t) && typeof e !== "symbol" && e in t && String(+e) == String(e); }; const Z = function (t, e) { return Y(t, e = m(e, !0)) ? c(2, t[e]) : L(t, e); }; const K = function (t, e, n) { return !(Y(t, e = m(e, !0)) && y(n) && g(n, "value")) || g(n, "get") || g(n, "set") || n.configurable || g(n, "writable") && !n.writable || g(n, "enumerable") && !n.enumerable ? M(t, e, n) : (t[e] = n.value, t); }; o ? (R || (E.f = Z, C.f = K, W(z, "buffer"), W(z, "byteOffset"), W(z, "byteLength"), W(z, "length")), r({ target: "Object", stat: !0, forced: !R }, { getOwnPropertyDescriptor: Z, defineProperty: K }), t.exports = function (t, e, n) {
        const o = t.match(/\d+$/)[0] / 8; const a = `${t + (n ? "Clamped" : "") }Array`; const l = `get${ t}`; const c = `set${ t}`; const m = i[a]; let g = m; let v = g && g.prototype; const C = {}; const E = function (t, e) { M(t, e, { get() { return (function (t, e) { let n = O(t); return n.view[l](e * o + n.byteOffset, !0); }(this, e)); }, set(t) { return (function (t, e, r) { let i = O(t); n && (r = (r = I(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r), i.view[c](e * o + i.byteOffset, r, !0); }(this, e, t)); }, enumerable: !0 }); }; R ? s && (g = e(((t, e, n, r) => (u(t, g, a), P(y(e) ? G(e) ? void 0 !== r ? new m(e, f(n, o), r) : void 0 !== n ? new m(e, f(n, o)) : new m(e) : q(e) ? U(g, e) : x.call(g, e) : new m(p(e)), t, g)))), b && b(g, V), S(w(m), ((t) => { t in g || d(g, t, m[t]); })), g.prototype = v) : (g = e(((t, e, n, r) => {
          u(t, g, a); let i; let s; let l; let c = 0; let d = 0; if (y(e)) { if (!G(e)) return q(e) ? U(g, e) : x.call(g, e); i = e, d = f(n, o); const m = e.byteLength; if (void 0 === r) { if (m % o) throw j($); if ((s = m - d) < 0) throw j($); } else if ((s = h(r) * o) + d > m) throw j($); l = s / o; } else l = p(e), i = new D(s = l * o); for (A(t, {
            buffer: i, byteOffset: d, byteLength: s, length: l, view: new N(i),
          }); c < l;)E(t, c++);
        })), b && b(g, V), v = g.prototype = _(z)), v.constructor !== g && d(v, "constructor", g), F && d(v, F, a), C[a] = g, r({ global: !0, forced: g != m, sham: !R }, C), H in g || d(g, H, o), H in v || d(v, H, o), k(a);
      }) : t.exports = function () {};
    },
    3832(t, e, n) { const r = n(7854); const i = n(7293); const o = n(7072); const s = n(260).NATIVE_ARRAY_BUFFER_VIEWS; const a = r.ArrayBuffer; const l = r.Int8Array; t.exports = !s || !i((() => { l(1); })) || !i((() => { new l(-1); })) || !o(((t) => { new l(), new l(null), new l(1.5), new l(t); }), !0) || i((() => new l(new a(2), 1, void 0).length !== 1)); },
    3074(t, e, n) { const r = n(260).aTypedArrayConstructor; const i = n(6707); t.exports = function (t, e) { for (var n = i(t, t.constructor), o = 0, s = e.length, a = new (r(n))(s); s > o;)a[o] = e[o++]; return a; }; },
    7321(t, e, n) { const r = n(7908); const i = n(7466); const o = n(1246); const s = n(7659); const a = n(9974); const l = n(260).aTypedArrayConstructor; t.exports = function (t) { let e; let n; let u; let c; let d; let h; let p = r(t); const f = arguments.length; let m = f > 1 ? arguments[1] : void 0; const g = void 0 !== m; const v = o(p); if (v != null && !s(v)) for (h = (d = v.call(p)).next, p = []; !(c = h.call(d)).done;)p.push(c.value); for (g && f > 2 && (m = a(m, arguments[2], 2)), n = i(p.length), u = new (l(this))(n), e = 0; n > e; e++)u[e] = g ? m(p[e], e) : p[e]; return u; }; },
    9711(t) { let e = 0; const n = Math.random(); t.exports = function (t) { return `Symbol(${String(void 0 === t ? "" : t)})_${(++e + n).toString(36)}`; }; },
    3307(t, e, n) { const r = n(133); t.exports = r && !Symbol.sham && typeof Symbol.iterator === "symbol"; },
    5112(t, e, n) { const r = n(7854); const i = n(2309); const o = n(6656); const s = n(9711); const a = n(133); const l = n(3307); const u = i("wks"); const c = r.Symbol; const d = l ? c : c && c.withoutSetter || s; t.exports = function (t) { return o(u, t) || (a && o(c, t) ? u[t] = c[t] : u[t] = d(`Symbol.${t}`)), u[t]; }; },
    1361(t) { t.exports = "\t\n\v\f\r \u2028\u2029\ufeff"; },
    8264(t, e, n) {
      const r = n(2109); const i = n(7854); const o = n(3331); const s = n(6340); const a = o.ArrayBuffer; r({ global: !0, forced: i.ArrayBuffer !== a }, { ArrayBuffer: a }), s("ArrayBuffer");
    },
    2222(t, e, n) {
      const r = n(2109); const i = n(7293); const o = n(3157); const s = n(111); const a = n(7908); const l = n(7466); const u = n(6135); const c = n(5417); const d = n(1194); const h = n(5112); const p = n(7392); const f = h("isConcatSpreadable"); const m = 9007199254740991; const g = "Maximum allowed index exceeded"; const v = p >= 51 || !i((() => { const t = []; return t[f] = !1, t.concat()[0] !== t; })); const y = d("concat"); const _ = function (t) { if (!s(t)) return !1; const e = t[f]; return void 0 !== e ? !!e : o(t); }; r({ target: "Array", proto: !0, forced: !v || !y }, { concat(t) { let e; let n; let r; let i; let o; const s = a(this); const d = c(s, 0); let h = 0; for (e = -1, r = arguments.length; e < r; e++) if (_(o = e === -1 ? s : arguments[e])) { if (h + (i = l(o.length)) > m) throw TypeError(g); for (n = 0; n < i; n++, h++)n in o && u(d, h, o[n]); } else { if (h >= m) throw TypeError(g); u(d, h++, o); } return d.length = h, d; } });
    },
    7327(t, e, n) {
      const r = n(2109); const i = n(2092).filter; r({ target: "Array", proto: !0, forced: !n(1194)("filter") }, { filter(t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0); } });
    },
    2772(t, e, n) {
      const r = n(2109); const i = n(1318).indexOf; const o = n(9341); const s = [].indexOf; const a = !!s && 1 / [1].indexOf(1, -0) < 0; const l = o("indexOf"); r({ target: "Array", proto: !0, forced: a || !l }, { indexOf(t) { return a ? s.apply(this, arguments) || 0 : i(this, t, arguments.length > 1 ? arguments[1] : void 0); } });
    },
    6992(t, e, n) {
      const r = n(5656); const i = n(1223); const o = n(7497); const s = n(9909); const a = n(654); const l = "Array Iterator"; const u = s.set; const c = s.getterFor(l); t.exports = a(Array, "Array", (function (t, e) {
        u(this, {
          type: l, target: r(t), index: 0, kind: e,
        });
      }), (function () { const t = c(this); const e = t.target; const n = t.kind; const r = t.index++; return !e || r >= e.length ? (t.target = void 0, { value: void 0, done: !0 }) : n == "keys" ? { value: r, done: !1 } : n == "values" ? { value: e[r], done: !1 } : { value: [r, e[r]], done: !1 }; }), "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries");
    },
    1249(t, e, n) {
      const r = n(2109); const i = n(2092).map; r({ target: "Array", proto: !0, forced: !n(1194)("map") }, { map(t) { return i(this, t, arguments.length > 1 ? arguments[1] : void 0); } });
    },
    7042(t, e, n) {
      const r = n(2109); const i = n(111); const o = n(3157); const s = n(1400); const a = n(7466); const l = n(5656); const u = n(6135); const c = n(5112); const d = n(1194)("slice"); const h = c("species"); const p = [].slice; const f = Math.max; r({ target: "Array", proto: !0, forced: !d }, { slice(t, e) { let n; let r; let c; const d = l(this); const m = a(d.length); let g = s(t, m); const v = s(void 0 === e ? m : e, m); if (o(d) && (typeof (n = d.constructor) !== "function" || n !== Array && !o(n.prototype) ? i(n) && (n = n[h]) === null && (n = void 0) : n = void 0, n === Array || void 0 === n)) return p.call(d, g, v); for (r = new (void 0 === n ? Array : n)(f(v - g, 0)), c = 0; g < v; g++, c++)g in d && u(r, c, d[g]); return r.length = c, r; } });
    },
    561(t, e, n) {
      const r = n(2109); const i = n(1400); const o = n(9958); const s = n(7466); const a = n(7908); const l = n(5417); const u = n(6135); const c = n(1194)("splice"); const d = Math.max; const h = Math.min; const p = 9007199254740991; const f = "Maximum allowed length exceeded"; r({ target: "Array", proto: !0, forced: !c }, { splice(t, e) { let n; let r; let c; let m; let g; let v; const y = a(this); const _ = s(y.length); const b = i(t, _); const w = arguments.length; if (w === 0 ? n = r = 0 : w === 1 ? (n = 0, r = _ - b) : (n = w - 2, r = h(d(o(e), 0), _ - b)), _ + n - r > p) throw TypeError(f); for (c = l(y, r), m = 0; m < r; m++)(g = b + m) in y && u(c, m, y[g]); if (c.length = r, n < r) { for (m = b; m < _ - r; m++)v = m + n, (g = m + r) in y ? y[v] = y[g] : delete y[v]; for (m = _; m > _ - r + n; m--) delete y[m - 1]; } else if (n > r) for (m = _ - r; m > b; m--)v = m + n - 1, (g = m + r - 1) in y ? y[v] = y[g] : delete y[v]; for (m = 0; m < n; m++)y[m + b] = arguments[m + 2]; return y.length = _ - r + n, c; } });
    },
    8309(t, e, n) { const r = n(9781); const i = n(3070).f; const o = Function.prototype; const s = o.toString; const a = /^\s*function ([^ (]*)/; const l = "name"; r && !(l in o) && i(o, l, { configurable: !0, get() { try { return s.call(this).match(a)[1]; } catch (t) { return ""; } } }); },
    489(t, e, n) {
      const r = n(2109); const i = n(7293); const o = n(7908); const s = n(9518); const a = n(8544); r({
        target: "Object", stat: !0, forced: i((() => { s(1); })), sham: !a,
      }, { getPrototypeOf(t) { return s(o(t)); } });
    },
    1539(t, e, n) { const r = n(1694); const i = n(1320); const o = n(288); r || i(Object.prototype, "toString", o, { unsafe: !0 }); },
    4916(t, e, n) {
      const r = n(2109); const i = n(2261); r({ target: "RegExp", proto: !0, forced: /./.exec !== i }, { exec: i });
    },
    9714(t, e, n) {
      const r = n(1320); const i = n(9670); const o = n(7293); const s = n(7066); const a = "toString"; const l = RegExp.prototype; const u = l.toString; const c = o((() => u.call({ source: "a", flags: "b" }) != "/a/b")); const d = u.name != a; (c || d) && r(RegExp.prototype, a, (function () { const t = i(this); const e = String(t.source); const n = t.flags; return `/${e}/${String(void 0 === n && t instanceof RegExp && !("flags" in l) ? s.call(t) : n)}`; }), { unsafe: !0 });
    },
    8783(t, e, n) {
      const r = n(8710).charAt; const i = n(9909); const o = n(654); const s = "String Iterator"; const a = i.set; const l = i.getterFor(s); o(String, "String", (function (t) { a(this, { type: s, string: String(t), index: 0 }); }), (function () { let t; const e = l(this); const n = e.string; const i = e.index; return i >= n.length ? { value: void 0, done: !0 } : (t = r(n, i), e.index += t.length, { value: t, done: !1 }); }));
    },
    4723(t, e, n) {
      const r = n(7007); const i = n(9670); const o = n(7466); const s = n(4488); const a = n(1530); const l = n(7651); r("match", 1, ((t, e, n) => [function (e) { const n = s(this); const r = e == null ? void 0 : e[t]; return void 0 !== r ? r.call(e, n) : new RegExp(e)[t](String(n)); }, function (t) { const r = n(e, t, this); if (r.done) return r.value; const s = i(t); const u = String(this); if (!s.global) return l(s, u); const c = s.unicode; s.lastIndex = 0; for (var d, h = [], p = 0; (d = l(s, u)) !== null;) { const f = String(d[0]); h[p] = f, f === "" && (s.lastIndex = a(u, o(s.lastIndex), c)), p++; } return p === 0 ? null : h; }]));
    },
    5306(t, e, n) {
      const r = n(7007); const i = n(9670); const o = n(7466); const s = n(9958); const a = n(4488); const l = n(1530); const u = n(647); const c = n(7651); const d = Math.max; const h = Math.min; r("replace", 2, ((t, e, n, r) => { const p = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE; const f = r.REPLACE_KEEPS_$0; const m = p ? "$" : "$0"; return [function (n, r) { const i = a(this); const o = n == null ? void 0 : n[t]; return void 0 !== o ? o.call(n, i, r) : e.call(String(i), n, r); }, function (t, r) { if (!p && f || typeof r === "string" && r.indexOf(m) === -1) { const a = n(e, t, this, r); if (a.done) return a.value; } const g = i(t); const v = String(this); const y = typeof r === "function"; y || (r = String(r)); const _ = g.global; if (_) { var b = g.unicode; g.lastIndex = 0; } for (var w = []; ;) { var x = c(g, v); if (x === null) break; if (w.push(x), !_) break; String(x[0]) === "" && (g.lastIndex = l(v, o(g.lastIndex), b)); } for (var S, k = "", C = 0, E = 0; E < w.length; E++) { x = w[E]; for (var T = String(x[0]), P = d(h(s(x.index), v.length), 0), O = [], A = 1; A < x.length; A++)O.push(void 0 === (S = x[A]) ? S : String(S)); const M = x.groups; if (y) { const L = [T].concat(O, P, v); void 0 !== M && L.push(M); var I = String(r.apply(void 0, L)); } else I = u(T, v, P, O, M, r); P >= C && (k += v.slice(C, P) + I, C = P + T.length); } return k + v.slice(C); }]; }));
    },
    3123(t, e, n) {
      const r = n(7007); const i = n(7850); const o = n(9670); const s = n(4488); const a = n(6707); const l = n(1530); const u = n(7466); const c = n(7651); const d = n(2261); const h = n(7293); const p = [].push; const f = Math.min; const m = 4294967295; const g = !h((() => !RegExp(m, "y"))); r("split", 2, ((t, e, n) => { let r; return r = "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (t, n) { const r = String(s(this)); const o = void 0 === n ? m : n >>> 0; if (o === 0) return []; if (void 0 === t) return [r]; if (!i(t)) return e.call(r, t, o); for (var a, l, u, c = [], h = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), f = 0, g = new RegExp(t.source, `${h}g`); (a = d.call(g, r)) && !((l = g.lastIndex) > f && (c.push(r.slice(f, a.index)), a.length > 1 && a.index < r.length && p.apply(c, a.slice(1)), u = a[0].length, f = l, c.length >= o));)g.lastIndex === a.index && g.lastIndex++; return f === r.length ? !u && g.test("") || c.push("") : c.push(r.slice(f)), c.length > o ? c.slice(0, o) : c; } : "0".split(void 0, 0).length ? function (t, n) { return void 0 === t && n === 0 ? [] : e.call(this, t, n); } : e, [function (e, n) { const i = s(this); const o = e == null ? void 0 : e[t]; return void 0 !== o ? o.call(e, i, n) : r.call(String(i), e, n); }, function (t, i) { const s = n(r, t, this, i, r !== e); if (s.done) return s.value; const d = o(t); const h = String(this); const p = a(d, RegExp); const v = d.unicode; const y = (d.ignoreCase ? "i" : "") + (d.multiline ? "m" : "") + (d.unicode ? "u" : "") + (g ? "y" : "g"); const _ = new p(g ? d : `^(?:${ d.source })`, y); const b = void 0 === i ? m : i >>> 0; if (b === 0) return []; if (h.length === 0) return c(_, h) === null ? [h] : []; for (var w = 0, x = 0, S = []; x < h.length;) { _.lastIndex = g ? x : 0; var k; const C = c(_, g ? h : h.slice(x)); if (C === null || (k = f(u(_.lastIndex + (g ? 0 : x)), h.length)) === w)x = l(h, x, v); else { if (S.push(h.slice(w, x)), S.length === b) return S; for (let E = 1; E <= C.length - 1; E++) if (S.push(C[E]), S.length === b) return S; x = w = k; } } return S.push(h.slice(w)), S; }]; }), !g);
    },
    3210(t, e, n) {
      const r = n(2109); const i = n(3111).trim; r({ target: "String", proto: !0, forced: n(6091)("trim") }, { trim() { return i(this); } });
    },
    2990(t, e, n) {
      const r = n(260); const i = n(1048); const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("copyWithin", (function (t, e) { return i.call(o(this), t, e, arguments.length > 2 ? arguments[2] : void 0); }));
    },
    8927(t, e, n) {
      const r = n(260); const i = n(2092).every; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("every", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    3105(t, e, n) {
      const r = n(260); const i = n(1285); const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("fill", (function (t) { return i.apply(o(this), arguments); }));
    },
    5035(t, e, n) {
      const r = n(260); const i = n(2092).filter; const o = n(3074); const s = r.aTypedArray; (0, r.exportTypedArrayMethod)("filter", (function (t) { const e = i(s(this), t, arguments.length > 1 ? arguments[1] : void 0); return o(this, e); }));
    },
    7174(t, e, n) {
      const r = n(260); const i = n(2092).findIndex; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("findIndex", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    4345(t, e, n) {
      const r = n(260); const i = n(2092).find; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("find", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    2846(t, e, n) {
      const r = n(260); const i = n(2092).forEach; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("forEach", (function (t) { i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    4731(t, e, n) {
      const r = n(260); const i = n(1318).includes; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("includes", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    7209(t, e, n) {
      const r = n(260); const i = n(1318).indexOf; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("indexOf", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    6319(t, e, n) {
      const r = n(7854); const i = n(260); const o = n(6992); const s = n(5112)("iterator"); const a = r.Uint8Array; const l = o.values; const u = o.keys; const c = o.entries; const d = i.aTypedArray; const h = i.exportTypedArrayMethod; const p = a && a.prototype[s]; const f = !!p && (p.name == "values" || p.name == null); const m = function () { return l.call(d(this)); }; h("entries", (function () { return c.call(d(this)); })), h("keys", (function () { return u.call(d(this)); })), h("values", m, !f), h(s, m, !f);
    },
    8867(t, e, n) {
      const r = n(260); const i = r.aTypedArray; const o = r.exportTypedArrayMethod; const s = [].join; o("join", (function (t) { return s.apply(i(this), arguments); }));
    },
    7789(t, e, n) {
      const r = n(260); const i = n(6583); const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("lastIndexOf", (function (t) { return i.apply(o(this), arguments); }));
    },
    3739(t, e, n) {
      const r = n(260); const i = n(2092).map; const o = n(6707); const s = r.aTypedArray; const a = r.aTypedArrayConstructor; (0, r.exportTypedArrayMethod)("map", (function (t) { return i(s(this), t, arguments.length > 1 ? arguments[1] : void 0, ((t, e) => new (a(o(t, t.constructor)))(e))); }));
    },
    4483(t, e, n) {
      const r = n(260); const i = n(3671).right; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("reduceRight", (function (t) { return i(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    9368(t, e, n) {
      const r = n(260); const i = n(3671).left; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("reduce", (function (t) { return i(o(this), t, arguments.length, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    2056(t, e, n) {
      const r = n(260); const i = r.aTypedArray; const o = r.exportTypedArrayMethod; const s = Math.floor; o("reverse", (function () { for (var t, e = this, n = i(e).length, r = s(n / 2), o = 0; o < r;)t = e[o], e[o++] = e[--n], e[n] = t; return e; }));
    },
    3462(t, e, n) {
      const r = n(260); const i = n(7466); const o = n(4590); const s = n(7908); const a = n(7293); const l = r.aTypedArray; (0, r.exportTypedArrayMethod)("set", (function (t) { l(this); const e = o(arguments.length > 1 ? arguments[1] : void 0, 1); const n = this.length; const r = s(t); const a = i(r.length); let u = 0; if (a + e > n) throw RangeError("Wrong length"); for (;u < a;) this[e + u] = r[u++]; }), a((() => { new Int8Array(1).set({}); })));
    },
    678(t, e, n) {
      const r = n(260); const i = n(6707); const o = n(7293); const s = r.aTypedArray; const a = r.aTypedArrayConstructor; const l = r.exportTypedArrayMethod; const u = [].slice; l("slice", (function (t, e) { for (var n = u.call(s(this), t, e), r = i(this, this.constructor), o = 0, l = n.length, c = new (a(r))(l); l > o;)c[o] = n[o++]; return c; }), o((() => { new Int8Array(1).slice(); })));
    },
    7462(t, e, n) {
      const r = n(260); const i = n(2092).some; const o = r.aTypedArray; (0, r.exportTypedArrayMethod)("some", (function (t) { return i(o(this), t, arguments.length > 1 ? arguments[1] : void 0); }));
    },
    3824(t, e, n) {
      const r = n(260); const i = r.aTypedArray; const o = r.exportTypedArrayMethod; const s = [].sort; o("sort", (function (t) { return s.call(i(this), t); }));
    },
    5021(t, e, n) {
      const r = n(260); const i = n(7466); const o = n(1400); const s = n(6707); const a = r.aTypedArray; (0, r.exportTypedArrayMethod)("subarray", (function (t, e) { const n = a(this); const r = n.length; const l = o(t, r); return new (s(n, n.constructor))(n.buffer, n.byteOffset + l * n.BYTES_PER_ELEMENT, i((void 0 === e ? r : o(e, r)) - l)); }));
    },
    2974(t, e, n) {
      const r = n(7854); const i = n(260); const o = n(7293); const s = r.Int8Array; const a = i.aTypedArray; const l = i.exportTypedArrayMethod; const u = [].toLocaleString; const c = [].slice; const d = !!s && o((() => { u.call(new s(1)); })); l("toLocaleString", (function () { return u.apply(d ? c.call(a(this)) : a(this), arguments); }), o((() => [1, 2].toLocaleString() != new s([1, 2]).toLocaleString())) || !o((() => { s.prototype.toLocaleString.call([1, 2]); })));
    },
    5016(t, e, n) {
      const r = n(260).exportTypedArrayMethod; const i = n(7293); const o = n(7854).Uint8Array; const s = o && o.prototype || {}; let a = [].toString; const l = [].join; i((() => { a.call({}); })) && (a = function () { return l.call(this); }); const u = s.toString != a; r("toString", a, u);
    },
    2472(t, e, n) { n(9843)("Uint8", ((t) => function (e, n, r) { return t(this, e, n, r); })); },
    4747(t, e, n) { const r = n(7854); const i = n(8324); const o = n(8533); const s = n(8880); for (const a in i) { const l = r[a]; const u = l && l.prototype; if (u && u.forEach !== o) try { s(u, "forEach", o); } catch (t) { u.forEach = o; } } },
    3948(t, e, n) { const r = n(7854); const i = n(8324); const o = n(6992); const s = n(8880); const a = n(5112); const l = a("iterator"); const u = a("toStringTag"); const c = o.values; for (const d in i) { const h = r[d]; const p = h && h.prototype; if (p) { if (p[l] !== c) try { s(p, l, c); } catch (t) { p[l] = c; } if (p[u] || s(p, u, d), i[d]) for (const f in o) if (p[f] !== o[f]) try { s(p, f, o[f]); } catch (t) { p[f] = o[f]; } } } },
    1637(t, e, n) {
      n(6992); const r = n(2109); const i = n(5005); const o = n(590); const s = n(1320); const a = n(2248); const l = n(8003); const u = n(4994); const c = n(9909); const d = n(5787); const h = n(6656); const p = n(9974); const f = n(648); const m = n(9670); const g = n(111); const v = n(30); const y = n(9114); const _ = n(8554); const b = n(1246); const w = n(5112); const x = i("fetch"); const S = i("Headers"); const k = w("iterator"); const C = "URLSearchParams"; const E = "URLSearchParamsIterator"; const T = c.set; const P = c.getterFor(C); const O = c.getterFor(E); const A = /\+/g; const M = Array(4); const L = function (t) { return M[t - 1] || (M[t - 1] = RegExp(`((?:%[\\da-f]{2}){${t}})`, "gi")); }; const I = function (t) { try { return decodeURIComponent(t); } catch (e) { return t; } }; const j = function (t) { let e = t.replace(A, " "); let n = 4; try { return decodeURIComponent(e); } catch (t) { for (;n;)e = e.replace(L(n--), I); return e; } }; const D = /[!'()~]|%20/g; const N = {
        "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", 
      }; const R = function (t) { return N[t]; }; const F = function (t) { return encodeURIComponent(t).replace(D, R); }; const V = function (t, e) { if (e) for (var n, r, i = e.split("&"), o = 0; o < i.length;)(n = i[o++]).length && (r = n.split("="), t.push({ key: j(r.shift()), value: j(r.join("=")) })); }; const z = function (t) { this.entries.length = 0, V(this.entries, t); }; const B = function (t, e) { if (t < e) throw TypeError("Not enough arguments"); }; const q = u((function (t, e) { T(this, { type: E, iterator: _(P(t).entries), kind: e }); }), "Iterator", (function () { const t = O(this); const e = t.kind; const n = t.iterator.next(); const r = n.value; return n.done || (n.value = e === "keys" ? r.key : e === "values" ? r.value : [r.key, r.value]), n; })); var H = function () {
        d(this, H, C); let t; let e; let n; let r; let i; let o; let s; let a; let l; const u = arguments.length > 0 ? arguments[0] : void 0; const c = this; const p = []; if (T(c, {
          type: C, entries: p, updateURL() {}, updateSearchParams: z,
        }), void 0 !== u) if (g(u)) if (typeof (t = b(u)) === "function") for (n = (e = t.call(u)).next; !(r = n.call(e)).done;) { if ((s = (o = (i = _(m(r.value))).next).call(i)).done || (a = o.call(i)).done || !o.call(i).done) throw TypeError("Expected sequence with length 2"); p.push({ key: `${s.value}`, value: `${a.value}` }); } else for (l in u)h(u, l) && p.push({ key: l, value: `${u[l]}` }); else V(p, typeof u === "string" ? u.charAt(0) === "?" ? u.slice(1) : u : `${u}`);
      }; const $ = H.prototype; a($, {
        append(t, e) { B(arguments.length, 2); const n = P(this); n.entries.push({ key: `${t}`, value: `${e}` }), n.updateURL(); }, delete(t) { B(arguments.length, 1); for (var e = P(this), n = e.entries, r = `${t}`, i = 0; i < n.length;)n[i].key === r ? n.splice(i, 1) : i++; e.updateURL(); }, get(t) { B(arguments.length, 1); for (let e = P(this).entries, n = `${t}`, r = 0; r < e.length; r++) if (e[r].key === n) return e[r].value; return null; }, getAll(t) { B(arguments.length, 1); for (var e = P(this).entries, n = `${t}`, r = [], i = 0; i < e.length; i++)e[i].key === n && r.push(e[i].value); return r; }, has(t) { B(arguments.length, 1); for (let e = P(this).entries, n = `${t}`, r = 0; r < e.length;) if (e[r++].key === n) return !0; return !1; }, set(t, e) { B(arguments.length, 1); for (var n, r = P(this), i = r.entries, o = !1, s = `${t}`, a = `${e}`, l = 0; l < i.length; l++)(n = i[l]).key === s && (o ? i.splice(l--, 1) : (o = !0, n.value = a)); o || i.push({ key: s, value: a }), r.updateURL(); }, sort() { let t; let e; let n; const r = P(this); const i = r.entries; const o = i.slice(); for (i.length = 0, n = 0; n < o.length; n++) { for (t = o[n], e = 0; e < n; e++) if (i[e].key > t.key) { i.splice(e, 0, t); break; }e === n && i.push(t); }r.updateURL(); }, forEach(t) { for (var e, n = P(this).entries, r = p(t, arguments.length > 1 ? arguments[1] : void 0, 3), i = 0; i < n.length;)r((e = n[i++]).value, e.key, this); }, keys() { return new q(this, "keys"); }, values() { return new q(this, "values"); }, entries() { return new q(this, "entries"); },
      }, { enumerable: !0 }), s($, k, $.entries), s($, "toString", (function () { for (var t, e = P(this).entries, n = [], r = 0; r < e.length;)t = e[r++], n.push(`${F(t.key)}=${F(t.value)}`); return n.join("&"); }), { enumerable: !0 }), l(H, C), r({ global: !0, forced: !o }, { URLSearchParams: H }), o || typeof x !== "function" || typeof S !== "function" || r({ global: !0, enumerable: !0, forced: !0 }, { fetch(t) { let e; let n; let r; const i = [t]; return arguments.length > 1 && (g(e = arguments[1]) && (n = e.body, f(n) === C && ((r = e.headers ? new S(e.headers) : new S()).has("content-type") || r.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), e = v(e, { body: y(0, String(n)), headers: y(0, r) }))), i.push(e)), x.apply(this, i); } }), t.exports = { URLSearchParams: H, getState: P };
    },
    285(t, e, n) {
      n(8783); let r; const i = n(2109); const o = n(9781); const s = n(590); const a = n(7854); const l = n(6048); const u = n(1320); const c = n(5787); const d = n(6656); const h = n(1574); const p = n(8457); const f = n(8710).codeAt; const m = n(3197); const g = n(8003); const v = n(1637); const y = n(9909); const _ = a.URL; const b = v.URLSearchParams; const w = v.getState; const x = y.set; const S = y.getterFor("URL"); const k = Math.floor; const C = Math.pow; const E = "Invalid scheme"; const T = "Invalid host"; const P = "Invalid port"; const O = /[A-Za-z]/; const A = /[\d+-.A-Za-z]/; const M = /\d/; const L = /^(0x|0X)/; const I = /^[0-7]+$/; const j = /^\d+$/; const D = /^[\dA-Fa-f]+$/; const N = /[\u0000\t\u000A\u000D #%/:?@[\\]]/; const R = /[\u0000\t\u000A\u000D #/:?@[\\]]/; const F = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g; const V = /[\t\u000A\u000D]/g; const z = function (t, e) { let n; let r; let i; if (e.charAt(0) == "[") { if (e.charAt(e.length - 1) != "]") return T; if (!(n = q(e.slice(1, -1)))) return T; t.host = n; } else if (K(t)) { if (e = m(e), N.test(e)) return T; if ((n = B(e)) === null) return T; t.host = n; } else { if (R.test(e)) return T; for (n = "", r = p(e), i = 0; i < r.length; i++)n += Y(r[i], $); t.host = n; } }; var B = function (t) { let e; let n; let r; let i; let o; let s; let a; const l = t.split("."); if (l.length && l[l.length - 1] == "" && l.pop(), (e = l.length) > 4) return t; for (n = [], r = 0; r < e; r++) { if ((i = l[r]) == "") return t; if (o = 10, i.length > 1 && i.charAt(0) == "0" && (o = L.test(i) ? 16 : 8, i = i.slice(o == 8 ? 1 : 2)), i === "")s = 0; else { if (!(o == 10 ? j : o == 8 ? I : D).test(i)) return t; s = parseInt(i, o); }n.push(s); } for (r = 0; r < e; r++) if (s = n[r], r == e - 1) { if (s >= 256 ** (5 - e)) return null; } else if (s > 255) return null; for (a = n.pop(), r = 0; r < n.length; r++)a += n[r] * 256 ** (3 - r); return a; }; var q = function (t) { let e; let n; let r; let i; let o; let s; let a; const l = [0, 0, 0, 0, 0, 0, 0, 0]; let u = 0; let c = null; let d = 0; const h = function () { return t.charAt(d); }; if (h() == ":") { if (t.charAt(1) != ":") return; d += 2, c = ++u; } for (;h();) { if (u == 8) return; if (h() != ":") { for (e = n = 0; n < 4 && D.test(h());)e = 16 * e + parseInt(h(), 16), d++, n++; if (h() == ".") { if (n == 0) return; if (d -= n, u > 6) return; for (r = 0; h();) { if (i = null, r > 0) { if (!(h() == "." && r < 4)) return; d++; } if (!M.test(h())) return; for (;M.test(h());) { if (o = parseInt(h(), 10), i === null)i = o; else { if (i == 0) return; i = 10 * i + o; } if (i > 255) return; d++; }l[u] = 256 * l[u] + i, ++r != 2 && r != 4 || u++; } if (r != 4) return; break; } if (h() == ":") { if (d++, !h()) return; } else if (h()) return; l[u++] = e; } else { if (c !== null) return; d++, c = ++u; } } if (c !== null) for (s = u - c, u = 7; u != 0 && s > 0;)a = l[u], l[u--] = l[c + s - 1], l[c + --s] = a; else if (u != 8) return; return l; }; const H = function (t) { let e; let n; let r; let i; if (typeof t === "number") { for (e = [], n = 0; n < 4; n++)e.unshift(t % 256), t = k(t / 256); return e.join("."); } if (typeof t === "object") { for (e = "", r = (function (t) { for (var e = null, n = 1, r = null, i = 0, o = 0; o < 8; o++)t[o] !== 0 ? (i > n && (e = r, n = i), r = null, i = 0) : (r === null && (r = o), ++i); return i > n && (e = r, n = i), e; }(t)), n = 0; n < 8; n++)i && t[n] === 0 || (i && (i = !1), r === n ? (e += n ? ":" : "::", i = !0) : (e += t[n].toString(16), n < 7 && (e += ":"))); return `[${ e }]`; } return t; }; var $ = {}; const U = h({}, $, {
        " ": 1, '"': 1, "<": 1, ">": 1, "`": 1, 
      }); const W = h({}, U, {
        "#": 1, "?": 1, "{": 1, "}": 1, 
      }); const G = h({}, W, {
        "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1, 
      }); var Y = function (t, e) { const n = f(t, 0); return n > 32 && n < 127 && !d(e, t) ? t : encodeURIComponent(t); }; const Z = {
        ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443, 
      }; var K = function (t) { return d(Z, t.scheme); }; const X = function (t) { return t.username != "" || t.password != ""; }; const Q = function (t) { return !t.host || t.cannotBeABaseURL || t.scheme == "file"; }; const J = function (t, e) { let n; return t.length == 2 && O.test(t.charAt(0)) && ((n = t.charAt(1)) == ":" || !e && n == "|"); }; const tt = function (t) { let e; return t.length > 1 && J(t.slice(0, 2)) && (t.length == 2 || (e = t.charAt(2)) === "/" || e === "\\" || e === "?" || e === "#"); }; const et = function (t) { const e = t.path; const n = e.length; !n || t.scheme == "file" && n == 1 && J(e[0], !0) || e.pop(); }; const nt = function (t) { return t === "." || t.toLowerCase() === "%2e"; }; const rt = {}; const it = {}; const ot = {}; const st = {}; const at = {}; const lt = {}; const ut = {}; const ct = {}; const dt = {}; const ht = {}; const pt = {}; const ft = {}; const mt = {}; const gt = {}; const vt = {}; const yt = {}; const _t = {}; const bt = {}; const wt = {}; const xt = {}; const St = {}; const kt = function (t, e, n, i) { let o; let s; let a; let l; let u; let c = n || rt; let h = 0; let f = ""; let m = !1; let g = !1; let v = !1; for (n || (t.scheme = "", t.username = "", t.password = "", t.host = null, t.port = null, t.path = [], t.query = null, t.fragment = null, t.cannotBeABaseURL = !1, e = e.replace(F, "")), e = e.replace(V, ""), o = p(e); h <= o.length;) { switch (s = o[h], c) { case rt: if (!s || !O.test(s)) { if (n) return E; c = ot; continue; }f += s.toLowerCase(), c = it; break; case it: if (s && (A.test(s) || s == "+" || s == "-" || s == "."))f += s.toLowerCase(); else { if (s != ":") { if (n) return E; f = "", c = ot, h = 0; continue; } if (n && (K(t) != d(Z, f) || f == "file" && (X(t) || t.port !== null) || t.scheme == "file" && !t.host)) return; if (t.scheme = f, n) return void (K(t) && Z[t.scheme] == t.port && (t.port = null)); f = "", t.scheme == "file" ? c = gt : K(t) && i && i.scheme == t.scheme ? c = st : K(t) ? c = ct : o[h + 1] == "/" ? (c = at, h++) : (t.cannotBeABaseURL = !0, t.path.push(""), c = wt); } break; case ot: if (!i || i.cannotBeABaseURL && s != "#") return E; if (i.cannotBeABaseURL && s == "#") { t.scheme = i.scheme, t.path = i.path.slice(), t.query = i.query, t.fragment = "", t.cannotBeABaseURL = !0, c = St; break; }c = i.scheme == "file" ? gt : lt; continue; case st: if (s != "/" || o[h + 1] != "/") { c = lt; continue; }c = dt, h++; break; case at: if (s == "/") { c = ht; break; }c = bt; continue; case lt: if (t.scheme = i.scheme, s == r)t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.query = i.query; else if (s == "/" || s == "\\" && K(t))c = ut; else if (s == "?")t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.query = "", c = xt; else { if (s != "#") { t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.path.pop(), c = bt; continue; }t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, t.path = i.path.slice(), t.query = i.query, t.fragment = "", c = St; } break; case ut: if (!K(t) || s != "/" && s != "\\") { if (s != "/") { t.username = i.username, t.password = i.password, t.host = i.host, t.port = i.port, c = bt; continue; }c = ht; } else c = dt; break; case ct: if (c = dt, s != "/" || f.charAt(h + 1) != "/") continue; h++; break; case dt: if (s != "/" && s != "\\") { c = ht; continue; } break; case ht: if (s == "@") { m && (f = `%40${ f}`), m = !0, a = p(f); for (let y = 0; y < a.length; y++) { const _ = a[y]; if (_ != ":" || v) { const b = Y(_, G); v ? t.password += b : t.username += b; } else v = !0; }f = ""; } else if (s == r || s == "/" || s == "?" || s == "#" || s == "\\" && K(t)) { if (m && f == "") return "Invalid authority"; h -= p(f).length + 1, f = "", c = pt; } else f += s; break; case pt: case ft: if (n && t.scheme == "file") { c = yt; continue; } if (s != ":" || g) { if (s == r || s == "/" || s == "?" || s == "#" || s == "\\" && K(t)) { if (K(t) && f == "") return T; if (n && f == "" && (X(t) || t.port !== null)) return; if (l = z(t, f)) return l; if (f = "", c = _t, n) return; continue; }s == "[" ? g = !0 : s == "]" && (g = !1), f += s; } else { if (f == "") return T; if (l = z(t, f)) return l; if (f = "", c = mt, n == ft) return; } break; case mt: if (!M.test(s)) { if (s == r || s == "/" || s == "?" || s == "#" || s == "\\" && K(t) || n) { if (f != "") { const w = parseInt(f, 10); if (w > 65535) return P; t.port = K(t) && w === Z[t.scheme] ? null : w, f = ""; } if (n) return; c = _t; continue; } return P; }f += s; break; case gt: if (t.scheme = "file", s == "/" || s == "\\")c = vt; else { if (!i || i.scheme != "file") { c = bt; continue; } if (s == r)t.host = i.host, t.path = i.path.slice(), t.query = i.query; else if (s == "?")t.host = i.host, t.path = i.path.slice(), t.query = "", c = xt; else { if (s != "#") { tt(o.slice(h).join("")) || (t.host = i.host, t.path = i.path.slice(), et(t)), c = bt; continue; }t.host = i.host, t.path = i.path.slice(), t.query = i.query, t.fragment = "", c = St; } } break; case vt: if (s == "/" || s == "\\") { c = yt; break; }i && i.scheme == "file" && !tt(o.slice(h).join("")) && (J(i.path[0], !0) ? t.path.push(i.path[0]) : t.host = i.host), c = bt; continue; case yt: if (s == r || s == "/" || s == "\\" || s == "?" || s == "#") { if (!n && J(f))c = bt; else if (f == "") { if (t.host = "", n) return; c = _t; } else { if (l = z(t, f)) return l; if (t.host == "localhost" && (t.host = ""), n) return; f = "", c = _t; } continue; }f += s; break; case _t: if (K(t)) { if (c = bt, s != "/" && s != "\\") continue; } else if (n || s != "?") if (n || s != "#") { if (s != r && (c = bt, s != "/")) continue; } else t.fragment = "", c = St; else t.query = "", c = xt; break; case bt: if (s == r || s == "/" || s == "\\" && K(t) || !n && (s == "?" || s == "#")) { if ((u = (u = f).toLowerCase()) === ".." || u === "%2e." || u === ".%2e" || u === "%2e%2e" ? (et(t), s == "/" || s == "\\" && K(t) || t.path.push("")) : nt(f) ? s == "/" || s == "\\" && K(t) || t.path.push("") : (t.scheme == "file" && !t.path.length && J(f) && (t.host && (t.host = ""), f = `${f.charAt(0) }:`), t.path.push(f)), f = "", t.scheme == "file" && (s == r || s == "?" || s == "#")) for (;t.path.length > 1 && t.path[0] === "";)t.path.shift(); s == "?" ? (t.query = "", c = xt) : s == "#" && (t.fragment = "", c = St); } else f += Y(s, W); break; case wt: s == "?" ? (t.query = "", c = xt) : s == "#" ? (t.fragment = "", c = St) : s != r && (t.path[0] += Y(s, $)); break; case xt: n || s != "#" ? s != r && (s == "'" && K(t) ? t.query += "%27" : t.query += s == "#" ? "%23" : Y(s, $)) : (t.fragment = "", c = St); break; case St: s != r && (t.fragment += Y(s, U)); }h++; } }; var Ct = function (t) {
        let e; let n; const r = c(this, Ct, "URL"); const i = arguments.length > 1 ? arguments[1] : void 0; const s = String(t); const a = x(r, { type: "URL" }); if (void 0 !== i) if (i instanceof Ct)e = S(i); else if (n = kt(e = {}, String(i))) throw TypeError(n); if (n = kt(a, s, null, e)) throw TypeError(n); const l = a.searchParams = new b(); const 
        u = w(l); u.updateSearchParams(a.query), u.updateURL = function () { a.query = String(l) || null; }, o || (r.href = Tt.call(r), r.origin = Pt.call(r), r.protocol = Ot.call(r), r.username = At.call(r), r.password = Mt.call(r), r.host = Lt.call(r), r.hostname = It.call(r), r.port = jt.call(r), r.pathname = Dt.call(r), r.search = Nt.call(r), r.searchParams = Rt.call(r), r.hash = Ft.call(r));
      }; const Et = Ct.prototype; var Tt = function () { const t = S(this); const e = t.scheme; const n = t.username; const r = t.password; const i = t.host; const o = t.port; const s = t.path; const a = t.query; const l = t.fragment; let u = `${e}:`; return i !== null ? (u += "//", X(t) && (u += `${n + (r ? `:${ r}` : "")}@`), u += H(i), o !== null && (u += `:${o}`)) : e == "file" && (u += "//"), u += t.cannotBeABaseURL ? s[0] : s.length ? `/${s.join("/")}` : "", a !== null && (u += `?${a}`), l !== null && (u += `#${l}`), u; }; var Pt = function () { const t = S(this); const e = t.scheme; const n = t.port; if (e == "blob") try { return new URL(e.path[0]).origin; } catch (t) { return "null"; } return e != "file" && K(t) ? `${e}://${H(t.host)}${n !== null ? `:${n}` : ""}` : "null"; }; var Ot = function () { return `${S(this).scheme}:`; }; var At = function () { return S(this).username; }; var Mt = function () { return S(this).password; }; var Lt = function () { const t = S(this); const e = t.host; const n = t.port; return e === null ? "" : n === null ? H(e) : `${H(e)}:${n}`; }; var It = function () { const t = S(this).host; return t === null ? "" : H(t); }; var jt = function () { const t = S(this).port; return t === null ? "" : String(t); }; var Dt = function () { const t = S(this); const e = t.path; return t.cannotBeABaseURL ? e[0] : e.length ? `/${e.join("/")}` : ""; }; var Nt = function () { const t = S(this).query; return t ? `?${t}` : ""; }; var Rt = function () { return S(this).searchParams; }; var Ft = function () { const t = S(this).fragment; return t ? `#${t}` : ""; }; const Vt = function (t, e) {
        return {
          get: t, set: e, configurable: !0, enumerable: !0,
        };
      }; if (o && l(Et, {
        href: Vt(Tt, (function (t) { const e = S(this); const n = String(t); const r = kt(e, n); if (r) throw TypeError(r); w(e.searchParams).updateSearchParams(e.query); })), origin: Vt(Pt), protocol: Vt(Ot, (function (t) { const e = S(this); kt(e, `${String(t)}:`, rt); })), username: Vt(At, (function (t) { const e = S(this); const n = p(String(t)); if (!Q(e)) { e.username = ""; for (let r = 0; r < n.length; r++)e.username += Y(n[r], G); } })), password: Vt(Mt, (function (t) { const e = S(this); const n = p(String(t)); if (!Q(e)) { e.password = ""; for (let r = 0; r < n.length; r++)e.password += Y(n[r], G); } })), host: Vt(Lt, (function (t) { const e = S(this); e.cannotBeABaseURL || kt(e, String(t), pt); })), hostname: Vt(It, (function (t) { const e = S(this); e.cannotBeABaseURL || kt(e, String(t), ft); })), port: Vt(jt, (function (t) { const e = S(this); Q(e) || ((t = String(t)) == "" ? e.port = null : kt(e, t, mt)); })), pathname: Vt(Dt, (function (t) { const e = S(this); e.cannotBeABaseURL || (e.path = [], kt(e, `${t}`, _t)); })), search: Vt(Nt, (function (t) { const e = S(this); (t = String(t)) == "" ? e.query = null : (t.charAt(0) == "?" && (t = t.slice(1)), e.query = "", kt(e, t, xt)), w(e.searchParams).updateSearchParams(e.query); })), searchParams: Vt(Rt), hash: Vt(Ft, (function (t) { const e = S(this); (t = String(t)) != "" ? (t.charAt(0) == "#" && (t = t.slice(1)), e.fragment = "", kt(e, t, St)) : e.fragment = null; })),
      }), u(Et, "toJSON", (function () { return Tt.call(this); }), { enumerable: !0 }), u(Et, "toString", (function () { return Tt.call(this); }), { enumerable: !0 }), _) { const zt = _.createObjectURL; const Bt = _.revokeObjectURL; zt && u(Ct, "createObjectURL", (function (t) { return zt.apply(_, arguments); })), Bt && u(Ct, "revokeObjectURL", (function (t) { return Bt.apply(_, arguments); })); }g(Ct, "URL"), i({ global: !0, forced: !s, sham: !o }, { URL: Ct });
    },
  }; const e = {}; function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { exports: {} }; return t[r](i, i.exports, n), i.exports; }n.d = function (t, e) { for (const r in e)n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: e[r] }); }, n.g = (function () { if (typeof globalThis === "object") return globalThis; try { return this || new Function("return this")(); } catch (t) { if (typeof window === "object") return window; } }()), n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, n.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }; const r = {}; return (function () {
    function t(t, n) {
      let r; if (typeof Symbol === "undefined" || t[Symbol.iterator] == null) {
        if (Array.isArray(t) || (r = (function (t, n) { if (t) { if (typeof t === "string") return e(t, n); let r = Object.prototype.toString.call(t).slice(8, -1); return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0; } }(t))) || n && t && typeof t.length === "number") {
          r && (t = r); let i = 0; const o = function () {}; return {
            s: o, n() { return i >= t.length ? { done: !0 } : { done: !1, value: t[i++] }; }, e(t) { throw t; }, f: o,
          };
        } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      } let s; let a = !0; let l = !1; return {
        s() { r = t[Symbol.iterator](); }, n() { const t = r.next(); return a = t.done, t; }, e(t) { l = !0, s = t; }, f() { try { a || r.return == null || r.return(); } finally { if (l) throw s; } },
      };
    } function e(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r; }n.r(r), n.d(r, { Dropzone() { return y; }, default() { return S; } }), n(2222), n(7327), n(2772), n(6992), n(1249), n(7042), n(561), n(8264), n(8309), n(489), n(1539), n(4916), n(9714), n(8783), n(4723), n(5306), n(3123), n(3210), n(2472), n(2990), n(8927), n(3105), n(5035), n(4345), n(7174), n(2846), n(4731), n(7209), n(6319), n(8867), n(7789), n(3739), n(9368), n(4483), n(2056), n(3462), n(678), n(7462), n(3824), n(5021), n(2974), n(5016), n(4747), n(3948), n(285); const i = (function () { function e() { !(function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); }(this, e)); } let n; return (n = [{ key: "on", value(t, e) { return this._callbacks = this._callbacks || {}, this._callbacks[t] || (this._callbacks[t] = []), this._callbacks[t].push(e), this; } }, { key: "emit", value(e) { this._callbacks = this._callbacks || {}; for (var n = this._callbacks[e], r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)i[o - 1] = arguments[o]; if (n) { let s; const a = t(n, !0); try { for (a.s(); !(s = a.n()).done;) { const l = s.value; l.apply(this, i); } } catch (t) { a.e(t); } finally { a.f(); } } return this.element && this.element.dispatchEvent(this.makeEvent(`dropzone:${e}`, { args: i })), this; } }, { key: "makeEvent", value(t, e) { const n = { bubbles: !0, cancelable: !0, detail: e }; if (typeof window.CustomEvent === "function") return new CustomEvent(t, n); const r = document.createEvent("CustomEvent"); return r.initCustomEvent(t, n.bubbles, n.cancelable, n.detail), r; } }, { key: "off", value(t, e) { if (!this._callbacks || arguments.length === 0) return this._callbacks = {}, this; const n = this._callbacks[t]; if (!n) return this; if (arguments.length === 1) return delete this._callbacks[t], this; for (let r = 0; r < n.length; r++) { const i = n[r]; if (i === e) { n.splice(r, 1); break; } } return this; } }]) && (function (t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } }(e.prototype, n)), e; }()); function o(t, e) {
      let n; if (typeof Symbol === "undefined" || t[Symbol.iterator] == null) {
        if (Array.isArray(t) || (n = (function (t, e) { if (t) { if (typeof t === "string") return s(t, e); let n = Object.prototype.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(t, e) : void 0; } }(t))) || e && t && typeof t.length === "number") {
          n && (t = n); let r = 0; const i = function () {}; return {
            s: i, n() { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] }; }, e(t) { throw t; }, f: i,
          };
        } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      } let o; let a = !0; let l = !1; return {
        s() { n = t[Symbol.iterator](); }, n() { const t = n.next(); return a = t.done, t; }, e(t) { l = !0, o = t; }, f() { try { a || n.return == null || n.return(); } finally { if (l) throw o; } },
      };
    } function s(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r; } const a = {
      url: null,
      method: "post",
      withCredentials: !1,
      timeout: null,
      parallelUploads: 2,
      uploadMultiple: !1,
      chunking: !1,
      forceChunking: !1,
      chunkSize: 2e6,
      parallelChunkUploads: !1,
      retryChunks: !1,
      retryChunksLimit: 3,
      maxFilesize: 256,
      paramName: "file",
      createImageThumbnails: !0,
      maxThumbnailFilesize: 10,
      thumbnailWidth: 120,
      thumbnailHeight: 120,
      thumbnailMethod: "crop",
      resizeWidth: null,
      resizeHeight: null,
      resizeMimeType: null,
      resizeQuality: 0.8,
      resizeMethod: "contain",
      filesizeBase: 1e3,
      maxFiles: null,
      headers: null,
      clickable: !0,
      ignoreHiddenFiles: !0,
      acceptedFiles: null,
      acceptedMimeTypes: null,
      autoProcessQueue: !0,
      autoQueue: !0,
      addRemoveLinks: !1,
      previewsContainer: null,
      disablePreviews: !1,
      hiddenInputContainer: "body",
      capture: null,
      renameFilename: null,
      renameFile: null,
      forceFallback: !1,
      dictDefaultMessage: "Drop files here to upload",
      dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
      dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
      dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
      dictInvalidFileType: "You can't upload files of this type.",
      dictResponseError: "Server responded with {{statusCode}} code.",
      dictCancelUpload: "Cancel upload",
      dictUploadCanceled: "Upload canceled.",
      dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
      dictRemoveFile: "Remove file",
      dictRemoveFileConfirmation: null,
      dictMaxFilesExceeded: "You can not upload any more files.",
      dictFileSizeUnits: {
        tb: "TB", gb: "GB", mb: "MB", kb: "KB", b: "b",
      },
      init() {},
      params(t, e, n) {
        if (n) { return {
          dzuuid: n.file.upload.uuid, dzchunkindex: n.index, dztotalfilesize: n.file.size, dzchunksize: this.options.chunkSize, dztotalchunkcount: n.file.upload.totalChunkCount, dzchunkbyteoffset: n.index * this.options.chunkSize, 
        }; }
      },
      accept(t, e) { return e(); },
      chunksUploaded(t, e) { e(); },
      fallback() { let t; this.element.className = "".concat(this.element.className, " dz-browser-not-supported"); let e; const n = o(this.element.getElementsByTagName("div"), !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; if (/(^| )dz-message($| )/.test(r.className)) { t = r, r.className = "dz-message"; break; } } } catch (t) { n.e(t); } finally { n.f(); }t || (t = y.createElement('<div class="dz-message"><span></span></div>'), this.element.appendChild(t)); const i = t.getElementsByTagName("span")[0]; return i && (i.textContent != null ? i.textContent = this.options.dictFallbackMessage : i.innerText != null && (i.innerText = this.options.dictFallbackMessage)), this.element.appendChild(this.getFallbackForm()); },
      resize(t, e, n, r) {
        const i = {
          srcX: 0, srcY: 0, srcWidth: t.width, srcHeight: t.height, 
        }; const o = t.width / t.height; e == null && n == null ? (e = i.srcWidth, n = i.srcHeight) : e == null ? e = n * o : n == null && (n = e / o); const s = (e = Math.min(e, i.srcWidth)) / (n = Math.min(n, i.srcHeight)); if (i.srcWidth > e || i.srcHeight > n) if (r === "crop")o > s ? (i.srcHeight = t.height, i.srcWidth = i.srcHeight * s) : (i.srcWidth = t.width, i.srcHeight = i.srcWidth / s); else { if (r !== "contain") throw new Error("Unknown resizeMethod '".concat(r, "'")); o > s ? n = e / o : e = n * o; } return i.srcX = (t.width - i.srcWidth) / 2, i.srcY = (t.height - i.srcHeight) / 2, i.trgWidth = e, i.trgHeight = n, i;
      },
      transformFile(t, e) { return (this.options.resizeWidth || this.options.resizeHeight) && t.type.match(/image.*/) ? this.resizeImage(t, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, e) : e(t); },
      previewTemplate: '<div class="dz-preview dz-file-preview"> <div class="dz-image"><img data-dz-thumbnail/></div> <div class="dz-details"> <div class="dz-size"><span data-dz-size></span></div> <div class="dz-filename"><span data-dz-name></span></div> </div> <div class="dz-progress"> <span class="dz-upload" data-dz-uploadprogress></span> </div> <div class="dz-error-message"><span data-dz-errormessage></span></div> <div class="dz-success-mark"> <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <title>Check</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <path d="M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z" stroke-opacity="0.198794158" stroke="#747474" fill-opacity="0.816519475" fill="#FFFFFF"></path> </g> </svg> </div> <div class="dz-error-mark"> <svg width="54px" height="54px" viewBox="0 0 54 54" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <title>Error</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g stroke="#747474" stroke-opacity="0.198794158" fill="#FFFFFF" fill-opacity="0.816519475"> <path d="M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z"></path> </g> </g> </svg> </div> </div> ',
      drop(t) { return this.element.classList.remove("dz-drag-hover"); },
      dragstart(t) {},
      dragend(t) { return this.element.classList.remove("dz-drag-hover"); },
      dragenter(t) { return this.element.classList.add("dz-drag-hover"); },
      dragover(t) { return this.element.classList.add("dz-drag-hover"); },
      dragleave(t) { return this.element.classList.remove("dz-drag-hover"); },
      paste(t) {},
      reset() { return this.element.classList.remove("dz-started"); },
      addedfile(t) { const e = this; if (this.element === this.previewsContainer && this.element.classList.add("dz-started"), this.previewsContainer && !this.options.disablePreviews) { t.previewElement = y.createElement(this.options.previewTemplate.trim()), t.previewTemplate = t.previewElement, this.previewsContainer.appendChild(t.previewElement); let n; const r = o(t.previewElement.querySelectorAll("[data-dz-name]"), !0); try { for (r.s(); !(n = r.n()).done;) { var i = n.value; i.textContent = t.name; } } catch (t) { r.e(t); } finally { r.f(); } let s; const a = o(t.previewElement.querySelectorAll("[data-dz-size]"), !0); try { for (a.s(); !(s = a.n()).done;)(i = s.value).innerHTML = this.filesize(t.size); } catch (t) { a.e(t); } finally { a.f(); } this.options.addRemoveLinks && (t._removeLink = y.createElement('<a class="dz-remove" href="javascript:undefined;" data-dz-remove>'.concat(this.options.dictRemoveFile, "</a>")), t.previewElement.appendChild(t._removeLink)); let l; const u = function (n) { return n.preventDefault(), n.stopPropagation(), t.status === y.UPLOADING ? y.confirm(e.options.dictCancelUploadConfirmation, (() => e.removeFile(t))) : e.options.dictRemoveFileConfirmation ? y.confirm(e.options.dictRemoveFileConfirmation, (() => e.removeFile(t))) : e.removeFile(t); }; const c = o(t.previewElement.querySelectorAll("[data-dz-remove]"), !0); try { for (c.s(); !(l = c.n()).done;)l.value.addEventListener("click", u); } catch (t) { c.e(t); } finally { c.f(); } } },
      removedfile(t) { return t.previewElement != null && t.previewElement.parentNode != null && t.previewElement.parentNode.removeChild(t.previewElement), this._updateMaxFilesReachedClass(); },
      thumbnail(t, e) { if (t.previewElement) { t.previewElement.classList.remove("dz-file-preview"); let n; const r = o(t.previewElement.querySelectorAll("[data-dz-thumbnail]"), !0); try { for (r.s(); !(n = r.n()).done;) { const i = n.value; i.alt = t.name, i.src = e; } } catch (t) { r.e(t); } finally { r.f(); } return setTimeout((() => t.previewElement.classList.add("dz-image-preview")), 1); } },
      error(t, e) { if (t.previewElement) { t.previewElement.classList.add("dz-error"), typeof e !== "string" && e.error && (e = e.error); let n; const r = o(t.previewElement.querySelectorAll("[data-dz-errormessage]"), !0); try { for (r.s(); !(n = r.n()).done;)n.value.textContent = e; } catch (t) { r.e(t); } finally { r.f(); } } },
      errormultiple() {},
      processing(t) { if (t.previewElement && (t.previewElement.classList.add("dz-processing"), t._removeLink)) return t._removeLink.innerHTML = this.options.dictCancelUpload; },
      processingmultiple() {},
      uploadprogress(t, e, n) { if (t.previewElement) { let r; const i = o(t.previewElement.querySelectorAll("[data-dz-uploadprogress]"), !0); try { for (i.s(); !(r = i.n()).done;) { const s = r.value; s.nodeName === "PROGRESS" ? s.value = e : s.style.width = "".concat(e, "%"); } } catch (t) { i.e(t); } finally { i.f(); } } },
      totaluploadprogress() {},
      sending() {},
      sendingmultiple() {},
      success(t) { if (t.previewElement) return t.previewElement.classList.add("dz-success"); },
      successmultiple() {},
      canceled(t) { return this.emit("error", t, this.options.dictUploadCanceled); },
      canceledmultiple() {},
      complete(t) { if (t._removeLink && (t._removeLink.innerHTML = this.options.dictRemoveFile), t.previewElement) return t.previewElement.classList.add("dz-complete"); },
      completemultiple() {},
      maxfilesexceeded() {},
      maxfilesreached() {},
      queuecomplete() {},
      addedfiles() {},
    }; function l(t) { return (l = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; })(t); } function u(t, e) {
      let n; if (typeof Symbol === "undefined" || t[Symbol.iterator] == null) {
        if (Array.isArray(t) || (n = (function (t, e) { if (t) { if (typeof t === "string") return c(t, e); let n = Object.prototype.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? c(t, e) : void 0; } }(t))) || e && t && typeof t.length === "number") {
          n && (t = n); let r = 0; const i = function () {}; return {
            s: i, n() { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] }; }, e(t) { throw t; }, f: i,
          };
        } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      } let o; let s = !0; let a = !1; return {
        s() { n = t[Symbol.iterator](); }, n() { const t = n.next(); return s = t.done, t; }, e(t) { a = !0, o = t; }, f() { try { s || n.return == null || n.return(); } finally { if (a) throw o; } },
      };
    } function c(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r; } function d(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function"); } function h(t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r); } } function p(t, e, n) { return e && h(t.prototype, e), n && h(t, n), t; } function f(t, e) { return (f = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function m(t, e) { return !e || l(e) !== "object" && typeof e !== "function" ? g(t) : e; } function g(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function v(t) { return (v = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } var y = (function (t) {
      !(function (t, e) { if (typeof e !== "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && f(t, e); }(o, t)); let e; let n; const r = (e = o, n = (function () { if (typeof Reflect === "undefined" || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === "function") return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (() => {}))), !0; } catch (t) { return !1; } }()), function () { let t; const r = v(e); if (n) { const i = v(this).constructor; t = Reflect.construct(r, arguments, i); } else t = r.apply(this, arguments); return m(this, t); }); function o(t, e) { let n; let i; let s; if (d(this, o), (n = r.call(this)).element = t, n.version = o.version, n.clickableElements = [], n.listeners = [], n.files = [], typeof n.element === "string" && (n.element = document.querySelector(n.element)), !n.element || n.element.nodeType == null) throw new Error("Invalid dropzone element."); if (n.element.dropzone) throw new Error("Dropzone already attached."); o.instances.push(g(n)), n.element.dropzone = g(n); const l = (s = o.optionsForElement(n.element)) != null ? s : {}; if (n.options = o.extend({}, a, l, e != null ? e : {}), n.options.previewTemplate = n.options.previewTemplate.replace(/\n*/g, ""), n.options.forceFallback || !o.isBrowserSupported()) return m(n, n.options.fallback.call(g(n))); if (n.options.url == null && (n.options.url = n.element.getAttribute("action")), !n.options.url) throw new Error("No URL provided."); if (n.options.acceptedFiles && n.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated."); if (n.options.uploadMultiple && n.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking."); return n.options.acceptedMimeTypes && (n.options.acceptedFiles = n.options.acceptedMimeTypes, delete n.options.acceptedMimeTypes), n.options.renameFilename != null && (n.options.renameFile = function (t) { return n.options.renameFilename.call(g(n), t.name, t); }), typeof n.options.method === "string" && (n.options.method = n.options.method.toUpperCase()), (i = n.getExistingFallback()) && i.parentNode && i.parentNode.removeChild(i), !1 !== n.options.previewsContainer && (n.options.previewsContainer ? n.previewsContainer = o.getElement(n.options.previewsContainer, "previewsContainer") : n.previewsContainer = n.element), n.options.clickable && (!0 === n.options.clickable ? n.clickableElements = [n.element] : n.clickableElements = o.getElements(n.options.clickable, "clickable")), n.init(), n; } return p(o, [{ key: "getAcceptedFiles", value() { return this.files.filter(((t) => t.accepted)).map(((t) => t)); } }, { key: "getRejectedFiles", value() { return this.files.filter(((t) => !t.accepted)).map(((t) => t)); } }, { key: "getFilesWithStatus", value(t) { return this.files.filter(((e) => e.status === t)).map(((t) => t)); } }, { key: "getQueuedFiles", value() { return this.getFilesWithStatus(o.QUEUED); } }, { key: "getUploadingFiles", value() { return this.getFilesWithStatus(o.UPLOADING); } }, { key: "getAddedFiles", value() { return this.getFilesWithStatus(o.ADDED); } }, { key: "getActiveFiles", value() { return this.files.filter(((t) => t.status === o.UPLOADING || t.status === o.QUEUED)).map(((t) => t)); } }, {
        key: "init",
        value() {
          const t = this; this.element.tagName === "form" && this.element.setAttribute("enctype", "multipart/form-data"), this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message") && this.element.appendChild(o.createElement('<div class="dz-default dz-message"><button class="dz-button" type="button">'.concat(this.options.dictDefaultMessage, "</button></div>"))), this.clickableElements.length && (function e() { t.hiddenFileInput && t.hiddenFileInput.parentNode.removeChild(t.hiddenFileInput), t.hiddenFileInput = document.createElement("input"), t.hiddenFileInput.setAttribute("type", "file"), (t.options.maxFiles === null || t.options.maxFiles > 1) && t.hiddenFileInput.setAttribute("multiple", "multiple"), t.hiddenFileInput.className = "dz-hidden-input", t.options.acceptedFiles !== null && t.hiddenFileInput.setAttribute("accept", t.options.acceptedFiles), t.options.capture !== null && t.hiddenFileInput.setAttribute("capture", t.options.capture), t.hiddenFileInput.setAttribute("tabindex", "-1"), t.hiddenFileInput.style.visibility = "hidden", t.hiddenFileInput.style.position = "absolute", t.hiddenFileInput.style.top = "0", t.hiddenFileInput.style.left = "0", t.hiddenFileInput.style.height = "0", t.hiddenFileInput.style.width = "0", o.getElement(t.options.hiddenInputContainer, "hiddenInputContainer").appendChild(t.hiddenFileInput), t.hiddenFileInput.addEventListener("change", (() => { const n = t.hiddenFileInput.files; if (n.length) { let r; const i = u(n, !0); try { for (i.s(); !(r = i.n()).done;) { const o = r.value; t.addFile(o); } } catch (t) { i.e(t); } finally { i.f(); } }t.emit("addedfiles", n), e(); })); }()), this.URL = window.URL !== null ? window.URL : window.webkitURL; let e; const n = u(this.events, !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; this.on(r, this.options[r]); } } catch (t) { n.e(t); } finally { n.f(); } this.on("uploadprogress", (() => t.updateTotalUploadProgress())), this.on("removedfile", (() => t.updateTotalUploadProgress())), this.on("canceled", ((e) => t.emit("complete", e))), this.on("complete", ((e) => { if (t.getAddedFiles().length === 0 && t.getUploadingFiles().length === 0 && t.getQueuedFiles().length === 0) return setTimeout((() => t.emit("queuecomplete")), 0); })); const i = function (t) { if (function (t) { if (t.dataTransfer.types) for (let e = 0; e < t.dataTransfer.types.length; e++) if (t.dataTransfer.types[e] === "Files") return !0; return !1; }(t)) return t.stopPropagation(), t.preventDefault ? t.preventDefault() : t.returnValue = !1; }; return this.listeners = [{
            element: this.element,
            events: {
              dragstart(e) { return t.emit("dragstart", e); }, dragenter(e) { return i(e), t.emit("dragenter", e); }, dragover(e) { let n; try { n = e.dataTransfer.effectAllowed; } catch (t) {} return e.dataTransfer.dropEffect = n === "move" || n === "linkMove" ? "move" : "copy", i(e), t.emit("dragover", e); }, dragleave(e) { return t.emit("dragleave", e); }, drop(e) { return i(e), t.drop(e); }, dragend(e) { return t.emit("dragend", e); },
            }, 
          }], this.clickableElements.forEach(((e) => t.listeners.push({ element: e, events: { click(n) { return (e !== t.element || n.target === t.element || o.elementInside(n.target, t.element.querySelector(".dz-message"))) && t.hiddenFileInput.click(), !0; } } }))), this.enable(), this.options.init.call(this);
        }, 
      }, { key: "destroy", value() { return this.disable(), this.removeAllFiles(!0), (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : void 0) && (this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput), this.hiddenFileInput = null), delete this.element.dropzone, o.instances.splice(o.instances.indexOf(this), 1); } }, { key: "updateTotalUploadProgress", value() { let t; let e = 0; let n = 0; if (this.getActiveFiles().length) { let r; const i = u(this.getActiveFiles(), !0); try { for (i.s(); !(r = i.n()).done;) { const o = r.value; e += o.upload.bytesSent, n += o.upload.total; } } catch (t) { i.e(t); } finally { i.f(); }t = 100 * e / n; } else t = 100; return this.emit("totaluploadprogress", t, n, e); } }, { key: "_getParamName", value(t) { return typeof this.options.paramName === "function" ? this.options.paramName(t) : "".concat(this.options.paramName).concat(this.options.uploadMultiple ? "[".concat(t, "]") : ""); } }, { key: "_renameFile", value(t) { return typeof this.options.renameFile !== "function" ? t.name : this.options.renameFile(t); } }, { key: "getFallbackForm", value() { let t; let e; if (t = this.getExistingFallback()) return t; let n = '<div class="dz-fallback">'; this.options.dictFallbackText && (n += "<p>".concat(this.options.dictFallbackText, "</p>")), n += '<input type="file" name="'.concat(this._getParamName(0), '" ').concat(this.options.uploadMultiple ? 'multiple="multiple"' : void 0, ' /><input type="submit" value="Upload!"></div>'); const r = o.createElement(n); return this.element.tagName !== "FORM" ? (e = o.createElement('<form action="'.concat(this.options.url, '" enctype="multipart/form-data" method="').concat(this.options.method, '"></form>'))).appendChild(r) : (this.element.setAttribute("enctype", "multipart/form-data"), this.element.setAttribute("method", this.options.method)), e != null ? e : r; } }, { key: "getExistingFallback", value() { for (let t = function (t) { let e; const n = u(t, !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; if (/(^| )fallback($| )/.test(r.className)) return r; } } catch (t) { n.e(t); } finally { n.f(); } }, e = 0, n = ["div", "form"]; e < n.length; e++) { var r; const i = n[e]; if (r = t(this.element.getElementsByTagName(i))) return r; } } }, { key: "setupEventListeners", value() { return this.listeners.map(((t) => (function () { let e = []; for (const n in t.events) { let r = t.events[n]; e.push(t.element.addEventListener(n, r, !1)); } return e; }()))); } }, { key: "removeEventListeners", value() { return this.listeners.map(((t) => (function () { let e = []; for (const n in t.events) { let r = t.events[n]; e.push(t.element.removeEventListener(n, r, !1)); } return e; }()))); } }, { key: "disable", value() { const t = this; return this.clickableElements.forEach(((t) => t.classList.remove("dz-clickable"))), this.removeEventListeners(), this.disabled = !0, this.files.map(((e) => t.cancelUpload(e))); } }, { key: "enable", value() { return delete this.disabled, this.clickableElements.forEach(((t) => t.classList.add("dz-clickable"))), this.setupEventListeners(); } }, { key: "filesize", value(t) { let e = 0; let n = "b"; if (t > 0) { for (let r = ["tb", "gb", "mb", "kb", "b"], i = 0; i < r.length; i++) { const o = r[i]; if (t >= this.options.filesizeBase ** (4 - i) / 10) { e = t / this.options.filesizeBase ** (4 - i), n = o; break; } }e = Math.round(10 * e) / 10; } return "<strong>".concat(e, "</strong> ").concat(this.options.dictFileSizeUnits[n]); } }, { key: "_updateMaxFilesReachedClass", value() { return this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles ? (this.getAcceptedFiles().length === this.options.maxFiles && this.emit("maxfilesreached", this.files), this.element.classList.add("dz-max-files-reached")) : this.element.classList.remove("dz-max-files-reached"); } }, { key: "drop", value(t) { if (t.dataTransfer) { this.emit("drop", t); for (var e = [], n = 0; n < t.dataTransfer.files.length; n++)e[n] = t.dataTransfer.files[n]; if (e.length) { const r = t.dataTransfer.items; r && r.length && r[0].webkitGetAsEntry != null ? this._addFilesFromItems(r) : this.handleFiles(e); } this.emit("addedfiles", e); } } }, { key: "paste", value(t) { if (((e = t != null ? t.clipboardData : void 0) != null ? (function (t) { return t.items; }(e)) : void 0) != null) { var e; this.emit("paste", t); const n = t.clipboardData.items; return n.length ? this._addFilesFromItems(n) : void 0; } } }, { key: "handleFiles", value(t) { let e; const n = u(t, !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; this.addFile(r); } } catch (t) { n.e(t); } finally { n.f(); } } }, { key: "_addFilesFromItems", value(t) { const e = this; return (function () { let n; const r = []; const i = u(t, !0); try { for (i.s(); !(n = i.n()).done;) { var o; const s = n.value; s.webkitGetAsEntry != null && (o = s.webkitGetAsEntry()) ? o.isFile ? r.push(e.addFile(s.getAsFile())) : o.isDirectory ? r.push(e._addFilesFromDirectory(o, o.name)) : r.push(void 0) : s.getAsFile == null || s.kind != null && s.kind !== "file" ? r.push(void 0) : r.push(e.addFile(s.getAsFile())); } } catch (t) { i.e(t); } finally { i.f(); } return r; }()); } }, { key: "_addFilesFromDirectory", value(t, e) { const n = this; const r = t.createReader(); const i = function (t) { return n = function (e) { return e.log(t); }, (e = console) != null && typeof e.log === "function" ? n(e) : void 0; let e; let n; }; return (function t() { return r.readEntries(((r) => { if (r.length > 0) { let i; const o = u(r, !0); try { for (o.s(); !(i = o.n()).done;) { const s = i.value; s.isFile ? s.file(((t) => { if (!n.options.ignoreHiddenFiles || t.name.substring(0, 1) !== ".") return t.fullPath = "".concat(e, "/").concat(t.name), n.addFile(t); })) : s.isDirectory && n._addFilesFromDirectory(s, "".concat(e, "/").concat(s.name)); } } catch (t) { o.e(t); } finally { o.f(); }t(); } return null; }), i); }()); } }, { key: "accept", value(t, e) { this.options.maxFilesize && t.size > 1024 * this.options.maxFilesize * 1024 ? e(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(t.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize)) : o.isValidFile(t, this.options.acceptedFiles) ? this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles ? (e(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles)), this.emit("maxfilesexceeded", t)) : this.options.accept.call(this, t, e) : e(this.options.dictInvalidFileType); } }, {
        key: "addFile",
        value(t) {
          const e = this; t.upload = {
            uuid: o.uuidv4(), progress: 0, total: t.size, bytesSent: 0, filename: this._renameFile(t),
          }, this.files.push(t), t.status = o.ADDED, this.emit("addedfile", t), this._enqueueThumbnail(t), this.accept(t, ((n) => { n ? (t.accepted = !1, e._errorProcessing([t], n)) : (t.accepted = !0, e.options.autoQueue && e.enqueueFile(t)), e._updateMaxFilesReachedClass(); }));
        }, 
      }, { key: "enqueueFiles", value(t) { let e; const n = u(t, !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; this.enqueueFile(r); } } catch (t) { n.e(t); } finally { n.f(); } return null; } }, { key: "enqueueFile", value(t) { const e = this; if (t.status !== o.ADDED || !0 !== t.accepted) throw new Error("This file can't be queued because it has already been processed or was rejected."); if (t.status = o.QUEUED, this.options.autoProcessQueue) return setTimeout((() => e.processQueue()), 0); } }, { key: "_enqueueThumbnail", value(t) { const e = this; if (this.options.createImageThumbnails && t.type.match(/image.*/) && t.size <= 1024 * this.options.maxThumbnailFilesize * 1024) return this._thumbnailQueue.push(t), setTimeout((() => e._processThumbnailQueue()), 0); } }, { key: "_processThumbnailQueue", value() { const t = this; if (!this._processingThumbnail && this._thumbnailQueue.length !== 0) { this._processingThumbnail = !0; const e = this._thumbnailQueue.shift(); return this.createThumbnail(e, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, !0, ((n) => (t.emit("thumbnail", e, n), t._processingThumbnail = !1, t._processThumbnailQueue()))); } } }, { key: "removeFile", value(t) { if (t.status === o.UPLOADING && this.cancelUpload(t), this.files = _(this.files, t), this.emit("removedfile", t), this.files.length === 0) return this.emit("reset"); } }, { key: "removeAllFiles", value(t) { t == null && (t = !1); let e; const n = u(this.files.slice(), !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; (r.status !== o.UPLOADING || t) && this.removeFile(r); } } catch (t) { n.e(t); } finally { n.f(); } return null; } }, { key: "resizeImage", value(t, e, n, r, i) { const s = this; return this.createThumbnail(t, e, n, r, !0, ((e, n) => { if (n == null) return i(t); let r = s.options.resizeMimeType; r == null && (r = t.type); let a = n.toDataURL(r, s.options.resizeQuality); return r !== "image/jpeg" && r !== "image/jpg" || (a = x.restore(t.dataURL, a)), i(o.dataURItoBlob(a)); })); } }, { key: "createThumbnail", value(t, e, n, r, i, o) { const s = this; const a = new FileReader(); a.onload = function () { t.dataURL = a.result, t.type !== "image/svg+xml" ? s.createThumbnailFromUrl(t, e, n, r, i, o) : o != null && o(a.result); }, a.readAsDataURL(t); } }, { key: "displayExistingFile", value(t, e, n, r) { const i = this; const o = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; if (this.emit("addedfile", t), this.emit("complete", t), o) { const s = function (e) { i.emit("thumbnail", t, e), n && n(); }; t.dataURL = e, this.createThumbnailFromUrl(t, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.resizeMethod, this.options.fixOrientation, s, r); } else this.emit("thumbnail", t, e), n && n(); } }, { key: "createThumbnailFromUrl", value(t, e, n, r, i, o, s) { const a = this; const l = document.createElement("img"); return s && (l.crossOrigin = s), i = getComputedStyle(document.body).imageOrientation != "from-image" && i, l.onload = function () { let s = function (t) { return t(1); }; return typeof EXIF !== "undefined" && EXIF !== null && i && (s = function (t) { return EXIF.getData(l, (function () { return t(EXIF.getTag(this, "Orientation")); })); }), s(((i) => { t.width = l.width, t.height = l.height; const s = a.options.resize.call(a, t, e, n, r); const u = document.createElement("canvas"); const c = u.getContext("2d"); switch (u.width = s.trgWidth, u.height = s.trgHeight, i > 4 && (u.width = s.trgHeight, u.height = s.trgWidth), i) { case 2: c.translate(u.width, 0), c.scale(-1, 1); break; case 3: c.translate(u.width, u.height), c.rotate(Math.PI); break; case 4: c.translate(0, u.height), c.scale(1, -1); break; case 5: c.rotate(0.5 * Math.PI), c.scale(1, -1); break; case 6: c.rotate(0.5 * Math.PI), c.translate(0, -u.width); break; case 7: c.rotate(0.5 * Math.PI), c.translate(u.height, -u.width), c.scale(-1, 1); break; case 8: c.rotate(-0.5 * Math.PI), c.translate(-u.height, 0); }w(c, l, s.srcX != null ? s.srcX : 0, s.srcY != null ? s.srcY : 0, s.srcWidth, s.srcHeight, s.trgX != null ? s.trgX : 0, s.trgY != null ? s.trgY : 0, s.trgWidth, s.trgHeight); const d = u.toDataURL("image/png"); if (o != null) return o(d, u); })); }, o != null && (l.onerror = o), l.src = t.dataURL; } }, { key: "processQueue", value() { const t = this.options.parallelUploads; const e = this.getUploadingFiles().length; let n = e; if (!(e >= t)) { const r = this.getQueuedFiles(); if (r.length > 0) { if (this.options.uploadMultiple) return this.processFiles(r.slice(0, t - e)); for (;n < t;) { if (!r.length) return; this.processFile(r.shift()), n++; } } } } }, { key: "processFile", value(t) { return this.processFiles([t]); } }, { key: "processFiles", value(t) { let e; const n = u(t, !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; r.processing = !0, r.status = o.UPLOADING, this.emit("processing", r); } } catch (t) { n.e(t); } finally { n.f(); } return this.options.uploadMultiple && this.emit("processingmultiple", t), this.uploadFiles(t); } }, { key: "_getFilesWithXhr", value(t) { return this.files.filter(((e) => e.xhr === t)).map(((t) => t)); } }, { key: "cancelUpload", value(t) { if (t.status === o.UPLOADING) { let e; const n = this._getFilesWithXhr(t.xhr); const r = u(n, !0); try { for (r.s(); !(e = r.n()).done;)e.value.status = o.CANCELED; } catch (t) { r.e(t); } finally { r.f(); } void 0 !== t.xhr && t.xhr.abort(); let i; const s = u(n, !0); try { for (s.s(); !(i = s.n()).done;) { const a = i.value; this.emit("canceled", a); } } catch (t) { s.e(t); } finally { s.f(); } this.options.uploadMultiple && this.emit("canceledmultiple", n); } else t.status !== o.ADDED && t.status !== o.QUEUED || (t.status = o.CANCELED, this.emit("canceled", t), this.options.uploadMultiple && this.emit("canceledmultiple", [t])); if (this.options.autoProcessQueue) return this.processQueue(); } }, { key: "resolveOption", value(t) { if (typeof t === "function") { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return t.apply(this, n); } return t; } }, { key: "uploadFile", value(t) { return this.uploadFiles([t]); } }, {
        key: "uploadFiles",
        value(t) {
          const e = this; this._transformFiles(t, ((n) => {
            if (e.options.chunking) { const r = n[0]; t[0].upload.chunked = e.options.chunking && (e.options.forceChunking || r.size > e.options.chunkSize), t[0].upload.totalChunkCount = Math.ceil(r.size / e.options.chunkSize); } if (t[0].upload.chunked) {
              const i = t[0]; const s = n[0]; i.upload.chunks = []; const a = function () {
 for (var n = 0; void 0 !== i.upload.chunks[n];)n++; if (!(n >= i.upload.totalChunkCount)) {
 const r = n * e.options.chunkSize; const a = Math.min(r + e.options.chunkSize, s.size); const l = {
 name: e._getParamName(0), data: s.webkitSlice ? s.webkitSlice(r, a) : s.slice(r, a), filename: i.upload.filename, chunkIndex: n 
}; i.upload.chunks[n] = {
                file: i, index: n, dataBlock: l, status: o.UPLOADING, progress: 0, retries: 0, 
              }, e._uploadData(t, [l]); 
} 
}; if (i.upload.finishedChunkUpload = function (n, r) { let s = !0; n.status = o.SUCCESS, n.dataBlock = null, n.xhr = null; for (let l = 0; l < i.upload.totalChunkCount; l++) { if (void 0 === i.upload.chunks[l]) return a(); i.upload.chunks[l].status !== o.SUCCESS && (s = !1); }s && e.options.chunksUploaded(i, (() => { e._finished(t, r, null); })); }, e.options.parallelChunkUploads) for (let l = 0; l < i.upload.totalChunkCount; l++)a(); else a();
            } else { for (var u = [], c = 0; c < t.length; c++)u[c] = { name: e._getParamName(c), data: n[c], filename: t[c].upload.filename }; e._uploadData(t, u); }
          }));
        }, 
      }, { key: "_getChunk", value(t, e) { for (let n = 0; n < t.upload.totalChunkCount; n++) if (void 0 !== t.upload.chunks[n] && t.upload.chunks[n].xhr === e) return t.upload.chunks[n]; } }, { key: "_uploadData", value(t, e) { let n; const r = this; const i = new XMLHttpRequest(); const s = u(t, !0); try { for (s.s(); !(n = s.n()).done;)n.value.xhr = i; } catch (t) { s.e(t); } finally { s.f(); }t[0].upload.chunked && (t[0].upload.chunks[e[0].chunkIndex].xhr = i); const a = this.resolveOption(this.options.method, t); const l = this.resolveOption(this.options.url, t); i.open(a, l, !0), this.resolveOption(this.options.timeout, t) && (i.timeout = this.resolveOption(this.options.timeout, t)), i.withCredentials = !!this.options.withCredentials, i.onload = function (e) { r._finishedUploading(t, i, e); }, i.ontimeout = function () { r._handleUploadError(t, i, "Request timedout after ".concat(r.options.timeout / 1e3, " seconds")); }, i.onerror = function () { r._handleUploadError(t, i); }, (i.upload != null ? i.upload : i).onprogress = function (e) { return r._updateFilesUploadProgress(t, i, e); }; const c = { Accept: "application/json", "Cache-Control": "no-cache", "X-Requested-With": "XMLHttpRequest" }; for (const d in this.options.headers && o.extend(c, this.options.headers), c) { const h = c[d]; h && i.setRequestHeader(d, h); } const p = new FormData(); if (this.options.params) { let f = this.options.params; for (const m in typeof f === "function" && (f = f.call(this, t, i, t[0].upload.chunked ? this._getChunk(t[0], i) : null)), f) { const g = f[m]; if (Array.isArray(g)) for (let v = 0; v < g.length; v++)p.append(m, g[v]); else p.append(m, g); } } let y; const _ = u(t, !0); try { for (_.s(); !(y = _.n()).done;) { const b = y.value; this.emit("sending", b, i, p); } } catch (t) { _.e(t); } finally { _.f(); } this.options.uploadMultiple && this.emit("sendingmultiple", t, i, p), this._addFormElementData(p); for (let w = 0; w < e.length; w++) { const x = e[w]; p.append(x.name, x.data, x.filename); } this.submitRequest(i, p, t); } }, { key: "_transformFiles", value(t, e) { for (var n = this, r = [], i = 0, o = function (o) { n.options.transformFile.call(n, t[o], ((n) => { r[o] = n, ++i === t.length && e(r); })); }, s = 0; s < t.length; s++)o(s); } }, { key: "_addFormElementData", value(t) { if (this.element.tagName === "FORM") { let e; const n = u(this.element.querySelectorAll("input, textarea, select, button"), !0); try { for (n.s(); !(e = n.n()).done;) { const r = e.value; const i = r.getAttribute("name"); let o = r.getAttribute("type"); if (o && (o = o.toLowerCase()), i != null) if (r.tagName === "SELECT" && r.hasAttribute("multiple")) { var s; const a = u(r.options, !0); try { for (a.s(); !(s = a.n()).done;) { const l = s.value; l.selected && t.append(i, l.value); } } catch (t) { a.e(t); } finally { a.f(); } } else (!o || o !== "checkbox" && o !== "radio" || r.checked) && t.append(i, r.value); } } catch (t) { n.e(t); } finally { n.f(); } } } }, { key: "_updateFilesUploadProgress", value(t, e, n) { if (t[0].upload.chunked) { const r = t[0]; const i = this._getChunk(r, e); n ? (i.progress = 100 * n.loaded / n.total, i.total = n.total, i.bytesSent = n.loaded) : (i.progress = 100, i.bytesSent = i.total), r.upload.progress = 0, r.upload.total = 0, r.upload.bytesSent = 0; for (let o = 0; o < r.upload.totalChunkCount; o++)r.upload.chunks[o] && void 0 !== r.upload.chunks[o].progress && (r.upload.progress += r.upload.chunks[o].progress, r.upload.total += r.upload.chunks[o].total, r.upload.bytesSent += r.upload.chunks[o].bytesSent); r.upload.progress = r.upload.progress / r.upload.totalChunkCount, this.emit("uploadprogress", r, r.upload.progress, r.upload.bytesSent); } else { let s; const a = u(t, !0); try { for (a.s(); !(s = a.n()).done;) { const l = s.value; l.upload.total && l.upload.bytesSent && l.upload.bytesSent == l.upload.total || (n ? (l.upload.progress = 100 * n.loaded / n.total, l.upload.total = n.total, l.upload.bytesSent = n.loaded) : (l.upload.progress = 100, l.upload.bytesSent = l.upload.total), this.emit("uploadprogress", l, l.upload.progress, l.upload.bytesSent)); } } catch (t) { a.e(t); } finally { a.f(); } } } }, { key: "_finishedUploading", value(t, e, n) { let r; if (t[0].status !== o.CANCELED && e.readyState === 4) { if (e.responseType !== "arraybuffer" && e.responseType !== "blob" && (r = e.responseText, e.getResponseHeader("content-type") && ~e.getResponseHeader("content-type").indexOf("application/json"))) try { r = JSON.parse(r); } catch (t) { n = t, r = "Invalid JSON response from server."; } this._updateFilesUploadProgress(t, e), e.status >= 200 && e.status < 300 ? t[0].upload.chunked ? t[0].upload.finishedChunkUpload(this._getChunk(t[0], e), r) : this._finished(t, r, n) : this._handleUploadError(t, e, r); } } }, { key: "_handleUploadError", value(t, e, n) { if (t[0].status !== o.CANCELED) { if (t[0].upload.chunked && this.options.retryChunks) { const r = this._getChunk(t[0], e); if (r.retries++ < this.options.retryChunksLimit) return void this._uploadData(t, [r.dataBlock]); console.warn("Retried this chunk too often. Giving up."); } this._errorProcessing(t, n || this.options.dictResponseError.replace("{{statusCode}}", e.status), e); } } }, { key: "submitRequest", value(t, e, n) { t.readyState == 1 ? t.send(e) : console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED."); } }, { key: "_finished", value(t, e, n) { let r; const i = u(t, !0); try { for (i.s(); !(r = i.n()).done;) { const s = r.value; s.status = o.SUCCESS, this.emit("success", s, e, n), this.emit("complete", s); } } catch (t) { i.e(t); } finally { i.f(); } if (this.options.uploadMultiple && (this.emit("successmultiple", t, e, n), this.emit("completemultiple", t)), this.options.autoProcessQueue) return this.processQueue(); } }, { key: "_errorProcessing", value(t, e, n) { let r; const i = u(t, !0); try { for (i.s(); !(r = i.n()).done;) { const s = r.value; s.status = o.ERROR, this.emit("error", s, e, n), this.emit("complete", s); } } catch (t) { i.e(t); } finally { i.f(); } if (this.options.uploadMultiple && (this.emit("errormultiple", t, e, n), this.emit("completemultiple", t)), this.options.autoProcessQueue) return this.processQueue(); } }], [{ key: "initClass", value() { this.prototype.Emitter = i, this.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"], this.prototype._thumbnailQueue = [], this.prototype._processingThumbnail = !1; } }, { key: "extend", value(t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; for (let i = 0, o = n; i < o.length; i++) { const s = o[i]; for (const a in s) { const l = s[a]; t[a] = l; } } return t; } }, { key: "uuidv4", value() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, ((t) => { const e = 16 * Math.random() | 0; return (t === "x" ? e : 3 & e | 8).toString(16); })); } }]), o;
    }(i)); y.initClass(), y.version = "5.9.2", y.options = {}, y.optionsForElement = function (t) { return t.getAttribute("id") ? y.options[b(t.getAttribute("id"))] : void 0; }, y.instances = [], y.forElement = function (t) { if (typeof t === "string" && (t = document.querySelector(t)), (t != null ? t.dropzone : void 0) == null) throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone."); return t.dropzone; }, y.autoDiscover = !0, y.discover = function () { let t; if (document.querySelectorAll)t = document.querySelectorAll(".dropzone"); else { t = []; const e = function (e) { return (function () { let n; const r = []; const i = u(e, !0); try { for (i.s(); !(n = i.n()).done;) { const o = n.value; /(^| )dropzone($| )/.test(o.className) ? r.push(t.push(o)) : r.push(void 0); } } catch (t) { i.e(t); } finally { i.f(); } return r; }()); }; e(document.getElementsByTagName("div")), e(document.getElementsByTagName("form")); } return (function () { let e; const n = []; const r = u(t, !0); try { for (r.s(); !(e = r.n()).done;) { const i = e.value; !1 !== y.optionsForElement(i) ? n.push(new y(i)) : n.push(void 0); } } catch (t) { r.e(t); } finally { r.f(); } return n; }()); }, y.blockedBrowsers = [/opera.*(Macintosh|Windows Phone).*version\/12/i], y.isBrowserSupported = function () { let t = !0; if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) if ("classList" in document.createElement("a")) { void 0 !== y.blacklistedBrowsers && (y.blockedBrowsers = y.blacklistedBrowsers); let e; const n = u(y.blockedBrowsers, !0); try { for (n.s(); !(e = n.n()).done;)e.value.test(navigator.userAgent) && (t = !1); } catch (t) { n.e(t); } finally { n.f(); } } else t = !1; else t = !1; return t; }, y.dataURItoBlob = function (t) { for (var e = atob(t.split(",")[1]), n = t.split(",")[0].split(":")[1].split(";")[0], r = new ArrayBuffer(e.length), i = new Uint8Array(r), o = 0, s = e.length, a = s >= 0; a ? o <= s : o >= s; a ? o++ : o--)i[o] = e.charCodeAt(o); return new Blob([r], { type: n }); }; var _ = function (t, e) { return t.filter(((t) => t !== e)).map(((t) => t)); }; var b = function (t) { return t.replace(/[\-_](\w)/g, ((t) => t.charAt(1).toUpperCase())); }; y.createElement = function (t) { const e = document.createElement("div"); return e.innerHTML = t, e.childNodes[0]; }, y.elementInside = function (t, e) { if (t === e) return !0; for (;t = t.parentNode;) if (t === e) return !0; return !1; }, y.getElement = function (t, e) { let n; if (typeof t === "string" ? n = document.querySelector(t) : t.nodeType != null && (n = t), n == null) throw new Error("Invalid `".concat(e, "` option provided. Please provide a CSS selector or a plain HTML element.")); return n; }, y.getElements = function (t, e) { let n; let r; if (t instanceof Array) { r = []; try { let i; const o = u(t, !0); try { for (o.s(); !(i = o.n()).done;)n = i.value, r.push(this.getElement(n, e)); } catch (t) { o.e(t); } finally { o.f(); } } catch (t) { r = null; } } else if (typeof t === "string") { r = []; let s; const a = u(document.querySelectorAll(t), !0); try { for (a.s(); !(s = a.n()).done;)n = s.value, r.push(n); } catch (t) { a.e(t); } finally { a.f(); } } else t.nodeType != null && (r = [t]); if (r == null || !r.length) throw new Error("Invalid `".concat(e, "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.")); return r; }, y.confirm = function (t, e, n) { return window.confirm(t) ? e() : n != null ? n() : void 0; }, y.isValidFile = function (t, e) { if (!e) return !0; e = e.split(","); let n; const r = t.type; const i = r.replace(/\/.*$/, ""); const o = u(e, !0); try { for (o.s(); !(n = o.n()).done;) { let s = n.value; if ((s = s.trim()).charAt(0) === ".") { if (t.name.toLowerCase().indexOf(s.toLowerCase(), t.name.length - s.length) !== -1) return !0; } else if (/\/\*$/.test(s)) { if (i === s.replace(/\/.*$/, "")) return !0; } else if (r === s) return !0; } } catch (t) { o.e(t); } finally { o.f(); } return !1; }, typeof jQuery !== "undefined" && jQuery !== null && (jQuery.fn.dropzone = function (t) { return this.each((function () { return new y(this, t); })); }), y.ADDED = "added", y.QUEUED = "queued", y.ACCEPTED = y.QUEUED, y.UPLOADING = "uploading", y.PROCESSING = y.UPLOADING, y.CANCELED = "canceled", y.ERROR = "error", y.SUCCESS = "success"; var w = function (t, e, n, r, i, o, s, a, l, u) { const c = (function (t) { t.naturalWidth; const e = t.naturalHeight; const n = document.createElement("canvas"); n.width = 1, n.height = e; const r = n.getContext("2d"); r.drawImage(t, 0, 0); for (var i = r.getImageData(1, 0, 1, e).data, o = 0, s = e, a = e; a > o;)i[4 * (a - 1) + 3] === 0 ? s = a : o = a, a = s + o >> 1; const l = a / e; return l === 0 ? 1 : l; }(e)); return t.drawImage(e, n, r, i, o, s, a, l, u / c); }; var x = (function () { function t() { d(this, t); } return p(t, null, [{ key: "initClass", value() { this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; } }, { key: "encode64", value(t) { for (var e = "", n = void 0, r = void 0, i = "", o = void 0, s = void 0, a = void 0, l = "", u = 0; o = (n = t[u++]) >> 2, s = (3 & n) << 4 | (r = t[u++]) >> 4, a = (15 & r) << 2 | (i = t[u++]) >> 6, l = 63 & i, isNaN(r) ? a = l = 64 : isNaN(i) && (l = 64), e = e + this.KEY_STR.charAt(o) + this.KEY_STR.charAt(s) + this.KEY_STR.charAt(a) + this.KEY_STR.charAt(l), n = r = i = "", o = s = a = l = "", u < t.length;);return e; } }, { key: "restore", value(t, e) { if (!t.match("data:image/jpeg;base64,")) return e; const n = this.decode64(t.replace("data:image/jpeg;base64,", "")); const r = this.slice2Segments(n); const i = this.exifManipulation(e, r); return "data:image/jpeg;base64,".concat(this.encode64(i)); } }, { key: "exifManipulation", value(t, e) { const n = this.getExifArray(e); const r = this.insertExif(t, n); return new Uint8Array(r); } }, { key: "getExifArray", value(t) { for (let e = void 0, n = 0; n < t.length;) { if ((e = t[n])[0] === 255 & e[1] === 225) return e; n++; } return []; } }, { key: "insertExif", value(t, e) { const n = t.replace("data:image/jpeg;base64,", ""); const r = this.decode64(n); const i = r.indexOf(255, 3); const o = r.slice(0, i); const s = r.slice(i); return o.concat(e).concat(s); } }, { key: "slice2Segments", value(t) { for (var e = 0, n = []; !(t[e] === 255 & t[e + 1] === 218);) { if (t[e] === 255 & t[e + 1] === 216)e += 2; else { const r = e + (256 * t[e + 2] + t[e + 3]) + 2; const i = t.slice(e, r); n.push(i), e = r; } if (e > t.length) break; } return n; } }, { key: "decode64", value(t) { let e = void 0; let n = void 0; let r = ""; let i = void 0; let o = void 0; let s = ""; let a = 0; const l = []; for (/[^A-Za-z0-9\+\/\=]/g.exec(t) && console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding."), t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); e = this.KEY_STR.indexOf(t.charAt(a++)) << 2 | (i = this.KEY_STR.indexOf(t.charAt(a++))) >> 4, n = (15 & i) << 4 | (o = this.KEY_STR.indexOf(t.charAt(a++))) >> 2, r = (3 & o) << 6 | (s = this.KEY_STR.indexOf(t.charAt(a++))), l.push(e), o !== 64 && l.push(n), s !== 64 && l.push(r), e = n = r = "", i = o = s = "", a < t.length;);return l; } }]), t; }()); x.initClass(), y._autoDiscoverFunction = function () { if (y.autoDiscover) return y.discover(); }, (function (t, e) { let n = !1; let r = !0; const i = t.document; const o = i.documentElement; const s = i.addEventListener ? "addEventListener" : "attachEvent"; const a = i.addEventListener ? "removeEventListener" : "detachEvent"; const l = i.addEventListener ? "" : "on"; const u = function r(o) { if (o.type !== "readystatechange" || i.readyState === "complete") return (o.type === "load" ? t : i)[a](l + o.type, r, !1), !n && (n = !0) ? e.call(t, o.type || o) : void 0; }; if (i.readyState !== "complete") { if (i.createEventObject && o.doScroll) { try { r = !t.frameElement; } catch (t) {}r && (function t() { try { o.doScroll("left"); } catch (e) { return void setTimeout(t, 50); } return u("poll"); }()); }i[s](`${l}DOMContentLoaded`, u, !1), i[s](`${l}readystatechange`, u, !1), t[s](`${l}load`, u, !1); } }(window, y._autoDiscoverFunction)), window.Dropzone = y; var S = y;
  }()), r;
}())))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSStepForm = e() : t.HSStepForm = e(); }(window, (() => {
  return d = {
    "./src/js/hs-step-form.js": function (module, __webpack_exports__, __webpack_require__) {
      eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return HSStepForm; });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n* HSStepForm Plugin\n* @version: 3.0.1 (Sun, 1 Aug 2021)\n* @author: HtmlStream\n* @event-namespace: .HSStepForm\n* @license: Htmlstream Libraries (https://htmlstream.com/)\n* Copyright 2021 Htmlstream\n*/\nvar dataAttributeName = 'data-hs-step-form-options';\nvar defaults = {\n  progressSelector: null,\n  progressItems: null,\n  stepsSelector: null,\n  stepsItems: null,\n  stepsActiveItem: null,\n  nextSelector: '[data-hs-step-form-next-options]',\n  prevSelector: '[data-hs-step-form-prev-options]',\n  endSelector: null,\n  isValidate: false,\n  classMap: {\n    active: 'active',\n    checked: 'is-valid',\n    error: 'is-invalid',\n    required: 'js-step-required',\n    focus: 'focus'\n  },\n  finish: function finish() {},\n  preventNextStep: function preventNextStep() {\n    return new Promise(function (resolve, reject) {\n      resolve();\n    });\n  },\n  onNextStep: function onNextStep() {},\n  onPrevStep: function onPrevStep() {}\n};\n\nvar HSStepForm = /*#__PURE__*/function () {\n  function HSStepForm(el, options, id) {\n    _classCallCheck(this, HSStepForm);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSStepForm, [{\n    key: \"_init\",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty('$initializedEl')) {\n          return \"continue\";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options;\n        _options.progressItems = _$el.querySelector(_options.progressSelector).children;\n        _options.stepsItems = _$el.querySelector(_options.stepsSelector).children;\n        _options.stepsActiveItem = _$el.querySelector(_options.stepsSelector).querySelector(\".\".concat(_options.classMap.active));\n\n        that._prepareObject(_$el, _options);\n\n        _$el.querySelectorAll(_options.nextSelector).forEach(function (item) {\n          item.addEventListener('click', function () {\n            that._nextClickEvents(_$el, _options, item);\n          });\n        });\n\n        _$el.querySelectorAll(_options.prevSelector).forEach(function (item) {\n          item.addEventListener('click', function () {\n            that._prevClickEvents(_$el, _options, item);\n          });\n        });\n\n        _$el.querySelectorAll(_options.endSelector).forEach(function (item) {\n          item.addEventListener('click', function () {\n            that._endClickEvents(_$el, _options);\n          });\n        });\n\n        that.collection[i].$initializedEl = _options;\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"_prepareObject\",\n    value: function _prepareObject($el, settings) {\n      $el.querySelector(settings.stepsSelector).querySelectorAll(\":scope > :not(.\".concat(settings.classMap.active, \")\")).forEach(function (item) {\n        item.style.display = 'none';\n      });\n\n      settings.progressItems[_toConsumableArray(settings.stepsActiveItem.parentNode.children).indexOf(settings.stepsActiveItem)].classList.add(settings.classMap.active, settings.classMap.focus);\n    }\n  }, {\n    key: \"_endClickEvents\",\n    value: function _endClickEvents($el, settings) {\n      var isValid = true;\n\n      if (settings.isValidate) {\n        $el.classList.remove('was-validated');\n        settings.progressItems[settings.progressItems.length - 1].classList.remove(settings.classMap.error);\n        Array.from($el.elements).forEach(function (item) {\n          if (item.offsetParent !== null && !item.checkValidity()) {\n            isValid = false;\n            settings.progressItems[settings.progressItems.length - 1].classList.add(settings.classMap.error);\n\n            if (settings.validator) {\n              settings.validator.updateFieldStete(item);\n              $el.classList.add('was-validated');\n            }\n          }\n        });\n      }\n\n      if (isValid) {\n        return settings.finish($el, settings);\n      }\n    }\n  }, {\n    key: \"_nextClickEvents\",\n    value: function _nextClickEvents($el, settings, nextEl) {\n      var _this = this;\n\n      var nextDataSettings = nextEl.hasAttribute('data-hs-step-form-next-options') ? JSON.parse(nextEl.getAttribute('data-hs-step-form-next-options')) : {};\n      var nextItemDefaults = {\n        targetSelector: null\n      },\n          nextItemOptions = Object.assign({}, nextItemDefaults, nextDataSettings);\n      var targetSelector = $el.querySelector(nextItemOptions.targetSelector);\n\n      var targetIndex = _toConsumableArray(targetSelector.parentNode.children).indexOf(targetSelector);\n\n      for (var i = 0; i < settings.progressItems.length; i++) {\n        if (settings.isValidate) {\n          if (settings.validator) {\n            $el.classList.remove('was-validated');\n          }\n\n          if (targetIndex > i) {\n            settings.progressItems[i].classList.add(settings.classMap.error);\n            var requiredSelector = settings.progressItems[i].querySelector(settings.nextSelector).getAttribute('data-hs-step-form-next-options');\n\n            var _iterator = _createForOfIteratorHelper(settings.stepsItems),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var item = _step.value;\n                item.classList.remove(settings.classMap.active);\n                item.style.display = 'none';\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            var newTargetSelector = $el.querySelector(JSON.parse(requiredSelector).targetSelector);\n            newTargetSelector.classList.add(settings.classMap.active);\n            newTargetSelector.style.display = 'block';\n            var isValid = true;\n            Array.from($el.elements).forEach(function (item) {\n              if (item.offsetParent !== null && !item.checkValidity()) {\n                isValid = false;\n\n                if (settings.validator) {\n                  settings.validator.updateFieldStete(item);\n                  $el.classList.add('was-validated');\n                }\n              }\n            });\n\n            if (!isValid) {\n              settings.progressItems[i].classList.remove(settings.classMap.checked);\n              return false;\n            } else {\n              settings.progressItems[i].classList.remove(settings.classMap.error);\n            }\n          }\n\n          if (targetIndex > i && settings.isValidate) {\n            settings.progressItems[i].classList.add(settings.classMap.checked);\n          }\n        } else {\n          if (targetIndex > i && settings.isValidate) {\n            settings.progressItems[i].classList.add(settings.classMap.checked);\n          }\n\n          if (targetIndex > i && !settings.isValidate) {\n            settings.progressItems[i].classList.add(settings.classMap.active);\n          }\n        }\n      }\n\n      settings.preventNextStep($el).then(function () {\n        var _iterator2 = _createForOfIteratorHelper(settings.progressItems),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _item = _step2.value;\n\n            _item.classList.remove(settings.classMap.active, settings.classMap.focus);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        settings.progressItems[targetIndex].classList.add(settings.classMap.active, settings.classMap.focus);\n\n        var _iterator3 = _createForOfIteratorHelper(settings.stepsItems),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _item2 = _step3.value;\n\n            _item2.classList.remove(settings.classMap.active);\n\n            _item2.style.display = 'none';\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        targetSelector.classList.add(settings.classMap.active);\n\n        _this.fadeIn(targetSelector, 400);\n\n        return settings.onNextStep();\n      });\n    }\n  }, {\n    key: \"_prevClickEvents\",\n    value: function _prevClickEvents($el, settings, prevEl) {\n      var prevDataSettings = prevEl.hasAttribute('data-hs-step-form-prev-options') ? JSON.parse(prevEl.getAttribute('data-hs-step-form-prev-options')) : {};\n      var prevItemDefaults = {\n        targetSelector: null\n      },\n          prevItemOptions = Object.assign({}, prevItemDefaults, prevDataSettings);\n      var targetSelector = $el.querySelector(prevItemOptions.targetSelector);\n\n      var targetIndex = _toConsumableArray(targetSelector.parentNode.children).indexOf(targetSelector);\n\n      for (var i = 0; i < settings.progressItems.length; i++) {\n        if (settings.isValidate) {\n          if (targetIndex > i) {\n            settings.progressItems[i].classList.add(settings.classMap.error);\n            var requiredSelector = settings.progressItems[i].querySelector(settings.nextSelector).getAttribute('data-hs-step-form-next-options');\n\n            var _iterator4 = _createForOfIteratorHelper(settings.stepsItems),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var item = _step4.value;\n                item.classList.remove(settings.classMap.active);\n                item.style.display = 'none';\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            var newTargetSelector = $el.querySelector(JSON.parse(requiredSelector).targetSelector);\n            newTargetSelector.classList.add(settings.classMap.active);\n            newTargetSelector.style.display = 'block';\n            var isValid = true;\n            Array.from($el.elements).forEach(function (item) {\n              if (item.offsetParent !== null && !item.checkValidity()) {\n                isValid = false;\n              }\n            });\n\n            if (!isValid) {\n              settings.progressItems[i].classList.remove(settings.classMap.checked);\n              return false;\n            } else {\n              settings.progressItems[i].classList.remove(settings.classMap.error);\n            }\n          }\n\n          if (targetIndex > i && settings.isValidate) {\n            settings.progressItems[i].classList.add(settings.classMap.checked);\n          }\n        } else {\n          if (targetIndex > i && settings.isValidate) {\n            settings.progressItems[i].classList.add(settings.classMap.checked);\n          }\n\n          if (targetIndex > i && !settings.isValidate) {\n            settings.progressItems[i].classList.add(settings.classMap.active);\n          }\n        }\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(settings.progressItems),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _item3 = _step5.value;\n\n          _item3.classList.remove(settings.classMap.active, settings.classMap.focus);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      settings.progressItems[targetIndex].classList.add(settings.classMap.active, settings.classMap.focus);\n\n      var _iterator6 = _createForOfIteratorHelper(settings.stepsItems),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _item4 = _step6.value;\n\n          _item4.classList.remove(settings.classMap.active);\n\n          _item4.style.display = 'none';\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      targetSelector.classList.add(settings.classMap.active);\n      this.fadeIn(targetSelector, 400);\n      return settings.onPrevStep();\n    }\n  }, {\n    key: \"fadeIn\",\n    value: function fadeIn(el, time) {\n      el.style.opacity = 0;\n      el.style.display = 'block';\n      var last = +new Date();\n\n      var tick = function tick() {\n        el.style.opacity = +el.style.opacity + (new Date() - last) / time;\n        last = +new Date();\n\n        if (+el.style.opacity < 1) {\n          window.requestAnimationFrame && requestAnimationFrame(tick) || setTimeout(tick, 16);\n        }\n      };\n\n      tick();\n    }\n  }, {\n    key: \"addToCollection\",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(item) {\n      if (typeof item === 'number') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSStepForm;\n}();\n\n\n\n//# sourceURL=webpack://HSStepForm/./src/js/hs-step-form.js?");
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-step-form.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), (function (t, e) { typeof exports === "object" && void 0 !== module ? module.exports = e(function () { try { return require("moment"); } catch (t) {} }()) : typeof define === "function" && define.amd ? define(["require"], ((t) => e(function () { try { return t("moment"); } catch (t) {} }()))) : (t = t || self).Chart = e(t.moment); }(this, ((t) => {
  t = t && t.hasOwnProperty("default") ? t.default : t; const e = {
    aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
  }; const n = (function (t, e) { return t(e = { exports: {} }), e.exports; }(((t) => {
    const n = {}; for (const r in e)e.hasOwnProperty(r) && (n[e[r]] = r); const i = t.exports = {
      rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] },
    }; for (const o in i) if (i.hasOwnProperty(o)) { if (!("channels" in i[o])) throw new Error(`missing channels property: ${o}`); if (!("labels" in i[o])) throw new Error(`missing channel labels property: ${o}`); if (i[o].labels.length !== i[o].channels) throw new Error(`channel and label counts mismatch: ${o}`); const s = i[o].channels; const a = i[o].labels; delete i[o].channels, delete i[o].labels, Object.defineProperty(i[o], "channels", { value: s }), Object.defineProperty(i[o], "labels", { value: a }); }i.rgb.hsl = function (t) { let e; let n; const r = t[0] / 255; const i = t[1] / 255; const o = t[2] / 255; const s = Math.min(r, i, o); const a = Math.max(r, i, o); const l = a - s; return a === s ? e = 0 : r === a ? e = (i - o) / l : i === a ? e = 2 + (o - r) / l : o === a && (e = 4 + (r - i) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), n = (s + a) / 2, [e, 100 * (a === s ? 0 : n <= 0.5 ? l / (a + s) : l / (2 - a - s)), 100 * n]; }, i.rgb.hsv = function (t) { let e; let n; let r; let i; let o; const s = t[0] / 255; const a = t[1] / 255; const l = t[2] / 255; const u = Math.max(s, a, l); const c = u - Math.min(s, a, l); const d = function (t) { return (u - t) / 6 / c + 0.5; }; return c === 0 ? i = o = 0 : (o = c / u, e = d(s), n = d(a), r = d(l), s === u ? i = r - n : a === u ? i = 1 / 3 + e - r : l === u && (i = 2 / 3 + n - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [360 * i, 100 * o, 100 * u]; }, i.rgb.hwb = function (t) { const e = t[0]; const n = t[1]; let r = t[2]; return [i.rgb.hsl(t)[0], 1 / 255 * Math.min(e, Math.min(n, r)) * 100, 100 * (r = 1 - 1 / 255 * Math.max(e, Math.max(n, r)))]; }, i.rgb.cmyk = function (t) { let e; const n = t[0] / 255; const r = t[1] / 255; const i = t[2] / 255; return [100 * ((1 - n - (e = Math.min(1 - n, 1 - r, 1 - i))) / (1 - e) || 0), 100 * ((1 - r - e) / (1 - e) || 0), 100 * ((1 - i - e) / (1 - e) || 0), 100 * e]; }, i.rgb.keyword = function (t) { const r = n[t]; if (r) return r; let i; let o; let s; let a = 1 / 0; for (const l in e) if (e.hasOwnProperty(l)) { const u = (o = t, s = e[l], (o[0] - s[0]) ** 2 + (o[1] - s[1]) ** 2 + (o[2] - s[2]) ** 2); u < a && (a = u, i = l); } return i; }, i.keyword.rgb = function (t) { return e[t]; }, i.rgb.xyz = function (t) { let e = t[0] / 255; let n = t[1] / 255; let r = t[2] / 255; return [100 * (0.4124 * (e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92) + 0.3576 * (n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92) + 0.1805 * (r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92)), 100 * (0.2126 * e + 0.7152 * n + 0.0722 * r), 100 * (0.0193 * e + 0.1192 * n + 0.9505 * r)]; }, i.rgb.lab = function (t) { const e = i.rgb.xyz(t); let n = e[0]; let r = e[1]; let o = e[2]; return r /= 100, o /= 108.883, n = (n /= 95.047) > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, [116 * (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116) - 16, 500 * (n - r), 200 * (r - (o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116))]; }, i.hsl.rgb = function (t) { let e; let n; let r; let i; let o; const s = t[0] / 360; const a = t[1] / 100; const l = t[2] / 100; if (a === 0) return [o = 255 * l, o, o]; e = 2 * l - (n = l < 0.5 ? l * (1 + a) : l + a - l * a), i = [0, 0, 0]; for (let u = 0; u < 3; u++)(r = s + 1 / 3 * -(u - 1)) < 0 && r++, r > 1 && r--, o = 6 * r < 1 ? e + 6 * (n - e) * r : 2 * r < 1 ? n : 3 * r < 2 ? e + (n - e) * (2 / 3 - r) * 6 : e, i[u] = 255 * o; return i; }, i.hsl.hsv = function (t) { const e = t[0]; let n = t[1] / 100; let r = t[2] / 100; let i = n; const o = Math.max(r, 0.01); return n *= (r *= 2) <= 1 ? r : 2 - r, i *= o <= 1 ? o : 2 - o, [e, 100 * (r === 0 ? 2 * i / (o + i) : 2 * n / (r + n)), (r + n) / 2 * 100]; }, i.hsv.rgb = function (t) { const e = t[0] / 60; const n = t[1] / 100; let r = t[2] / 100; const i = Math.floor(e) % 6; const o = e - Math.floor(e); const s = 255 * r * (1 - n); const a = 255 * r * (1 - n * o); const l = 255 * r * (1 - n * (1 - o)); switch (r *= 255, i) { case 0: return [r, l, s]; case 1: return [a, r, s]; case 2: return [s, r, l]; case 3: return [s, a, r]; case 4: return [l, s, r]; case 5: return [r, s, a]; } }, i.hsv.hsl = function (t) { let e; let n; let r; const i = t[0]; const o = t[1] / 100; const s = t[2] / 100; const a = Math.max(s, 0.01); return r = (2 - o) * s, n = o * a, [i, 100 * (n = (n /= (e = (2 - o) * a) <= 1 ? e : 2 - e) || 0), 100 * (r /= 2)]; }, i.hwb.rgb = function (t) { let e; let n; let r; let i; let o; let s; let a; const l = t[0] / 360; let u = t[1] / 100; let c = t[2] / 100; const d = u + c; switch (d > 1 && (u /= d, c /= d), r = 6 * l - (e = Math.floor(6 * l)), (1 & e) != 0 && (r = 1 - r), i = u + r * ((n = 1 - c) - u), e) { default: case 6: case 0: o = n, s = i, a = u; break; case 1: o = i, s = n, a = u; break; case 2: o = u, s = n, a = i; break; case 3: o = u, s = i, a = n; break; case 4: o = i, s = u, a = n; break; case 5: o = n, s = u, a = i; } return [255 * o, 255 * s, 255 * a]; }, i.cmyk.rgb = function (t) { const e = t[0] / 100; const n = t[1] / 100; const r = t[2] / 100; const i = t[3] / 100; return [255 * (1 - Math.min(1, e * (1 - i) + i)), 255 * (1 - Math.min(1, n * (1 - i) + i)), 255 * (1 - Math.min(1, r * (1 - i) + i))]; }, i.xyz.rgb = function (t) { let e; let n; let r; const i = t[0] / 100; const o = t[1] / 100; const s = t[2] / 100; return n = -0.9689 * i + 1.8758 * o + 0.0415 * s, r = 0.0557 * i + -0.204 * o + 1.057 * s, e = (e = 3.2406 * i + -1.5372 * o + -0.4986 * s) > 0.0031308 ? 1.055 * e ** (1 / 2.4) - 0.055 : 12.92 * e, n = n > 0.0031308 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n, r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (n = Math.min(Math.max(0, n), 1)), 255 * (r = Math.min(Math.max(0, r), 1))]; }, i.xyz.lab = function (t) { let e = t[0]; let n = t[1]; let r = t[2]; return n /= 100, r /= 108.883, e = (e /= 95.047) > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116, [116 * (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (e - n), 200 * (n - (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116))]; }, i.lab.xyz = function (t) { let e; let n; let r; const i = t[0]; e = t[1] / 500 + (n = (i + 16) / 116), r = n - t[2] / 200; const o = n ** 3; const s = e ** 3; const a = r ** 3; return n = o > 0.008856 ? o : (n - 16 / 116) / 7.787, e = s > 0.008856 ? s : (e - 16 / 116) / 7.787, r = a > 0.008856 ? a : (r - 16 / 116) / 7.787, [e *= 95.047, n *= 100, r *= 108.883]; }, i.lab.lch = function (t) { let e; const n = t[0]; const r = t[1]; const i = t[2]; return (e = 360 * Math.atan2(i, r) / 2 / Math.PI) < 0 && (e += 360), [n, Math.sqrt(r * r + i * i), e]; }, i.lch.lab = function (t) { let e; const n = t[0]; const r = t[1]; return e = t[2] / 360 * 2 * Math.PI, [n, r * Math.cos(e), r * Math.sin(e)]; }, i.rgb.ansi16 = function (t) { const e = t[0]; const n = t[1]; const r = t[2]; let o = 1 in arguments ? arguments[1] : i.rgb.hsv(t)[2]; if ((o = Math.round(o / 50)) === 0) return 30; let s = 30 + (Math.round(r / 255) << 2 | Math.round(n / 255) << 1 | Math.round(e / 255)); return o === 2 && (s += 60), s; }, i.hsv.ansi16 = function (t) { return i.rgb.ansi16(i.hsv.rgb(t), t[2]); }, i.rgb.ansi256 = function (t) { const e = t[0]; const n = t[1]; const r = t[2]; return e === n && n === r ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5); }, i.ansi16.rgb = function (t) { let e = t % 10; if (e === 0 || e === 7) return t > 50 && (e += 3.5), [e = e / 10.5 * 255, e, e]; const n = 0.5 * (1 + ~~(t > 50)); return [(1 & e) * n * 255, (e >> 1 & 1) * n * 255, (e >> 2 & 1) * n * 255]; }, i.ansi256.rgb = function (t) { if (t >= 232) { const e = 10 * (t - 232) + 8; return [e, e, e]; } let n; return t -= 16, [Math.floor(t / 36) / 5 * 255, Math.floor((n = t % 36) / 6) / 5 * 255, n % 6 / 5 * 255]; }, i.rgb.hex = function (t) { const e = (((255 & Math.round(t[0])) << 16) + ((255 & Math.round(t[1])) << 8) + (255 & Math.round(t[2]))).toString(16).toUpperCase(); return "000000".substring(e.length) + e; }, i.hex.rgb = function (t) { const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i); if (!e) return [0, 0, 0]; let n = e[0]; e[0].length === 3 && (n = n.split("").map(((t) => t + t)).join("")); const r = parseInt(n, 16); return [r >> 16 & 255, r >> 8 & 255, 255 & r]; }, i.rgb.hcg = function (t) { let e; const n = t[0] / 255; const r = t[1] / 255; const i = t[2] / 255; const o = Math.max(Math.max(n, r), i); const s = Math.min(Math.min(n, r), i); const a = o - s; return e = a <= 0 ? 0 : o === n ? (r - i) / a % 6 : o === r ? 2 + (i - n) / a : 4 + (n - r) / a + 4, e /= 6, [360 * (e %= 1), 100 * a, 100 * (a < 1 ? s / (1 - a) : 0)]; }, i.hsl.hcg = function (t) { let e; const n = t[1] / 100; const r = t[2] / 100; let i = 0; return (e = r < 0.5 ? 2 * n * r : 2 * n * (1 - r)) < 1 && (i = (r - 0.5 * e) / (1 - e)), [t[0], 100 * e, 100 * i]; }, i.hsv.hcg = function (t) { const e = t[1] / 100; const n = t[2] / 100; const r = e * n; let i = 0; return r < 1 && (i = (n - r) / (1 - r)), [t[0], 100 * r, 100 * i]; }, i.hcg.rgb = function (t) { const e = t[0] / 360; const n = t[1] / 100; const r = t[2] / 100; if (n === 0) return [255 * r, 255 * r, 255 * r]; let i; const o = [0, 0, 0]; const s = e % 1 * 6; const a = s % 1; const l = 1 - a; switch (Math.floor(s)) { case 0: o[0] = 1, o[1] = a, o[2] = 0; break; case 1: o[0] = l, o[1] = 1, o[2] = 0; break; case 2: o[0] = 0, o[1] = 1, o[2] = a; break; case 3: o[0] = 0, o[1] = l, o[2] = 1; break; case 4: o[0] = a, o[1] = 0, o[2] = 1; break; default: o[0] = 1, o[1] = 0, o[2] = l; } return i = (1 - n) * r, [255 * (n * o[0] + i), 255 * (n * o[1] + i), 255 * (n * o[2] + i)]; }, i.hcg.hsv = function (t) { const e = t[1] / 100; const n = e + t[2] / 100 * (1 - e); let r = 0; return n > 0 && (r = e / n), [t[0], 100 * r, 100 * n]; }, i.hcg.hsl = function (t) { const e = t[1] / 100; const n = t[2] / 100 * (1 - e) + 0.5 * e; let r = 0; return n > 0 && n < 0.5 ? r = e / (2 * n) : n >= 0.5 && n < 1 && (r = e / (2 * (1 - n))), [t[0], 100 * r, 100 * n]; }, i.hcg.hwb = function (t) { const e = t[1] / 100; const n = e + t[2] / 100 * (1 - e); return [t[0], 100 * (n - e), 100 * (1 - n)]; }, i.hwb.hcg = function (t) { const e = t[1] / 100; const n = 1 - t[2] / 100; const r = n - e; let i = 0; return r < 1 && (i = (n - r) / (1 - r)), [t[0], 100 * r, 100 * i]; }, i.apple.rgb = function (t) { return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255]; }, i.rgb.apple = function (t) { return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535]; }, i.gray.rgb = function (t) { return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255]; }, i.gray.hsl = i.gray.hsv = function (t) { return [0, 0, t[0]]; }, i.gray.hwb = function (t) { return [0, 100, t[0]]; }, i.gray.cmyk = function (t) { return [0, 0, 0, t[0]]; }, i.gray.lab = function (t) { return [t[0], 0, 0]; }, i.gray.hex = function (t) { const e = 255 & Math.round(t[0] / 100 * 255); const n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase(); return "000000".substring(n.length) + n; }, i.rgb.gray = function (t) { return [(t[0] + t[1] + t[2]) / 3 / 255 * 100]; };
  }))); function r(t) { const e = (function () { for (var t = {}, e = Object.keys(n), r = e.length, i = 0; i < r; i++)t[e[i]] = { distance: -1, parent: null }; return t; }()); const r = [t]; for (e[t].distance = 0; r.length;) for (let i = r.pop(), o = Object.keys(n[i]), s = o.length, a = 0; a < s; a++) { const l = o[a]; const u = e[l]; u.distance === -1 && (u.distance = e[i].distance + 1, u.parent = i, r.unshift(l)); } return e; } function i(t, e) { return function (n) { return e(t(n)); }; } function o(t, e) { for (var r = [e[t].parent, t], o = n[e[t].parent][t], s = e[t].parent; e[s].parent;)r.unshift(e[s].parent), o = i(n[e[s].parent][s], o), s = e[s].parent; return o.conversion = r, o; }n.rgb, n.hsl, n.hsv, n.hwb, n.cmyk, n.xyz, n.lab, n.lch, n.hex, n.keyword, n.ansi16, n.ansi256, n.hcg, n.apple, n.gray; const s = {}; Object.keys(n).forEach(((t) => { s[t] = {}, Object.defineProperty(s[t], "channels", { value: n[t].channels }), Object.defineProperty(s[t], "labels", { value: n[t].labels }); const e = (function (t) { for (var e = r(t), n = {}, i = Object.keys(e), s = i.length, a = 0; a < s; a++) { const l = i[a]; e[l].parent !== null && (n[l] = o(l, e)); } return n; }(t)); Object.keys(e).forEach(((n) => { const r = e[n]; s[t][n] = (function (t) { const e = function (e) { if (e == null) return e; arguments.length > 1 && (e = Array.prototype.slice.call(arguments)); const n = t(e); if (typeof n === "object") for (let r = n.length, i = 0; i < r; i++)n[i] = Math.round(n[i]); return n; }; return "conversion" in t && (e.conversion = t.conversion), e; }(r)), s[t][n].raw = (function (t) { const e = function (e) { return e == null ? e : (arguments.length > 1 && (e = Array.prototype.slice.call(arguments)), t(e)); }; return "conversion" in t && (e.conversion = t.conversion), e; }(r)); })); })); const a = s; const l = {
    aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50],
  }; const u = {
    getRgba: c, getHsla: d, getRgb(t) { const e = c(t); return e && e.slice(0, 3); }, getHsl(t) { const e = d(t); return e && e.slice(0, 3); }, getHwb: h, getAlpha(t) { let e = c(t); return e || (e = d(t)) || (e = h(t)) ? e[3] : void 0; }, hexString(t, e) { return e = void 0 !== e && t.length === 3 ? e : t[3], `#${v(t[0])}${v(t[1])}${v(t[2])}${e >= 0 && e < 1 ? v(Math.round(255 * e)) : ""}`; }, rgbString(t, e) { return e < 1 || t[3] && t[3] < 1 ? p(t, e) : `rgb(${t[0]}, ${t[1]}, ${t[2]})`; }, rgbaString: p, percentString(t, e) { return e < 1 || t[3] && t[3] < 1 ? f(t, e) : `rgb(${Math.round(t[0] / 255 * 100)}%, ${Math.round(t[1] / 255 * 100)}%, ${Math.round(t[2] / 255 * 100)}%)`; }, percentaString: f, hslString(t, e) { return e < 1 || t[3] && t[3] < 1 ? m(t, e) : `hsl(${t[0]}, ${t[1]}%, ${t[2]}%)`; }, hslaString: m, hwbString(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `hwb(${t[0]}, ${t[1]}%, ${t[2]}%${void 0 !== e && e !== 1 ? `, ${e}` : ""})`; }, keyword(t) { return y[t.slice(0, 3)]; },
  }; function c(t) { if (t) { let e = [0, 0, 0]; let n = 1; let r = t.match(/^#([a-fA-F0-9]{3,4})$/i); let i = ""; if (r) { i = (r = r[1])[3]; for (var o = 0; o < e.length; o++)e[o] = parseInt(r[o] + r[o], 16); i && (n = Math.round(parseInt(i + i, 16) / 255 * 100) / 100); } else if (r = t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)) { for (i = r[2], r = r[1], o = 0; o < e.length; o++)e[o] = parseInt(r.slice(2 * o, 2 * o + 2), 16); i && (n = Math.round(parseInt(i, 16) / 255 * 100) / 100); } else if (r = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = parseInt(r[o + 1]); n = parseFloat(r[4]); } else if (r = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = Math.round(2.55 * parseFloat(r[o + 1])); n = parseFloat(r[4]); } else if (r = t.match(/(\w+)/)) { if (r[1] == "transparent") return [0, 0, 0, 0]; if (!(e = l[r[1]])) return; } for (o = 0; o < e.length; o++)e[o] = g(e[o], 0, 255); return n = n || n == 0 ? g(n, 0, 1) : 1, e[3] = n, e; } } function d(t) { if (t) { const e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { const n = parseFloat(e[4]); return [g(parseInt(e[1]), 0, 360), g(parseFloat(e[2]), 0, 100), g(parseFloat(e[3]), 0, 100), g(isNaN(n) ? 1 : n, 0, 1)]; } } } function h(t) { if (t) { const e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { const n = parseFloat(e[4]); return [g(parseInt(e[1]), 0, 360), g(parseFloat(e[2]), 0, 100), g(parseFloat(e[3]), 0, 100), g(isNaN(n) ? 1 : n, 0, 1)]; } } } function p(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `rgba(${t[0]}, ${t[1]}, ${t[2]}, ${e})`; } function f(t, e) { return `rgba(${Math.round(t[0] / 255 * 100)}%, ${Math.round(t[1] / 255 * 100)}%, ${Math.round(t[2] / 255 * 100)}%, ${e || t[3] || 1})`; } function m(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), `hsla(${t[0]}, ${t[1]}%, ${t[2]}%, ${e})`; } function g(t, e, n) { return Math.min(Math.max(e, t), n); } function v(t) { const e = t.toString(16).toUpperCase(); return e.length < 2 ? `0${e}` : e; } var y = {}; for (const _ in l)y[l[_]] = _; var b = function (t) {
    return t instanceof b ? t : this instanceof b ? (this.valid = !1, this.values = {
      rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1,
    }, void (typeof t === "string" ? (e = u.getRgba(t)) ? this.setValues("rgb", e) : (e = u.getHsla(t)) ? this.setValues("hsl", e) : (e = u.getHwb(t)) && this.setValues("hwb", e) : typeof t === "object" && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new b(t); let e;
  }; b.prototype = {
    isValid() { return this.valid; }, rgb() { return this.setSpace("rgb", arguments); }, hsl() { return this.setSpace("hsl", arguments); }, hsv() { return this.setSpace("hsv", arguments); }, hwb() { return this.setSpace("hwb", arguments); }, cmyk() { return this.setSpace("cmyk", arguments); }, rgbArray() { return this.values.rgb; }, hslArray() { return this.values.hsl; }, hsvArray() { return this.values.hsv; }, hwbArray() { const t = this.values; return t.alpha !== 1 ? t.hwb.concat([t.alpha]) : t.hwb; }, cmykArray() { return this.values.cmyk; }, rgbaArray() { const t = this.values; return t.rgb.concat([t.alpha]); }, hslaArray() { const t = this.values; return t.hsl.concat([t.alpha]); }, alpha(t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this); }, red(t) { return this.setChannel("rgb", 0, t); }, green(t) { return this.setChannel("rgb", 1, t); }, blue(t) { return this.setChannel("rgb", 2, t); }, hue(t) { return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t); }, saturation(t) { return this.setChannel("hsl", 1, t); }, lightness(t) { return this.setChannel("hsl", 2, t); }, saturationv(t) { return this.setChannel("hsv", 1, t); }, whiteness(t) { return this.setChannel("hwb", 1, t); }, blackness(t) { return this.setChannel("hwb", 2, t); }, value(t) { return this.setChannel("hsv", 2, t); }, cyan(t) { return this.setChannel("cmyk", 0, t); }, magenta(t) { return this.setChannel("cmyk", 1, t); }, yellow(t) { return this.setChannel("cmyk", 2, t); }, black(t) { return this.setChannel("cmyk", 3, t); }, hexString() { return u.hexString(this.values.rgb); }, rgbString() { return u.rgbString(this.values.rgb, this.values.alpha); }, rgbaString() { return u.rgbaString(this.values.rgb, this.values.alpha); }, percentString() { return u.percentString(this.values.rgb, this.values.alpha); }, hslString() { return u.hslString(this.values.hsl, this.values.alpha); }, hslaString() { return u.hslaString(this.values.hsl, this.values.alpha); }, hwbString() { return u.hwbString(this.values.hwb, this.values.alpha); }, keyword() { return u.keyword(this.values.rgb, this.values.alpha); }, rgbNumber() { const t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2]; }, luminosity() { for (var t = this.values.rgb, e = [], n = 0; n < t.length; n++) { const r = t[n] / 255; e[n] = r <= 0.03928 ? r / 12.92 : ((r + 0.055) / 1.055) ** 2.4; } return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]; }, contrast(t) { const e = this.luminosity(); const n = t.luminosity(); return e > n ? (e + 0.05) / (n + 0.05) : (n + 0.05) / (e + 0.05); }, level(t) { const e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : ""; }, dark() { const t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128; }, light() { return !this.dark(); }, negate() { for (var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this; }, lighten(t) { const e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this; }, darken(t) { const e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this; }, saturate(t) { const e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this; }, desaturate(t) { const e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this; }, whiten(t) { const e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this; }, blacken(t) { const e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this; }, greyscale() { const t = this.values.rgb; const e = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2]; return this.setValues("rgb", [e, e, e]), this; }, clearer(t) { const e = this.values.alpha; return this.setValues("alpha", e - e * t), this; }, opaquer(t) { const e = this.values.alpha; return this.setValues("alpha", e + e * t), this; }, rotate(t) { const e = this.values.hsl; const n = (e[0] + t) % 360; return e[0] = n < 0 ? 360 + n : n, this.setValues("hsl", e), this; }, mix(t, e) { const n = t; const r = void 0 === e ? 0.5 : e; const i = 2 * r - 1; const o = this.alpha() - n.alpha(); const s = ((i * o == -1 ? i : (i + o) / (1 + i * o)) + 1) / 2; const a = 1 - s; return this.rgb(s * this.red() + a * n.red(), s * this.green() + a * n.green(), s * this.blue() + a * n.blue()).alpha(this.alpha() * r + n.alpha() * (1 - r)); }, toJSON() { return this.rgb(); }, clone() { let t; let e; const n = new b(); const r = this.values; const i = n.values; for (const o in r)r.hasOwnProperty(o) && (t = r[o], (e = {}.toString.call(t)) === "[object Array]" ? i[o] = t.slice(0) : e === "[object Number]" ? i[o] = t : console.error("unexpected color value:", t)); return n; },
  }, b.prototype.spaces = {
    rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"],
  }, b.prototype.maxes = {
    rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100],
  }, b.prototype.getValues = function (t) { for (var e = this.values, n = {}, r = 0; r < t.length; r++)n[t.charAt(r)] = e[t][r]; return e.alpha !== 1 && (n.a = e.alpha), n; }, b.prototype.setValues = function (t, e) { let n; let r; const i = this.values; const o = this.spaces; const s = this.maxes; let l = 1; if (this.valid = !0, t === "alpha")l = e; else if (e.length)i[t] = e.slice(0, t.length), l = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (n = 0; n < t.length; n++)i[t][n] = e[t.charAt(n)]; l = e.a; } else if (void 0 !== e[o[t][0]]) { const u = o[t]; for (n = 0; n < t.length; n++)i[t][n] = e[u[n]]; l = e.alpha; } if (i.alpha = Math.max(0, Math.min(1, void 0 === l ? i.alpha : l)), t === "alpha") return !1; for (n = 0; n < t.length; n++)r = Math.max(0, Math.min(s[t][n], i[t][n])), i[t][n] = Math.round(r); for (const c in o)c !== t && (i[c] = a[t][c](i[t])); return !0; }, b.prototype.setSpace = function (t, e) { let n = e[0]; return void 0 === n ? this.getValues(t) : (typeof n === "number" && (n = Array.prototype.slice.call(e)), this.setValues(t, n), this); }, b.prototype.setChannel = function (t, e, n) { const r = this.values[t]; return void 0 === n ? r[e] : (n === r[e] || (r[e] = n, this.setValues(t, r)), this); }, typeof window !== "undefined" && (window.Color = b); const w = b; function x(t) { return ["__proto__", "prototype", "constructor"].indexOf(t) === -1; } let S; var k = {
    noop() {}, uid: (S = 0, function () { return S++; }), isNullOrUndef(t) { return t == null; }, isArray(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return e.substr(0, 7) === "[object" && e.substr(-6) === "Array]"; }, isObject(t) { return t !== null && Object.prototype.toString.call(t) === "[object Object]"; }, isFinite(t) { return (typeof t === "number" || t instanceof Number) && isFinite(t); }, valueOrDefault(t, e) { return void 0 === t ? e : t; }, valueAtIndexOrDefault(t, e, n) { return k.valueOrDefault(k.isArray(t) ? t[e] : t, n); }, callback(t, e, n) { if (t && typeof t.call === "function") return t.apply(n, e); }, each(t, e, n, r) { let i; let o; let s; if (k.isArray(t)) if (o = t.length, r) for (i = o - 1; i >= 0; i--)e.call(n, t[i], i); else for (i = 0; i < o; i++)e.call(n, t[i], i); else if (k.isObject(t)) for (o = (s = Object.keys(t)).length, i = 0; i < o; i++)e.call(n, t[s[i]], s[i]); }, arrayEquals(t, e) { let n; let r; let i; let o; if (!t || !e || t.length !== e.length) return !1; for (n = 0, r = t.length; n < r; ++n) if (i = t[n], o = e[n], i instanceof Array && o instanceof Array) { if (!k.arrayEquals(i, o)) return !1; } else if (i !== o) return !1; return !0; }, clone(t) { if (k.isArray(t)) return t.map(k.clone); if (k.isObject(t)) { for (var e = Object.create(t), n = Object.keys(t), r = n.length, i = 0; i < r; ++i)e[n[i]] = k.clone(t[n[i]]); return e; } return t; }, _merger(t, e, n, r) { if (x(t)) { const i = e[t]; const o = n[t]; k.isObject(i) && k.isObject(o) ? k.merge(i, o, r) : e[t] = k.clone(o); } }, _mergerIf(t, e, n) { if (x(t)) { const r = e[t]; const i = n[t]; k.isObject(r) && k.isObject(i) ? k.mergeIf(r, i) : e.hasOwnProperty(t) || (e[t] = k.clone(i)); } }, merge(t, e, n) { let r; let i; let o; let s; let a; const l = k.isArray(e) ? e : [e]; const u = l.length; if (!k.isObject(t)) return t; for (r = (n = n || {}).merger || k._merger, i = 0; i < u; ++i) if (e = l[i], k.isObject(e)) for (a = 0, s = (o = Object.keys(e)).length; a < s; ++a)r(o[a], t, e, n); return t; }, mergeIf(t, e) { return k.merge(t, e, { merger: k._mergerIf }); }, extend: Object.assign || function (t) { return k.merge(t, [].slice.call(arguments, 1), { merger(t, e, n) { e[t] = n[t]; } }); }, inherits(t) { const e = this; const n = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments); }; const r = function () { this.constructor = n; }; return r.prototype = e.prototype, n.prototype = new r(), n.extend = k.inherits, t && k.extend(n.prototype, t), n.__super__ = e.prototype, n; }, _deprecated(t, e, n, r) { void 0 !== e && console.warn(`${t}: "${n}" is deprecated. Please use "${r}" instead`); },
  }; const C = k; k.callCallback = k.callback, k.indexOf = function (t, e, n) { return Array.prototype.indexOf.call(t, e, n); }, k.getValueOrDefault = k.valueOrDefault, k.getValueAtIndexOrDefault = k.valueAtIndexOrDefault; var E = {
    linear(t) { return t; }, easeInQuad(t) { return t * t; }, easeOutQuad(t) { return -t * (t - 2); }, easeInOutQuad(t) { return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }, easeInCubic(t) { return t * t * t; }, easeOutCubic(t) { return (t -= 1) * t * t + 1; }, easeInOutCubic(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }, easeInQuart(t) { return t * t * t * t; }, easeOutQuart(t) { return -((t -= 1) * t * t * t - 1); }, easeInOutQuart(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }, easeInQuint(t) { return t * t * t * t * t; }, easeOutQuint(t) { return (t -= 1) * t * t * t * t + 1; }, easeInOutQuint(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }, easeInSine(t) { return 1 - Math.cos(t * (Math.PI / 2)); }, easeOutSine(t) { return Math.sin(t * (Math.PI / 2)); }, easeInOutSine(t) { return -0.5 * (Math.cos(Math.PI * t) - 1); }, easeInExpo(t) { return t === 0 ? 0 : 2 ** (10 * (t - 1)); }, easeOutExpo(t) { return t === 1 ? 1 : 1 - 2 ** (-10 * t); }, easeInOutExpo(t) { return t === 0 ? 0 : t === 1 ? 1 : (t /= 0.5) < 1 ? 0.5 * 2 ** (10 * (t - 1)) : 0.5 * (2 - 2 ** (-10 * --t)); }, easeInCirc(t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1); }, easeOutCirc(t) { return Math.sqrt(1 - (t -= 1) * t); }, easeInOutCirc(t) { return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }, easeInElastic(t) { let e = 1.70158; let n = 0; let r = 1; return t === 0 ? 0 : t === 1 ? 1 : (n || (n = 0.3), r < 1 ? (r = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / r), -r * 2 ** (10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)); }, easeOutElastic(t) { let e = 1.70158; let n = 0; let r = 1; return t === 0 ? 0 : t === 1 ? 1 : (n || (n = 0.3), r < 1 ? (r = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / r), r * 2 ** (-10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1); }, easeInOutElastic(t) { let e = 1.70158; let n = 0; let r = 1; return t === 0 ? 0 : (t /= 0.5) == 2 ? 1 : (n || (n = 0.45), r < 1 ? (r = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / r), t < 1 ? r * 2 ** (10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * -0.5 : r * 2 ** (-10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * 0.5 + 1); }, easeInBack(t) { const e = 1.70158; return t * t * ((e + 1) * t - e); }, easeOutBack(t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1; }, easeInOutBack(t) { let e = 1.70158; return (t /= 0.5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2); }, easeInBounce(t) { return 1 - E.easeOutBounce(1 - t); }, easeOutBounce(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }, easeInOutBounce(t) { return t < 0.5 ? 0.5 * E.easeInBounce(2 * t) : 0.5 * E.easeOutBounce(2 * t - 1) + 0.5; },
  }; const T = { effects: E }; C.easingEffects = E; const P = Math.PI; const O = P / 180; const A = 2 * P; const M = P / 2; const L = P / 4; const I = 2 * P / 3; const j = {
    clear(t) { t.ctx.clearRect(0, 0, t.width, t.height); }, roundedRect(t, e, n, r, i, o) { if (o) { const s = Math.min(o, i / 2, r / 2); const a = e + s; const l = n + s; const u = e + r - s; const c = n + i - s; t.moveTo(e, l), a < u && l < c ? (t.arc(a, l, s, -P, -M), t.arc(u, l, s, -M, 0), t.arc(u, c, s, 0, M), t.arc(a, c, s, M, P)) : a < u ? (t.moveTo(a, n), t.arc(u, l, s, -M, M), t.arc(a, l, s, M, P + M)) : l < c ? (t.arc(a, l, s, -P, 0), t.arc(a, c, s, 0, P)) : t.arc(a, l, s, -P, P), t.closePath(), t.moveTo(e, n); } else t.rect(e, n, r, i); }, drawPoint(t, e, n, r, i, o) { let s; let a; let l; let u; let c; let d = (o || 0) * O; if (e && typeof e === "object" && ((s = e.toString()) === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) return t.save(), t.translate(r, i), t.rotate(d), t.drawImage(e, -e.width / 2, -e.height / 2, e.width, e.height), void t.restore(); if (!(isNaN(n) || n <= 0)) { switch (t.beginPath(), e) { default: t.arc(r, i, n, 0, A), t.closePath(); break; case "triangle": t.moveTo(r + Math.sin(d) * n, i - Math.cos(d) * n), d += I, t.lineTo(r + Math.sin(d) * n, i - Math.cos(d) * n), d += I, t.lineTo(r + Math.sin(d) * n, i - Math.cos(d) * n), t.closePath(); break; case "rectRounded": u = n - (c = 0.516 * n), a = Math.cos(d + L) * u, l = Math.sin(d + L) * u, t.arc(r - a, i - l, c, d - P, d - M), t.arc(r + l, i - a, c, d - M, d), t.arc(r + a, i + l, c, d, d + M), t.arc(r - l, i + a, c, d + M, d + P), t.closePath(); break; case "rect": if (!o) { u = Math.SQRT1_2 * n, t.rect(r - u, i - u, 2 * u, 2 * u); break; }d += L; case "rectRot": a = Math.cos(d) * n, l = Math.sin(d) * n, t.moveTo(r - a, i - l), t.lineTo(r + l, i - a), t.lineTo(r + a, i + l), t.lineTo(r - l, i + a), t.closePath(); break; case "crossRot": d += L; case "cross": a = Math.cos(d) * n, l = Math.sin(d) * n, t.moveTo(r - a, i - l), t.lineTo(r + a, i + l), t.moveTo(r + l, i - a), t.lineTo(r - l, i + a); break; case "star": a = Math.cos(d) * n, l = Math.sin(d) * n, t.moveTo(r - a, i - l), t.lineTo(r + a, i + l), t.moveTo(r + l, i - a), t.lineTo(r - l, i + a), d += L, a = Math.cos(d) * n, l = Math.sin(d) * n, t.moveTo(r - a, i - l), t.lineTo(r + a, i + l), t.moveTo(r + l, i - a), t.lineTo(r - l, i + a); break; case "line": a = Math.cos(d) * n, l = Math.sin(d) * n, t.moveTo(r - a, i - l), t.lineTo(r + a, i + l); break; case "dash": t.moveTo(r, i), t.lineTo(r + Math.cos(d) * n, i + Math.sin(d) * n); }t.fill(), t.stroke(); } }, _isPointInArea(t, e) { return t.x > e.left - 1e-6 && t.x < e.right + 1e-6 && t.y > e.top - 1e-6 && t.y < e.bottom + 1e-6; }, clipArea(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip(); }, unclipArea(t) { t.restore(); }, lineTo(t, e, n, r) { const i = n.steppedLine; if (i) { if (i === "middle") { const o = (e.x + n.x) / 2; t.lineTo(o, r ? n.y : e.y), t.lineTo(o, r ? e.y : n.y); } else i === "after" && !r || i !== "after" && r ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y); t.lineTo(n.x, n.y); } else n.tension ? t.bezierCurveTo(r ? e.controlPointPreviousX : e.controlPointNextX, r ? e.controlPointPreviousY : e.controlPointNextY, r ? n.controlPointNextX : n.controlPointPreviousX, r ? n.controlPointNextY : n.controlPointPreviousY, n.x, n.y) : t.lineTo(n.x, n.y); },
  }; const D = j; C.clear = j.clear, C.drawRoundedRectangle = function (t) { t.beginPath(), j.roundedRect.apply(j, arguments); }; const N = { _set(t, e) { return C.merge(this[t] || (this[t] = {}), e); } }; N._set("global", {
    defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", defaultLineHeight: 1.2, showLines: !0,
  }); const R = N; const F = C.valueOrDefault; const V = {
    toLineHeight(t, e) { const n = (`${t}`).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!n || n[1] === "normal") return 1.2 * e; switch (t = +n[2], n[3]) { case "px": return t; case "%": t /= 100; } return e * t; },
    toPadding(t) {
      let e; let n; let r; let i; return C.isObject(t) ? (e = +t.top || 0, n = +t.right || 0, r = +t.bottom || 0, i = +t.left || 0) : e = n = r = i = +t || 0, {
        top: e, right: n, bottom: r, left: i, height: e + r, width: i + n,
      };
    },
    _parseFont(t) {
      const e = R.global; const n = F(t.fontSize, e.defaultFontSize); const r = {
        family: F(t.fontFamily, e.defaultFontFamily), lineHeight: C.options.toLineHeight(F(t.lineHeight, e.defaultLineHeight), n), size: n, style: F(t.fontStyle, e.defaultFontStyle), weight: null, string: "",
      }; return r.string = (function (t) { return !t || C.isNullOrUndef(t.size) || C.isNullOrUndef(t.family) ? null : `${(t.style ? `${t.style} ` : "") + (t.weight ? `${t.weight} ` : "") + t.size}px ${t.family}`; }(r)), r;
    },
    resolve(t, e, n, r) { let i; let o; let s; let a = !0; for (i = 0, o = t.length; i < o; ++i) if (void 0 !== (s = t[i]) && (void 0 !== e && typeof s === "function" && (s = s(e), a = !1), void 0 !== n && C.isArray(s) && (s = s[n], a = !1), void 0 !== s)) return r && !a && (r.cacheable = !1), s; },
  }; const z = { _factorize(t) { let e; const n = []; const r = Math.sqrt(t); for (e = 1; e < r; e++)t % e == 0 && (n.push(e), n.push(t / e)); return r === (0 | r) && n.push(r), n.sort(((t, e) => t - e)).pop(), n; }, log10: Math.log10 || function (t) { const e = Math.log(t) * Math.LOG10E; const n = Math.round(e); return t === 10 ** n ? n : e; } }; const B = z; C.log10 = z.log10; const q = C; const H = T; const $ = D; const U = V; const W = B; q.easing = H, q.canvas = $, q.options = U, q.math = W, q.rtl = {
    getRtlAdapter(t, e, n) {
      return t ? (function (t, e) {
        return {
          x(n) { return t + t + e - n; }, setWidth(t) { e = t; }, textAlign(t) { return t === "center" ? t : t === "right" ? "left" : "right"; }, xPlus(t, e) { return t - e; }, leftForLtr(t, e) { return t - e; },
        };
      }(e, n)) : {
        x(t) { return t; }, setWidth(t) {}, textAlign(t) { return t; }, xPlus(t, e) { return t + e; }, leftForLtr(t, e) { return t; },
      };
    },
    overrideTextDirection(t, e) { let n; let r; e !== "ltr" && e !== "rtl" || (r = [(n = t.canvas.style).getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = r); },
    restoreTextDirection(t) { const e = t.prevTextDirection; void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])); },
  }; const G = function (t) { q.extend(this, t), this.initialize.apply(this, arguments); }; q.extend(G.prototype, {
    _type: void 0, initialize() { this.hidden = !1; }, pivot() { const t = this; return t._view || (t._view = q.extend({}, t._model)), t._start = {}, t; }, transition(t) { const e = this; const n = e._model; let r = e._start; let i = e._view; return n && t !== 1 ? (i || (i = e._view = {}), r || (r = e._start = {}), (function (t, e, n, r) { let i; let o; let s; let a; let l; let u; let c; let d; let h; const p = Object.keys(n); for (i = 0, o = p.length; i < o; ++i) if (u = n[s = p[i]], e.hasOwnProperty(s) || (e[s] = u), (a = e[s]) !== u && s[0] !== "_") { if (t.hasOwnProperty(s) || (t[s] = a), (c = typeof u) === typeof (l = t[s])) if (c === "string") { if ((d = w(l)).valid && (h = w(u)).valid) { e[s] = h.mix(d, r).rgbString(); continue; } } else if (q.isFinite(l) && q.isFinite(u)) { e[s] = l + (u - l) * r; continue; }e[s] = u; } }(r, i, n, t)), e) : (e._view = q.extend({}, n), e._start = null, e); }, tooltipPosition() { return { x: this._model.x, y: this._model.y }; }, hasValue() { return q.isNumber(this._model.x) && q.isNumber(this._model.y); },
  }), G.extend = q.inherits; const Y = G; const Z = Y.extend({
    chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null,
  }); const K = Z; Object.defineProperty(Z.prototype, "animationObject", { get() { return this; } }), Object.defineProperty(Z.prototype, "chartInstance", { get() { return this.chart; }, set(t) { this.chart = t; } }), R._set("global", {
    animation: {
      duration: 1e3, easing: "easeOutQuart", onProgress: q.noop, onComplete: q.noop,
    },
  }); const X = {
    animations: [], request: null, addAnimation(t, e, n, r) { let i; let o; const s = this.animations; for (e.chart = t, e.startTime = Date.now(), e.duration = n, r || (t.animating = !0), i = 0, o = s.length; i < o; ++i) if (s[i].chart === t) return void (s[i] = e); s.push(e), s.length === 1 && this.requestAnimationFrame(); }, cancelAnimation(t) { const e = q.findIndex(this.animations, ((e) => e.chart === t)); e !== -1 && (this.animations.splice(e, 1), t.animating = !1); }, requestAnimationFrame() { const t = this; t.request === null && (t.request = q.requestAnimFrame.call(window, (() => { t.request = null, t.startDigest(); }))); }, startDigest() { this.advance(), this.animations.length > 0 && this.requestAnimationFrame(); }, advance() { for (var t, e, n, r, i = this.animations, o = 0; o < i.length;)e = (t = i[o]).chart, n = t.numSteps, r = Math.floor((Date.now() - t.startTime) / t.duration * n) + 1, t.currentStep = Math.min(r, n), q.callback(t.render, [e, t], e), q.callback(t.onAnimationProgress, [t], e), t.currentStep >= n ? (q.callback(t.onAnimationComplete, [t], e), e.animating = !1, i.splice(o, 1)) : ++o; },
  }; const Q = q.options.resolve; const J = ["push", "pop", "shift", "splice", "unshift"]; function tt(t, e) { const n = t._chartjs; if (n) { const r = n.listeners; const i = r.indexOf(e); i !== -1 && r.splice(i, 1), r.length > 0 || (J.forEach(((e) => { delete t[e]; })), delete t._chartjs); } } const et = function (t, e) { this.initialize(t, e); }; q.extend(et.prototype, {
    datasetElementType: null,
    dataElementType: null,
    _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth"],
    _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "pointStyle"],
    initialize(t, e) { const n = this; n.chart = t, n.index = e, n.linkScales(), n.addElements(), n._type = n.getMeta().type; },
    updateIndex(t) { this.index = t; },
    linkScales() { const t = this.getMeta(); const e = this.chart; const n = e.scales; const r = this.getDataset(); const i = e.options.scales; t.xAxisID !== null && t.xAxisID in n && !r.xAxisID || (t.xAxisID = r.xAxisID || i.xAxes[0].id), t.yAxisID !== null && t.yAxisID in n && !r.yAxisID || (t.yAxisID = r.yAxisID || i.yAxes[0].id); },
    getDataset() { return this.chart.data.datasets[this.index]; },
    getMeta() { return this.chart.getDatasetMeta(this.index); },
    getScaleForId(t) { return this.chart.scales[t]; },
    _getValueScaleId() { return this.getMeta().yAxisID; },
    _getIndexScaleId() { return this.getMeta().xAxisID; },
    _getValueScale() { return this.getScaleForId(this._getValueScaleId()); },
    _getIndexScale() { return this.getScaleForId(this._getIndexScaleId()); },
    reset() { this._update(!0); },
    destroy() { this._data && tt(this._data, this); },
    createMetaDataset() { const t = this.datasetElementType; return t && new t({ _chart: this.chart, _datasetIndex: this.index }); },
    createMetaData(t) { const e = this.dataElementType; return e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t }); },
    addElements() { let t; let e; const n = this.getMeta(); const r = this.getDataset().data || []; const i = n.data; for (t = 0, e = r.length; t < e; ++t)i[t] = i[t] || this.createMetaData(t); n.dataset = n.dataset || this.createMetaDataset(); },
    addElementAndReset(t) { const e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0); },
    buildOrUpdateElements() { let t; let e; const n = this; const r = n.getDataset(); const i = r.data || (r.data = []); n._data !== i && (n._data && tt(n._data, n), i && Object.isExtensible(i) && (e = n, (t = i)._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), J.forEach(((e) => { const n = `onData${e.charAt(0).toUpperCase()}${e.slice(1)}`; const r = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value() { const e = Array.prototype.slice.call(arguments); const i = r.apply(this, e); return q.each(t._chartjs.listeners, ((t) => { typeof t[n] === "function" && t[n].apply(t, e); })), i; } }); })))), n._data = i), n.resyncElements(); },
    _configure() { this._config = q.merge(Object.create(null), [this.chart.options.datasets[this._type], this.getDataset()], { merger(t, e, n) { t !== "_meta" && t !== "data" && q._merger(t, e, n); } }); },
    _update(t) { this._configure(), this._cachedDataOpts = null, this.update(t); },
    update: q.noop,
    transition(t) { for (var e = this.getMeta(), n = e.data || [], r = n.length, i = 0; i < r; ++i)n[i].transition(t); e.dataset && e.dataset.transition(t); },
    draw() { const t = this.getMeta(); const e = t.data || []; const n = e.length; let r = 0; for (t.dataset && t.dataset.draw(); r < n; ++r)e[r].draw(); },
    getStyle(t) { let e; const n = this.getMeta(); const r = n.dataset; return this._configure(), r && void 0 === t ? e = this._resolveDatasetElementOptions(r || {}) : (t = t || 0, e = this._resolveDataElementOptions(n.data[t] || {}, t)), !1 !== e.fill && e.fill !== null || (e.backgroundColor = e.borderColor), e; },
    _resolveDatasetElementOptions(t, e) {
      let n; let r; let i; let o; const s = this; const a = s.chart; const l = s._config; const u = t.custom || {}; const c = a.options.elements[s.datasetElementType.prototype._type] || {}; const d = s._datasetElementOptions; const h = {}; const p = {
        chart: a, dataset: s.getDataset(), datasetIndex: s.index, hover: e,
      }; for (n = 0, r = d.length; n < r; ++n)i = d[n], o = e ? `hover${i.charAt(0).toUpperCase()}${i.slice(1)}` : i, h[i] = Q([u[o], l[o], c[o]], p); return h;
    },
    _resolveDataElementOptions(t, e) {
      const n = this; let r = t && t.custom; const i = n._cachedDataOpts; if (i && !r) return i; let o; let s; let a; let l; const u = n.chart; const c = n._config; const d = u.options.elements[n.dataElementType.prototype._type] || {}; const h = n._dataElementOptions; const p = {}; const f = {
        chart: u, dataIndex: e, dataset: n.getDataset(), datasetIndex: n.index,
      }; const m = { cacheable: !r }; if (r = r || {}, q.isArray(h)) for (s = 0, a = h.length; s < a; ++s)p[l = h[s]] = Q([r[l], c[l], d[l]], f, e, m); else for (s = 0, a = (o = Object.keys(h)).length; s < a; ++s)p[l = o[s]] = Q([r[l], c[h[l]], c[l], d[l]], f, e, m); return m.cacheable && (n._cachedDataOpts = Object.freeze(p)), p;
    },
    removeHoverStyle(t) { q.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle; },
    setHoverStyle(t) { const e = this.chart.data.datasets[t._datasetIndex]; const n = t._index; const r = t.custom || {}; const i = t._model; const o = q.getHoverColor; t.$previousStyle = { backgroundColor: i.backgroundColor, borderColor: i.borderColor, borderWidth: i.borderWidth }, i.backgroundColor = Q([r.hoverBackgroundColor, e.hoverBackgroundColor, o(i.backgroundColor)], void 0, n), i.borderColor = Q([r.hoverBorderColor, e.hoverBorderColor, o(i.borderColor)], void 0, n), i.borderWidth = Q([r.hoverBorderWidth, e.hoverBorderWidth, i.borderWidth], void 0, n); },
    _removeDatasetHoverStyle() { const t = this.getMeta().dataset; t && this.removeHoverStyle(t); },
    _setDatasetHoverStyle() { let t; let e; let n; let r; let i; let o; const s = this.getMeta().dataset; const a = {}; if (s) { for (o = s._model, i = this._resolveDatasetElementOptions(s, !0), t = 0, e = (r = Object.keys(i)).length; t < e; ++t)a[n = r[t]] = o[n], o[n] = i[n]; s.$previousStyle = a; } },
    resyncElements() { const t = this.getMeta(); const e = this.getDataset().data; const n = t.data.length; const r = e.length; r < n ? t.data.splice(r, n - r) : r > n && this.insertElements(n, r - n); },
    insertElements(t, e) { for (let n = 0; n < e; ++n) this.addElementAndReset(t + n); },
    onDataPush() { const t = arguments.length; this.insertElements(this.getDataset().data.length - t, t); },
    onDataPop() { this.getMeta().data.pop(); },
    onDataShift() { this.getMeta().data.shift(); },
    onDataSplice(t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2); },
    onDataUnshift() { this.insertElements(0, arguments.length); },
  }), et.extend = q.inherits; const nt = et; const rt = 2 * Math.PI; function it(t, e) { const n = e.startAngle; const r = e.endAngle; const i = e.pixelMargin; let o = i / e.outerRadius; const s = e.x; const a = e.y; t.beginPath(), t.arc(s, a, e.outerRadius, n - o, r + o), e.innerRadius > i ? (o = i / e.innerRadius, t.arc(s, a, e.innerRadius - i, r + o, n - o, !0)) : t.arc(s, a, i, r + Math.PI / 2, n - Math.PI / 2), t.closePath(), t.clip(); }R._set("global", {
    elements: {
      arc: {
        backgroundColor: R.global.defaultColor, borderColor: "#fff", borderWidth: 2, borderAlign: "center",
      },
    },
  }); const ot = Y.extend({
    _type: "arc",
    inLabelRange(t) { const e = this._view; return !!e && (t - e.x) ** 2 < (e.radius + e.hoverRadius) ** 2; },
    inRange(t, e) { const n = this._view; if (n) { for (var r = q.getAngleFromPoint(n, { x: t, y: e }), i = r.angle, o = r.distance, s = n.startAngle, a = n.endAngle; a < s;)a += rt; for (;i > a;)i -= rt; for (;i < s;)i += rt; const l = i >= s && i <= a; const u = o >= n.innerRadius && o <= n.outerRadius; return l && u; } return !1; },
    getCenterPoint() { const t = this._view; const e = (t.startAngle + t.endAngle) / 2; const n = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * n, y: t.y + Math.sin(e) * n }; },
    getArea() { const t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (t.outerRadius ** 2 - t.innerRadius ** 2); },
    tooltipPosition() { const t = this._view; const e = t.startAngle + (t.endAngle - t.startAngle) / 2; const n = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * n, y: t.y + Math.sin(e) * n }; },
    draw() {
      let t; const e = this._chart.ctx; const n = this._view; const r = n.borderAlign === "inner" ? 0.33 : 0; const i = {
        x: n.x, y: n.y, innerRadius: n.innerRadius, outerRadius: Math.max(n.outerRadius - r, 0), pixelMargin: r, startAngle: n.startAngle, endAngle: n.endAngle, fullCircles: Math.floor(n.circumference / rt),
      }; if (e.save(), e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, i.fullCircles) { for (i.endAngle = i.startAngle + rt, e.beginPath(), e.arc(i.x, i.y, i.outerRadius, i.startAngle, i.endAngle), e.arc(i.x, i.y, i.innerRadius, i.endAngle, i.startAngle, !0), e.closePath(), t = 0; t < i.fullCircles; ++t)e.fill(); i.endAngle = i.startAngle + n.circumference % rt; }e.beginPath(), e.arc(i.x, i.y, i.outerRadius, i.startAngle, i.endAngle), e.arc(i.x, i.y, i.innerRadius, i.endAngle, i.startAngle, !0), e.closePath(), e.fill(), n.borderWidth && (function (t, e, n) { const r = e.borderAlign === "inner"; r ? (t.lineWidth = 2 * e.borderWidth, t.lineJoin = "round") : (t.lineWidth = e.borderWidth, t.lineJoin = "bevel"), n.fullCircles && (function (t, e, n, r) { let i; const o = n.endAngle; for (r && (n.endAngle = n.startAngle + rt, it(t, n), n.endAngle = o, n.endAngle === n.startAngle && n.fullCircles && (n.endAngle += rt, n.fullCircles--)), t.beginPath(), t.arc(n.x, n.y, n.innerRadius, n.startAngle + rt, n.startAngle, !0), i = 0; i < n.fullCircles; ++i)t.stroke(); for (t.beginPath(), t.arc(n.x, n.y, e.outerRadius, n.startAngle, n.startAngle + rt), i = 0; i < n.fullCircles; ++i)t.stroke(); }(t, e, n, r)), r && it(t, n), t.beginPath(), t.arc(n.x, n.y, e.outerRadius, n.startAngle, n.endAngle), t.arc(n.x, n.y, n.innerRadius, n.endAngle, n.startAngle, !0), t.closePath(), t.stroke(); }(e, n, i)), e.restore();
    },
  }); const st = q.valueOrDefault; const at = R.global.defaultColor; R._set("global", {
    elements: {
      line: {
        tension: 0.4, backgroundColor: at, borderWidth: 3, borderColor: at, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0,
      },
    },
  }); const lt = Y.extend({ _type: "line", draw() { let t; let e; let n; const r = this; const i = r._view; const o = r._chart.ctx; const s = i.spanGaps; let a = r._children.slice(); const l = R.global; const u = l.elements.line; let c = -1; let d = r._loop; if (a.length) { if (r._loop) { for (t = 0; t < a.length; ++t) if (e = q.previousItem(a, t), !a[t]._view.skip && e._view.skip) { a = a.slice(t).concat(a.slice(0, t)), d = s; break; }d && a.push(a[0]); } for (o.save(), o.lineCap = i.borderCapStyle || u.borderCapStyle, o.setLineDash && o.setLineDash(i.borderDash || u.borderDash), o.lineDashOffset = st(i.borderDashOffset, u.borderDashOffset), o.lineJoin = i.borderJoinStyle || u.borderJoinStyle, o.lineWidth = st(i.borderWidth, u.borderWidth), o.strokeStyle = i.borderColor || l.defaultColor, o.beginPath(), (n = a[0]._view).skip || (o.moveTo(n.x, n.y), c = 0), t = 1; t < a.length; ++t)n = a[t]._view, e = c === -1 ? q.previousItem(a, t) : a[c], n.skip || (c !== t - 1 && !s || c === -1 ? o.moveTo(n.x, n.y) : q.canvas.lineTo(o, e._view, n), c = t); d && o.closePath(), o.stroke(), o.restore(); } } }); const ut = q.valueOrDefault; const ct = R.global.defaultColor; function dt(t) { const e = this._view; return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius; }R._set("global", {
    elements: {
      point: {
        radius: 3, pointStyle: "circle", backgroundColor: ct, borderColor: ct, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1,
      },
    },
  }); const ht = Y.extend({
    _type: "point", inRange(t, e) { const n = this._view; return !!n && (t - n.x) ** 2 + (e - n.y) ** 2 < (n.hitRadius + n.radius) ** 2; }, inLabelRange: dt, inXRange: dt, inYRange(t) { const e = this._view; return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius; }, getCenterPoint() { const t = this._view; return { x: t.x, y: t.y }; }, getArea() { return Math.PI * this._view.radius ** 2; }, tooltipPosition() { const t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth }; }, draw(t) { const e = this._view; const n = this._chart.ctx; const r = e.pointStyle; const i = e.rotation; const o = e.radius; const s = e.x; const a = e.y; const l = R.global; const u = l.defaultColor; e.skip || (void 0 === t || q.canvas._isPointInArea(e, t)) && (n.strokeStyle = e.borderColor || u, n.lineWidth = ut(e.borderWidth, l.elements.point.borderWidth), n.fillStyle = e.backgroundColor || u, q.canvas.drawPoint(n, r, o, s, a, i)); },
  }); const pt = R.global.defaultColor; function ft(t) { return t && void 0 !== t.width; } function mt(t) {
    let e; let n; let r; let i; let o; return ft(t) ? (o = t.width / 2, e = t.x - o, n = t.x + o, r = Math.min(t.y, t.base), i = Math.max(t.y, t.base)) : (o = t.height / 2, e = Math.min(t.x, t.base), n = Math.max(t.x, t.base), r = t.y - o, i = t.y + o), {
      left: e, top: r, right: n, bottom: i,
    };
  } function gt(t, e, n) { return t === e ? n : t === n ? e : t; } function vt(t, e, n) { const r = e === null; const i = n === null; const o = !(!t || r && i) && mt(t); return o && (r || e >= o.left && e <= o.right) && (i || n >= o.top && n <= o.bottom); }R._set("global", {
    elements: {
      rectangle: {
        backgroundColor: pt, borderColor: pt, borderSkipped: "bottom", borderWidth: 0,
      },
    },
  }); const yt = Y.extend({
    _type: "rectangle",
    draw() {
      const t = this._chart.ctx; const e = this._view; const n = (function (t) {
        const e = mt(t); const n = e.right - e.left; const r = e.bottom - e.top; const i = (function (t, e, n) { let r; let i; let o; let s; let a = t.borderWidth; let l = (function (t) { var e = t.borderSkipped; var n = {}; return e ? (t.horizontal ? t.base > t.x && (e = gt(e, "left", "right")) : t.base < t.y && (e = gt(e, "bottom", "top")), n[e] = !0, n) : n }(t)); return q.isObject(a) ? (r = +a.top || 0, i = +a.right || 0, o = +a.bottom || 0, s = +a.left || 0) : r = i = o = s = +a || 0, {
 t: l.top || r < 0 ? 0 : r > n ? n : r, r: l.right || i < 0 ? 0 : i > e ? e : i, b: l.bottom || o < 0 ? 0 : o > n ? n : o, l: l.left || s < 0 ? 0 : s > e ? e : s 
}; }(t, n / 2, r / 2)); return {
          outer: {
            x: e.left, y: e.top, w: n, h: r,
          },
          inner: {
            x: e.left + i.l, y: e.top + i.t, w: n - i.l - i.r, h: r - i.t - i.b,
          }, 
        };
      }(e)); const r = n.outer; const i = n.inner; t.fillStyle = e.backgroundColor, t.fillRect(r.x, r.y, r.w, r.h), r.w === i.w && r.h === i.h || (t.save(), t.beginPath(), t.rect(r.x, r.y, r.w, r.h), t.clip(), t.fillStyle = e.borderColor, t.rect(i.x, i.y, i.w, i.h), t.fill("evenodd"), t.restore());
    },
    height() { const t = this._view; return t.base - t.y; },
    inRange(t, e) { return vt(this._view, t, e); },
    inLabelRange(t, e) { const n = this._view; return ft(n) ? vt(n, t, null) : vt(n, null, e); },
    inXRange(t) { return vt(this._view, t, null); },
    inYRange(t) { return vt(this._view, null, t); },
    getCenterPoint() { let t; let e; const n = this._view; return ft(n) ? (t = n.x, e = (n.y + n.base) / 2) : (t = (n.x + n.base) / 2, e = n.y), { x: t, y: e }; },
    getArea() { const t = this._view; return ft(t) ? t.width * Math.abs(t.y - t.base) : t.height * Math.abs(t.x - t.base); },
    tooltipPosition() { const t = this._view; return { x: t.x, y: t.y }; },
  }); const _t = {}; const bt = ot; const wt = lt; const xt = ht; const St = yt; _t.Arc = bt, _t.Line = wt, _t.Point = xt, _t.Rectangle = St; const kt = q._deprecated; const Ct = q.valueOrDefault; R._set("bar", { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", offset: !0, gridLines: { offsetGridLines: !0 } }], yAxes: [{ type: "linear" }] } }), R._set("global", { datasets: { bar: { categoryPercentage: 0.8, barPercentage: 0.9 } } }); const Et = nt.extend({
    dataElementType: _t.Rectangle,
    _dataElementOptions: ["backgroundColor", "borderColor", "borderSkipped", "borderWidth", "barPercentage", "barThickness", "categoryPercentage", "maxBarThickness", "minBarLength"],
    initialize() { let t; let e; const n = this; nt.prototype.initialize.apply(n, arguments), (t = n.getMeta()).stack = n.getDataset().stack, t.bar = !0, e = n._getIndexScale().options, kt("bar chart", e.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage"), kt("bar chart", e.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness"), kt("bar chart", e.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage"), kt("bar chart", n._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength"), kt("bar chart", e.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness"); },
    update(t) { let e; let n; const r = this.getMeta().data; for (this._ruler = this.getRuler(), e = 0, n = r.length; e < n; ++e) this.updateElement(r[e], e, t); },
    updateElement(t, e, n) {
      const r = this; const i = r.getMeta(); const o = r.getDataset(); const s = r._resolveDataElementOptions(t, e); t._xScale = r.getScaleForId(i.xAxisID), t._yScale = r.getScaleForId(i.yAxisID), t._datasetIndex = r.index, t._index = e, t._model = {
        backgroundColor: s.backgroundColor, borderColor: s.borderColor, borderSkipped: s.borderSkipped, borderWidth: s.borderWidth, datasetLabel: o.label, label: r.chart.data.labels[e],
      }, q.isArray(o.data[e]) && (t._model.borderSkipped = null), r._updateElementGeometry(t, e, n, s), t.pivot();
    },
    _updateElementGeometry(t, e, n, r) { const i = this; const o = t._model; const s = i._getValueScale(); const a = s.getBasePixel(); const l = s.isHorizontal(); const u = i._ruler || i.getRuler(); const c = i.calculateBarValuePixels(i.index, e, r); const d = i.calculateBarIndexPixels(i.index, e, u, r); o.horizontal = l, o.base = n ? a : c.base, o.x = l ? n ? a : c.head : d.center, o.y = l ? d.center : n ? a : c.head, o.height = l ? d.size : void 0, o.width = l ? void 0 : d.size; },
    _getStacks(t) { let e; let n; const r = this._getIndexScale(); const i = r._getMatchingVisibleMetas(this._type); const o = r.options.stacked; const s = i.length; const a = []; for (e = 0; e < s && (n = i[e], (!1 === o || a.indexOf(n.stack) === -1 || void 0 === o && void 0 === n.stack) && a.push(n.stack), n.index !== t); ++e);return a; },
    getStackCount() { return this._getStacks().length; },
    getStackIndex(t, e) { const n = this._getStacks(t); const r = void 0 !== e ? n.indexOf(e) : -1; return r === -1 ? n.length - 1 : r; },
    getRuler() {
      let t; let e; const n = this._getIndexScale(); const r = []; for (t = 0, e = this.getMeta().data.length; t < e; ++t)r.push(n.getPixelForValue(null, t, this.index)); return {
        pixels: r, start: n._startPixel, end: n._endPixel, stackCount: this.getStackCount(), scale: n,
      };
    },
    calculateBarValuePixels(t, e, n) {
      let r; let i; let o; let s; let a; let l; let u; const c = this.chart; const d = this._getValueScale(); const h = d.isHorizontal(); const p = c.data.datasets; const f = d._getMatchingVisibleMetas(this._type); const m = d._parseValue(p[t].data[e]); const g = n.minBarLength; const v = d.options.stacked; const y = this.getMeta().stack; let _ = void 0 === m.start ? 0 : m.max >= 0 && m.min >= 0 ? m.min : m.max; const b = void 0 === m.start ? m.end : m.max >= 0 && m.min >= 0 ? m.max - m.min : m.min - m.max; const w = f.length; if (v || void 0 === v && void 0 !== y) for (r = 0; r < w && (i = f[r]).index !== t; ++r)i.stack === y && (o = void 0 === (u = d._parseValue(p[i.index].data[e])).start ? u.end : u.min >= 0 && u.max >= 0 ? u.max : u.min, (m.min < 0 && o < 0 || m.max >= 0 && o > 0) && (_ += o)); return s = d.getPixelForValue(_), l = (a = d.getPixelForValue(_ + b)) - s, void 0 !== g && Math.abs(l) < g && (l = g, a = b >= 0 && !h || b < 0 && h ? s - g : s + g), {
        size: l, base: s, head: a, center: a + l / 2,
      };
    },
    calculateBarIndexPixels(t, e, n, r) {
      const i = r.barThickness === "flex" ? (function (t, e, n) { let r; const i = e.pixels; const o = i[t]; let s = t > 0 ? i[t - 1] : null; let a = t < i.length - 1 ? i[t + 1] : null; const l = n.categoryPercentage; return s === null && (s = o - (a === null ? e.end - e.start : a - o)), a === null && (a = o + o - s), r = o - (o - Math.min(s, a)) / 2 * l, { chunk: Math.abs(a - s) / 2 * l / e.stackCount, ratio: n.barPercentage, start: r }; }(e, n, r)) : (function (t, e, n) { let r; let i; const o = n.barThickness; const s = e.stackCount; const a = e.pixels[t]; const l = q.isNullOrUndef(o) ? (function (t, e) { let n; let r; let i; let o; let s = t._length; for (i = 1, o = e.length; i < o; ++i)s = Math.min(s, Math.abs(e[i] - e[i - 1])); for (i = 0, o = t.getTicks().length; i < o; ++i)r = t.getPixelForTick(i), s = i > 0 ? Math.min(s, Math.abs(r - n)) : s, n = r; return s; }(e.scale, e.pixels)) : -1; return q.isNullOrUndef(o) ? (r = l * n.categoryPercentage, i = n.barPercentage) : (r = o * s, i = 1), { chunk: r / s, ratio: i, start: a - r / 2 }; }(e, n, r)); const o = this.getStackIndex(t, this.getMeta().stack); const s = i.start + i.chunk * o + i.chunk / 2; const a = Math.min(Ct(r.maxBarThickness, 1 / 0), i.chunk * i.ratio); return {
        base: s - a / 2, head: s + a / 2, center: s, size: a,
      };
    },
    draw() { const t = this.chart; const e = this._getValueScale(); const n = this.getMeta().data; const r = this.getDataset(); const i = n.length; let o = 0; for (q.canvas.clipArea(t.ctx, t.chartArea); o < i; ++o) { const s = e._parseValue(r.data[o]); isNaN(s.min) || isNaN(s.max) || n[o].draw(); }q.canvas.unclipArea(t.ctx); },
    _resolveDataElementOptions() { const t = this; const e = q.extend({}, nt.prototype._resolveDataElementOptions.apply(t, arguments)); const n = t._getIndexScale().options; const r = t._getValueScale().options; return e.barPercentage = Ct(n.barPercentage, e.barPercentage), e.barThickness = Ct(n.barThickness, e.barThickness), e.categoryPercentage = Ct(n.categoryPercentage, e.categoryPercentage), e.maxBarThickness = Ct(n.maxBarThickness, e.maxBarThickness), e.minBarLength = Ct(r.minBarLength, e.minBarLength), e; },
  }); const Tt = q.valueOrDefault; const Pt = q.options.resolve; R._set("bubble", { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title() { return ""; }, label(t, e) { const n = e.datasets[t.datasetIndex].label || ""; const r = e.datasets[t.datasetIndex].data[t.index]; return `${n}: (${t.xLabel}, ${t.yLabel}, ${r.r})`; } } } }); const Ot = nt.extend({
    dataElementType: _t.Point,
    _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"],
    update(t) { const e = this; const n = e.getMeta().data; q.each(n, ((n, r) => { e.updateElement(n, r, t); })); },
    updateElement(t, e, n) {
      const r = this; const i = r.getMeta(); const o = t.custom || {}; const s = r.getScaleForId(i.xAxisID); const a = r.getScaleForId(i.yAxisID); const l = r._resolveDataElementOptions(t, e); const u = r.getDataset().data[e]; const c = r.index; const d = n ? s.getPixelForDecimal(0.5) : s.getPixelForValue(typeof u === "object" ? u : NaN, e, c); const h = n ? a.getBasePixel() : a.getPixelForValue(u, e, c); t._xScale = s, t._yScale = a, t._options = l, t._datasetIndex = c, t._index = e, t._model = {
        backgroundColor: l.backgroundColor, borderColor: l.borderColor, borderWidth: l.borderWidth, hitRadius: l.hitRadius, pointStyle: l.pointStyle, rotation: l.rotation, radius: n ? 0 : l.radius, skip: o.skip || isNaN(d) || isNaN(h), x: d, y: h,
      }, t.pivot();
    },
    setHoverStyle(t) {
      const e = t._model; const n = t._options; const r = q.getHoverColor; t.$previousStyle = {
        backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth, radius: e.radius,
      }, e.backgroundColor = Tt(n.hoverBackgroundColor, r(n.backgroundColor)), e.borderColor = Tt(n.hoverBorderColor, r(n.borderColor)), e.borderWidth = Tt(n.hoverBorderWidth, n.borderWidth), e.radius = n.radius + n.hoverRadius;
    },
    _resolveDataElementOptions(t, e) {
      const n = this; const r = n.chart; const i = n.getDataset(); const o = t.custom || {}; const s = i.data[e] || {}; let a = nt.prototype._resolveDataElementOptions.apply(n, arguments); const l = {
        chart: r, dataIndex: e, dataset: i, datasetIndex: n.index,
      }; return n._cachedDataOpts === a && (a = q.extend({}, a)), a.radius = Pt([o.radius, s.r, n._config.radius, r.options.elements.point.radius], l, e), a;
    },
  }); const At = q.valueOrDefault; const Mt = Math.PI; const Lt = 2 * Mt; const It = Mt / 2; R._set("doughnut", {
    animation: { animateRotate: !0, animateScale: !1 },
    hover: { mode: "single" },
    legendCallback(t) { let e; let n; let r; const i = document.createElement("ul"); const o = t.data; const s = o.datasets; const a = o.labels; if (i.setAttribute("class", `${t.id}-legend`), s.length) for (e = 0, n = s[0].data.length; e < n; ++e)(r = i.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = s[0].backgroundColor[e], a[e] && r.appendChild(document.createTextNode(a[e])); return i.outerHTML; },
    legend: {
      labels: {
        generateLabels(t) {
          const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(((n, r) => {
            const i = t.getDatasetMeta(0); const o = i.controller.getStyle(r); return {
              text: n, fillStyle: o.backgroundColor, strokeStyle: o.borderColor, lineWidth: o.borderWidth, hidden: isNaN(e.datasets[0].data[r]) || i.data[r].hidden, index: r,
            };
          })) : [];
        },
      },
      onClick(t, e) { let n; let r; let i; const o = e.index; const s = this.chart; for (n = 0, r = (s.data.datasets || []).length; n < r; ++n)(i = s.getDatasetMeta(n)).data[o] && (i.data[o].hidden = !i.data[o].hidden); s.update(); },
    },
    cutoutPercentage: 50,
    rotation: -It,
    circumference: Lt,
    tooltips: { callbacks: { title() { return ""; }, label(t, e) { let n = e.labels[t.index]; const r = `: ${e.datasets[t.datasetIndex].data[t.index]}`; return q.isArray(n) ? (n = n.slice())[0] += r : n += r, n; } } },
  }); const jt = nt.extend({
    dataElementType: _t.Arc,
    linkScales: q.noop,
    _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
    getRingIndex(t) { for (var e = 0, n = 0; n < t; ++n) this.chart.isDatasetVisible(n) && ++e; return e; },
    update(t) { let e; let n; let r; let i; const o = this; const s = o.chart; const a = s.chartArea; const l = s.options; let u = 1; let c = 1; let d = 0; let h = 0; const p = o.getMeta(); const f = p.data; const m = l.cutoutPercentage / 100 || 0; const g = l.circumference; const v = o._getRingWeight(o.index); if (g < Lt) { let y = l.rotation % Lt; const _ = (y += y >= Mt ? -Lt : y < -Mt ? Lt : 0) + g; const b = Math.cos(y); const w = Math.sin(y); const x = Math.cos(_); const S = Math.sin(_); const k = y <= 0 && _ >= 0 || _ >= Lt; const C = y <= It && _ >= It || _ >= Lt + It; const E = y <= -It && _ >= -It || _ >= Mt + It; const T = y === -Mt || _ >= Mt ? -1 : Math.min(b, b * m, x, x * m); const P = E ? -1 : Math.min(w, w * m, S, S * m); const O = k ? 1 : Math.max(b, b * m, x, x * m); const A = C ? 1 : Math.max(w, w * m, S, S * m); u = (O - T) / 2, c = (A - P) / 2, d = -(O + T) / 2, h = -(A + P) / 2; } for (r = 0, i = f.length; r < i; ++r)f[r]._options = o._resolveDataElementOptions(f[r], r); for (s.borderWidth = o.getMaxBorderWidth(), e = (a.right - a.left - s.borderWidth) / u, n = (a.bottom - a.top - s.borderWidth) / c, s.outerRadius = Math.max(Math.min(e, n) / 2, 0), s.innerRadius = Math.max(s.outerRadius * m, 0), s.radiusLength = (s.outerRadius - s.innerRadius) / (o._getVisibleDatasetWeightTotal() || 1), s.offsetX = d * s.outerRadius, s.offsetY = h * s.outerRadius, p.total = o.calculateTotal(), o.outerRadius = s.outerRadius - s.radiusLength * o._getRingWeightOffset(o.index), o.innerRadius = Math.max(o.outerRadius - s.radiusLength * v, 0), r = 0, i = f.length; r < i; ++r)o.updateElement(f[r], r, t); },
    updateElement(t, e, n) {
      const r = this; const i = r.chart; const o = i.chartArea; const s = i.options; const a = s.animation; const l = (o.left + o.right) / 2; const u = (o.top + o.bottom) / 2; const c = s.rotation; const d = s.rotation; const h = r.getDataset(); const p = n && a.animateRotate || t.hidden ? 0 : r.calculateCircumference(h.data[e]) * (s.circumference / Lt); const f = n && a.animateScale ? 0 : r.innerRadius; const m = n && a.animateScale ? 0 : r.outerRadius; const g = t._options || {}; q.extend(t, {
        _datasetIndex: r.index,
        _index: e,
        _model: {
          backgroundColor: g.backgroundColor, borderColor: g.borderColor, borderWidth: g.borderWidth, borderAlign: g.borderAlign, x: l + i.offsetX, y: u + i.offsetY, startAngle: c, endAngle: d, circumference: p, outerRadius: m, innerRadius: f, label: q.valueAtIndexOrDefault(h.label, e, i.data.labels[e]),
        },
      }); const v = t._model; n && a.animateRotate || (v.startAngle = e === 0 ? s.rotation : r.getMeta().data[e - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot();
    },
    calculateTotal() { let t; const e = this.getDataset(); const n = this.getMeta(); let r = 0; return q.each(n.data, ((n, i) => { t = e.data[i], isNaN(t) || n.hidden || (r += Math.abs(t)); })), r; },
    calculateCircumference(t) { const e = this.getMeta().total; return e > 0 && !isNaN(t) ? Lt * (Math.abs(t) / e) : 0; },
    getMaxBorderWidth(t) { let e; let n; let r; let i; let o; let s; let a; let l; let u = 0; const c = this.chart; if (!t) for (e = 0, n = c.data.datasets.length; e < n; ++e) if (c.isDatasetVisible(e)) { t = (r = c.getDatasetMeta(e)).data, e !== this.index && (o = r.controller); break; } if (!t) return 0; for (e = 0, n = t.length; e < n; ++e)i = t[e], o ? (o._configure(), s = o._resolveDataElementOptions(i, e)) : s = i._options, s.borderAlign !== "inner" && (a = s.borderWidth, u = (l = s.hoverBorderWidth) > (u = a > u ? a : u) ? l : u); return u; },
    setHoverStyle(t) { const e = t._model; const n = t._options; const r = q.getHoverColor; t.$previousStyle = { backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth }, e.backgroundColor = At(n.hoverBackgroundColor, r(n.backgroundColor)), e.borderColor = At(n.hoverBorderColor, r(n.borderColor)), e.borderWidth = At(n.hoverBorderWidth, n.borderWidth); },
    _getRingWeightOffset(t) { for (var e = 0, n = 0; n < t; ++n) this.chart.isDatasetVisible(n) && (e += this._getRingWeight(n)); return e; },
    _getRingWeight(t) { return Math.max(At(this.chart.data.datasets[t].weight, 1), 0); },
    _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length); },
  }); R._set("horizontalBar", {
    hover: { mode: "index", axis: "y" },
    scales: {
      xAxes: [{ type: "linear", position: "bottom" }],
      yAxes: [{
        type: "category", position: "left", offset: !0, gridLines: { offsetGridLines: !0 },
      }],
    },
    elements: { rectangle: { borderSkipped: "left" } },
    tooltips: { mode: "index", axis: "y" },
  }), R._set("global", { datasets: { horizontalBar: { categoryPercentage: 0.8, barPercentage: 0.9 } } }); const Dt = Et.extend({ _getValueScaleId() { return this.getMeta().xAxisID; }, _getIndexScaleId() { return this.getMeta().yAxisID; } }); const Nt = q.valueOrDefault; const Rt = q.options.resolve; const Ft = q.canvas._isPointInArea; function Vt(t, e) { const n = t && t.options.ticks || {}; const r = n.reverse; const i = void 0 === n.min ? e : 0; const o = void 0 === n.max ? e : 0; return { start: r ? o : i, end: r ? i : o }; } function zt(t, e, n) {
    const r = n / 2; const i = Vt(t, r); const o = Vt(e, r); return {
      top: o.end, right: i.end, bottom: o.start, left: i.start,
    };
  } function Bt(t) {
    let e; let n; let r; let i; return q.isObject(t) ? (e = t.top, n = t.right, r = t.bottom, i = t.left) : e = n = r = i = t, {
      top: e, right: n, bottom: r, left: i,
    };
  }R._set("line", {
    showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] },
  }); const qt = nt.extend({
    datasetElementType: _t.Line,
    dataElementType: _t.Point,
    _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth", "cubicInterpolationMode", "fill"],
    _dataElementOptions: {
      backgroundColor: "pointBackgroundColor", borderColor: "pointBorderColor", borderWidth: "pointBorderWidth", hitRadius: "pointHitRadius", hoverBackgroundColor: "pointHoverBackgroundColor", hoverBorderColor: "pointHoverBorderColor", hoverBorderWidth: "pointHoverBorderWidth", hoverRadius: "pointHoverRadius", pointStyle: "pointStyle", radius: "pointRadius", rotation: "pointRotation",
    },
    update(t) { let e; let n; const r = this; const i = r.getMeta(); const o = i.dataset; const s = i.data || []; const a = r.chart.options; const l = r._config; const u = r._showLine = Nt(l.showLine, a.showLines); for (r._xScale = r.getScaleForId(i.xAxisID), r._yScale = r.getScaleForId(i.yAxisID), u && (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), o._scale = r._yScale, o._datasetIndex = r.index, o._children = s, o._model = r._resolveDatasetElementOptions(o), o.pivot()), e = 0, n = s.length; e < n; ++e)r.updateElement(s[e], e, t); for (u && o._model.tension !== 0 && r.updateBezierControlPoints(), e = 0, n = s.length; e < n; ++e)s[e].pivot(); },
    updateElement(t, e, n) {
      let r; let i; const o = this; const s = o.getMeta(); const a = t.custom || {}; const l = o.getDataset(); const u = o.index; const c = l.data[e]; const d = o._xScale; const h = o._yScale; const p = s.dataset._model; const f = o._resolveDataElementOptions(t, e); r = d.getPixelForValue(typeof c === "object" ? c : NaN, e, u), i = n ? h.getBasePixel() : o.calculatePointY(c, e, u), t._xScale = d, t._yScale = h, t._options = f, t._datasetIndex = u, t._index = e, t._model = {
        x: r, y: i, skip: a.skip || isNaN(r) || isNaN(i), radius: f.radius, pointStyle: f.pointStyle, rotation: f.rotation, backgroundColor: f.backgroundColor, borderColor: f.borderColor, borderWidth: f.borderWidth, tension: Nt(a.tension, p ? p.tension : 0), steppedLine: !!p && p.steppedLine, hitRadius: f.hitRadius,
      };
    },
    _resolveDatasetElementOptions(t) { const e = this; const n = e._config; const r = t.custom || {}; const i = e.chart.options; const o = i.elements.line; const s = nt.prototype._resolveDatasetElementOptions.apply(e, arguments); return s.spanGaps = Nt(n.spanGaps, i.spanGaps), s.tension = Nt(n.lineTension, o.tension), s.steppedLine = Rt([r.steppedLine, n.steppedLine, o.stepped]), s.clip = Bt(Nt(n.clip, zt(e._xScale, e._yScale, s.borderWidth))), s; },
    calculatePointY(t, e, n) { let r; let i; let o; let s; let a; let l; let u; const c = this.chart; const d = this._yScale; let h = 0; let p = 0; if (d.options.stacked) { for (a = +d.getRightValue(t), u = (l = c._getSortedVisibleDatasetMetas()).length, r = 0; r < u && (o = l[r]).index !== n; ++r)i = c.data.datasets[o.index], o.type === "line" && o.yAxisID === d.id && ((s = +d.getRightValue(i.data[e])) < 0 ? p += s || 0 : h += s || 0); return a < 0 ? d.getPixelForValue(p + a) : d.getPixelForValue(h + a); } return d.getPixelForValue(t); },
    updateBezierControlPoints() { let t; let e; let n; let r; const i = this.chart; const o = this.getMeta(); const s = o.dataset._model; const a = i.chartArea; let l = o.data || []; function u(t, e, n) { return Math.max(Math.min(t, n), e); } if (s.spanGaps && (l = l.filter(((t) => !t._model.skip))), s.cubicInterpolationMode === "monotone")q.splineCurveMonotone(l); else for (t = 0, e = l.length; t < e; ++t)n = l[t]._model, r = q.splineCurve(q.previousItem(l, t)._model, n, q.nextItem(l, t)._model, s.tension), n.controlPointPreviousX = r.previous.x, n.controlPointPreviousY = r.previous.y, n.controlPointNextX = r.next.x, n.controlPointNextY = r.next.y; if (i.options.elements.line.capBezierPoints) for (t = 0, e = l.length; t < e; ++t)n = l[t]._model, Ft(n, a) && (t > 0 && Ft(l[t - 1]._model, a) && (n.controlPointPreviousX = u(n.controlPointPreviousX, a.left, a.right), n.controlPointPreviousY = u(n.controlPointPreviousY, a.top, a.bottom)), t < l.length - 1 && Ft(l[t + 1]._model, a) && (n.controlPointNextX = u(n.controlPointNextX, a.left, a.right), n.controlPointNextY = u(n.controlPointNextY, a.top, a.bottom))); },
    draw() {
      let t; const e = this.chart; const n = this.getMeta(); const r = n.data || []; const i = e.chartArea; const o = e.canvas; let s = 0; const a = r.length; for (this._showLine && (t = n.dataset._model.clip, q.canvas.clipArea(e.ctx, {
        left: !1 === t.left ? 0 : i.left - t.left, right: !1 === t.right ? o.width : i.right + t.right, top: !1 === t.top ? 0 : i.top - t.top, bottom: !1 === t.bottom ? o.height : i.bottom + t.bottom,
      }), n.dataset.draw(), q.canvas.unclipArea(e.ctx)); s < a; ++s)r[s].draw(i);
    },
    setHoverStyle(t) {
      const e = t._model; const n = t._options; const r = q.getHoverColor; t.$previousStyle = {
        backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth, radius: e.radius,
      }, e.backgroundColor = Nt(n.hoverBackgroundColor, r(n.backgroundColor)), e.borderColor = Nt(n.hoverBorderColor, r(n.borderColor)), e.borderWidth = Nt(n.hoverBorderWidth, n.borderWidth), e.radius = Nt(n.hoverRadius, n.radius);
    },
  }); const Ht = q.options.resolve; R._set("polarArea", {
    scale: {
      type: "radialLinear", angleLines: { display: !1 }, gridLines: { circular: !0 }, pointLabels: { display: !1 }, ticks: { beginAtZero: !0 },
    },
    animation: { animateRotate: !0, animateScale: !0 },
    startAngle: -0.5 * Math.PI,
    legendCallback(t) { let e; let n; let r; const i = document.createElement("ul"); const o = t.data; const s = o.datasets; const a = o.labels; if (i.setAttribute("class", `${t.id}-legend`), s.length) for (e = 0, n = s[0].data.length; e < n; ++e)(r = i.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = s[0].backgroundColor[e], a[e] && r.appendChild(document.createTextNode(a[e])); return i.outerHTML; },
    legend: {
      labels: {
        generateLabels(t) {
          const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(((n, r) => {
            const i = t.getDatasetMeta(0); const o = i.controller.getStyle(r); return {
              text: n, fillStyle: o.backgroundColor, strokeStyle: o.borderColor, lineWidth: o.borderWidth, hidden: isNaN(e.datasets[0].data[r]) || i.data[r].hidden, index: r,
            };
          })) : [];
        },
      },
      onClick(t, e) { let n; let r; let i; const o = e.index; const s = this.chart; for (n = 0, r = (s.data.datasets || []).length; n < r; ++n)(i = s.getDatasetMeta(n)).data[o].hidden = !i.data[o].hidden; s.update(); },
    },
    tooltips: { callbacks: { title() { return ""; }, label(t, e) { return `${e.labels[t.index]}: ${t.yLabel}`; } } },
  }); const $t = nt.extend({
    dataElementType: _t.Arc,
    linkScales: q.noop,
    _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
    _getIndexScaleId() { return this.chart.scale.id; },
    _getValueScaleId() { return this.chart.scale.id; },
    update(t) { let e; let n; let r; const i = this; const o = i.getDataset(); const s = i.getMeta(); let a = i.chart.options.startAngle || 0; const l = i._starts = []; const u = i._angles = []; const c = s.data; for (i._updateRadius(), s.count = i.countVisibleElements(), e = 0, n = o.data.length; e < n; e++)l[e] = a, r = i._computeAngle(e), u[e] = r, a += r; for (e = 0, n = c.length; e < n; ++e)c[e]._options = i._resolveDataElementOptions(c[e], e), i.updateElement(c[e], e, t); },
    _updateRadius() { const t = this; const e = t.chart; const n = e.chartArea; const r = e.options; const i = Math.min(n.right - n.left, n.bottom - n.top); e.outerRadius = Math.max(i / 2, 0), e.innerRadius = Math.max(r.cutoutPercentage ? e.outerRadius / 100 * r.cutoutPercentage : 1, 0), e.radiusLength = (e.outerRadius - e.innerRadius) / e.getVisibleDatasetCount(), t.outerRadius = e.outerRadius - e.radiusLength * t.index, t.innerRadius = t.outerRadius - e.radiusLength; },
    updateElement(t, e, n) {
      const r = this; const i = r.chart; const o = r.getDataset(); const s = i.options; const a = s.animation; const l = i.scale; const u = i.data.labels; const c = l.xCenter; const d = l.yCenter; const h = s.startAngle; const p = t.hidden ? 0 : l.getDistanceFromCenterForValue(o.data[e]); const f = r._starts[e]; const m = f + (t.hidden ? 0 : r._angles[e]); const g = a.animateScale ? 0 : l.getDistanceFromCenterForValue(o.data[e]); const v = t._options || {}; q.extend(t, {
        _datasetIndex: r.index,
        _index: e,
        _scale: l,
        _model: {
          backgroundColor: v.backgroundColor, borderColor: v.borderColor, borderWidth: v.borderWidth, borderAlign: v.borderAlign, x: c, y: d, innerRadius: 0, outerRadius: n ? g : p, startAngle: n && a.animateRotate ? h : f, endAngle: n && a.animateRotate ? h : m, label: q.valueAtIndexOrDefault(u, e, u[e]),
        },
      }), t.pivot();
    },
    countVisibleElements() { const t = this.getDataset(); const e = this.getMeta(); let n = 0; return q.each(e.data, ((e, r) => { isNaN(t.data[r]) || e.hidden || n++; })), n; },
    setHoverStyle(t) { const e = t._model; const n = t._options; const r = q.getHoverColor; const i = q.valueOrDefault; t.$previousStyle = { backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth }, e.backgroundColor = i(n.hoverBackgroundColor, r(n.backgroundColor)), e.borderColor = i(n.hoverBorderColor, r(n.borderColor)), e.borderWidth = i(n.hoverBorderWidth, n.borderWidth); },
    _computeAngle(t) {
      const e = this; const n = this.getMeta().count; const r = e.getDataset(); const i = e.getMeta(); if (isNaN(r.data[t]) || i.data[t].hidden) return 0; const o = {
        chart: e.chart, dataIndex: t, dataset: r, datasetIndex: e.index,
      }; return Ht([e.chart.options.elements.arc.angle, 2 * Math.PI / n], o, t);
    },
  }); R._set("pie", q.clone(R.doughnut)), R._set("pie", { cutoutPercentage: 0 }); const Ut = jt; const Wt = q.valueOrDefault; R._set("radar", { spanGaps: !1, scale: { type: "radialLinear" }, elements: { line: { fill: "start", tension: 0 } } }); const Gt = nt.extend({
    datasetElementType: _t.Line,
    dataElementType: _t.Point,
    linkScales: q.noop,
    _datasetElementOptions: ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"],
    _dataElementOptions: {
      backgroundColor: "pointBackgroundColor", borderColor: "pointBorderColor", borderWidth: "pointBorderWidth", hitRadius: "pointHitRadius", hoverBackgroundColor: "pointHoverBackgroundColor", hoverBorderColor: "pointHoverBorderColor", hoverBorderWidth: "pointHoverBorderWidth", hoverRadius: "pointHoverRadius", pointStyle: "pointStyle", radius: "pointRadius", rotation: "pointRotation",
    },
    _getIndexScaleId() { return this.chart.scale.id; },
    _getValueScaleId() { return this.chart.scale.id; },
    update(t) { let e; let n; const r = this; const i = r.getMeta(); const o = i.dataset; const s = i.data || []; const a = r.chart.scale; const l = r._config; for (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), o._scale = a, o._datasetIndex = r.index, o._children = s, o._loop = !0, o._model = r._resolveDatasetElementOptions(o), o.pivot(), e = 0, n = s.length; e < n; ++e)r.updateElement(s[e], e, t); for (r.updateBezierControlPoints(), e = 0, n = s.length; e < n; ++e)s[e].pivot(); },
    updateElement(t, e, n) {
      const r = this; const i = t.custom || {}; const o = r.getDataset(); const s = r.chart.scale; const a = s.getPointPositionForValue(e, o.data[e]); const l = r._resolveDataElementOptions(t, e); const u = r.getMeta().dataset._model; const c = n ? s.xCenter : a.x; const d = n ? s.yCenter : a.y; t._scale = s, t._options = l, t._datasetIndex = r.index, t._index = e, t._model = {
        x: c, y: d, skip: i.skip || isNaN(c) || isNaN(d), radius: l.radius, pointStyle: l.pointStyle, rotation: l.rotation, backgroundColor: l.backgroundColor, borderColor: l.borderColor, borderWidth: l.borderWidth, tension: Wt(i.tension, u ? u.tension : 0), hitRadius: l.hitRadius,
      };
    },
    _resolveDatasetElementOptions() { const t = this; const e = t._config; const n = t.chart.options; const r = nt.prototype._resolveDatasetElementOptions.apply(t, arguments); return r.spanGaps = Wt(e.spanGaps, n.spanGaps), r.tension = Wt(e.lineTension, n.elements.line.tension), r; },
    updateBezierControlPoints() { let t; let e; let n; let r; const i = this.getMeta(); const o = this.chart.chartArea; let s = i.data || []; function a(t, e, n) { return Math.max(Math.min(t, n), e); } for (i.dataset._model.spanGaps && (s = s.filter(((t) => !t._model.skip))), t = 0, e = s.length; t < e; ++t)n = s[t]._model, r = q.splineCurve(q.previousItem(s, t, !0)._model, n, q.nextItem(s, t, !0)._model, n.tension), n.controlPointPreviousX = a(r.previous.x, o.left, o.right), n.controlPointPreviousY = a(r.previous.y, o.top, o.bottom), n.controlPointNextX = a(r.next.x, o.left, o.right), n.controlPointNextY = a(r.next.y, o.top, o.bottom); },
    setHoverStyle(t) {
      const e = t._model; const n = t._options; const r = q.getHoverColor; t.$previousStyle = {
        backgroundColor: e.backgroundColor, borderColor: e.borderColor, borderWidth: e.borderWidth, radius: e.radius,
      }, e.backgroundColor = Wt(n.hoverBackgroundColor, r(n.backgroundColor)), e.borderColor = Wt(n.hoverBorderColor, r(n.borderColor)), e.borderWidth = Wt(n.hoverBorderWidth, n.borderWidth), e.radius = Wt(n.hoverRadius, n.radius);
    },
  }); R._set("scatter", { hover: { mode: "single" }, scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] }, tooltips: { callbacks: { title() { return ""; }, label(t) { return `(${t.xLabel}, ${t.yLabel})`; } } } }), R._set("global", { datasets: { scatter: { showLine: !1 } } }); const Yt = {
    bar: Et, bubble: Ot, doughnut: jt, horizontalBar: Dt, line: qt, polarArea: $t, pie: Ut, radar: Gt, scatter: qt,
  }; function Zt(t, e) { return t.native ? { x: t.x, y: t.y } : q.getRelativePosition(t, e); } function Kt(t, e) { let n; let r; let i; let o; let s; let a; const l = t._getSortedVisibleDatasetMetas(); for (r = 0, o = l.length; r < o; ++r) for (i = 0, s = (n = l[r].data).length; i < s; ++i)(a = n[i])._view.skip || e(a); } function Xt(t, e) { const n = []; return Kt(t, ((t) => { t.inRange(e.x, e.y) && n.push(t); })), n; } function Qt(t, e, n, r) { let i = Number.POSITIVE_INFINITY; let o = []; return Kt(t, ((t) => { if (!n || t.inRange(e.x, e.y)) { const s = t.getCenterPoint(); const a = r(e, s); a < i ? (o = [t], i = a) : a === i && o.push(t); } })), o; } function Jt(t) { const e = t.indexOf("x") !== -1; const n = t.indexOf("y") !== -1; return function (t, r) { const i = e ? Math.abs(t.x - r.x) : 0; const o = n ? Math.abs(t.y - r.y) : 0; return Math.sqrt(i ** 2 + o ** 2); }; } function te(t, e, n) { const r = Zt(e, t); n.axis = n.axis || "x"; const i = Jt(n.axis); const o = n.intersect ? Xt(t, r) : Qt(t, r, !1, i); const s = []; return o.length ? (t._getSortedVisibleDatasetMetas().forEach(((t) => { const e = t.data[o[0]._index]; e && !e._view.skip && s.push(e); })), s) : []; } const ee = {
    modes: {
      single(t, e) { const n = Zt(e, t); const r = []; return Kt(t, ((t) => { if (t.inRange(n.x, n.y)) return r.push(t), r; })), r.slice(0, 1); }, label: te, index: te, dataset(t, e, n) { const r = Zt(e, t); n.axis = n.axis || "xy"; const i = Jt(n.axis); let o = n.intersect ? Xt(t, r) : Qt(t, r, !1, i); return o.length > 0 && (o = t.getDatasetMeta(o[0]._datasetIndex).data), o; }, "x-axis": function (t, e) { return te(t, e, { intersect: !1 }); }, point(t, e) { return Xt(t, Zt(e, t)); }, nearest(t, e, n) { const r = Zt(e, t); n.axis = n.axis || "xy"; const i = Jt(n.axis); return Qt(t, r, n.intersect, i); }, x(t, e, n) { const r = Zt(e, t); let i = []; let o = !1; return Kt(t, ((t) => { t.inXRange(r.x) && i.push(t), t.inRange(r.x, r.y) && (o = !0); })), n.intersect && !o && (i = []), i; }, y(t, e, n) { const r = Zt(e, t); let i = []; let o = !1; return Kt(t, ((t) => { t.inYRange(r.y) && i.push(t), t.inRange(r.x, r.y) && (o = !0); })), n.intersect && !o && (i = []), i; },
    },
  }; const ne = q.extend; function re(t, e) { return q.where(t, ((t) => t.pos === e)); } function ie(t, e) { return t.sort(((t, n) => { const r = e ? n : t; const i = e ? t : n; return r.weight === i.weight ? r.index - i.index : r.weight - i.weight; })); } function oe(t, e, n, r) { return Math.max(t[n], e[n]) + Math.max(t[r], e[r]); } function se(t, e, n) { let r; let i; const o = n.box; const s = t.maxPadding; if (n.size && (t[n.pos] -= n.size), n.size = n.horizontal ? o.height : o.width, t[n.pos] += n.size, o.getPadding) { const a = o.getPadding(); s.top = Math.max(s.top, a.top), s.left = Math.max(s.left, a.left), s.bottom = Math.max(s.bottom, a.bottom), s.right = Math.max(s.right, a.right); } if (r = e.outerWidth - oe(s, t, "left", "right"), i = e.outerHeight - oe(s, t, "top", "bottom"), r !== t.w || i !== t.h) { t.w = r, t.h = i; const l = n.horizontal ? [r, t.w] : [i, t.h]; return !(l[0] === l[1] || isNaN(l[0]) && isNaN(l[1])); } } function ae(t, e) {
    const n = e.maxPadding; return (function (t) {
      const r = {
        left: 0, top: 0, right: 0, bottom: 0,
      }; return t.forEach(((t) => { r[t] = Math.max(e[t], n[t]); })), r;
    }(t ? ["left", "right"] : ["top", "bottom"]));
  } function le(t, e, n) { let r; let i; let o; let s; let a; let l; const u = []; for (r = 0, i = t.length; r < i; ++r)(s = (o = t[r]).box).update(o.width || e.w, o.height || e.h, ae(o.horizontal, e)), se(e, n, o) && (l = !0, u.length && (a = !0)), s.fullWidth || u.push(o); return a && le(u, e, n) || l; } function ue(t, e, n) { let r; let i; let o; let s; const a = n.padding; let l = e.x; let u = e.y; for (r = 0, i = t.length; r < i; ++r)s = (o = t[r]).box, o.horizontal ? (s.left = s.fullWidth ? a.left : e.left, s.right = s.fullWidth ? n.outerWidth - a.right : e.left + e.w, s.top = u, s.bottom = u + s.height, s.width = s.right - s.left, u = s.bottom) : (s.left = l, s.right = l + s.width, s.top = e.top, s.bottom = e.top + e.h, s.height = s.bottom - s.top, l = s.right); e.x = l, e.y = u; }R._set("global", {
    layout: {
      padding: {
        top: 0, right: 0, bottom: 0, left: 0,
      },
    },
  }); let ce; const de = {
    defaults: {},
    addBox(t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw() { e.draw.apply(e, arguments); } }]; }, t.boxes.push(e); },
    removeBox(t, e) { const n = t.boxes ? t.boxes.indexOf(e) : -1; n !== -1 && t.boxes.splice(n, 1); },
    configure(t, e, n) { for (var r, i = ["fullWidth", "position", "weight"], o = i.length, s = 0; s < o; ++s)r = i[s], n.hasOwnProperty(r) && (e[r] = n[r]); },
    update(t, e, n) {
      if (t) {
        const r = t.options.layout || {}; const i = q.options.toPadding(r.padding); const o = e - i.width; const s = n - i.height; const a = (function (t) {
 const e = (function (t) { var e; var n; var r; var i = []; for (e = 0, n = (t || []).length; e < n; ++e)r = t[e], i.push({ index: e, box: r, pos: r.position, horizontal: r.isHorizontal(), weight: r.weight }); return i }(t)); const n = ie(re(e, "left"), !0); const r = ie(re(e, "right")); const i = ie(re(e, "top"), !0); const o = ie(re(e, "bottom")); return {
          leftAndTop: n.concat(i), rightAndBottom: r.concat(o), chartArea: re(e, "chartArea"), vertical: n.concat(r), horizontal: i.concat(o), 
        }; 
}(t.boxes)); const l = a.vertical; const u = a.horizontal; const c = Object.freeze({
          outerWidth: e, outerHeight: n, padding: i, availableWidth: o, vBoxMaxWidth: o / 2 / l.length, hBoxMaxHeight: s / 2,
        }); const d = ne({
          maxPadding: ne({}, i), w: o, h: s, x: i.left, y: i.top,
        }, i); !(function (t, e) { let n; let r; let i; for (n = 0, r = t.length; n < r; ++n)(i = t[n]).width = i.horizontal ? i.box.fullWidth && e.availableWidth : e.vBoxMaxWidth, i.height = i.horizontal && e.hBoxMaxHeight; }(l.concat(u), c)), le(l, d, c), le(u, d, c) && le(l, d, c), (function (t) { const e = t.maxPadding; function n(n) { const r = Math.max(e[n] - t[n], 0); return t[n] += r, r; }t.y += n("top"), t.x += n("left"), n("right"), n("bottom"); }(d)), ue(a.leftAndTop, d, c), d.x += d.w, d.y += d.h, ue(a.rightAndBottom, d, c), t.chartArea = {
          left: d.left, top: d.top, right: d.left + d.w, bottom: d.top + d.h,
        }, q.each(a.chartArea, ((e) => { const n = e.box; ne(n, t.chartArea), n.update(d.w, d.h); }));
      }
    },
  }; const he = (ce = Object.freeze({ __proto__: null, default: "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}" })) && ce.default || ce; const pe = "$chartjs"; const fe = "chartjs-size-monitor"; const me = "chartjs-render-monitor"; const ge = ["animationstart", "webkitAnimationStart"]; const ve = {
    touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout",
  }; function ye(t, e) { const n = q.getStyle(t, e); const r = n && n.match(/^(\d+)(\.\d+)?px$/); return r ? Number(r[1]) : void 0; } const _e = !!(function () { let t = !1; try { const e = Object.defineProperty({}, "passive", { get() { t = !0; } }); window.addEventListener("e", null, e); } catch (t) {} return t; }()) && { passive: !0 }; function be(t, e, n) { t.addEventListener(e, n, _e); } function we(t, e, n) { t.removeEventListener(e, n, _e); } function xe(t, e, n, r, i) {
    return {
      type: t, chart: e, native: i || null, x: void 0 !== n ? n : null, y: void 0 !== r ? r : null,
    };
  } function Se(t) { const e = document.createElement("div"); return e.className = t || "", e; } const ke = {
    disableCSSInjection: !1, _enabled: typeof window !== "undefined" && typeof document !== "undefined", _ensureLoaded(t) { if (!this.disableCSSInjection) { const e = t.getRootNode ? t.getRootNode() : document; !(function (t, e) { const n = t[pe] || (t[pe] = {}); if (!n.containsStyles) { n.containsStyles = !0, e = `/* Chart.js */\n${e}`; const r = document.createElement("style"); r.setAttribute("type", "text/css"), r.appendChild(document.createTextNode(e)), t.appendChild(r); } }(e.host ? e : document.head, he)); } }, acquireContext(t, e) { typeof t === "string" ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas); const n = t && t.getContext && t.getContext("2d"); return n && n.canvas === t ? (this._ensureLoaded(t), (function (t, e) { const n = t.style; const r = t.getAttribute("height"); const i = t.getAttribute("width"); if (t[pe] = { initial: { height: r, width: i, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", i === null || i === "") { var o = ye(t, "width"); void 0 !== o && (t.width = o); } if (r === null || r === "") if (t.style.height === "")t.height = t.width / (e.options.aspectRatio || 2); else { const s = ye(t, "height"); void 0 !== o && (t.height = s); } }(t, e)), n) : null; }, releaseContext(t) { const e = t.canvas; if (e[pe]) { const n = e[pe].initial; ["height", "width"].forEach(((t) => { const r = n[t]; q.isNullOrUndef(r) ? e.removeAttribute(t) : e.setAttribute(t, r); })), q.each(n.style || {}, ((t, n) => { e.style[n] = t; })), e.width = e.width, delete e[pe]; } }, addEventListener(t, e, n) { const r = t.canvas; if (e !== "resize") { const i = n[pe] || (n[pe] = {}); be(r, e, (i.proxies || (i.proxies = {}))[`${t.id}_${e}`] = function (e) { n(function (t, e) { const n = ve[t.type] || t.type; const r = q.getRelativePosition(t, e); return xe(n, e, r.x, r.y, t); }(e, t)); }); } else !(function (t, e, n) { let r; let i; let o; let s; const a = t[pe] || (t[pe] = {}); const l = a.resizer = (function (t) { const e = Se(fe); const n = Se(`${fe}-expand`); const r = Se(`${fe}-shrink`); n.appendChild(Se()), r.appendChild(Se()), e.appendChild(n), e.appendChild(r), e._reset = function () { n.scrollLeft = 1e6, n.scrollTop = 1e6, r.scrollLeft = 1e6, r.scrollTop = 1e6; }; const i = function () { e._reset(), t(); }; return be(n, "scroll", i.bind(n, "expand")), be(r, "scroll", i.bind(r, "shrink")), e; }((r = function () { if (a.resizer) { const r = n.options.maintainAspectRatio && t.parentNode; const i = r ? r.clientWidth : 0; e(xe("resize", n)), r && r.clientWidth < i && n.canvas && e(xe("resize", n)); } }, o = !1, s = [], function () { s = Array.prototype.slice.call(arguments), i = i || this, o || (o = !0, q.requestAnimFrame.call(window, (() => { o = !1, r.apply(i, s); }))); }))); !(function (t, e) { const n = t[pe] || (t[pe] = {}); const r = n.renderProxy = function (t) { t.animationName === "chartjs-render-animation" && e(); }; q.each(ge, ((e) => { be(t, e, r); })), n.reflow = !!t.offsetParent, t.classList.add(me); }(t, (() => { if (a.resizer) { const e = t.parentNode; e && e !== l.parentNode && e.insertBefore(l, e.firstChild), l._reset(); } }))); }(r, n, t)); }, removeEventListener(t, e, n) { const r = t.canvas; if (e !== "resize") { const i = ((n[pe] || {}).proxies || {})[`${t.id}_${e}`]; i && we(r, e, i); } else !(function (t) { const e = t[pe] || {}; const n = e.resizer; delete e.resizer, (function (t) { const e = t[pe] || {}; const n = e.renderProxy; n && (q.each(ge, ((e) => { we(t, e, n); })), delete e.renderProxy), t.classList.remove(me); }(t)), n && n.parentNode && n.parentNode.removeChild(n); }(r)); },
  }; q.addEvent = be, q.removeEvent = we; const Ce = ke._enabled ? ke : { acquireContext(t) { return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null; } }; const Ee = q.extend({
    initialize() {}, acquireContext() {}, releaseContext() {}, addEventListener() {}, removeEventListener() {},
  }, Ce); R._set("global", { plugins: {} }); const Te = {
    _plugins: [], _cacheId: 0, register(t) { const e = this._plugins; [].concat(t).forEach(((t) => { e.indexOf(t) === -1 && e.push(t); })), this._cacheId++; }, unregister(t) { const e = this._plugins; [].concat(t).forEach(((t) => { const n = e.indexOf(t); n !== -1 && e.splice(n, 1); })), this._cacheId++; }, clear() { this._plugins = [], this._cacheId++; }, count() { return this._plugins.length; }, getAll() { return this._plugins; }, notify(t, e, n) { let r; let i; let o; let s; let a; const l = this.descriptors(t); const u = l.length; for (r = 0; r < u; ++r) if (typeof (a = (o = (i = l[r]).plugin)[e]) === "function" && ((s = [t].concat(n || [])).push(i.options), !1 === a.apply(o, s))) return !1; return !0; }, descriptors(t) { const e = t.$plugins || (t.$plugins = {}); if (e.id === this._cacheId) return e.descriptors; const n = []; const r = []; const i = t && t.config || {}; const o = i.options && i.options.plugins || {}; return this._plugins.concat(i.plugins || []).forEach(((t) => { if (n.indexOf(t) === -1) { const e = t.id; let i = o[e]; !1 !== i && (!0 === i && (i = q.clone(R.global.plugins[e])), n.push(t), r.push({ plugin: t, options: i || {} })); } })), e.descriptors = r, e.id = this._cacheId, r; }, _invalidate(t) { delete t.$plugins; },
  }; const Pe = {
    constructors: {}, defaults: {}, registerScaleType(t, e, n) { this.constructors[t] = e, this.defaults[t] = q.clone(n); }, getScaleConstructor(t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0; }, getScaleDefaults(t) { return this.defaults.hasOwnProperty(t) ? q.merge(Object.create(null), [R.scale, this.defaults[t]]) : {}; }, updateScaleDefaults(t, e) { this.defaults.hasOwnProperty(t) && (this.defaults[t] = q.extend(this.defaults[t], e)); }, addScalesToLayout(t) { q.each(t.scales, ((e) => { e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, de.addBox(t, e); })); },
  }; const Oe = q.valueOrDefault; const Ae = q.rtl.getRtlAdapter; R._set("global", {
    tooltips: {
      enabled: !0,
      custom: null,
      mode: "nearest",
      position: "average",
      intersect: !0,
      backgroundColor: "rgba(0,0,0,0.8)",
      titleFontStyle: "bold",
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleFontColor: "#fff",
      titleAlign: "left",
      bodySpacing: 2,
      bodyFontColor: "#fff",
      bodyAlign: "left",
      footerFontStyle: "bold",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFontColor: "#fff",
      footerAlign: "left",
      yPadding: 6,
      xPadding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      multiKeyBackground: "#fff",
      displayColors: !0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      callbacks: {
        beforeTitle: q.noop, title(t, e) { let n = ""; const r = e.labels; const i = r ? r.length : 0; if (t.length > 0) { const o = t[0]; o.label ? n = o.label : o.xLabel ? n = o.xLabel : i > 0 && o.index < i && (n = r[o.index]); } return n; }, afterTitle: q.noop, beforeBody: q.noop, beforeLabel: q.noop, label(t, e) { let n = e.datasets[t.datasetIndex].label || ""; return n && (n += ": "), q.isNullOrUndef(t.value) ? n += t.yLabel : n += t.value, n; }, labelColor(t, e) { const n = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: n.borderColor, backgroundColor: n.backgroundColor }; }, labelTextColor() { return this._options.bodyFontColor; }, afterLabel: q.noop, afterBody: q.noop, beforeFooter: q.noop, footer: q.noop, afterFooter: q.noop,
      },
    },
  }); const Me = { average(t) { if (!t.length) return !1; let e; let n; let r = 0; let i = 0; let o = 0; for (e = 0, n = t.length; e < n; ++e) { const s = t[e]; if (s && s.hasValue()) { const a = s.tooltipPosition(); r += a.x, i += a.y, ++o; } } return { x: r / o, y: i / o }; }, nearest(t, e) { let n; let r; let i; let o = e.x; let s = e.y; let a = Number.POSITIVE_INFINITY; for (n = 0, r = t.length; n < r; ++n) { const l = t[n]; if (l && l.hasValue()) { const u = l.getCenterPoint(); const c = q.distanceBetweenPoints(e, u); c < a && (a = c, i = l); } } if (i) { const d = i.tooltipPosition(); o = d.x, s = d.y; } return { x: o, y: s }; } }; function Le(t, e) { return e && (q.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t; } function Ie(t) { return (typeof t === "string" || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t; } function je(t) {
    const e = R.global; return {
      xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, rtl: t.rtl, textDirection: t.textDirection, bodyFontColor: t.bodyFontColor, _bodyFontFamily: Oe(t.bodyFontFamily, e.defaultFontFamily), _bodyFontStyle: Oe(t.bodyFontStyle, e.defaultFontStyle), _bodyAlign: t.bodyAlign, bodyFontSize: Oe(t.bodyFontSize, e.defaultFontSize), bodySpacing: t.bodySpacing, titleFontColor: t.titleFontColor, _titleFontFamily: Oe(t.titleFontFamily, e.defaultFontFamily), _titleFontStyle: Oe(t.titleFontStyle, e.defaultFontStyle), titleFontSize: Oe(t.titleFontSize, e.defaultFontSize), _titleAlign: t.titleAlign, titleSpacing: t.titleSpacing, titleMarginBottom: t.titleMarginBottom, footerFontColor: t.footerFontColor, _footerFontFamily: Oe(t.footerFontFamily, e.defaultFontFamily), _footerFontStyle: Oe(t.footerFontStyle, e.defaultFontStyle), footerFontSize: Oe(t.footerFontSize, e.defaultFontSize), _footerAlign: t.footerAlign, footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, cornerRadius: t.cornerRadius, backgroundColor: t.backgroundColor, opacity: 0, legendColorBackground: t.multiKeyBackground, displayColors: t.displayColors, borderColor: t.borderColor, borderWidth: t.borderWidth,
    };
  } function De(t, e) { return e === "center" ? t.x + t.width / 2 : e === "right" ? t.x + t.width - t.xPadding : t.x + t.xPadding; } function Ne(t) { return Le([], Ie(t)); } const Re = Y.extend({
    initialize() { this._model = je(this._options), this._lastActive = []; },
    getTitle() { const t = this; const e = t._options; const n = e.callbacks; const r = n.beforeTitle.apply(t, arguments); const i = n.title.apply(t, arguments); const o = n.afterTitle.apply(t, arguments); let s = []; return s = Le(s, Ie(r)), s = Le(s, Ie(i)), Le(s, Ie(o)); },
    getBeforeBody() { return Ne(this._options.callbacks.beforeBody.apply(this, arguments)); },
    getBody(t, e) { const n = this; const r = n._options.callbacks; const i = []; return q.each(t, ((t) => { const o = { before: [], lines: [], after: [] }; Le(o.before, Ie(r.beforeLabel.call(n, t, e))), Le(o.lines, r.label.call(n, t, e)), Le(o.after, Ie(r.afterLabel.call(n, t, e))), i.push(o); })), i; },
    getAfterBody() { return Ne(this._options.callbacks.afterBody.apply(this, arguments)); },
    getFooter() { const t = this; const e = t._options.callbacks; const n = e.beforeFooter.apply(t, arguments); const r = e.footer.apply(t, arguments); const i = e.afterFooter.apply(t, arguments); let o = []; return o = Le(o, Ie(n)), o = Le(o, Ie(r)), Le(o, Ie(i)); },
    update(t) {
      let e; let n; let r; let i; let o; let s; let a; let l; let u; let c; const d = this; const h = d._options; const p = d._model; const f = d._model = je(h); const m = d._active; const g = d._data; let v = { xAlign: p.xAlign, yAlign: p.yAlign }; let y = { x: p.x, y: p.y }; let _ = { width: p.width, height: p.height }; let b = { x: p.caretX, y: p.caretY }; if (m.length) {
        f.opacity = 1; const w = []; const x = []; b = Me[h.position].call(d, m, d._eventPosition); let S = []; for (e = 0, n = m.length; e < n; ++e) {
          S.push((i = void 0, o = void 0, void 0, void 0, l = void 0, u = void 0, c = void 0, i = (r = m[e])._xScale, o = r._yScale || r._scale, s = r._index, a = r._datasetIndex, u = (l = r._chart.getDatasetMeta(a).controller)._getIndexScale(), c = l._getValueScale(), {
            xLabel: i ? i.getLabelForIndex(s, a) : "", yLabel: o ? o.getLabelForIndex(s, a) : "", label: u ? `${u.getLabelForIndex(s, a)}` : "", value: c ? `${c.getLabelForIndex(s, a)}` : "", index: s, datasetIndex: a, x: r._model.x, y: r._model.y,
          }));
        } h.filter && (S = S.filter(((t) => h.filter(t, g)))), h.itemSort && (S = S.sort(((t, e) => h.itemSort(t, e, g)))), q.each(S, ((t) => { w.push(h.callbacks.labelColor.call(d, t, d._chart)), x.push(h.callbacks.labelTextColor.call(d, t, d._chart)); })), f.title = d.getTitle(S, g), f.beforeBody = d.getBeforeBody(S, g), f.body = d.getBody(S, g), f.afterBody = d.getAfterBody(S, g), f.footer = d.getFooter(S, g), f.x = b.x, f.y = b.y, f.caretPadding = h.caretPadding, f.labelColors = w, f.labelTextColors = x, f.dataPoints = S, y = (function (t, e, n, r) { let i = t.x; let o = t.y; const s = t.caretSize; const a = t.caretPadding; const l = t.cornerRadius; const u = n.xAlign; const c = n.yAlign; const d = s + a; const h = l + a; return u === "right" ? i -= e.width : u === "center" && ((i -= e.width / 2) + e.width > r.width && (i = r.width - e.width), i < 0 && (i = 0)), c === "top" ? o += d : o -= c === "bottom" ? e.height + d : e.height / 2, c === "center" ? u === "left" ? i += d : u === "right" && (i -= d) : u === "left" ? i -= h : u === "right" && (i += h), { x: i, y: o }; }(f, _ = (function (t, e) { const n = t._chart.ctx; let r = 2 * e.yPadding; let i = 0; const o = e.body; let s = o.reduce(((t, e) => t + e.before.length + e.lines.length + e.after.length), 0); s += e.beforeBody.length + e.afterBody.length; const a = e.title.length; const l = e.footer.length; const u = e.titleFontSize; const c = e.bodyFontSize; const d = e.footerFontSize; r += a * u, r += a ? (a - 1) * e.titleSpacing : 0, r += a ? e.titleMarginBottom : 0, r += s * c, r += s ? (s - 1) * e.bodySpacing : 0, r += l ? e.footerMarginTop : 0, r += l * d, r += l ? (l - 1) * e.footerSpacing : 0; let h = 0; const p = function (t) { i = Math.max(i, n.measureText(t).width + h); }; return n.font = q.fontString(u, e._titleFontStyle, e._titleFontFamily), q.each(e.title, p), n.font = q.fontString(c, e._bodyFontStyle, e._bodyFontFamily), q.each(e.beforeBody.concat(e.afterBody), p), h = e.displayColors ? c + 2 : 0, q.each(o, ((t) => { q.each(t.before, p), q.each(t.lines, p), q.each(t.after, p); })), h = 0, n.font = q.fontString(d, e._footerFontStyle, e._footerFontFamily), q.each(e.footer, p), { width: i += 2 * e.xPadding, height: r }; }(this, f)), v = (function (t, e) { let n; let r; let i; let o; let s; const a = t._model; const l = t._chart; const u = t._chart.chartArea; let c = "center"; let d = "center"; a.y < e.height ? d = "top" : a.y > l.height - e.height && (d = "bottom"); const h = (u.left + u.right) / 2; const p = (u.top + u.bottom) / 2; d === "center" ? (n = function (t) { return t <= h; }, r = function (t) { return t > h; }) : (n = function (t) { return t <= e.width / 2; }, r = function (t) { return t >= l.width - e.width / 2; }), i = function (t) { return t + e.width + a.caretSize + a.caretPadding > l.width; }, o = function (t) { return t - e.width - a.caretSize - a.caretPadding < 0; }, s = function (t) { return t <= p ? "top" : "bottom"; }, n(a.x) ? (c = "left", i(a.x) && (c = "center", d = s(a.y))) : r(a.x) && (c = "right", o(a.x) && (c = "center", d = s(a.y))); const f = t._options; return { xAlign: f.xAlign ? f.xAlign : c, yAlign: f.yAlign ? f.yAlign : d }; }(this, _)), d._chart));
      } else f.opacity = 0; return f.xAlign = v.xAlign, f.yAlign = v.yAlign, f.x = y.x, f.y = y.y, f.width = _.width, f.height = _.height, f.caretX = b.x, f.caretY = b.y, d._model = f, t && h.custom && h.custom.call(d, f), d;
    },
    drawCaret(t, e) { const n = this._chart.ctx; const r = this._view; const i = this.getCaretPosition(t, e, r); n.lineTo(i.x1, i.y1), n.lineTo(i.x2, i.y2), n.lineTo(i.x3, i.y3); },
    getCaretPosition(t, e, n) {
      let r; let i; let o; let s; let a; let l; const u = n.caretSize; const c = n.cornerRadius; const d = n.xAlign; const h = n.yAlign; const p = t.x; const f = t.y; const m = e.width; const g = e.height; if (h === "center")a = f + g / 2, d === "left" ? (i = (r = p) - u, o = r, s = a + u, l = a - u) : (i = (r = p + m) + u, o = r, s = a - u, l = a + u); else if (d === "left" ? (r = (i = p + c + u) - u, o = i + u) : d === "right" ? (r = (i = p + m - c - u) - u, o = i + u) : (r = (i = n.caretX) - u, o = i + u), h === "top")a = (s = f) - u, l = s; else { a = (s = f + g) + u, l = s; const v = o; o = r, r = v; } return {
        x1: r, x2: i, x3: o, y1: s, y2: a, y3: l,
      };
    },
    drawTitle(t, e, n) { let r; let i; let o; const s = e.title; const a = s.length; if (a) { const l = Ae(e.rtl, e.x, e.width); for (t.x = De(e, e._titleAlign), n.textAlign = l.textAlign(e._titleAlign), n.textBaseline = "middle", r = e.titleFontSize, i = e.titleSpacing, n.fillStyle = e.titleFontColor, n.font = q.fontString(r, e._titleFontStyle, e._titleFontFamily), o = 0; o < a; ++o)n.fillText(s[o], l.x(t.x), t.y + r / 2), t.y += r + i, o + 1 === a && (t.y += e.titleMarginBottom - i); } },
    drawBody(t, e, n) { let r; let i; let o; let s; let a; let l; let u; let c; const d = e.bodyFontSize; const h = e.bodySpacing; const p = e._bodyAlign; const f = e.body; const m = e.displayColors; let g = 0; const v = m ? De(e, "left") : 0; const y = Ae(e.rtl, e.x, e.width); const _ = function (e) { n.fillText(e, y.x(t.x + g), t.y + d / 2), t.y += d + h; }; const b = y.textAlign(p); for (n.textAlign = p, n.textBaseline = "middle", n.font = q.fontString(d, e._bodyFontStyle, e._bodyFontFamily), t.x = De(e, b), n.fillStyle = e.bodyFontColor, q.each(e.beforeBody, _), g = m && b !== "right" ? p === "center" ? d / 2 + 1 : d + 2 : 0, a = 0, u = f.length; a < u; ++a) { for (r = f[a], i = e.labelTextColors[a], o = e.labelColors[a], n.fillStyle = i, q.each(r.before, _), l = 0, c = (s = r.lines).length; l < c; ++l) { if (m) { const w = y.x(v); n.fillStyle = e.legendColorBackground, n.fillRect(y.leftForLtr(w, d), t.y, d, d), n.lineWidth = 1, n.strokeStyle = o.borderColor, n.strokeRect(y.leftForLtr(w, d), t.y, d, d), n.fillStyle = o.backgroundColor, n.fillRect(y.leftForLtr(y.xPlus(w, 1), d - 2), t.y + 1, d - 2, d - 2), n.fillStyle = i; }_(s[l]); }q.each(r.after, _); }g = 0, q.each(e.afterBody, _), t.y -= h; },
    drawFooter(t, e, n) { let r; let i; const o = e.footer; const s = o.length; if (s) { const a = Ae(e.rtl, e.x, e.width); for (t.x = De(e, e._footerAlign), t.y += e.footerMarginTop, n.textAlign = a.textAlign(e._footerAlign), n.textBaseline = "middle", r = e.footerFontSize, n.fillStyle = e.footerFontColor, n.font = q.fontString(r, e._footerFontStyle, e._footerFontFamily), i = 0; i < s; ++i)n.fillText(o[i], a.x(t.x), t.y + r / 2), t.y += r + e.footerSpacing; } },
    drawBackground(t, e, n, r) { n.fillStyle = e.backgroundColor, n.strokeStyle = e.borderColor, n.lineWidth = e.borderWidth; const i = e.xAlign; const o = e.yAlign; const s = t.x; const a = t.y; const l = r.width; const u = r.height; const c = e.cornerRadius; n.beginPath(), n.moveTo(s + c, a), o === "top" && this.drawCaret(t, r), n.lineTo(s + l - c, a), n.quadraticCurveTo(s + l, a, s + l, a + c), o === "center" && i === "right" && this.drawCaret(t, r), n.lineTo(s + l, a + u - c), n.quadraticCurveTo(s + l, a + u, s + l - c, a + u), o === "bottom" && this.drawCaret(t, r), n.lineTo(s + c, a + u), n.quadraticCurveTo(s, a + u, s, a + u - c), o === "center" && i === "left" && this.drawCaret(t, r), n.lineTo(s, a + c), n.quadraticCurveTo(s, a, s + c, a), n.closePath(), n.fill(), e.borderWidth > 0 && n.stroke(); },
    draw() { const t = this._chart.ctx; const e = this._view; if (e.opacity !== 0) { const n = { width: e.width, height: e.height }; const r = { x: e.x, y: e.y }; const i = Math.abs(e.opacity < 0.001) ? 0 : e.opacity; const o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; this._options.enabled && o && (t.save(), t.globalAlpha = i, this.drawBackground(r, e, t, n), r.y += e.yPadding, q.rtl.overrideTextDirection(t, e.textDirection), this.drawTitle(r, e, t), this.drawBody(r, e, t), this.drawFooter(r, e, t), q.rtl.restoreTextDirection(t, e.textDirection), t.restore()); } },
    handleEvent(t) { let e; const n = this; const r = n._options; return n._lastActive = n._lastActive || [], t.type === "mouseout" ? n._active = [] : (n._active = n._chart.getElementsAtEventForMode(t, r.mode, r), r.reverse && n._active.reverse()), (e = !q.arrayEquals(n._active, n._lastActive)) && (n._lastActive = n._active, (r.enabled || r.custom) && (n._eventPosition = { x: t.x, y: t.y }, n.update(!0), n.pivot())), e; },
  }); const Fe = Me; const Ve = Re; Ve.positioners = Fe; const ze = q.valueOrDefault; function Be() { return q.merge(Object.create(null), [].slice.call(arguments), { merger(t, e, n, r) { if (t === "xAxes" || t === "yAxes") { let i; let o; let s; const a = n[t].length; for (e[t] || (e[t] = []), i = 0; i < a; ++i)s = n[t][i], o = ze(s.type, t === "xAxes" ? "category" : "linear"), i >= e[t].length && e[t].push({}), !e[t][i].type || s.type && s.type !== e[t][i].type ? q.merge(e[t][i], [Pe.getScaleDefaults(o), s]) : q.merge(e[t][i], s); } else q._merger(t, e, n, r); } }); } function qe() { return q.merge(Object.create(null), [].slice.call(arguments), { merger(t, e, n, r) { const i = e[t] || Object.create(null); const o = n[t]; t === "scales" ? e[t] = Be(i, o) : t === "scale" ? e[t] = q.merge(i, [Pe.getScaleDefaults(o.type), o]) : q._merger(t, e, n, r); } }); } function He(t) { let e = t.options; q.each(t.scales, ((e) => { de.removeBox(t, e); })), e = qe(R.global, R[t.config.type], e), t.options = t.config.options = e, t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.tooltip._options = e.tooltips, t.tooltip.initialize(); } function $e(t, e, n) { let r; const i = function (t) { return t.id === r; }; do { r = e + n++; } while (q.findIndex(t, i) >= 0); return r; } function Ue(t) { return t === "top" || t === "bottom"; } function We(t, e) { return function (n, r) { return n[t] === r[t] ? n[e] - r[e] : n[t] - r[t]; }; }R._set("global", {
    elements: {},
    events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
    hover: {
      onHover: null, mode: "nearest", intersect: !0, animationDuration: 400,
    },
    onClick: null,
    maintainAspectRatio: !0,
    responsive: !0,
    responsiveAnimationDuration: 0,
  }); const Ge = function (t, e) { return this.construct(t, e), this; }; q.extend(Ge.prototype, {
    construct(t, e) { const n = this; e = (function (t) { const e = (t = t || Object.create(null)).data = t.data || {}; return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = qe(R.global, R[t.type], t.options || {}), t; }(e)); const r = Ee.acquireContext(t, e); const i = r && r.canvas; const o = i && i.height; const s = i && i.width; n.id = q.uid(), n.ctx = r, n.canvas = i, n.config = e, n.width = s, n.height = o, n.aspectRatio = o ? s / o : null, n.options = e.options, n._bufferedRender = !1, n._layers = [], n.chart = n, n.controller = n, Ge.instances[n.id] = n, Object.defineProperty(n, "data", { get() { return n.config.data; }, set(t) { n.config.data = t; } }), r && i ? (n.initialize(), n.update()) : console.error("Failed to create chart: can't acquire context from the given item"); },
    initialize() { const t = this; return Te.notify(t, "beforeInit"), q.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.initToolTip(), Te.notify(t, "afterInit"), t; },
    clear() { return q.canvas.clear(this), this; },
    stop() { return X.cancelAnimation(this), this; },
    resize(t) { const e = this; const n = e.options; const r = e.canvas; const i = n.maintainAspectRatio && e.aspectRatio || null; const o = Math.max(0, Math.floor(q.getMaximumWidth(r))); const s = Math.max(0, Math.floor(i ? o / i : q.getMaximumHeight(r))); if ((e.width !== o || e.height !== s) && (r.width = e.width = o, r.height = e.height = s, r.style.width = `${o}px`, r.style.height = `${s}px`, q.retinaScale(e, n.devicePixelRatio), !t)) { const a = { width: o, height: s }; Te.notify(e, "resize", [a]), n.onResize && n.onResize(e, a), e.stop(), e.update({ duration: n.responsiveAnimationDuration }); } },
    ensureScalesHaveIDs() { const t = this.options; const e = t.scales || {}; const n = t.scale; q.each(e.xAxes, ((t, n) => { t.id || (t.id = $e(e.xAxes, "x-axis-", n)); })), q.each(e.yAxes, ((t, n) => { t.id || (t.id = $e(e.yAxes, "y-axis-", n)); })), n && (n.id = n.id || "scale"); },
    buildOrUpdateScales() {
      const t = this; const e = t.options; const n = t.scales || {}; let r = []; const i = Object.keys(n).reduce(((t, e) => (t[e] = !1, t)), {}); e.scales && (r = r.concat((e.scales.xAxes || []).map(((t) => ({ options: t, dtype: "category", dposition: "bottom" }))), (e.scales.yAxes || []).map(((t) => ({ options: t, dtype: "linear", dposition: "left" }))))), e.scale && r.push({
        options: e.scale, dtype: "radialLinear", isDefault: !0, dposition: "chartArea",
      }), q.each(r, ((e) => {
        const r = e.options; const o = r.id; const s = ze(r.type, e.dtype); Ue(r.position) !== Ue(e.dposition) && (r.position = e.dposition), i[o] = !0; let a = null; if (o in n && n[o].type === s)(a = n[o]).options = r, a.ctx = t.ctx, a.chart = t; else {
          const l = Pe.getScaleConstructor(s); if (!l) return; a = new l({
            id: o, type: s, options: r, ctx: t.ctx, chart: t,
          }), n[a.id] = a;
        }a.mergeTicksOptions(), e.isDefault && (t.scale = a);
      })), q.each(i, ((t, e) => { t || delete n[e]; })), t.scales = n, Pe.addScalesToLayout(this);
    },
    buildOrUpdateControllers() { let t; let e; const n = this; const r = []; const i = n.data.datasets; for (t = 0, e = i.length; t < e; t++) { const o = i[t]; let s = n.getDatasetMeta(t); const a = o.type || n.config.type; if (s.type && s.type !== a && (n.destroyDatasetMeta(t), s = n.getDatasetMeta(t)), s.type = a, s.order = o.order || 0, s.index = t, s.controller)s.controller.updateIndex(t), s.controller.linkScales(); else { const l = Yt[s.type]; if (void 0 === l) throw new Error(`"${s.type}" is not a chart type.`); s.controller = new l(n, t), r.push(s.controller); } } return r; },
    resetElements() { const t = this; q.each(t.data.datasets, ((e, n) => { t.getDatasetMeta(n).controller.reset(); }), t); },
    reset() { this.resetElements(), this.tooltip.initialize(); },
    update(t) { let e; let n; const r = this; if (t && typeof t === "object" || (t = { duration: t, lazy: arguments[1] }), He(r), Te._invalidate(r), !1 !== Te.notify(r, "beforeUpdate")) { r.tooltip._data = r.data; const i = r.buildOrUpdateControllers(); for (e = 0, n = r.data.datasets.length; e < n; e++)r.getDatasetMeta(e).controller.buildOrUpdateElements(); r.updateLayout(), r.options.animation && r.options.animation.duration && q.each(i, ((t) => { t.reset(); })), r.updateDatasets(), r.tooltip.initialize(), r.lastActive = [], Te.notify(r, "afterUpdate"), r._layers.sort(We("z", "_idx")), r._bufferedRender ? r._bufferedRequest = { duration: t.duration, easing: t.easing, lazy: t.lazy } : r.render(t); } },
    updateLayout() { const t = this; !1 !== Te.notify(t, "beforeLayout") && (de.update(this, this.width, this.height), t._layers = [], q.each(t.boxes, ((e) => { e._configure && e._configure(), t._layers.push.apply(t._layers, e._layers()); }), t), t._layers.forEach(((t, e) => { t._idx = e; })), Te.notify(t, "afterScaleUpdate"), Te.notify(t, "afterLayout")); },
    updateDatasets() { if (!1 !== Te.notify(this, "beforeDatasetsUpdate")) { for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.updateDataset(t); Te.notify(this, "afterDatasetsUpdate"); } },
    updateDataset(t) { const e = this.getDatasetMeta(t); const n = { meta: e, index: t }; !1 !== Te.notify(this, "beforeDatasetUpdate", [n]) && (e.controller._update(), Te.notify(this, "afterDatasetUpdate", [n])); },
    render(t) {
      const e = this; t && typeof t === "object" || (t = { duration: t, lazy: arguments[1] }); const n = e.options.animation; const r = ze(t.duration, n && n.duration); const i = t.lazy; if (!1 !== Te.notify(e, "beforeRender")) {
        const o = function (t) { Te.notify(e, "afterRender"), q.callback(n && n.onComplete, [t], e); }; if (n && r) {
          const s = new K({
            numSteps: r / 16.66, easing: t.easing || n.easing, render(t, e) { const n = q.easing.effects[e.easing]; const r = e.currentStep; const i = r / e.numSteps; t.draw(n(i), i, r); }, onAnimationProgress: n.onProgress, onAnimationComplete: o,
          }); X.addAnimation(e, s, r, i);
        } else e.draw(), o(new K({ numSteps: 0, chart: e })); return e;
      }
    },
    draw(t) { let e; let n; const r = this; if (r.clear(), q.isNullOrUndef(t) && (t = 1), r.transition(t), !(r.width <= 0 || r.height <= 0) && !1 !== Te.notify(r, "beforeDraw", [t])) { for (n = r._layers, e = 0; e < n.length && n[e].z <= 0; ++e)n[e].draw(r.chartArea); for (r.drawDatasets(t); e < n.length; ++e)n[e].draw(r.chartArea); r._drawTooltip(t), Te.notify(r, "afterDraw", [t]); } },
    transition(t) { for (let e = 0, n = (this.data.datasets || []).length; e < n; ++e) this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t); this.tooltip.transition(t); },
    _getSortedDatasetMetas(t) { let e; let n; const r = []; for (e = 0, n = (this.data.datasets || []).length; e < n; ++e)t && !this.isDatasetVisible(e) || r.push(this.getDatasetMeta(e)); return r.sort(We("order", "index")), r; },
    _getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0); },
    drawDatasets(t) { let e; let n; if (!1 !== Te.notify(this, "beforeDatasetsDraw", [t])) { for (n = (e = this._getSortedVisibleDatasetMetas()).length - 1; n >= 0; --n) this.drawDataset(e[n], t); Te.notify(this, "afterDatasetsDraw", [t]); } },
    drawDataset(t, e) { const n = { meta: t, index: t.index, easingValue: e }; !1 !== Te.notify(this, "beforeDatasetDraw", [n]) && (t.controller.draw(e), Te.notify(this, "afterDatasetDraw", [n])); },
    _drawTooltip(t) { const e = this.tooltip; const n = { tooltip: e, easingValue: t }; !1 !== Te.notify(this, "beforeTooltipDraw", [n]) && (e.draw(), Te.notify(this, "afterTooltipDraw", [n])); },
    getElementAtEvent(t) { return ee.modes.single(this, t); },
    getElementsAtEvent(t) { return ee.modes.label(this, t, { intersect: !0 }); },
    getElementsAtXAxis(t) { return ee.modes["x-axis"](this, t, { intersect: !0 }); },
    getElementsAtEventForMode(t, e, n) { const r = ee.modes[e]; return typeof r === "function" ? r(this, t, n) : []; },
    getDatasetAtEvent(t) { return ee.modes.dataset(this, t, { intersect: !0 }); },
    getDatasetMeta(t) {
      const e = this.data.datasets[t]; e._meta || (e._meta = {}); let n = e._meta[this.id]; return n || (n = e._meta[this.id] = {
        type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e.order || 0, index: t,
      }), n;
    },
    getVisibleDatasetCount() { for (var t = 0, e = 0, n = this.data.datasets.length; e < n; ++e) this.isDatasetVisible(e) && t++; return t; },
    isDatasetVisible(t) { const e = this.getDatasetMeta(t); return typeof e.hidden === "boolean" ? !e.hidden : !this.data.datasets[t].hidden; },
    generateLegend() { return this.options.legendCallback(this); },
    destroyDatasetMeta(t) { const e = this.id; const n = this.data.datasets[t]; const r = n._meta && n._meta[e]; r && (r.controller.destroy(), delete n._meta[e]); },
    destroy() { let t; let e; const n = this; const r = n.canvas; for (n.stop(), t = 0, e = n.data.datasets.length; t < e; ++t)n.destroyDatasetMeta(t); r && (n.unbindEvents(), q.canvas.clear(n), Ee.releaseContext(n.ctx), n.canvas = null, n.ctx = null), Te.notify(n, "destroy"), delete Ge.instances[n.id]; },
    toBase64Image() { return this.canvas.toDataURL.apply(this.canvas, arguments); },
    initToolTip() {
      const t = this; t.tooltip = new Ve({
        _chart: t, _chartInstance: t, _data: t.data, _options: t.options.tooltips,
      }, t);
    },
    bindEvents() { const t = this; const e = t._listeners = {}; let n = function () { t.eventHandler.apply(t, arguments); }; q.each(t.options.events, ((r) => { Ee.addEventListener(t, r, n), e[r] = n; })), t.options.responsive && (n = function () { t.resize(); }, Ee.addEventListener(t, "resize", n), e.resize = n); },
    unbindEvents() { const t = this; const e = t._listeners; e && (delete t._listeners, q.each(e, ((e, n) => { Ee.removeEventListener(t, n, e); }))); },
    updateHoverStyle(t, e, n) { let r; let i; let o; const s = n ? "set" : "remove"; for (i = 0, o = t.length; i < o; ++i)(r = t[i]) && this.getDatasetMeta(r._datasetIndex).controller[`${s}HoverStyle`](r); e === "dataset" && this.getDatasetMeta(t[0]._datasetIndex).controller[`_${s}DatasetHoverStyle`](); },
    eventHandler(t) { const e = this; const n = e.tooltip; if (!1 !== Te.notify(e, "beforeEvent", [t])) { e._bufferedRender = !0, e._bufferedRequest = null; let r = e.handleEvent(t); n && (r = n._start ? n.handleEvent(t) : r | n.handleEvent(t)), Te.notify(e, "afterEvent", [t]); const i = e._bufferedRequest; return i ? e.render(i) : r && !e.animating && (e.stop(), e.render({ duration: e.options.hover.animationDuration, lazy: !0 })), e._bufferedRender = !1, e._bufferedRequest = null, e; } },
    handleEvent(t) { let e; const n = this; const r = n.options || {}; const i = r.hover; return n.lastActive = n.lastActive || [], t.type === "mouseout" ? n.active = [] : n.active = n.getElementsAtEventForMode(t, i.mode, i), q.callback(r.onHover || r.hover.onHover, [t.native, n.active], n), t.type !== "mouseup" && t.type !== "click" || r.onClick && r.onClick.call(n, t.native, n.active), n.lastActive.length && n.updateHoverStyle(n.lastActive, i.mode, !1), n.active.length && i.mode && n.updateHoverStyle(n.active, i.mode, !0), e = !q.arrayEquals(n.active, n.lastActive), n.lastActive = n.active, e; },
  }), Ge.instances = {}; const Ye = Ge; function Ze() { throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided."); } function Ke(t) { this.options = t || {}; }Ge.Controller = Ge, Ge.types = {}, q.configMerge = qe, q.scaleMerge = Be, q.extend(Ke.prototype, {
    formats: Ze, parse: Ze, format: Ze, add: Ze, diff: Ze, startOf: Ze, endOf: Ze, _create(t) { return t; },
  }), Ke.override = function (t) { q.extend(Ke.prototype, t); }; const Xe = { _date: Ke }; const Qe = { formatters: { values(t) { return q.isArray(t) ? t : `${t}`; }, linear(t, e, n) { let r = n.length > 3 ? n[2] - n[1] : n[1] - n[0]; Math.abs(r) > 1 && t !== Math.floor(t) && (r = t - Math.floor(t)); const i = q.log10(Math.abs(r)); let o = ""; if (t !== 0) if (Math.max(Math.abs(n[0]), Math.abs(n[n.length - 1])) < 1e-4) { const s = q.log10(Math.abs(t)); let a = Math.floor(s) - Math.floor(i); a = Math.max(Math.min(a, 20), 0), o = t.toExponential(a); } else { let l = -1 * Math.floor(i); l = Math.max(Math.min(l, 20), 0), o = t.toFixed(l); } else o = "0"; return o; }, logarithmic(t, e, n) { const r = t / 10 ** Math.floor(q.log10(t)); return t === 0 ? "0" : r === 1 || r === 2 || r === 5 || e === 0 || e === n.length - 1 ? t.toExponential() : ""; } } }; const Je = q.isArray; const tn = q.isNullOrUndef; const en = q.valueOrDefault; const nn = q.valueAtIndexOrDefault; function rn(t, e, n) { let r; const i = t.getTicks().length; const o = Math.min(e, i - 1); let s = t.getPixelForTick(o); const a = t._startPixel; const l = t._endPixel; if (!(n && (r = i === 1 ? Math.max(s - a, l - s) : e === 0 ? (t.getPixelForTick(1) - s) / 2 : (s - t.getPixelForTick(o - 1)) / 2, (s += o < e ? r : -r) < a - 1e-6 || s > l + 1e-6))) return s; } function on(t) { return t.drawTicks ? t.tickMarkLength : 0; } function sn(t) { let e; let n; return t.display ? (e = q.options._parseFont(t), n = q.options.toPadding(t.padding), e.lineHeight + n.height) : 0; } function an(t, e) {
    return q.extend(q.options._parseFont({
      fontFamily: en(e.fontFamily, t.fontFamily), fontSize: en(e.fontSize, t.fontSize), fontStyle: en(e.fontStyle, t.fontStyle), lineHeight: en(e.lineHeight, t.lineHeight),
    }), { color: q.options.resolve([e.fontColor, t.fontColor, R.global.defaultFontColor]) });
  } function ln(t) { const e = an(t, t.minor); return { minor: e, major: t.major.enabled ? an(t, t.major) : e }; } function un(t) { let e; let n; let r; const i = []; for (n = 0, r = t.length; n < r; ++n) void 0 !== (e = t[n])._index && i.push(e); return i; } function cn(t, e, n, r) { let i; let o; let s; let a; const l = en(n, 0); const u = Math.min(en(r, t.length), t.length); let c = 0; for (e = Math.ceil(e), r && (e = (i = r - n) / Math.floor(i / e)), a = l; a < 0;)c++, a = Math.round(l + c * e); for (o = Math.max(l, 0); o < u; o++)s = t[o], o === a ? (s._index = o, c++, a = Math.round(l + c * e)) : delete s.label; }R._set("scale", {
    display: !0,
    position: "left",
    offset: !1,
    gridLines: {
      display: !0, color: "rgba(0,0,0,0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: !1, borderDash: [], borderDashOffset: 0,
    },
    scaleLabel: { display: !1, labelString: "", padding: { top: 4, bottom: 4 } },
    ticks: {
      beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: Qe.formatters.values, minor: {}, major: {},
    },
  }); const dn = Y.extend({
    zeroLineIndex: 0,
    getPadding() {
      return {
        left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0,
      };
    },
    getTicks() { return this._ticks; },
    _getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []; },
    mergeTicksOptions() {},
    beforeUpdate() { q.callback(this.options.beforeUpdate, [this]); },
    update(t, e, n) {
      let r; let i; let o; let s; let a; const l = this; const u = l.options.ticks; const c = u.sampleSize; if (l.beforeUpdate(), l.maxWidth = t, l.maxHeight = e, l.margins = q.extend({
        left: 0, right: 0, top: 0, bottom: 0,
      }, n), l._ticks = null, l.ticks = null, l._labelSizes = null, l._maxLabelLines = 0, l.longestLabelWidth = 0, l.longestTextCache = l.longestTextCache || {}, l._gridLineItems = null, l._labelItems = null, l.beforeSetDimensions(), l.setDimensions(), l.afterSetDimensions(), l.beforeDataLimits(), l.determineDataLimits(), l.afterDataLimits(), l.beforeBuildTicks(), s = l.buildTicks() || [], (!(s = l.afterBuildTicks(s) || s) || !s.length) && l.ticks) for (s = [], r = 0, i = l.ticks.length; r < i; ++r)s.push({ value: l.ticks[r], major: !1 }); return l._ticks = s, a = c < s.length, o = l._convertTicksToLabels(a ? (function (t, e) { for (var n = [], r = t.length / e, i = 0, o = t.length; i < o; i += r)n.push(t[Math.floor(i)]); return n; }(s, c)) : s), l._configure(), l.beforeCalculateTickRotation(), l.calculateTickRotation(), l.afterCalculateTickRotation(), l.beforeFit(), l.fit(), l.afterFit(), l._ticksToDraw = u.display && (u.autoSkip || u.source === "auto") ? l._autoSkip(s) : s, a && (o = l._convertTicksToLabels(l._ticksToDraw)), l.ticks = o, l.afterUpdate(), l.minSize;
    },
    _configure() { let t; let e; const n = this; let r = n.options.ticks.reverse; n.isHorizontal() ? (t = n.left, e = n.right) : (t = n.top, e = n.bottom, r = !r), n._startPixel = t, n._endPixel = e, n._reversePixels = r, n._length = e - t; },
    afterUpdate() { q.callback(this.options.afterUpdate, [this]); },
    beforeSetDimensions() { q.callback(this.options.beforeSetDimensions, [this]); },
    setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0; },
    afterSetDimensions() { q.callback(this.options.afterSetDimensions, [this]); },
    beforeDataLimits() { q.callback(this.options.beforeDataLimits, [this]); },
    determineDataLimits: q.noop,
    afterDataLimits() { q.callback(this.options.afterDataLimits, [this]); },
    beforeBuildTicks() { q.callback(this.options.beforeBuildTicks, [this]); },
    buildTicks: q.noop,
    afterBuildTicks(t) { const e = this; return Je(t) && t.length ? q.callback(e.options.afterBuildTicks, [e, t]) : (e.ticks = q.callback(e.options.afterBuildTicks, [e, e.ticks]) || e.ticks, t); },
    beforeTickToLabelConversion() { q.callback(this.options.beforeTickToLabelConversion, [this]); },
    convertTicksToLabels() { const t = this.options.ticks; this.ticks = this.ticks.map(t.userCallback || t.callback, this); },
    afterTickToLabelConversion() { q.callback(this.options.afterTickToLabelConversion, [this]); },
    beforeCalculateTickRotation() { q.callback(this.options.beforeCalculateTickRotation, [this]); },
    calculateTickRotation() { let t; let e; let n; let r; let i; let o; let s; const a = this; const l = a.options; const u = l.ticks; const c = a.getTicks().length; const d = u.minRotation || 0; const h = u.maxRotation; let p = d; !a._isVisible() || !u.display || d >= h || c <= 1 || !a.isHorizontal() ? a.labelRotation = d : (e = (t = a._getLabelSizes()).widest.width, n = t.highest.height - t.highest.offset, r = Math.min(a.maxWidth, a.chart.width - e), e + 6 > (i = l.offset ? a.maxWidth / c : r / (c - 1)) && (i = r / (c - (l.offset ? 0.5 : 1)), o = a.maxHeight - on(l.gridLines) - u.padding - sn(l.scaleLabel), s = Math.sqrt(e * e + n * n), p = q.toDegrees(Math.min(Math.asin(Math.min((t.highest.height + 6) / i, 1)), Math.asin(Math.min(o / s, 1)) - Math.asin(n / s))), p = Math.max(d, Math.min(h, p))), a.labelRotation = p); },
    afterCalculateTickRotation() { q.callback(this.options.afterCalculateTickRotation, [this]); },
    beforeFit() { q.callback(this.options.beforeFit, [this]); },
    fit() { const t = this; const e = t.minSize = { width: 0, height: 0 }; const n = t.chart; const r = t.options; const i = r.ticks; const o = r.scaleLabel; const s = r.gridLines; const a = t._isVisible(); const l = r.position === "bottom"; const u = t.isHorizontal(); if (u ? e.width = t.maxWidth : a && (e.width = on(s) + sn(o)), u ? a && (e.height = on(s) + sn(o)) : e.height = t.maxHeight, i.display && a) { const c = ln(i); const d = t._getLabelSizes(); const h = d.first; const p = d.last; const f = d.widest; const m = d.highest; const g = 0.4 * c.minor.lineHeight; const v = i.padding; if (u) { const y = t.labelRotation !== 0; const _ = q.toRadians(t.labelRotation); const b = Math.cos(_); const w = Math.sin(_); const x = w * f.width + b * (m.height - (y ? m.offset : 0)) + (y ? 0 : g); e.height = Math.min(t.maxHeight, e.height + x + v); let S; let k; const C = t.getPixelForTick(0) - t.left; const E = t.right - t.getPixelForTick(t.getTicks().length - 1); y ? (S = l ? b * h.width + w * h.offset : w * (h.height - h.offset), k = l ? w * (p.height - p.offset) : b * p.width + w * p.offset) : (S = h.width / 2, k = p.width / 2), t.paddingLeft = Math.max((S - C) * t.width / (t.width - C), 0) + 3, t.paddingRight = Math.max((k - E) * t.width / (t.width - E), 0) + 3; } else { const T = i.mirror ? 0 : f.width + v + g; e.width = Math.min(t.maxWidth, e.width + T), t.paddingTop = h.height / 2, t.paddingBottom = p.height / 2; } }t.handleMargins(), u ? (t.width = t._length = n.width - t.margins.left - t.margins.right, t.height = e.height) : (t.width = e.width, t.height = t._length = n.height - t.margins.top - t.margins.bottom); },
    handleMargins() { const t = this; t.margins && (t.margins.left = Math.max(t.paddingLeft, t.margins.left), t.margins.top = Math.max(t.paddingTop, t.margins.top), t.margins.right = Math.max(t.paddingRight, t.margins.right), t.margins.bottom = Math.max(t.paddingBottom, t.margins.bottom)); },
    afterFit() { q.callback(this.options.afterFit, [this]); },
    isHorizontal() { const t = this.options.position; return t === "top" || t === "bottom"; },
    isFullWidth() { return this.options.fullWidth; },
    getRightValue(t) { if (tn(t)) return NaN; if ((typeof t === "number" || t instanceof Number) && !isFinite(t)) return NaN; if (t) if (this.isHorizontal()) { if (void 0 !== t.x) return this.getRightValue(t.x); } else if (void 0 !== t.y) return this.getRightValue(t.y); return t; },
    _convertTicksToLabels(t) { let e; let n; let r; const i = this; for (i.ticks = t.map(((t) => t.value)), i.beforeTickToLabelConversion(), e = i.convertTicksToLabels(t) || i.ticks, i.afterTickToLabelConversion(), n = 0, r = t.length; n < r; ++n)t[n].label = e[n]; return e; },
    _getLabelSizes() {
      const t = this; let e = t._labelSizes; return e || (t._labelSizes = e = (function (t, e, n, r) {
        let i; let o; let s; let a; let l; let u; let c; let d; let h; let p; let f; let m; let g; const v = n.length; const y = []; const _ = []; const b = []; let w = 0; let x = 0; for (i = 0; i < v; ++i) { if (a = n[i].label, l = n[i].major ? e.major : e.minor, t.font = u = l.string, c = r[u] = r[u] || { data: {}, gc: [] }, d = l.lineHeight, h = p = 0, tn(a) || Je(a)) { if (Je(a)) for (o = 0, s = a.length; o < s; ++o)f = a[o], tn(f) || Je(f) || (h = q.measureText(t, c.data, c.gc, h, f), p += d); } else h = q.measureText(t, c.data, c.gc, h, a), p = d; y.push(h), _.push(p), b.push(d / 2), w = Math.max(h, w), x = Math.max(p, x); } function S(t) { return { width: y[t] || 0, height: _[t] || 0, offset: b[t] || 0 }; } return (function (t, e) { q.each(t, ((t) => { let n; const r = t.gc; const i = r.length / 2; if (i > e) { for (n = 0; n < i; ++n) delete t.data[r[n]]; r.splice(0, i); } })); }(r, v)), m = y.indexOf(w), g = _.indexOf(x), {
          first: S(0), last: S(v - 1), widest: S(m), highest: S(g),
        };
      }(t.ctx, ln(t.options.ticks), t.getTicks(), t.longestTextCache)), t.longestLabelWidth = e.widest.width), e;
    },
    _parseValue(t) {
      let e; let n; let r; let i; return Je(t) ? (e = +this.getRightValue(t[0]), n = +this.getRightValue(t[1]), r = Math.min(e, n), i = Math.max(e, n)) : (e = void 0, n = t = +this.getRightValue(t), r = t, i = t), {
        min: r, max: i, start: e, end: n,
      };
    },
    _getScaleLabel(t) { const e = this._parseValue(t); return void 0 !== e.start ? `[${e.start}, ${e.end}]` : +this.getRightValue(t); },
    getLabelForIndex: q.noop,
    getPixelForValue: q.noop,
    getValueForPixel: q.noop,
    getPixelForTick(t) { const e = this.options.offset; const n = this._ticks.length; const r = 1 / Math.max(n - (e ? 0 : 1), 1); return t < 0 || t > n - 1 ? null : this.getPixelForDecimal(t * r + (e ? r / 2 : 0)); },
    getPixelForDecimal(t) { return this._reversePixels && (t = 1 - t), this._startPixel + t * this._length; },
    getDecimalForPixel(t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e; },
    getBasePixel() { return this.getPixelForValue(this.getBaseValue()); },
    getBaseValue() { const t = this.min; const e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0; },
    _autoSkip(t) { let e; let n; let r; let i; const o = this.options.ticks; const s = this._length; const a = o.maxTicksLimit || s / this._tickSize() + 1; const l = o.major.enabled ? (function (t) { let e; let n; const r = []; for (e = 0, n = t.length; e < n; e++)t[e].major && r.push(e); return r; }(t)) : []; const u = l.length; const c = l[0]; const d = l[u - 1]; if (u > a) return (function (t, e, n) { let r; let i; let o = 0; let s = e[0]; for (n = Math.ceil(n), r = 0; r < t.length; r++)i = t[r], r === s ? (i._index = r, s = e[++o * n]) : delete i.label; }(t, l, u / a)), un(t); if (r = (function (t, e, n, r) { let i; let o; let s; let a; const l = (function (t) { let e; let n; const r = t.length; if (r < 2) return !1; for (n = t[0], e = 1; e < r; ++e) if (t[e] - t[e - 1] !== n) return !1; return n; }(t)); const u = (e.length - 1) / r; if (!l) return Math.max(u, 1); for (s = 0, a = (i = q.math._factorize(l)).length - 1; s < a; s++) if ((o = i[s]) > u) return o; return Math.max(u, 1); }(l, t, 0, a)), u > 0) { for (e = 0, n = u - 1; e < n; e++)cn(t, r, l[e], l[e + 1]); return i = u > 1 ? (d - c) / (u - 1) : null, cn(t, r, q.isNullOrUndef(i) ? 0 : c - i, c), cn(t, r, d, q.isNullOrUndef(i) ? t.length : d + i), un(t); } return cn(t, r), un(t); },
    _tickSize() { const t = this.options.ticks; const e = q.toRadians(this.labelRotation); const n = Math.abs(Math.cos(e)); const r = Math.abs(Math.sin(e)); const i = this._getLabelSizes(); const o = t.autoSkipPadding || 0; const s = i ? i.widest.width + o : 0; const a = i ? i.highest.height + o : 0; return this.isHorizontal() ? a * n > s * r ? s / n : a / r : a * r < s * n ? a / n : s / r; },
    _isVisible() { let t; let e; let n; const r = this.chart; const i = this.options.display; if (i !== "auto") return !!i; for (t = 0, e = r.data.datasets.length; t < e; ++t) if (r.isDatasetVisible(t) && ((n = r.getDatasetMeta(t)).xAxisID === this.id || n.yAxisID === this.id)) return !0; return !1; },
    _computeGridLineItems(t) {
      let e; let n; let r; let i; let o; let s; let a; let l; let u; let c; let d; let h; let p; let f; let m; let g; let v; const y = this; const _ = y.chart; const b = y.options; const w = b.gridLines; const x = b.position; const S = w.offsetGridLines; const k = y.isHorizontal(); const C = y._ticksToDraw; const E = C.length + (S ? 1 : 0); const T = on(w); const P = []; const O = w.drawBorder ? nn(w.lineWidth, 0, 0) : 0; const A = O / 2; const M = q._alignPixel; const L = function (t) { return M(_, t, O); }; for (x === "top" ? (e = L(y.bottom), a = y.bottom - T, u = e - A, d = L(t.top) + A, p = t.bottom) : x === "bottom" ? (e = L(y.top), d = t.top, p = L(t.bottom) - A, a = e + A, u = y.top + T) : x === "left" ? (e = L(y.right), s = y.right - T, l = e - A, c = L(t.left) + A, h = t.right) : (e = L(y.left), c = t.left, h = L(t.right) - A, s = e + A, l = y.left + T), n = 0; n < E; ++n) {
        r = C[n] || {}, tn(r.label) && n < C.length || (n === y.zeroLineIndex && b.offset === S ? (f = w.zeroLineWidth, m = w.zeroLineColor, g = w.zeroLineBorderDash || [], v = w.zeroLineBorderDashOffset || 0) : (f = nn(w.lineWidth, n, 1), m = nn(w.color, n, "rgba(0,0,0,0.1)"), g = w.borderDash || [], v = w.borderDashOffset || 0), void 0 !== (i = rn(y, r._index || n, S)) && (o = M(_, i, f), k ? s = l = c = h = o : a = u = d = p = o, P.push({
          tx1: s, ty1: a, tx2: l, ty2: u, x1: c, y1: d, x2: h, y2: p, width: f, color: m, borderDash: g, borderDashOffset: v,
        })));
      } return P.ticksLength = E, P.borderValue = e, P;
    },
    _computeLabelItems() {
      let t; let e; let n; let r; let i; let o; let s; let a; let l; let u; let c; let d; const h = this; const p = h.options; const f = p.ticks; const m = p.position; const g = f.mirror; const v = h.isHorizontal(); const y = h._ticksToDraw; const _ = ln(f); const b = f.padding; const w = on(p.gridLines); const x = -q.toRadians(h.labelRotation); const S = []; for (m === "top" ? (o = h.bottom - w - b, s = x ? "left" : "center") : m === "bottom" ? (o = h.top + w + b, s = x ? "right" : "center") : m === "left" ? (i = h.right - (g ? 0 : w) - b, s = g ? "left" : "right") : (i = h.left + (g ? 0 : w) + b, s = g ? "right" : "left"), t = 0, e = y.length; t < e; ++t) {
        r = (n = y[t]).label, tn(r) || (a = h.getPixelForTick(n._index || t) + f.labelOffset, u = (l = n.major ? _.major : _.minor).lineHeight, c = Je(r) ? r.length : 1, v ? (i = a, d = m === "top" ? ((x ? 1 : 0.5) - c) * u : (x ? 0 : 0.5) * u) : (o = a, d = (1 - c) * u / 2), S.push({
          x: i, y: o, rotation: x, label: r, font: l, textOffset: d, textAlign: s,
        }));
      } return S;
    },
    _drawGrid(t) { const e = this; const n = e.options.gridLines; if (n.display) { let r; let i; let o; let s; let a; const l = e.ctx; const u = e.chart; const c = q._alignPixel; const d = n.drawBorder ? nn(n.lineWidth, 0, 0) : 0; const h = e._gridLineItems || (e._gridLineItems = e._computeGridLineItems(t)); for (o = 0, s = h.length; o < s; ++o)r = (a = h[o]).width, i = a.color, r && i && (l.save(), l.lineWidth = r, l.strokeStyle = i, l.setLineDash && (l.setLineDash(a.borderDash), l.lineDashOffset = a.borderDashOffset), l.beginPath(), n.drawTicks && (l.moveTo(a.tx1, a.ty1), l.lineTo(a.tx2, a.ty2)), n.drawOnChartArea && (l.moveTo(a.x1, a.y1), l.lineTo(a.x2, a.y2)), l.stroke(), l.restore()); if (d) { let p; let f; let m; let g; const v = d; const y = nn(n.lineWidth, h.ticksLength - 1, 1); const _ = h.borderValue; e.isHorizontal() ? (p = c(u, e.left, v) - v / 2, f = c(u, e.right, y) + y / 2, m = g = _) : (m = c(u, e.top, v) - v / 2, g = c(u, e.bottom, y) + y / 2, p = f = _), l.lineWidth = d, l.strokeStyle = nn(n.color, 0), l.beginPath(), l.moveTo(p, m), l.lineTo(f, g), l.stroke(); } } },
    _drawLabels() { const t = this; if (t.options.ticks.display) { let e; let n; let r; let i; let o; let s; let a; let l; const u = t.ctx; const c = t._labelItems || (t._labelItems = t._computeLabelItems()); for (e = 0, r = c.length; e < r; ++e) { if (s = (o = c[e]).font, u.save(), u.translate(o.x, o.y), u.rotate(o.rotation), u.font = s.string, u.fillStyle = s.color, u.textBaseline = "middle", u.textAlign = o.textAlign, a = o.label, l = o.textOffset, Je(a)) for (n = 0, i = a.length; n < i; ++n)u.fillText(`${a[n]}`, 0, l), l += s.lineHeight; else u.fillText(a, 0, l); u.restore(); } } },
    _drawTitle() { const t = this; const e = t.ctx; const n = t.options; const r = n.scaleLabel; if (r.display) { let i; let o; const s = en(r.fontColor, R.global.defaultFontColor); const a = q.options._parseFont(r); const l = q.options.toPadding(r.padding); const u = a.lineHeight / 2; const c = n.position; let d = 0; if (t.isHorizontal())i = t.left + t.width / 2, o = c === "bottom" ? t.bottom - u - l.bottom : t.top + u + l.top; else { const h = c === "left"; i = h ? t.left + u + l.top : t.right - u - l.top, o = t.top + t.height / 2, d = h ? -0.5 * Math.PI : 0.5 * Math.PI; }e.save(), e.translate(i, o), e.rotate(d), e.textAlign = "center", e.textBaseline = "middle", e.fillStyle = s, e.font = a.string, e.fillText(r.labelString, 0, 0), e.restore(); } },
    draw(t) { this._isVisible() && (this._drawGrid(t), this._drawTitle(), this._drawLabels()); },
    _layers() { const t = this; const e = t.options; const n = e.ticks && e.ticks.z || 0; const r = e.gridLines && e.gridLines.z || 0; return t._isVisible() && n !== r && t.draw === t._draw ? [{ z: r, draw() { t._drawGrid.apply(t, arguments), t._drawTitle.apply(t, arguments); } }, { z: n, draw() { t._drawLabels.apply(t, arguments); } }] : [{ z: n, draw() { t.draw.apply(t, arguments); } }]; },
    _getMatchingVisibleMetas(t) { const e = this; const n = e.isHorizontal(); return e.chart._getSortedVisibleDatasetMetas().filter(((r) => (!t || r.type === t) && (n ? r.xAxisID === e.id : r.yAxisID === e.id))); },
  }); dn.prototype._draw = dn.prototype.draw; const hn = dn; const pn = q.isNullOrUndef; const fn = hn.extend({
    determineDataLimits() { let t; const e = this; const n = e._getLabels(); const r = e.options.ticks; const i = r.min; const o = r.max; let s = 0; let a = n.length - 1; void 0 !== i && (t = n.indexOf(i)) >= 0 && (s = t), void 0 !== o && (t = n.indexOf(o)) >= 0 && (a = t), e.minIndex = s, e.maxIndex = a, e.min = n[s], e.max = n[a]; }, buildTicks() { const t = this._getLabels(); const e = this.minIndex; const n = this.maxIndex; this.ticks = e === 0 && n === t.length - 1 ? t : t.slice(e, n + 1); }, getLabelForIndex(t, e) { const n = this.chart; return n.getDatasetMeta(e).controller._getValueScaleId() === this.id ? this.getRightValue(n.data.datasets[e].data[t]) : this._getLabels()[t]; }, _configure() { const t = this; const e = t.options.offset; const n = t.ticks; hn.prototype._configure.call(t), t.isHorizontal() || (t._reversePixels = !t._reversePixels), n && (t._startValue = t.minIndex - (e ? 0.5 : 0), t._valueRange = Math.max(n.length - (e ? 0 : 1), 1)); }, getPixelForValue(t, e, n) { let r; let i; let o; const s = this; return pn(e) || pn(n) || (t = s.chart.data.datasets[n].data[e]), pn(t) || (r = s.isHorizontal() ? t.x : t.y), (void 0 !== r || void 0 !== t && isNaN(e)) && (i = s._getLabels(), t = q.valueOrDefault(r, t), e = (o = i.indexOf(t)) !== -1 ? o : e, isNaN(e) && (e = t)), s.getPixelForDecimal((e - s._startValue) / s._valueRange); }, getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t], t + this.minIndex); }, getValueForPixel(t) { const e = Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange); return Math.min(Math.max(e, 0), this.ticks.length - 1); }, getBasePixel() { return this.bottom; },
  }); fn._defaults = { position: "bottom" }; const mn = q.noop; const gn = q.isNullOrUndef; const vn = hn.extend({
    getRightValue(t) { return typeof t === "string" ? +t : hn.prototype.getRightValue.call(this, t); },
    handleTickRangeOptions() { const t = this; const e = t.options.ticks; if (e.beginAtZero) { const n = q.sign(t.min); const r = q.sign(t.max); n < 0 && r < 0 ? t.max = 0 : n > 0 && r > 0 && (t.min = 0); } const i = void 0 !== e.min || void 0 !== e.suggestedMin; const o = void 0 !== e.max || void 0 !== e.suggestedMax; void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (t.min === null ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (t.max === null ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), i !== o && t.min >= t.max && (i ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--); },
    getTickLimit() { let t; const e = this.options.ticks; const n = e.stepSize; let r = e.maxTicksLimit; return n ? t = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1 : (t = this._computeTickLimit(), r = r || 11), r && (t = Math.min(r, t)), t; },
    _computeTickLimit() { return Number.POSITIVE_INFINITY; },
    handleDirectionalChanges: mn,
    buildTicks() {
      const t = this; const e = t.options.ticks; let n = t.getTickLimit(); const r = {
        maxTicks: n = Math.max(2, n), min: e.min, max: e.max, precision: e.precision, stepSize: q.valueOrDefault(e.fixedStepSize, e.stepSize),
      }; const i = t.ticks = (function (t, e) { let n; let r; let i; let o; const s = []; const a = t.stepSize; const l = a || 1; const u = t.maxTicks - 1; const c = t.min; const d = t.max; const h = t.precision; const p = e.min; const f = e.max; let m = q.niceNum((f - p) / u / l) * l; if (m < 1e-14 && gn(c) && gn(d)) return [p, f]; (o = Math.ceil(f / m) - Math.floor(p / m)) > u && (m = q.niceNum(o * m / u / l) * l), a || gn(h) ? n = 10 ** q._decimalPlaces(m) : (n = 10 ** h, m = Math.ceil(m * n) / n), r = Math.floor(p / m) * m, i = Math.ceil(f / m) * m, a && (!gn(c) && q.almostWhole(c / m, m / 1e3) && (r = c), !gn(d) && q.almostWhole(d / m, m / 1e3) && (i = d)), o = (i - r) / m, o = q.almostEquals(o, Math.round(o), m / 1e3) ? Math.round(o) : Math.ceil(o), r = Math.round(r * n) / n, i = Math.round(i * n) / n, s.push(gn(c) ? r : c); for (let g = 1; g < o; ++g)s.push(Math.round((r + g * m) * n) / n); return s.push(gn(d) ? i : d), s; }(r, t)); t.handleDirectionalChanges(), t.max = q.max(i), t.min = q.min(i), e.reverse ? (i.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
    },
    convertTicksToLabels() { const t = this; t.ticksAsNumbers = t.ticks.slice(), t.zeroLineIndex = t.ticks.indexOf(0), hn.prototype.convertTicksToLabels.call(t); },
    _configure() { let t; const e = this; const n = e.getTicks(); let r = e.min; let i = e.max; hn.prototype._configure.call(e), e.options.offset && n.length && (r -= t = (i - r) / Math.max(n.length - 1, 1) / 2, i += t), e._startValue = r, e._endValue = i, e._valueRange = i - r; },
  }); const yn = { position: "left", ticks: { callback: Qe.formatters.linear } }; function _n(t, e, n, r) { let i; let o; const s = t.options; const a = (function (t, e, n) { const r = [n.type, void 0 === e && void 0 === n.stack ? n.index : "", n.stack].join("."); return void 0 === t[r] && (t[r] = { pos: [], neg: [] }), t[r]; }(e, s.stacked, n)); const l = a.pos; const u = a.neg; const c = r.length; for (i = 0; i < c; ++i)o = t._parseValue(r[i]), isNaN(o.min) || isNaN(o.max) || n.data[i].hidden || (l[i] = l[i] || 0, u[i] = u[i] || 0, s.relativePoints ? l[i] = 100 : o.min < 0 || o.max < 0 ? u[i] += o.min : l[i] += o.max); } function bn(t, e, n) { let r; let i; const o = n.length; for (r = 0; r < o; ++r)i = t._parseValue(n[r]), isNaN(i.min) || isNaN(i.max) || e.data[r].hidden || (t.min = Math.min(t.min, i.min), t.max = Math.max(t.max, i.max)); } const wn = vn.extend({
    determineDataLimits() { let t; let e; let n; let r; const i = this; const o = i.options; const s = i.chart.data.datasets; const a = i._getMatchingVisibleMetas(); let l = o.stacked; const u = {}; const c = a.length; if (i.min = Number.POSITIVE_INFINITY, i.max = Number.NEGATIVE_INFINITY, void 0 === l) for (t = 0; !l && t < c; ++t)l = void 0 !== (e = a[t]).stack; for (t = 0; t < c; ++t)n = s[(e = a[t]).index].data, l ? _n(i, u, e, n) : bn(i, e, n); q.each(u, ((t) => { r = t.pos.concat(t.neg), i.min = Math.min(i.min, q.min(r)), i.max = Math.max(i.max, q.max(r)); })), i.min = q.isFinite(i.min) && !isNaN(i.min) ? i.min : 0, i.max = q.isFinite(i.max) && !isNaN(i.max) ? i.max : 1, i.handleTickRangeOptions(); }, _computeTickLimit() { let t; return this.isHorizontal() ? Math.ceil(this.width / 40) : (t = q.options._parseFont(this.options.ticks), Math.ceil(this.height / t.lineHeight)); }, handleDirectionalChanges() { this.isHorizontal() || this.ticks.reverse(); }, getLabelForIndex(t, e) { return this._getScaleLabel(this.chart.data.datasets[e].data[t]); }, getPixelForValue(t) { return this.getPixelForDecimal((+this.getRightValue(t) - this._startValue) / this._valueRange); }, getValueForPixel(t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange; }, getPixelForTick(t) { const e = this.ticksAsNumbers; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t]); },
  }); const xn = yn; wn._defaults = xn; const Sn = q.valueOrDefault; const kn = q.math.log10; const Cn = { position: "left", ticks: { callback: Qe.formatters.logarithmic } }; function En(t, e) { return q.isFinite(t) && t >= 0 ? t : e; } const Tn = hn.extend({
    determineDataLimits() { let t; let e; let n; let r; let i; let o; const s = this; const a = s.options; const l = s.chart; const u = l.data.datasets; const c = s.isHorizontal(); function d(t) { return c ? t.xAxisID === s.id : t.yAxisID === s.id; }s.min = Number.POSITIVE_INFINITY, s.max = Number.NEGATIVE_INFINITY, s.minNotZero = Number.POSITIVE_INFINITY; let h = a.stacked; if (void 0 === h) for (t = 0; t < u.length; t++) if (e = l.getDatasetMeta(t), l.isDatasetVisible(t) && d(e) && void 0 !== e.stack) { h = !0; break; } if (a.stacked || h) { const p = {}; for (t = 0; t < u.length; t++) { const f = [(e = l.getDatasetMeta(t)).type, void 0 === a.stacked && void 0 === e.stack ? t : "", e.stack].join("."); if (l.isDatasetVisible(t) && d(e)) for (void 0 === p[f] && (p[f] = []), i = 0, o = (r = u[t].data).length; i < o; i++) { const m = p[f]; n = s._parseValue(r[i]), isNaN(n.min) || isNaN(n.max) || e.data[i].hidden || n.min < 0 || n.max < 0 || (m[i] = m[i] || 0, m[i] += n.max); } }q.each(p, ((t) => { if (t.length > 0) { const e = q.min(t); const n = q.max(t); s.min = Math.min(s.min, e), s.max = Math.max(s.max, n); } })); } else for (t = 0; t < u.length; t++) if (e = l.getDatasetMeta(t), l.isDatasetVisible(t) && d(e)) for (i = 0, o = (r = u[t].data).length; i < o; i++)n = s._parseValue(r[i]), isNaN(n.min) || isNaN(n.max) || e.data[i].hidden || n.min < 0 || n.max < 0 || (s.min = Math.min(n.min, s.min), s.max = Math.max(n.max, s.max), n.min !== 0 && (s.minNotZero = Math.min(n.min, s.minNotZero))); s.min = q.isFinite(s.min) ? s.min : null, s.max = q.isFinite(s.max) ? s.max : null, s.minNotZero = q.isFinite(s.minNotZero) ? s.minNotZero : null, this.handleTickRangeOptions(); }, handleTickRangeOptions() { const t = this; const e = t.options.ticks; t.min = En(e.min, t.min), t.max = En(e.max, t.max), t.min === t.max && (t.min !== 0 && t.min !== null ? (t.min = 10 ** (Math.floor(kn(t.min)) - 1), t.max = 10 ** (Math.floor(kn(t.max)) + 1)) : (t.min = 1, t.max = 10)), t.min === null && (t.min = 10 ** (Math.floor(kn(t.max)) - 1)), t.max === null && (t.max = t.min !== 0 ? 10 ** (Math.floor(kn(t.min)) + 1) : 10), t.minNotZero === null && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = 10 ** Math.floor(kn(t.max)) : t.minNotZero = 1); }, buildTicks() { const t = this; const e = t.options.ticks; let n = !t.isHorizontal(); const r = { min: En(e.min), max: En(e.max) }; const i = t.ticks = (function (t, e) { let n; let r; const i = []; let o = Sn(t.min, 10 ** Math.floor(kn(e.min))); const s = Math.floor(kn(e.max)); const a = Math.ceil(e.max / 10 ** s); o === 0 ? (n = Math.floor(kn(e.minNotZero)), r = Math.floor(e.minNotZero / 10 ** n), i.push(o), o = r * 10 ** n) : (n = Math.floor(kn(o)), r = Math.floor(o / 10 ** n)); let l = n < 0 ? 10 ** Math.abs(n) : 1; do { i.push(o), ++r == 10 && (r = 1, l = ++n >= 0 ? 1 : l), o = Math.round(r * 10 ** n * l) / l; } while (n < s || n === s && r < a); const u = Sn(t.max, o); return i.push(u), i; }(r, t)); t.max = q.max(i), t.min = q.min(i), e.reverse ? (n = !n, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), n && i.reverse(); }, convertTicksToLabels() { this.tickValues = this.ticks.slice(), hn.prototype.convertTicksToLabels.call(this); }, getLabelForIndex(t, e) { return this._getScaleLabel(this.chart.data.datasets[e].data[t]); }, getPixelForTick(t) { const e = this.tickValues; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t]); }, _getFirstTickValue(t) { const e = Math.floor(kn(t)); return Math.floor(t / 10 ** e) * 10 ** e; }, _configure() { const t = this; let e = t.min; let n = 0; hn.prototype._configure.call(t), e === 0 && (e = t._getFirstTickValue(t.minNotZero), n = Sn(t.options.ticks.fontSize, R.global.defaultFontSize) / t._length), t._startValue = kn(e), t._valueOffset = n, t._valueRange = (kn(t.max) - kn(e)) / (1 - n); }, getPixelForValue(t) { const e = this; let n = 0; return (t = +e.getRightValue(t)) > e.min && t > 0 && (n = (kn(t) - e._startValue) / e._valueRange + e._valueOffset), e.getPixelForDecimal(n); }, getValueForPixel(t) { const e = this; const n = e.getDecimalForPixel(t); return n === 0 && e.min === 0 ? 0 : 10 ** (e._startValue + (n - e._valueOffset) * e._valueRange); },
  }); const Pn = Cn; Tn._defaults = Pn; const On = q.valueOrDefault; const An = q.valueAtIndexOrDefault; const Mn = q.options.resolve; const Ln = {
    display: !0,
    animate: !0,
    position: "chartArea",
    angleLines: {
      display: !0, color: "rgba(0,0,0,0.1)", lineWidth: 1, borderDash: [], borderDashOffset: 0,
    },
    gridLines: { circular: !1 },
    ticks: {
      showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: Qe.formatters.linear,
    },
    pointLabels: { display: !0, fontSize: 10, callback(t) { return t; } },
  }; function In(t) { const e = t.ticks; return e.display && t.display ? On(e.fontSize, R.global.defaultFontSize) + 2 * e.backdropPaddingY : 0; } function jn(t, e, n, r, i) { return t === r || t === i ? { start: e - n / 2, end: e + n / 2 } : t < r || t > i ? { start: e - n, end: e } : { start: e, end: e + n }; } function Dn(t) { return t === 0 || t === 180 ? "center" : t < 180 ? "left" : "right"; } function Nn(t, e, n, r) { let i; let o; let s = n.y + r / 2; if (q.isArray(e)) for (i = 0, o = e.length; i < o; ++i)t.fillText(e[i], n.x, s), s += r; else t.fillText(e, n.x, s); } function Rn(t, e, n) { t === 90 || t === 270 ? n.y -= e.h / 2 : (t > 270 || t < 90) && (n.y -= e.h); } function Fn(t) { return q.isNumber(t) ? t : 0; } const Vn = vn.extend({
    setDimensions() { const t = this; t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = In(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2; },
    determineDataLimits() { const t = this; const e = t.chart; let n = Number.POSITIVE_INFINITY; let r = Number.NEGATIVE_INFINITY; q.each(e.data.datasets, ((i, o) => { if (e.isDatasetVisible(o)) { const s = e.getDatasetMeta(o); q.each(i.data, ((e, i) => { const o = +t.getRightValue(e); isNaN(o) || s.data[i].hidden || (n = Math.min(o, n), r = Math.max(o, r)); })); } })), t.min = n === Number.POSITIVE_INFINITY ? 0 : n, t.max = r === Number.NEGATIVE_INFINITY ? 0 : r, t.handleTickRangeOptions(); },
    _computeTickLimit() { return Math.ceil(this.drawingArea / In(this.options)); },
    convertTicksToLabels() { const t = this; vn.prototype.convertTicksToLabels.call(t), t.pointLabels = t.chart.data.labels.map((function () { const e = q.callback(t.options.pointLabels.callback, arguments, t); return e || e === 0 ? e : ""; })); },
    getLabelForIndex(t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]); },
    fit() {
      const t = this.options; t.display && t.pointLabels.display ? (function (t) {
        let e; let n; let r; const i = q.options._parseFont(t.options.pointLabels); const o = {
          l: 0, r: t.width, t: 0, b: t.height - t.paddingTop,
        }; const s = {}; t.ctx.font = i.string, t._pointLabelSizes = []; let a; let l; let u; const c = t.chart.data.labels.length; for (e = 0; e < c; e++) { r = t.getPointPosition(e, t.drawingArea + 5), a = t.ctx, l = i.lineHeight, u = t.pointLabels[e], n = q.isArray(u) ? { w: q.longestText(a, a.font, u), h: u.length * l } : { w: a.measureText(u).width, h: l }, t._pointLabelSizes[e] = n; const d = t.getIndexAngle(e); const h = q.toDegrees(d) % 360; const p = jn(h, r.x, n.w, 0, 180); const f = jn(h, r.y, n.h, 90, 270); p.start < o.l && (o.l = p.start, s.l = d), p.end > o.r && (o.r = p.end, s.r = d), f.start < o.t && (o.t = f.start, s.t = d), f.end > o.b && (o.b = f.end, s.b = d); }t.setReductions(t.drawingArea, o, s);
      }(this)) : this.setCenterPoint(0, 0, 0, 0);
    },
    setReductions(t, e, n) { const r = this; let i = e.l / Math.sin(n.l); let o = Math.max(e.r - r.width, 0) / Math.sin(n.r); let s = -e.t / Math.cos(n.t); let a = -Math.max(e.b - (r.height - r.paddingTop), 0) / Math.cos(n.b); i = Fn(i), o = Fn(o), s = Fn(s), a = Fn(a), r.drawingArea = Math.min(Math.floor(t - (i + o) / 2), Math.floor(t - (s + a) / 2)), r.setCenterPoint(i, o, s, a); },
    setCenterPoint(t, e, n, r) { const i = this; const o = i.width - e - i.drawingArea; const s = t + i.drawingArea; const a = n + i.drawingArea; const l = i.height - i.paddingTop - r - i.drawingArea; i.xCenter = Math.floor((s + o) / 2 + i.left), i.yCenter = Math.floor((a + l) / 2 + i.top + i.paddingTop); },
    getIndexAngle(t) { const e = this.chart; const n = (t * (360 / e.data.labels.length) + ((e.options || {}).startAngle || 0)) % 360; return (n < 0 ? n + 360 : n) * Math.PI * 2 / 360; },
    getDistanceFromCenterForValue(t) { const e = this; if (q.isNullOrUndef(t)) return NaN; const n = e.drawingArea / (e.max - e.min); return e.options.ticks.reverse ? (e.max - t) * n : (t - e.min) * n; },
    getPointPosition(t, e) { const n = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.cos(n) * e + this.xCenter, y: Math.sin(n) * e + this.yCenter }; },
    getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)); },
    getBasePosition(t) { const e = this.min; const n = this.max; return this.getPointPositionForValue(t || 0, this.beginAtZero ? 0 : e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0); },
    _drawGrid() { let t; let e; let n; const r = this; const i = r.ctx; const o = r.options; const s = o.gridLines; const a = o.angleLines; const l = On(a.lineWidth, s.lineWidth); const u = On(a.color, s.color); if (o.pointLabels.display && (function (t) { const e = t.ctx; const n = t.options; const r = n.pointLabels; const i = In(n); const o = t.getDistanceFromCenterForValue(n.ticks.reverse ? t.min : t.max); const s = q.options._parseFont(r); e.save(), e.font = s.string, e.textBaseline = "middle"; for (let a = t.chart.data.labels.length - 1; a >= 0; a--) { const l = a === 0 ? i / 2 : 0; const u = t.getPointPosition(a, o + l + 5); const c = An(r.fontColor, a, R.global.defaultFontColor); e.fillStyle = c; const d = t.getIndexAngle(a); const h = q.toDegrees(d); e.textAlign = Dn(h), Rn(h, t._pointLabelSizes[a], u), Nn(e, t.pointLabels[a], u, s.lineHeight); }e.restore(); }(r)), s.display && q.each(r.ticks, ((t, n) => { n !== 0 && (e = r.getDistanceFromCenterForValue(r.ticksAsNumbers[n]), (function (t, e, n, r) { let i; const o = t.ctx; const s = e.circular; const a = t.chart.data.labels.length; const l = An(e.color, r - 1); const u = An(e.lineWidth, r - 1); if ((s || a) && l && u) { if (o.save(), o.strokeStyle = l, o.lineWidth = u, o.setLineDash && (o.setLineDash(e.borderDash || []), o.lineDashOffset = e.borderDashOffset || 0), o.beginPath(), s)o.arc(t.xCenter, t.yCenter, n, 0, 2 * Math.PI); else { i = t.getPointPosition(0, n), o.moveTo(i.x, i.y); for (let c = 1; c < a; c++)i = t.getPointPosition(c, n), o.lineTo(i.x, i.y); }o.closePath(), o.stroke(), o.restore(); } }(r, s, e, n))); })), a.display && l && u) { for (i.save(), i.lineWidth = l, i.strokeStyle = u, i.setLineDash && (i.setLineDash(Mn([a.borderDash, s.borderDash, []])), i.lineDashOffset = Mn([a.borderDashOffset, s.borderDashOffset, 0])), t = r.chart.data.labels.length - 1; t >= 0; t--)e = r.getDistanceFromCenterForValue(o.ticks.reverse ? r.min : r.max), n = r.getPointPosition(t, e), i.beginPath(), i.moveTo(r.xCenter, r.yCenter), i.lineTo(n.x, n.y), i.stroke(); i.restore(); } },
    _drawLabels() { const t = this; const e = t.ctx; const n = t.options.ticks; if (n.display) { let r; let i; const o = t.getIndexAngle(0); const s = q.options._parseFont(n); const a = On(n.fontColor, R.global.defaultFontColor); e.save(), e.font = s.string, e.translate(t.xCenter, t.yCenter), e.rotate(o), e.textAlign = "center", e.textBaseline = "middle", q.each(t.ticks, ((o, l) => { (l !== 0 || n.reverse) && (r = t.getDistanceFromCenterForValue(t.ticksAsNumbers[l]), n.showLabelBackdrop && (i = e.measureText(o).width, e.fillStyle = n.backdropColor, e.fillRect(-i / 2 - n.backdropPaddingX, -r - s.size / 2 - n.backdropPaddingY, i + 2 * n.backdropPaddingX, s.size + 2 * n.backdropPaddingY)), e.fillStyle = a, e.fillText(o, 0, -r)); })), e.restore(); } },
    _drawTitle: q.noop,
  }); const zn = Ln; Vn._defaults = zn; const Bn = q._deprecated; const qn = q.options.resolve; const Hn = q.valueOrDefault; const $n = Number.MIN_SAFE_INTEGER || -9007199254740991; const Un = Number.MAX_SAFE_INTEGER || 9007199254740991; const Wn = {
    millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 },
  }; const Gn = Object.keys(Wn); function Yn(t, e) { return t - e; } function Zn(t) { return q.valueOrDefault(t.time.min, t.ticks.min); } function Kn(t) { return q.valueOrDefault(t.time.max, t.ticks.max); } function Xn(t, e, n, r) { const i = (function (t, e, n) { for (var r, i, o, s = 0, a = t.length - 1; s >= 0 && s <= a;) { if (i = t[(r = s + a >> 1) - 1] || null, o = t[r], !i) return { lo: null, hi: o }; if (o[e] < n)s = r + 1; else { if (!(i[e] > n)) return { lo: i, hi: o }; a = r - 1; } } return { lo: o, hi: null }; }(t, e, n)); const o = i.lo ? i.hi ? i.lo : t[t.length - 2] : t[0]; const s = i.lo ? i.hi ? i.hi : t[t.length - 1] : t[1]; const a = s[e] - o[e]; const l = a ? (n - o[e]) / a : 0; const u = (s[r] - o[r]) * l; return o[r] + u; } function Qn(t, e) { const n = t._adapter; const r = t.options.time; const i = r.parser; const o = i || r.format; let s = e; return typeof i === "function" && (s = i(s)), q.isFinite(s) || (s = typeof o === "string" ? n.parse(s, o) : n.parse(s)), s !== null ? +s : (i || typeof o !== "function" || (s = o(e), q.isFinite(s) || (s = n.parse(s))), s); } function Jn(t, e) { if (q.isNullOrUndef(e)) return null; const n = t.options.time; let r = Qn(t, t.getRightValue(e)); return r === null || n.round && (r = +t._adapter.startOf(r, n.round)), r; } function tr(t, e, n, r) { let i; let o; let s; const a = Gn.length; for (i = Gn.indexOf(t); i < a - 1; ++i) if (s = (o = Wn[Gn[i]]).steps ? o.steps : Un, o.common && Math.ceil((n - e) / (s * o.size)) <= r) return Gn[i]; return Gn[a - 1]; } function er(t, e, n) { let r; let i; const o = []; const s = {}; const a = e.length; for (r = 0; r < a; ++r)s[i = e[r]] = r, o.push({ value: i, major: !1 }); return a !== 0 && n ? (function (t, e, n, r) { let i; let o; const s = t._adapter; const a = +s.startOf(e[0].value, r); const l = e[e.length - 1].value; for (i = a; i <= l; i = +s.add(i, 1, r))(o = n[i]) >= 0 && (e[o].major = !0); return e; }(t, o, s, n)) : o; } const nr = hn.extend({
    initialize() { this.mergeTicksOptions(), hn.prototype.initialize.call(this); }, update() { const t = this; const e = t.options; const n = e.time || (e.time = {}); const r = t._adapter = new Xe._date(e.adapters.date); return Bn("time scale", n.format, "time.format", "time.parser"), Bn("time scale", n.min, "time.min", "ticks.min"), Bn("time scale", n.max, "time.max", "ticks.max"), q.mergeIf(n.displayFormats, r.formats()), hn.prototype.update.apply(t, arguments); }, getRightValue(t) { return t && void 0 !== t.t && (t = t.t), hn.prototype.getRightValue.call(this, t); }, determineDataLimits() { let t; let e; let n; let r; let i; let o; let s; const a = this; const l = a.chart; const u = a._adapter; const c = a.options; const d = c.time.unit || "day"; let h = Un; let p = $n; let f = []; const m = []; const g = []; const v = a._getLabels(); for (t = 0, n = v.length; t < n; ++t)g.push(Jn(a, v[t])); for (t = 0, n = (l.data.datasets || []).length; t < n; ++t) if (l.isDatasetVisible(t)) if (i = l.data.datasets[t].data, q.isObject(i[0])) for (m[t] = [], e = 0, r = i.length; e < r; ++e)o = Jn(a, i[e]), f.push(o), m[t][e] = o; else m[t] = g.slice(0), s || (f = f.concat(g), s = !0); else m[t] = []; g.length && (h = Math.min(h, g[0]), p = Math.max(p, g[g.length - 1])), f.length && (f = n > 1 ? (function (t) { let e; let n; let r; const i = {}; const o = []; for (e = 0, n = t.length; e < n; ++e)i[r = t[e]] || (i[r] = !0, o.push(r)); return o; }(f)).sort(Yn) : f.sort(Yn), h = Math.min(h, f[0]), p = Math.max(p, f[f.length - 1])), h = Jn(a, Zn(c)) || h, p = Jn(a, Kn(c)) || p, h = h === Un ? +u.startOf(Date.now(), d) : h, p = p === $n ? +u.endOf(Date.now(), d) + 1 : p, a.min = Math.min(h, p), a.max = Math.max(h + 1, p), a._table = [], a._timestamps = { data: f, datasets: m, labels: g }; }, buildTicks() { let t; let e; let n; const r = this; let i = r.min; let o = r.max; const s = r.options; const a = s.ticks; const l = s.time; let u = r._timestamps; const c = []; const d = r.getLabelCapacity(i); const h = a.source; const p = s.distribution; for (u = h === "data" || h === "auto" && p === "series" ? u.data : h === "labels" ? u.labels : (function (t, e, n, r) { let i; const o = t._adapter; const s = t.options; const a = s.time; const l = a.unit || tr(a.minUnit, e, n, r); const u = qn([a.stepSize, a.unitStepSize, 1]); const c = l === "week" && a.isoWeekday; let d = e; const h = []; if (c && (d = +o.startOf(d, "isoWeek", c)), d = +o.startOf(d, c ? "day" : l), o.diff(n, e, l) > 1e5 * u) throw `${e} and ${n} are too far apart with stepSize of ${u} ${l}`; for (i = d; i < n; i = +o.add(i, u, l))h.push(i); return i !== n && s.bounds !== "ticks" || h.push(i), h; }(r, i, o, d)), s.bounds === "ticks" && u.length && (i = u[0], o = u[u.length - 1]), i = Jn(r, Zn(s)) || i, o = Jn(r, Kn(s)) || o, t = 0, e = u.length; t < e; ++t)(n = u[t]) >= i && n <= o && c.push(n); return r.min = i, r.max = o, r._unit = l.unit || (a.autoSkip ? tr(l.minUnit, r.min, r.max, d) : (function (t, e, n, r, i) { let o; let s; for (o = Gn.length - 1; o >= Gn.indexOf(n); o--) if (s = Gn[o], Wn[s].common && t._adapter.diff(i, r, s) >= e - 1) return s; return Gn[n ? Gn.indexOf(n) : 0]; }(r, c.length, l.minUnit, r.min, r.max))), r._majorUnit = a.major.enabled && r._unit !== "year" ? (function (t) { for (let e = Gn.indexOf(t) + 1, n = Gn.length; e < n; ++e) if (Wn[Gn[e]].common) return Gn[e]; }(r._unit)) : void 0, r._table = (function (t, e, n, r) { if (r === "linear" || !t.length) return [{ time: e, pos: 0 }, { time: n, pos: 1 }]; let i; let o; let s; let a; let l; const u = []; const c = [e]; for (i = 0, o = t.length; i < o; ++i)(a = t[i]) > e && a < n && c.push(a); for (c.push(n), i = 0, o = c.length; i < o; ++i)l = c[i + 1], s = c[i - 1], a = c[i], void 0 !== s && void 0 !== l && Math.round((l + s) / 2) === a || u.push({ time: a, pos: i / (o - 1) }); return u; }(r._timestamps.data, i, o, p)), r._offsets = (function (t, e, n, r, i) { let o; let s; let a = 0; let l = 0; return i.offset && e.length && (o = Xn(t, "time", e[0], "pos"), a = e.length === 1 ? 1 - o : (Xn(t, "time", e[1], "pos") - o) / 2, s = Xn(t, "time", e[e.length - 1], "pos"), l = e.length === 1 ? s : (s - Xn(t, "time", e[e.length - 2], "pos")) / 2), { start: a, end: l, factor: 1 / (a + 1 + l) }; }(r._table, c, 0, 0, s)), a.reverse && c.reverse(), er(r, c, r._majorUnit); }, getLabelForIndex(t, e) { const n = this; const r = n._adapter; const i = n.chart.data; const o = n.options.time; let s = i.labels && t < i.labels.length ? i.labels[t] : ""; const a = i.datasets[e].data[t]; return q.isObject(a) && (s = n.getRightValue(a)), o.tooltipFormat ? r.format(Qn(n, s), o.tooltipFormat) : typeof s === "string" ? s : r.format(Qn(n, s), o.displayFormats.datetime); }, tickFormatFunction(t, e, n, r) { const i = this._adapter; const o = this.options; const s = o.time.displayFormats; const a = s[this._unit]; const l = this._majorUnit; const u = s[l]; const c = n[e]; const d = o.ticks; const h = l && u && c && c.major; const p = i.format(t, r || (h ? u : a)); const f = h ? d.major : d.minor; const m = qn([f.callback, f.userCallback, d.callback, d.userCallback]); return m ? m(p, e, n) : p; }, convertTicksToLabels(t) { let e; let n; const r = []; for (e = 0, n = t.length; e < n; ++e)r.push(this.tickFormatFunction(t[e].value, e, t)); return r; }, getPixelForOffset(t) { const e = this._offsets; const n = Xn(this._table, "time", t, "pos"); return this.getPixelForDecimal((e.start + n) * e.factor); }, getPixelForValue(t, e, n) { let r = null; if (void 0 !== e && void 0 !== n && (r = this._timestamps.datasets[n][e]), r === null && (r = Jn(this, t)), r !== null) return this.getPixelForOffset(r); }, getPixelForTick(t) { const e = this.getTicks(); return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null; }, getValueForPixel(t) { const e = this._offsets; const n = this.getDecimalForPixel(t) / e.factor - e.end; const r = Xn(this._table, "pos", n, "time"); return this._adapter._create(r); }, _getLabelSize(t) { const e = this.options.ticks; const n = this.ctx.measureText(t).width; const r = q.toRadians(this.isHorizontal() ? e.maxRotation : e.minRotation); const i = Math.cos(r); const o = Math.sin(r); const s = Hn(e.fontSize, R.global.defaultFontSize); return { w: n * i + s * o, h: n * o + s * i }; }, getLabelWidth(t) { return this._getLabelSize(t).w; }, getLabelCapacity(t) { const e = this; const n = e.options.time; const r = n.displayFormats; const i = r[n.unit] || r.millisecond; const o = e.tickFormatFunction(t, 0, er(e, [t], e._majorUnit), i); const s = e._getLabelSize(o); let a = Math.floor(e.isHorizontal() ? e.width / s.w : e.height / s.h); return e.options.offset && a--, a > 0 ? a : 1; },
  }); nr._defaults = {
    position: "bottom",
    distribution: "linear",
    bounds: "data",
    adapters: {},
    time: {
      parser: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {},
    },
    ticks: { autoSkip: !1, source: "auto", major: { enabled: !1 } },
  }; const rr = {
    category: fn, linear: wn, logarithmic: Tn, radialLinear: Vn, time: nr,
  }; const ir = {
    datetime: "MMM D, YYYY, h:mm:ss a", millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY",
  }; Xe._date.override(typeof t === "function" ? {
    _id: "moment", formats() { return ir; }, parse(e, n) { return typeof e === "string" && typeof n === "string" ? e = t(e, n) : e instanceof t || (e = t(e)), e.isValid() ? e.valueOf() : null; }, format(e, n) { return t(e).format(n); }, add(e, n, r) { return t(e).add(n, r).valueOf(); }, diff(e, n, r) { return t(e).diff(t(n), r); }, startOf(e, n, r) { return e = t(e), n === "isoWeek" ? e.isoWeekday(r).valueOf() : e.startOf(n).valueOf(); }, endOf(e, n) { return t(e).endOf(n).valueOf(); }, _create(e) { return t(e); },
  } : {}), R._set("global", { plugins: { filler: { propagate: !0 } } }); const or = { dataset(t) { const e = t.fill; const n = t.chart; const r = n.getDatasetMeta(e); const i = r && n.isDatasetVisible(e) && r.dataset._children || []; const o = i.length || 0; return o ? function (t, e) { return e < o && i[e]._view || null; } : null; }, boundary(t) { const e = t.boundary; const n = e ? e.x : null; const r = e ? e.y : null; return q.isArray(e) ? function (t, n) { return e[n]; } : function (t) { return { x: n === null ? t.x : n, y: r === null ? t.y : r }; }; } }; function sr(t, e, n) { let r; const i = t._model || {}; let o = i.fill; if (void 0 === o && (o = !!i.backgroundColor), !1 === o || o === null) return !1; if (!0 === o) return "origin"; if (r = parseFloat(o, 10), isFinite(r) && Math.floor(r) === r) return o[0] !== "-" && o[0] !== "+" || (r = e + r), !(r === e || r < 0 || r >= n) && r; switch (o) { case "bottom": return "start"; case "top": return "end"; case "zero": return "origin"; case "origin": case "start": case "end": return o; default: return !1; } } function ar(t) { return (t.el._scale || {}).getPointPositionForValue ? (function (t) { let e; let n; let r; let i; let o; const s = t.el._scale; const a = s.options; const l = s.chart.data.labels.length; const u = t.fill; const c = []; if (!l) return null; for (e = a.ticks.reverse ? s.max : s.min, n = a.ticks.reverse ? s.min : s.max, r = s.getPointPositionForValue(0, e), i = 0; i < l; ++i)o = u === "start" || u === "end" ? s.getPointPositionForValue(i, u === "start" ? e : n) : s.getBasePosition(i), a.gridLines.circular && (o.cx = r.x, o.cy = r.y, o.angle = s.getIndexAngle(i) - Math.PI / 2), c.push(o); return c; }(t)) : (function (t) { let e; const n = t.el._model || {}; const r = t.el._scale || {}; const i = t.fill; let o = null; if (isFinite(i)) return null; if (i === "start" ? o = void 0 === n.scaleBottom ? r.bottom : n.scaleBottom : i === "end" ? o = void 0 === n.scaleTop ? r.top : n.scaleTop : void 0 !== n.scaleZero ? o = n.scaleZero : r.getBasePixel && (o = r.getBasePixel()), o != null) { if (void 0 !== o.x && void 0 !== o.y) return o; if (q.isFinite(o)) return { x: (e = r.isHorizontal()) ? o : null, y: e ? null : o }; } return null; }(t)); } function lr(t, e, n) { let r; let i = t[e].fill; const o = [e]; if (!n) return i; for (;!1 !== i && o.indexOf(i) === -1;) { if (!isFinite(i)) return i; if (!(r = t[i])) return !1; if (r.visible) return i; o.push(i), i = r.fill; } return !1; } function ur(t) { const e = t.fill; let n = "dataset"; return !1 === e ? null : (isFinite(e) || (n = "boundary"), or[n](t)); } function cr(t) { return t && !t.skip; } function dr(t, e, n, r, i) { let o; let s; let a; let l; if (r && i) { for (t.moveTo(e[0].x, e[0].y), o = 1; o < r; ++o)q.canvas.lineTo(t, e[o - 1], e[o]); if (void 0 === n[0].angle) for (t.lineTo(n[i - 1].x, n[i - 1].y), o = i - 1; o > 0; --o)q.canvas.lineTo(t, n[o], n[o - 1], !0); else for (s = n[0].cx, a = n[0].cy, l = Math.sqrt((n[0].x - s) ** 2 + (n[0].y - a) ** 2), o = i - 1; o > 0; --o)t.arc(s, a, l, n[o].angle, n[o - 1].angle, !0); } } function hr(t, e, n, r, i, o) { let s; let a; let l; let u; let c; let d; let h; let p; const f = e.length; const m = r.spanGaps; let g = []; let v = []; let y = 0; let _ = 0; for (t.beginPath(), s = 0, a = f; s < a; ++s)c = n(u = e[l = s % f]._view, l, r), d = cr(u), h = cr(c), o && void 0 === p && d && (a = f + (p = s + 1)), d && h ? (y = g.push(u), _ = v.push(c)) : y && _ && (m ? (d && g.push(u), h && v.push(c)) : (dr(t, g, v, y, _), y = _ = 0, g = [], v = [])); dr(t, g, v, y, _), t.closePath(), t.fillStyle = i, t.fill(); } const pr = {
    id: "filler",
    afterDatasetsUpdate(t, e) {
      let n; let r; let i; let o; const s = (t.data.datasets || []).length; const a = e.propagate; const l = []; for (r = 0; r < s; ++r) {
        o = null, (i = (n = t.getDatasetMeta(r)).dataset) && i._model && i instanceof _t.Line && (o = {
          visible: t.isDatasetVisible(r), fill: sr(i, r, s), chart: t, el: i,
        }), n.$filler = o, l.push(o);
      } for (r = 0; r < s; ++r)(o = l[r]) && (o.fill = lr(l, r, a), o.boundary = ar(o), o.mapper = ur(o));
    },
    beforeDatasetsDraw(t) { let e; let n; let r; let i; let o; let s; let a; const l = t._getSortedVisibleDatasetMetas(); const u = t.ctx; for (n = l.length - 1; n >= 0; --n)(e = l[n].$filler) && e.visible && (i = (r = e.el)._view, o = r._children || [], s = e.mapper, a = i.backgroundColor || R.global.defaultColor, s && a && o.length && (q.canvas.clipArea(u, t.chartArea), hr(u, o, s, i, a, r._loop), q.canvas.unclipArea(u))); },
  }; const fr = q.rtl.getRtlAdapter; const mr = q.noop; const gr = q.valueOrDefault; function vr(t, e) { return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth; }R._set("global", {
    legend: {
      display: !0,
      position: "top",
      align: "center",
      fullWidth: !0,
      reverse: !1,
      weight: 1e3,
      onClick(t, e) { const n = e.datasetIndex; const r = this.chart; const i = r.getDatasetMeta(n); i.hidden = i.hidden === null ? !r.data.datasets[n].hidden : null, r.update(); },
      onHover: null,
      onLeave: null,
      labels: {
        boxWidth: 40,
        padding: 10,
        generateLabels(t) {
          const e = t.data.datasets; const n = t.options.legend || {}; const r = n.labels && n.labels.usePointStyle; return t._getSortedDatasetMetas().map(((n) => {
            const i = n.controller.getStyle(r ? 0 : void 0); return {
              text: e[n.index].label, fillStyle: i.backgroundColor, hidden: !t.isDatasetVisible(n.index), lineCap: i.borderCapStyle, lineDash: i.borderDash, lineDashOffset: i.borderDashOffset, lineJoin: i.borderJoinStyle, lineWidth: i.borderWidth, strokeStyle: i.borderColor, pointStyle: i.pointStyle, rotation: i.rotation, datasetIndex: n.index,
            };
          }), this);
        },
      },
    },
    legendCallback(t) { let e; let n; let r; const i = document.createElement("ul"); const o = t.data.datasets; for (i.setAttribute("class", `${t.id}-legend`), e = 0, n = o.length; e < n; e++)(r = i.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = o[e].backgroundColor, o[e].label && r.appendChild(document.createTextNode(o[e].label)); return i.outerHTML; },
  }); const yr = Y.extend({
    initialize(t) { q.extend(this, t), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1; },
    beforeUpdate: mr,
    update(t, e, n) { const r = this; return r.beforeUpdate(), r.maxWidth = t, r.maxHeight = e, r.margins = n, r.beforeSetDimensions(), r.setDimensions(), r.afterSetDimensions(), r.beforeBuildLabels(), r.buildLabels(), r.afterBuildLabels(), r.beforeFit(), r.fit(), r.afterFit(), r.afterUpdate(), r.minSize; },
    afterUpdate: mr,
    beforeSetDimensions: mr,
    setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; },
    afterSetDimensions: mr,
    beforeBuildLabels: mr,
    buildLabels() { const t = this; const e = t.options.labels || {}; let n = q.callback(e.generateLabels, [t.chart], t) || []; e.filter && (n = n.filter(((n) => e.filter(n, t.chart.data)))), t.options.reverse && n.reverse(), t.legendItems = n; },
    afterBuildLabels: mr,
    beforeFit: mr,
    fit() {
      const t = this; const e = t.options; const n = e.labels; const r = e.display; const i = t.ctx; const o = q.options._parseFont(n); const s = o.size; const a = t.legendHitBoxes = []; const l = t.minSize; const u = t.isHorizontal(); if (u ? (l.width = t.maxWidth, l.height = r ? 10 : 0) : (l.width = r ? 10 : 0, l.height = t.maxHeight), r) {
        if (i.font = o.string, u) {
          const c = t.lineWidths = [0]; let d = 0; i.textAlign = "left", i.textBaseline = "middle", q.each(t.legendItems, ((t, e) => {
            const r = vr(n, s) + s / 2 + i.measureText(t.text).width; (e === 0 || c[c.length - 1] + r + 2 * n.padding > l.width) && (d += s + n.padding, c[c.length - (e > 0 ? 0 : 1)] = 0), a[e] = {
              left: 0, top: 0, width: r, height: s,
            }, c[c.length - 1] += r + n.padding;
          })), l.height += d;
        } else {
          const h = n.padding; const p = t.columnWidths = []; const f = t.columnHeights = []; let m = n.padding; let g = 0; let v = 0; q.each(t.legendItems, ((t, e) => {
            const r = vr(n, s) + s / 2 + i.measureText(t.text).width; e > 0 && v + s + 2 * h > l.height && (m += g + n.padding, p.push(g), f.push(v), g = 0, v = 0), g = Math.max(g, r), v += s + h, a[e] = {
              left: 0, top: 0, width: r, height: s,
            };
          })), m += g, p.push(g), f.push(v), l.width += m;
        }t.width = l.width, t.height = l.height;
      } else t.width = l.width = t.height = l.height = 0;
    },
    afterFit: mr,
    isHorizontal() { return this.options.position === "top" || this.options.position === "bottom"; },
    draw() { const t = this; const e = t.options; const n = e.labels; const r = R.global; const i = r.defaultColor; const o = r.elements.line; const s = t.height; const a = t.columnHeights; const l = t.width; const u = t.lineWidths; if (e.display) { let c; const d = fr(e.rtl, t.left, t.minSize.width); const h = t.ctx; const p = gr(n.fontColor, r.defaultFontColor); const f = q.options._parseFont(n); const m = f.size; h.textAlign = d.textAlign("left"), h.textBaseline = "middle", h.lineWidth = 0.5, h.strokeStyle = p, h.fillStyle = p, h.font = f.string; const g = vr(n, m); const v = t.legendHitBoxes; const y = function (t, r) { switch (e.align) { case "start": return n.padding; case "end": return t - r; default: return (t - r + n.padding) / 2; } }; const _ = t.isHorizontal(); c = _ ? { x: t.left + y(l, u[0]), y: t.top + n.padding, line: 0 } : { x: t.left + n.padding, y: t.top + y(s, a[0]), line: 0 }, q.rtl.overrideTextDirection(t.ctx, e.textDirection); const b = m + n.padding; q.each(t.legendItems, ((e, r) => { const p = h.measureText(e.text).width; const f = g + m / 2 + p; let w = c.x; let x = c.y; d.setWidth(t.minSize.width), _ ? r > 0 && w + f + n.padding > t.left + t.minSize.width && (x = c.y += b, c.line++, w = c.x = t.left + y(l, u[c.line])) : r > 0 && x + b > t.top + t.minSize.height && (w = c.x = w + t.columnWidths[c.line] + n.padding, c.line++, x = c.y = t.top + y(s, a[c.line])); const S = d.x(w); !(function (t, e, r) { if (!(isNaN(g) || g <= 0)) { h.save(); const s = gr(r.lineWidth, o.borderWidth); if (h.fillStyle = gr(r.fillStyle, i), h.lineCap = gr(r.lineCap, o.borderCapStyle), h.lineDashOffset = gr(r.lineDashOffset, o.borderDashOffset), h.lineJoin = gr(r.lineJoin, o.borderJoinStyle), h.lineWidth = s, h.strokeStyle = gr(r.strokeStyle, i), h.setLineDash && h.setLineDash(gr(r.lineDash, o.borderDash)), n && n.usePointStyle) { const a = g * Math.SQRT2 / 2; const l = d.xPlus(t, g / 2); const u = e + m / 2; q.canvas.drawPoint(h, r.pointStyle, a, l, u, r.rotation); } else h.fillRect(d.leftForLtr(t, g), e, g, m), s !== 0 && h.strokeRect(d.leftForLtr(t, g), e, g, m); h.restore(); } }(S, x, e)), v[r].left = d.leftForLtr(S, v[r].width), v[r].top = x, (function (t, e, n, r) { const i = m / 2; const o = d.xPlus(t, g + i); const s = e + i; h.fillText(n.text, o, s), n.hidden && (h.beginPath(), h.lineWidth = 2, h.moveTo(o, s), h.lineTo(d.xPlus(o, r), s), h.stroke()); }(S, x, e, p)), _ ? c.x += f + n.padding : c.y += b; })), q.rtl.restoreTextDirection(t.ctx, e.textDirection); } },
    _getLegendItemAt(t, e) { let n; let r; let i; const o = this; if (t >= o.left && t <= o.right && e >= o.top && e <= o.bottom) for (i = o.legendHitBoxes, n = 0; n < i.length; ++n) if (t >= (r = i[n]).left && t <= r.left + r.width && e >= r.top && e <= r.top + r.height) return o.legendItems[n]; return null; },
    handleEvent(t) { let e; const n = this; const r = n.options; const i = t.type === "mouseup" ? "click" : t.type; if (i === "mousemove") { if (!r.onHover && !r.onLeave) return; } else { if (i !== "click") return; if (!r.onClick) return; }e = n._getLegendItemAt(t.x, t.y), i === "click" ? e && r.onClick && r.onClick.call(n, t.native, e) : (r.onLeave && e !== n._hoveredItem && (n._hoveredItem && r.onLeave.call(n, t.native, n._hoveredItem), n._hoveredItem = e), r.onHover && e && r.onHover.call(n, t.native, e)); },
  }); function _r(t, e) { const n = new yr({ ctx: t.ctx, options: e, chart: t }); de.configure(t, n, e), de.addBox(t, n), t.legend = n; } const br = {
    id: "legend", _element: yr, beforeInit(t) { const e = t.options.legend; e && _r(t, e); }, beforeUpdate(t) { const e = t.options.legend; const n = t.legend; e ? (q.mergeIf(e, R.global.legend), n ? (de.configure(t, n, e), n.options = e) : _r(t, e)) : n && (de.removeBox(t, n), delete t.legend); }, afterEvent(t, e) { const n = t.legend; n && n.handleEvent(e); },
  }; const wr = q.noop; R._set("global", {
    title: {
      display: !1, fontStyle: "bold", fullWidth: !0, padding: 10, position: "top", text: "", weight: 2e3,
    },
  }); const xr = Y.extend({
    initialize(t) { q.extend(this, t), this.legendHitBoxes = []; }, beforeUpdate: wr, update(t, e, n) { const r = this; return r.beforeUpdate(), r.maxWidth = t, r.maxHeight = e, r.margins = n, r.beforeSetDimensions(), r.setDimensions(), r.afterSetDimensions(), r.beforeBuildLabels(), r.buildLabels(), r.afterBuildLabels(), r.beforeFit(), r.fit(), r.afterFit(), r.afterUpdate(), r.minSize; }, afterUpdate: wr, beforeSetDimensions: wr, setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 }; }, afterSetDimensions: wr, beforeBuildLabels: wr, buildLabels: wr, afterBuildLabels: wr, beforeFit: wr, fit() { let t; const e = this; const n = e.options; const r = e.minSize = {}; const i = e.isHorizontal(); n.display ? (t = (q.isArray(n.text) ? n.text.length : 1) * q.options._parseFont(n).lineHeight + 2 * n.padding, e.width = r.width = i ? e.maxWidth : t, e.height = r.height = i ? t : e.maxHeight) : e.width = r.width = e.height = r.height = 0; }, afterFit: wr, isHorizontal() { const t = this.options.position; return t === "top" || t === "bottom"; }, draw() { const t = this; const e = t.ctx; const n = t.options; if (n.display) { let r; let i; let o; const s = q.options._parseFont(n); const a = s.lineHeight; const l = a / 2 + n.padding; let u = 0; const c = t.top; const d = t.left; const h = t.bottom; const p = t.right; e.fillStyle = q.valueOrDefault(n.fontColor, R.global.defaultFontColor), e.font = s.string, t.isHorizontal() ? (i = d + (p - d) / 2, o = c + l, r = p - d) : (i = n.position === "left" ? d + l : p - l, o = c + (h - c) / 2, r = h - c, u = Math.PI * (n.position === "left" ? -0.5 : 0.5)), e.save(), e.translate(i, o), e.rotate(u), e.textAlign = "center", e.textBaseline = "middle"; const f = n.text; if (q.isArray(f)) for (let m = 0, g = 0; g < f.length; ++g)e.fillText(f[g], 0, m, r), m += a; else e.fillText(f, 0, 0, r); e.restore(); } },
  }); function Sr(t, e) { const n = new xr({ ctx: t.ctx, options: e, chart: t }); de.configure(t, n, e), de.addBox(t, n), t.titleBlock = n; } const kr = {}; const Cr = pr; const Er = br; const Tr = {
    id: "title", _element: xr, beforeInit(t) { const e = t.options.title; e && Sr(t, e); }, beforeUpdate(t) { const e = t.options.title; const n = t.titleBlock; e ? (q.mergeIf(e, R.global.title), n ? (de.configure(t, n, e), n.options = e) : Sr(t, e)) : n && (de.removeBox(t, n), delete t.titleBlock); },
  }; for (const Pr in kr.filler = Cr, kr.legend = Er, kr.title = Tr, Ye.helpers = q, (function () { function t(t, e, n) { let r; return typeof t === "string" ? (r = parseInt(t, 10), t.indexOf("%") !== -1 && (r = r / 100 * e.parentNode[n])) : r = t, r; } function e(t) { return t != null && t !== "none"; } function n(n, r, i) { const o = document.defaultView; const s = q._getParentNode(n); const a = o.getComputedStyle(n)[r]; const l = o.getComputedStyle(s)[r]; const u = e(a); const c = e(l); const d = Number.POSITIVE_INFINITY; return u || c ? Math.min(u ? t(a, n, i) : d, c ? t(l, s, i) : d) : "none"; }q.where = function (t, e) { if (q.isArray(t) && Array.prototype.filter) return t.filter(e); const n = []; return q.each(t, ((t) => { e(t) && n.push(t); })), n; }, q.findIndex = Array.prototype.findIndex ? function (t, e, n) { return t.findIndex(e, n); } : function (t, e, n) { n = void 0 === n ? t : n; for (let r = 0, i = t.length; r < i; ++r) if (e.call(n, t[r], r, t)) return r; return -1; }, q.findNextWhere = function (t, e, n) { q.isNullOrUndef(n) && (n = -1); for (let r = n + 1; r < t.length; r++) { const i = t[r]; if (e(i)) return i; } }, q.findPreviousWhere = function (t, e, n) { q.isNullOrUndef(n) && (n = t.length); for (let r = n - 1; r >= 0; r--) { const i = t[r]; if (e(i)) return i; } }, q.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t); }, q.almostEquals = function (t, e, n) { return Math.abs(t - e) < n; }, q.almostWhole = function (t, e) { const n = Math.round(t); return n - e <= t && n + e >= t; }, q.max = function (t) { return t.reduce(((t, e) => (isNaN(e) ? t : Math.max(t, e))), Number.NEGATIVE_INFINITY); }, q.min = function (t) { return t.reduce(((t, e) => (isNaN(e) ? t : Math.min(t, e))), Number.POSITIVE_INFINITY); }, q.sign = Math.sign ? function (t) { return Math.sign(t); } : function (t) { return (t = +t) == 0 || isNaN(t) ? t : t > 0 ? 1 : -1; }, q.toRadians = function (t) { return t * (Math.PI / 180); }, q.toDegrees = function (t) { return t * (180 / Math.PI); }, q._decimalPlaces = function (t) { if (q.isFinite(t)) { for (var e = 1, n = 0; Math.round(t * e) / e !== t;)e *= 10, n++; return n; } }, q.getAngleFromPoint = function (t, e) { const n = e.x - t.x; const r = e.y - t.y; const i = Math.sqrt(n * n + r * r); let o = Math.atan2(r, n); return o < -0.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: i }; }, q.distanceBetweenPoints = function (t, e) { return Math.sqrt((e.x - t.x) ** 2 + (e.y - t.y) ** 2); }, q.aliasPixel = function (t) { return t % 2 == 0 ? 0 : 0.5; }, q._alignPixel = function (t, e, n) { const r = t.currentDevicePixelRatio; const i = n / 2; return Math.round((e - i) * r) / r + i; }, q.splineCurve = function (t, e, n, r) { const i = t.skip ? e : t; const o = e; const s = n.skip ? e : n; const a = Math.sqrt((o.x - i.x) ** 2 + (o.y - i.y) ** 2); const l = Math.sqrt((s.x - o.x) ** 2 + (s.y - o.y) ** 2); let u = a / (a + l); let c = l / (a + l); const d = r * (u = isNaN(u) ? 0 : u); const h = r * (c = isNaN(c) ? 0 : c); return { previous: { x: o.x - d * (s.x - i.x), y: o.y - d * (s.y - i.y) }, next: { x: o.x + h * (s.x - i.x), y: o.y + h * (s.y - i.y) } }; }, q.EPSILON = Number.EPSILON || 1e-14, q.splineCurveMonotone = function (t) { let e; let n; let r; let i; let o; let s; let a; let l; let u; const c = (t || []).map(((t) => ({ model: t._model, deltaK: 0, mK: 0 }))); const d = c.length; for (e = 0; e < d; ++e) if (!(r = c[e]).model.skip) { if (n = e > 0 ? c[e - 1] : null, (i = e < d - 1 ? c[e + 1] : null) && !i.model.skip) { const h = i.model.x - r.model.x; r.deltaK = h !== 0 ? (i.model.y - r.model.y) / h : 0; }!n || n.model.skip ? r.mK = r.deltaK : !i || i.model.skip ? r.mK = n.deltaK : this.sign(n.deltaK) !== this.sign(r.deltaK) ? r.mK = 0 : r.mK = (n.deltaK + r.deltaK) / 2; } for (e = 0; e < d - 1; ++e)r = c[e], i = c[e + 1], r.model.skip || i.model.skip || (q.almostEquals(r.deltaK, 0, this.EPSILON) ? r.mK = i.mK = 0 : (o = r.mK / r.deltaK, s = i.mK / r.deltaK, (l = o ** 2 + s ** 2) <= 9 || (a = 3 / Math.sqrt(l), r.mK = o * a * r.deltaK, i.mK = s * a * r.deltaK))); for (e = 0; e < d; ++e)(r = c[e]).model.skip || (n = e > 0 ? c[e - 1] : null, i = e < d - 1 ? c[e + 1] : null, n && !n.model.skip && (u = (r.model.x - n.model.x) / 3, r.model.controlPointPreviousX = r.model.x - u, r.model.controlPointPreviousY = r.model.y - u * r.mK), i && !i.model.skip && (u = (i.model.x - r.model.x) / 3, r.model.controlPointNextX = r.model.x + u, r.model.controlPointNextY = r.model.y + u * r.mK)); }, q.nextItem = function (t, e, n) { return n ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1]; }, q.previousItem = function (t, e, n) { return n ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1]; }, q.niceNum = function (t, e) { const n = Math.floor(q.log10(t)); const r = t / 10 ** n; return (e ? r < 1.5 ? 1 : r < 3 ? 2 : r < 7 ? 5 : 10 : r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * 10 ** n; }, q.requestAnimFrame = typeof window === "undefined" ? function (t) { t(); } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60); }, q.getRelativePosition = function (t, e) { let n; let r; const i = t.originalEvent || t; const o = t.target || t.srcElement; const s = o.getBoundingClientRect(); const a = i.touches; a && a.length > 0 ? (n = a[0].clientX, r = a[0].clientY) : (n = i.clientX, r = i.clientY); const l = parseFloat(q.getStyle(o, "padding-left")); const u = parseFloat(q.getStyle(o, "padding-top")); const c = parseFloat(q.getStyle(o, "padding-right")); const d = parseFloat(q.getStyle(o, "padding-bottom")); const h = s.right - s.left - l - c; const p = s.bottom - s.top - u - d; return { x: n = Math.round((n - s.left - l) / h * o.width / e.currentDevicePixelRatio), y: r = Math.round((r - s.top - u) / p * o.height / e.currentDevicePixelRatio) }; }, q.getConstraintWidth = function (t) { return n(t, "max-width", "clientWidth"); }, q.getConstraintHeight = function (t) { return n(t, "max-height", "clientHeight"); }, q._calculatePadding = function (t, e, n) { return (e = q.getStyle(t, e)).indexOf("%") > -1 ? n * parseInt(e, 10) / 100 : parseInt(e, 10); }, q._getParentNode = function (t) { let e = t.parentNode; return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e; }, q.getMaximumWidth = function (t) { const e = q._getParentNode(t); if (!e) return t.clientWidth; const n = e.clientWidth; const r = n - q._calculatePadding(e, "padding-left", n) - q._calculatePadding(e, "padding-right", n); const i = q.getConstraintWidth(t); return isNaN(i) ? r : Math.min(r, i); }, q.getMaximumHeight = function (t) { const e = q._getParentNode(t); if (!e) return t.clientHeight; const n = e.clientHeight; const r = n - q._calculatePadding(e, "padding-top", n) - q._calculatePadding(e, "padding-bottom", n); const i = q.getConstraintHeight(t); return isNaN(i) ? r : Math.min(r, i); }, q.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e); }, q.retinaScale = function (t, e) { const n = t.currentDevicePixelRatio = e || typeof window !== "undefined" && window.devicePixelRatio || 1; if (n !== 1) { const r = t.canvas; const i = t.height; const o = t.width; r.height = i * n, r.width = o * n, t.ctx.scale(n, n), r.style.height || r.style.width || (r.style.height = `${i}px`, r.style.width = `${o}px`); } }, q.fontString = function (t, e, n) { return `${e} ${t}px ${n}`; }, q.longestText = function (t, e, n, r) { let i = (r = r || {}).data = r.data || {}; let o = r.garbageCollect = r.garbageCollect || []; r.font !== e && (i = r.data = {}, o = r.garbageCollect = [], r.font = e), t.font = e; let s; let a; let l; let u; let c; let d = 0; const h = n.length; for (s = 0; s < h; s++) if ((u = n[s]) != null && !0 !== q.isArray(u))d = q.measureText(t, i, o, d, u); else if (q.isArray(u)) for (a = 0, l = u.length; a < l; a++)(c = u[a]) == null || q.isArray(c) || (d = q.measureText(t, i, o, d, c)); const p = o.length / 2; if (p > n.length) { for (s = 0; s < p; s++) delete i[o[s]]; o.splice(0, p); } return d; }, q.measureText = function (t, e, n, r, i) { let o = e[i]; return o || (o = e[i] = t.measureText(i).width, n.push(i)), o > r && (r = o), r; }, q.numberOfLabelLines = function (t) { let e = 1; return q.each(t, ((t) => { q.isArray(t) && t.length > e && (e = t.length); })), e; }, q.color = w ? function (t) { return t instanceof CanvasGradient && (t = R.global.defaultColor), w(t); } : function (t) { return console.error("Color.js not found!"), t; }, q.getHoverColor = function (t) { return t instanceof CanvasPattern || t instanceof CanvasGradient ? t : q.color(t).saturate(0.5).darken(0.1).rgbString(); }; }()), Ye._adapters = Xe, Ye.Animation = K, Ye.animationService = X, Ye.controllers = Yt, Ye.DatasetController = nt, Ye.defaults = R, Ye.Element = Y, Ye.elements = _t, Ye.Interaction = ee, Ye.layouts = de, Ye.platform = Ee, Ye.plugins = Te, Ye.Scale = hn, Ye.scaleService = Pe, Ye.Ticks = Qe, Ye.Tooltip = Ve, Ye.helpers.each(rr, ((t, e) => { Ye.scaleService.registerScaleType(e, t, t._defaults); })), kr)kr.hasOwnProperty(Pr) && Ye.plugins.register(kr[Pr]); Ye.platform.initialize(); const Or = Ye; return typeof window !== "undefined" && (window.Chart = Ye), Ye.Chart = Ye, Ye.Legend = kr.legend._element, Ye.Title = kr.title._element, Ye.pluginService = Ye.plugins, Ye.PluginBase = Ye.Element.extend({}), Ye.canvasHelpers = Ye.helpers.canvas, Ye.layoutService = Ye.layouts, Ye.LinearScaleBase = vn, Ye.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], ((t) => { Ye[t] = function (e, n) { return new Ye(e, Ye.helpers.merge(n || {}, { type: t.charAt(0).toLowerCase() + t.slice(1) })); }; })), Or;
}))), (function (t, e) { typeof exports === "object" && typeof module === "object" ? module.exports = e() : typeof define === "function" && define.amd ? define([], e) : typeof exports === "object" ? exports.HSQuantityCounter = e() : t.HSQuantityCounter = e(); }(window, (() => {
  return d = {
    "./src/js/hs-quantity-counter.js": function (module, __webpack_exports__, __webpack_require__) {
      eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HSQuantityCounter; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar dataAttributeName = \'data-hs-quantity-counter-options\';\nvar defaults = {\n  classMap: {\n    plus: \'.js-plus\',\n    minus: \'.js-minus\',\n    result: \'.js-result\'\n  },\n  resultVal: null\n};\n\nvar HSQuantityCounter = /*#__PURE__*/function () {\n  function HSQuantityCounter(el, options, id) {\n    _classCallCheck(this, HSQuantityCounter);\n\n    this.collection = [];\n    var that = this;\n    var elems;\n\n    if (el instanceof HTMLElement) {\n      elems = [el];\n    } else if (el instanceof Object) {\n      elems = el;\n    } else {\n      elems = document.querySelectorAll(el);\n    }\n\n    for (var i = 0; i < elems.length; i += 1) {\n      that.addToCollection(elems[i], options, id || elems[i].id);\n    }\n\n    if (!that.collection.length) {\n      return false;\n    } // initialization calls\n\n\n    that._init();\n\n    return this;\n  }\n\n  _createClass(HSQuantityCounter, [{\n    key: "_init",\n    value: function _init() {\n      var that = this;\n\n      var _loop = function _loop(i) {\n        var _$el = void 0;\n\n        var _options = void 0;\n\n        if (that.collection[i].hasOwnProperty(\'$initializedEl\')) {\n          return "continue";\n        }\n\n        _$el = that.collection[i].$el;\n        _options = that.collection[i].options; // Change Default Values\n\n        _options.resultVal = parseInt(_$el.querySelector(_options.classMap.result).value); // Plus Click Events\n\n        _$el.querySelector(_options.classMap.plus).addEventListener(\'click\', function () {\n          that._plusClickEvents(_$el, _options);\n        }); // Minus Click Events\n\n\n        _$el.querySelector(_options.classMap.minus).addEventListener(\'click\', function () {\n          that._minusClickEvents(_$el, _options);\n        });\n      };\n\n      for (var i = 0; i < that.collection.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === "continue") continue;\n      }\n    }\n  }, {\n    key: "_plusClickEvents",\n    value: function _plusClickEvents($el, settings) {\n      settings.resultVal += 1;\n      $el.querySelector(settings.classMap.result).value++;\n    }\n  }, {\n    key: "_minusClickEvents",\n    value: function _minusClickEvents($el, settings) {\n      if (settings.resultVal >= 1) {\n        settings.resultVal -= 1;\n        $el.querySelector(settings.classMap.result).value--;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: "addToCollection",\n    value: function addToCollection(item, options, id) {\n      this.collection.push({\n        $el: item,\n        id: id || null,\n        options: Object.assign({}, defaults, item.hasAttribute(dataAttributeName) ? JSON.parse(item.getAttribute(dataAttributeName)) : {}, options)\n      });\n    }\n  }, {\n    key: "getItem",\n    value: function getItem(item) {\n      if (typeof item === \'number\') {\n        return this.collection[item].$initializedEl;\n      } else {\n        return this.collection.find(function (el) {\n          return el.id === item;\n        }).$initializedEl;\n      }\n    }\n  }]);\n\n  return HSQuantityCounter;\n}();\n\n\n\n//# sourceURL=webpack://HSQuantityCounter/./src/js/hs-quantity-counter.js?');
    },
  }, e = {}, f.m = d, f.c = e, f.d = function (t, e, n) { f.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, f.r = function (t) { typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }); }, f.t = function (t, e) { if (1 & e && (t = f(t)), 8 & e) return t; if (4 & e && typeof t === "object" && t && t.__esModule) return t; const n = Object.create(null); if (f.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && typeof t !== "string") for (const r in t)f.d(n, r, ((e) => t[e]).bind(null, r)); return n; }, f.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return f.d(e, "a", e), e; }, f.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, f.p = "", f(f.s = "./src/js/hs-quantity-counter.js").default; function f(t) { if (e[t]) return e[t].exports; const n = e[t] = { i: t, l: !1, exports: {} }; return d[t].call(n.exports, n, n.exports, f), n.l = !0, n.exports; } let d; let e;
}))), List = (function () {
  const t = {
    "./src/add-async.js": function (t) { t.exports = function (t) { return function e(n, r, i) { const o = n.splice(0, 50); i = (i = i || []).concat(t.add(o)), n.length > 0 ? setTimeout((() => { e(n, r, i); }), 1) : (t.update(), r(i)); }; }; },
    "./src/filter.js": function (t) { t.exports = function (t) { return t.handlers.filterStart = t.handlers.filterStart || [], t.handlers.filterComplete = t.handlers.filterComplete || [], function (e) { if (t.trigger("filterStart"), t.i = 1, t.reset.filter(), void 0 === e)t.filtered = !1; else { t.filtered = !0; for (let n = t.items, r = 0, i = n.length; r < i; r++) { const o = n[r]; e(o) ? o.filtered = !0 : o.filtered = !1; } } return t.update(), t.trigger("filterComplete"), t.visibleItems; }; }; },
    "./src/fuzzy-search.js": function (t, e, n) {
      n("./src/utils/classes.js"); const r = n("./src/utils/events.js"); const i = n("./src/utils/extend.js"); const o = n("./src/utils/to-string.js"); const s = n("./src/utils/get-by-class.js"); const a = n("./src/utils/fuzzy.js"); t.exports = function (t, e) {
        e = i({
          location: 0, distance: 100, threshold: 0.4, multiSearch: !0, searchClass: "fuzzy-search",
        }, e = e || {}); var n = { search(r, i) { for (let o = e.multiSearch ? r.replace(/ +$/, "").split(/ +/) : [r], s = 0, a = t.items.length; s < a; s++)n.item(t.items[s], i, o); }, item(t, e, r) { for (var i = !0, o = 0; o < r.length; o++) { for (var s = !1, a = 0, l = e.length; a < l; a++)n.values(t.values(), e[a], r[o]) && (s = !0); s || (i = !1); }t.found = i; }, values(t, n, r) { if (t.hasOwnProperty(n)) { const i = o(t[n]).toLowerCase(); if (a(i, r, e)) return !0; } return !1; } }; return r.bind(s(t.listContainer, e.searchClass), "keyup", t.utils.events.debounce(((e) => { const r = e.target || e.srcElement; t.search(r.value, n.search); }), t.searchDelay)), function (e, r) { t.search(e, r, n.search); };
      };
    },
    "./src/index.js": function (t, e, n) {
      const r = n("./node_modules/string-natural-compare/natural-compare.js"); const i = n("./src/utils/get-by-class.js"); const o = n("./src/utils/extend.js"); const s = n("./src/utils/index-of.js"); const a = n("./src/utils/events.js"); const l = n("./src/utils/to-string.js"); const u = n("./src/utils/classes.js"); const c = n("./src/utils/get-attribute.js"); const d = n("./src/utils/to-array.js"); t.exports = function (t, e, h) {
        let p; const f = this; const m = n("./src/item.js")(f); const g = n("./src/add-async.js")(f); const v = n("./src/pagination.js")(f); p = {
          start() {
            f.listClass = "list", f.searchClass = "search", f.sortClass = "sort", f.page = 1e4, f.i = 1, f.items = [], f.visibleItems = [], f.matchingItems = [], f.searched = !1, f.filtered = !1, f.searchColumns = void 0, f.searchDelay = 0, f.handlers = { updated: [] }, f.valueNames = [], f.utils = {
              getByClass: i, extend: o, indexOf: s, events: a, toString: l, naturalSort: r, classes: u, getAttribute: c, toArray: d,
            }, f.utils.extend(f, e), f.listContainer = typeof t === "string" ? document.getElementById(t) : t, f.listContainer && (f.list = i(f.listContainer, f.listClass, !0), f.parse = n("./src/parse.js")(f), f.templater = n("./src/templater.js")(f), f.search = n("./src/search.js")(f), f.filter = n("./src/filter.js")(f), f.sort = n("./src/sort.js")(f), f.fuzzySearch = n("./src/fuzzy-search.js")(f, e.fuzzySearch), this.handlers(), this.items(), this.pagination(), f.update());
          },
          handlers() { for (const t in f.handlers)f[t] && f.handlers.hasOwnProperty(t) && f.on(t, f[t]); },
          items() { f.parse(f.list), void 0 !== h && f.add(h); },
          pagination() { if (void 0 !== e.pagination) { !0 === e.pagination && (e.pagination = [{}]), void 0 === e.pagination[0] && (e.pagination = [e.pagination]); for (let t = 0, n = e.pagination.length; t < n; t++)v(e.pagination[t]); } },
        }, this.reIndex = function () { f.items = [], f.visibleItems = [], f.matchingItems = [], f.searched = !1, f.filtered = !1, f.parse(f.list); }, this.toJSON = function () { for (var t = [], e = 0, n = f.items.length; e < n; e++)t.push(f.items[e].values()); return t; }, this.add = function (t, e) { if (t.length !== 0) { if (!e) { const n = []; let r = !1; void 0 === t[0] && (t = [t]); for (let i = 0, o = t.length; i < o; i++) { var s; r = f.items.length > f.page, s = new m(t[i], void 0, r), f.items.push(s), n.push(s); } return f.update(), n; }g(t.slice(0), e); } }, this.show = function (t, e) { return this.i = t, this.page = e, f.update(), f; }, this.remove = function (t, e, n) { for (var r = 0, i = 0, o = f.items.length; i < o; i++)f.items[i].values()[t] == e && (f.templater.remove(f.items[i], n), f.items.splice(i, 1), o--, i--, r++); return f.update(), r; }, this.get = function (t, e) { for (var n = [], r = 0, i = f.items.length; r < i; r++) { const o = f.items[r]; o.values()[t] == e && n.push(o); } return n; }, this.size = function () { return f.items.length; }, this.clear = function () { return f.templater.clear(), f.items = [], f; }, this.on = function (t, e) { return f.handlers[t].push(e), f; }, this.off = function (t, e) { const n = f.handlers[t]; const r = s(n, e); return r > -1 && n.splice(r, 1), f; }, this.trigger = function (t) { for (let e = f.handlers[t].length; e--;)f.handlers[t][e](f); return f; }, this.reset = { filter() { for (let t = f.items, e = t.length; e--;)t[e].filtered = !1; return f; }, search() { for (let t = f.items, e = t.length; e--;)t[e].found = !1; return f; } }, this.update = function () { const t = f.items; const e = t.length; f.visibleItems = [], f.matchingItems = [], f.templater.clear(); for (let n = 0; n < e; n++)t[n].matching() && f.matchingItems.length + 1 >= f.i && f.visibleItems.length < f.page ? (t[n].show(), f.visibleItems.push(t[n]), f.matchingItems.push(t[n])) : t[n].matching() ? (f.matchingItems.push(t[n]), t[n].hide()) : t[n].hide(); return f.trigger("updated"), f; }, p.start();
      };
    },
    "./src/item.js": function (t) { t.exports = function (t) { return function (e, n, r) { const i = this; this._values = {}, this.found = !1, this.filtered = !1, this.values = function (e, n) { if (void 0 === e) return i._values; for (const r in e)i._values[r] = e[r]; !0 !== n && t.templater.set(i, i.values()); }, this.show = function () { t.templater.show(i); }, this.hide = function () { t.templater.hide(i); }, this.matching = function () { return t.filtered && t.searched && i.found && i.filtered || t.filtered && !t.searched && i.filtered || !t.filtered && t.searched && i.found || !t.filtered && !t.searched; }, this.visible = function () { return !(!i.elm || i.elm.parentNode != t.list); }, (function (e, n, r) { if (void 0 === n)r ? i.values(e, r) : i.values(e); else { i.elm = n; const o = t.templater.get(i, e); i.values(o); } }(e, n, r)); }; }; },
    "./src/pagination.js": function (t, e, n) {
      const r = n("./src/utils/classes.js"); const i = n("./src/utils/events.js"); const o = n("./src/index.js"); t.exports = function (t) {
        let e = !1; const n = function (n, i) { if (t.page < 1) return t.listContainer.style.display = "none", void (e = !0); e && (t.listContainer.style.display = "block"); let o; const a = t.matchingItems.length; const l = t.i; const u = t.page; const c = Math.ceil(a / u); const d = Math.ceil(l / u); const h = i.innerWindow || 2; const p = i.left || i.outerWindow || 0; let f = i.right || i.outerWindow || 0; f = c - f, n.clear(); for (let m = 1; m <= c; m++) { const g = d === m ? "active" : ""; s.number(m, p, f, d, h) ? (o = n.add({ page: m, dotted: !1 })[0], g && r(o.elm).add(g), o.elm.firstChild.setAttribute("data-i", m), o.elm.firstChild.setAttribute("data-page", u)) : s.dotted(n, m, p, f, d, h, n.size()) && (o = n.add({ page: "...", dotted: !0 })[0], r(o.elm).add("disabled")); } }; var s = {
          number(t, e, n, r, i) { return this.left(t, e) || this.right(t, n) || this.innerWindow(t, r, i); }, left(t, e) { return t <= e; }, right(t, e) { return t > e; }, innerWindow(t, e, n) { return t >= e - n && t <= e + n; }, dotted(t, e, n, r, i, o, s) { return this.dottedLeft(t, e, n, r, i, o) || this.dottedRight(t, e, n, r, i, o, s); }, dottedLeft(t, e, n, r, i, o) { return e == n + 1 && !this.innerWindow(e, i, o) && !this.right(e, r); }, dottedRight(t, e, n, r, i, o, s) { return !t.items[s - 1].values().dotted && e == r && !this.innerWindow(e, i, o) && !this.right(e, r); },
        }; return function (e) {
          const r = new o(t.listContainer.id, {
            listClass: e.paginationClass || "pagination", item: e.item || "<li><a class='page' href='#'></a></li>", valueNames: ["page", "dotted"], searchClass: "pagination-search-that-is-not-supposed-to-exist", sortClass: "pagination-sort-that-is-not-supposed-to-exist",
          }); i.bind(r.listContainer, "click", ((e) => { const n = e.target || e.srcElement; const r = t.utils.getAttribute(n, "data-page"); const i = t.utils.getAttribute(n, "data-i"); i && t.show((i - 1) * r + 1, r); })), t.on("updated", (() => { n(r, e); })), n(r, e);
        };
      };
    },
    "./src/parse.js": function (t, e, n) { t.exports = function (t) { const e = n("./src/item.js")(t); const r = function (n, r) { for (let i = 0, o = n.length; i < o; i++)t.items.push(new e(r, n[i])); }; return t.handlers.parseComplete = t.handlers.parseComplete || [], function () { const e = (function (t) { for (var e = t.childNodes, n = [], r = 0, i = e.length; r < i; r++) void 0 === e[r].data && n.push(e[r]); return n; }(t.list)); const n = t.valueNames; t.indexAsync ? (function e(n, i) { const o = n.splice(0, 50); r(o, i), n.length > 0 ? setTimeout((() => { e(n, i); }), 1) : (t.update(), t.trigger("parseComplete")); }(e, n)) : r(e, n); }; }; },
    "./src/search.js": function (t) {
      t.exports = function (t) {
        let e; let n; let r; var i = {
          resetList() { t.i = 1, t.templater.clear(), r = void 0; }, setOptions(t) { t.length == 2 && t[1] instanceof Array ? e = t[1] : t.length == 2 && typeof t[1] === "function" ? (e = void 0, r = t[1]) : t.length == 3 ? (e = t[1], r = t[2]) : e = void 0; }, setColumns() { t.items.length !== 0 && void 0 === e && (e = void 0 === t.searchColumns ? i.toArray(t.items[0].values()) : t.searchColumns); }, setSearchString(e) { e = (e = t.utils.toString(e).toLowerCase()).replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"), n = e; }, toArray(t) { const e = []; for (const n in t)e.push(n); return e; },
        }; const o = function () { for (var r, i = [], o = n; (r = o.match(/"([^"]+)"/)) !== null;)i.push(r[1]), o = o.substring(0, r.index) + o.substring(r.index + r[0].length); (o = o.trim()).length && (i = i.concat(o.split(/\s+/))); for (let s = 0, a = t.items.length; s < a; s++) { const l = t.items[s]; if (l.found = !1, i.length) { for (let u = 0, c = i.length; u < c; u++) { for (var d = !1, h = 0, p = e.length; h < p; h++) { const f = l.values(); const m = e[h]; if (f.hasOwnProperty(m) && void 0 !== f[m] && f[m] !== null && (typeof f[m] !== "string" ? f[m].toString() : f[m]).toLowerCase().indexOf(i[u]) !== -1) { d = !0; break; } } if (!d) break; }l.found = d; } } }; const s = function () { t.reset.search(), t.searched = !1; }; const a = function (a) { return t.trigger("searchStart"), i.resetList(), i.setSearchString(a), i.setOptions(arguments), i.setColumns(), n === "" ? s() : (t.searched = !0, r ? r(n, e) : o()), t.update(), t.trigger("searchComplete"), t.visibleItems; }; return t.handlers.searchStart = t.handlers.searchStart || [], t.handlers.searchComplete = t.handlers.searchComplete || [], t.utils.events.bind(t.utils.getByClass(t.listContainer, t.searchClass), "keyup", t.utils.events.debounce(((e) => { const n = e.target || e.srcElement; n.value === "" && !t.searched || a(n.value); }), t.searchDelay)), t.utils.events.bind(t.utils.getByClass(t.listContainer, t.searchClass), "input", ((t) => { (t.target || t.srcElement).value === "" && a(""); })), a;
      };
    },
    "./src/sort.js": function (t) {
      t.exports = function (t) {
        var e = {
          els: void 0, clear() { for (let n = 0, r = e.els.length; n < r; n++)t.utils.classes(e.els[n]).remove("asc"), t.utils.classes(e.els[n]).remove("desc"); }, getOrder(e) { const n = t.utils.getAttribute(e, "data-order"); return n == "asc" || n == "desc" ? n : t.utils.classes(e).has("desc") ? "asc" : t.utils.classes(e).has("asc") ? "desc" : "asc"; }, getInSensitive(e, n) { const r = t.utils.getAttribute(e, "data-insensitive"); n.insensitive = r !== "false"; }, setOrder(n) { for (let r = 0, i = e.els.length; r < i; r++) { const o = e.els[r]; if (t.utils.getAttribute(o, "data-sort") === n.valueName) { const s = t.utils.getAttribute(o, "data-order"); s == "asc" || s == "desc" ? s == n.order && t.utils.classes(o).add(n.order) : t.utils.classes(o).add(n.order); } } },
        }; const n = function () { t.trigger("sortStart"); let n = {}; const r = arguments[0].currentTarget || arguments[0].srcElement || void 0; r ? (n.valueName = t.utils.getAttribute(r, "data-sort"), e.getInSensitive(r, n), n.order = e.getOrder(r)) : ((n = arguments[1] || n).valueName = arguments[0], n.order = n.order || "asc", n.insensitive = void 0 === n.insensitive || n.insensitive), e.clear(), e.setOrder(n); let i; const o = n.sortFunction || t.sortFunction || null; const s = n.order === "desc" ? -1 : 1; i = o ? function (t, e) { return o(t, e, n) * s; } : function (e, r) { let i = t.utils.naturalSort; return i.alphabet = t.alphabet || n.alphabet || void 0, !i.alphabet && n.insensitive && (i = t.utils.naturalSort.caseInsensitive), i(e.values()[n.valueName], r.values()[n.valueName]) * s; }, t.items.sort(i), t.update(), t.trigger("sortComplete"); }; return t.handlers.sortStart = t.handlers.sortStart || [], t.handlers.sortComplete = t.handlers.sortComplete || [], e.els = t.utils.getByClass(t.listContainer, t.sortClass), t.utils.events.bind(e.els, "click", n), t.on("searchStart", e.clear), t.on("filterStart", e.clear), n;
      };
    },
    "./src/templater.js": function (t) { const e = function (t) { let e; const n = this; const r = function (t) { if (typeof t === "string") { if (/<tr[\s>]/g.exec(t)) { const e = document.createElement("tbody"); return e.innerHTML = t, e.firstElementChild; } if (t.indexOf("<") !== -1) { const n = document.createElement("div"); return n.innerHTML = t, n.firstElementChild; } } }; const i = function (e, n, r) { let i = void 0; const o = (function (e) { for (let n = 0, r = t.valueNames.length; n < r; n++) { const i = t.valueNames[n]; if (i.data) { for (let o = i.data, s = 0, a = o.length; s < a; s++) if (o[s] === e) return { data: e }; } else { if (i.attr && i.name && i.name == e) return i; if (i === e) return e; } } }(n)); o && (o.data ? e.elm.setAttribute(`data-${o.data}`, r) : o.attr && o.name ? (i = t.utils.getByClass(e.elm, o.name, !0)) && i.setAttribute(o.attr, r) : (i = t.utils.getByClass(e.elm, o, !0)) && (i.innerHTML = r)); }; this.get = function (e, r) { n.create(e); for (var i = {}, o = 0, s = r.length; o < s; o++) { let a = void 0; const l = r[o]; if (l.data) for (let u = 0, c = l.data.length; u < c; u++)i[l.data[u]] = t.utils.getAttribute(e.elm, `data-${l.data[u]}`); else l.attr && l.name ? (a = t.utils.getByClass(e.elm, l.name, !0), i[l.name] = a ? t.utils.getAttribute(a, l.attr) : "") : (a = t.utils.getByClass(e.elm, l, !0), i[l] = a ? a.innerHTML : ""); } return i; }, this.set = function (t, e) { if (!n.create(t)) for (const r in e)e.hasOwnProperty(r) && i(t, r, e[r]); }, this.create = function (t) { return void 0 === t.elm && (t.elm = e(t.values()), n.set(t, t.values()), !0); }, this.remove = function (e) { e.elm.parentNode === t.list && t.list.removeChild(e.elm); }, this.show = function (e) { n.create(e), t.list.appendChild(e.elm); }, this.hide = function (e) { void 0 !== e.elm && e.elm.parentNode === t.list && t.list.removeChild(e.elm); }, this.clear = function () { if (t.list.hasChildNodes()) for (;t.list.childNodes.length >= 1;)t.list.removeChild(t.list.firstChild); }, (function () { let n; if (typeof t.item !== "function") { if (!(n = typeof t.item === "string" ? t.item.indexOf("<") === -1 ? document.getElementById(t.item) : r(t.item) : (function () { for (let e = t.list.childNodes, n = 0, r = e.length; n < r; n++) if (void 0 === e[n].data) return e[n].cloneNode(!0); }()))) throw new Error("The list needs to have at least one item on init otherwise you'll have to add a template."); n = (function (e, n) { const r = e.cloneNode(!0); r.removeAttribute("id"); for (let i = 0, o = n.length; i < o; i++) { let s = void 0; const a = n[i]; if (a.data) for (let l = 0, u = a.data.length; l < u; l++)r.setAttribute(`data-${a.data[l]}`, ""); else a.attr && a.name ? (s = t.utils.getByClass(r, a.name, !0)) && s.setAttribute(a.attr, "") : (s = t.utils.getByClass(r, a, !0)) && (s.innerHTML = ""); } return r; }(n, t.valueNames)), e = function () { return n.cloneNode(!0); }; } else e = function (e) { const n = t.item(e); return r(n); }; }()); }; t.exports = function (t) { return new e(t); }; },
    "./src/utils/classes.js": function (t, e, n) { const r = n("./src/utils/index-of.js"); const i = /\s+/; function o(t) { if (!t || !t.nodeType) throw new Error("A DOM element reference is required"); this.el = t, this.list = t.classList; }Object.prototype.toString, t.exports = function (t) { return new o(t); }, o.prototype.add = function (t) { if (this.list) return this.list.add(t), this; const e = this.array(); return ~r(e, t) || e.push(t), this.el.className = e.join(" "), this; }, o.prototype.remove = function (t) { if (this.list) return this.list.remove(t), this; const e = this.array(); const n = r(e, t); return ~n && e.splice(n, 1), this.el.className = e.join(" "), this; }, o.prototype.toggle = function (t, e) { return this.list ? (void 0 !== e ? e !== this.list.toggle(t, e) && this.list.toggle(t) : this.list.toggle(t), this) : (void 0 !== e ? e ? this.add(t) : this.remove(t) : this.has(t) ? this.remove(t) : this.add(t), this); }, o.prototype.array = function () { const t = (this.el.getAttribute("class") || "").replace(/^\s+|\s+$/g, "").split(i); return t[0] === "" && t.shift(), t; }, o.prototype.has = o.prototype.contains = function (t) { return this.list ? this.list.contains(t) : !!~r(this.array(), t); }; },
    "./src/utils/events.js": function (t, e, n) { const r = window.addEventListener ? "addEventListener" : "attachEvent"; const i = window.removeEventListener ? "removeEventListener" : "detachEvent"; const o = r !== "addEventListener" ? "on" : ""; const s = n("./src/utils/to-array.js"); e.bind = function (t, e, n, i) { for (let a = 0, l = (t = s(t)).length; a < l; a++)t[a][r](o + e, n, i || !1); }, e.unbind = function (t, e, n, r) { for (let a = 0, l = (t = s(t)).length; a < l; a++)t[a][i](o + e, n, r || !1); }, e.debounce = function (t, e, n) { let r; return e ? function () { const i = this; const o = arguments; const s = function () { r = null, n || t.apply(i, o); }; const a = n && !r; clearTimeout(r), r = setTimeout(s, e), a && t.apply(i, o); } : t; }; },
    "./src/utils/extend.js": function (t) { t.exports = function (t) { for (var e, n = Array.prototype.slice.call(arguments, 1), r = 0; e = n[r]; r++) if (e) for (const i in e)t[i] = e[i]; return t; }; },
    "./src/utils/fuzzy.js": function (t) { t.exports = function (t, e, n) { const r = n.location || 0; const i = n.distance || 100; const o = n.threshold || 0.4; if (e === t) return !0; if (e.length > 32) return !1; const s = r; const a = (function () { let t; const n = {}; for (t = 0; t < e.length; t++)n[e.charAt(t)] = 0; for (t = 0; t < e.length; t++)n[e.charAt(t)] |= 1 << e.length - t - 1; return n; }()); function l(t, n) { const r = t / e.length; const o = Math.abs(s - n); return i ? r + o / i : o ? 1 : r; } let u = o; let c = t.indexOf(e, s); c != -1 && (u = Math.min(l(0, c), u), (c = t.lastIndexOf(e, s + e.length)) != -1 && (u = Math.min(l(0, c), u))); let d; let h; const p = 1 << e.length - 1; c = -1; for (var f, m = e.length + t.length, g = 0; g < e.length; g++) { for (d = 0, h = m; d < h;)l(g, s + h) <= u ? d = h : m = h, h = Math.floor((m - d) / 2 + d); m = h; let v = Math.max(1, s - h + 1); const y = Math.min(s + h, t.length) + e.length; const _ = Array(y + 2); _[y + 1] = (1 << g) - 1; for (let b = y; b >= v; b--) { const w = a[t.charAt(b - 1)]; if (_[b] = g === 0 ? (_[b + 1] << 1 | 1) & w : (_[b + 1] << 1 | 1) & w | (f[b + 1] | f[b]) << 1 | 1 | f[b + 1], _[b] & p) { const x = l(g, b - 1); if (x <= u) { if (u = x, !((c = b - 1) > s)) break; v = Math.max(1, 2 * s - c); } } } if (l(g + 1, s) > u) break; f = _; } return !(c < 0); }; },
    "./src/utils/get-attribute.js": function (t) { t.exports = function (t, e) { let n = t.getAttribute && t.getAttribute(e) || null; if (!n) for (let r = t.attributes, i = r.length, o = 0; o < i; o++) void 0 !== r[o] && r[o].nodeName === e && (n = r[o].nodeValue); return n; }; },
    "./src/utils/get-by-class.js": function (t) { t.exports = function (t, e, n, r) { return (r = r || {}).test && r.getElementsByClassName || !r.test && document.getElementsByClassName ? (function (t, e, n) { return n ? t.getElementsByClassName(e)[0] : t.getElementsByClassName(e); }(t, e, n)) : r.test && r.querySelector || !r.test && document.querySelector ? (function (t, e, n) { return e = `.${e}`, n ? t.querySelector(e) : t.querySelectorAll(e); }(t, e, n)) : (function (t, e, n) { for (var r = [], i = t.getElementsByTagName("*"), o = i.length, s = new RegExp(`(^|\\s)${e}(\\s|$)`), a = 0, l = 0; a < o; a++) if (s.test(i[a].className)) { if (n) return i[a]; r[l] = i[a], l++; } return r; }(t, e, n)); }; },
    "./src/utils/index-of.js": function (t) { const e = [].indexOf; t.exports = function (t, n) { if (e) return t.indexOf(n); for (let r = 0, i = t.length; r < i; ++r) if (t[r] === n) return r; return -1; }; },
    "./src/utils/to-array.js": function (t) { t.exports = function (t) { if (void 0 === t) return []; if (t === null) return [null]; if (t === window) return [window]; if (typeof t === "string") return [t]; if (function (t) { return Object.prototype.toString.call(t) === "[object Array]"; }(t)) return t; if (typeof t.length !== "number") return [t]; if (typeof t === "function" && t instanceof Function) return [t]; for (var e = [], n = 0, r = t.length; n < r; n++)(Object.prototype.hasOwnProperty.call(t, n) || n in t) && e.push(t[n]); return e.length ? e : []; }; },
    "./src/utils/to-string.js": function (t) { t.exports = function (t) { return (t = (t = void 0 === t ? "" : t) === null ? "" : t).toString(); }; },
    "./node_modules/string-natural-compare/natural-compare.js": function (t) {
      let e; let n; let r = 0; function i(t) { return t >= 48 && t <= 57; } function o(t, e) { for (var o = (t += "").length, s = (e += "").length, a = 0, l = 0; a < o && l < s;) { let u = t.charCodeAt(a); let c = e.charCodeAt(l); if (i(u)) { if (!i(c)) return u - c; for (var d = a, h = l; u === 48 && ++d < o;)u = t.charCodeAt(d); for (;c === 48 && ++h < s;)c = e.charCodeAt(h); for (var p = d, f = h; p < o && i(t.charCodeAt(p));)++p; for (;f < s && i(e.charCodeAt(f));)++f; let m = p - d - f + h; if (m) return m; for (;d < p;) if (m = t.charCodeAt(d++) - e.charCodeAt(h++)) return m; a = p, l = f; } else { if (u !== c) return u < r && c < r && n[u] !== -1 && n[c] !== -1 ? n[u] - n[c] : u - c; ++a, ++l; } } return a >= o && l < s && o >= s ? -1 : l >= s && a < o && s >= o ? 1 : o - s; }o.caseInsensitive = o.i = function (t, e) { return o((`${t}`).toLowerCase(), (`${e}`).toLowerCase()); }, Object.defineProperties(o, { alphabet: { get() { return e; }, set(t) { n = []; let i = 0; if (e = t) for (;i < e.length; i++)n[e.charCodeAt(i)] = i; for (r = n.length, i = 0; i < r; i++) void 0 === n[i] && (n[i] = -1); } } }), t.exports = o;
    },
  }; const e = {}; return (function n(r) { if (e[r]) return e[r].exports; const i = e[r] = { exports: {} }; return t[r](i, i.exports, n), i.exports; }("./src/index.js"));
}()); const _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {}; const Prism = (function () {
  const t = /\blang(?:uage)?-(\w+)\b/i; let e = 0; var n = _self.Prism = {
    manual: _self.Prism && _self.Prism.manual,
    disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
    util: {
      encode(t) { return t instanceof r ? new r(t.type, n.util.encode(t.content), t.alias) : n.util.type(t) === "Array" ? t.map(n.util.encode) : t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " "); }, type(t) { return Object.prototype.toString.call(t).match(/\[object (\w+)\]/)[1]; }, objId(t) { return t.__id || Object.defineProperty(t, "__id", { value: ++e }), t.__id; }, clone(t, e) { const r = n.util.type(t); switch (e = e || {}, r) { case "Object": if (e[n.util.objId(t)]) return e[n.util.objId(t)]; var i = {}; for (const o in e[n.util.objId(t)] = i, t)t.hasOwnProperty(o) && (i[o] = n.util.clone(t[o], e)); return i; case "Array": if (e[n.util.objId(t)]) return e[n.util.objId(t)]; i = []; return e[n.util.objId(t)] = i, t.forEach(((t, r) => { i[r] = n.util.clone(t, e); })), i; } return t; },
    },
    languages: { extend(t, e) { const r = n.util.clone(n.languages[t]); for (const i in e)r[i] = e[i]; return r; }, insertBefore(t, e, r, i) { const o = (i = i || n.languages)[t]; if (arguments.length == 2) { for (var s in r = arguments[1])r.hasOwnProperty(s) && (o[s] = r[s]); return o; } const a = {}; for (const l in o) if (o.hasOwnProperty(l)) { if (l == e) for (var s in r)r.hasOwnProperty(s) && (a[s] = r[s]); a[l] = o[l]; } return n.languages.DFS(n.languages, (function (e, n) { n === i[t] && e != t && (this[e] = a); })), i[t] = a; }, DFS(t, e, r, i) { for (const o in i = i || {}, t)t.hasOwnProperty(o) && (e.call(t, o, t[o], r || o), n.util.type(t[o]) !== "Object" || i[n.util.objId(t[o])] ? n.util.type(t[o]) !== "Array" || i[n.util.objId(t[o])] || (i[n.util.objId(t[o])] = !0, n.languages.DFS(t[o], e, o, i)) : (i[n.util.objId(t[o])] = !0, n.languages.DFS(t[o], e, null, i))); } },
    plugins: {},
    highlightAll(t, e) { n.highlightAllUnder(document, t, e); },
    highlightAllUnder(t, e, r) { const i = { callback: r, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; n.hooks.run("before-highlightall", i); for (var o, s = i.elements || t.querySelectorAll(i.selector), a = 0; o = s[a++];)n.highlightElement(o, !0 === e, i.callback); },
    highlightElement(e, r, i) {
      for (var o, s, a = e; a && !t.test(a.className);)a = a.parentNode; a && (o = (a.className.match(t) || [, ""])[1].toLowerCase(), s = n.languages[o]), e.className = `${e.className.replace(t, "").replace(/\s+/g, " ")} language-${o}`, e.parentNode && (a = e.parentNode, /pre/i.test(a.nodeName) && (a.className = `${a.className.replace(t, "").replace(/\s+/g, " ")} language-${o}`)); const l = {
        element: e, language: o, grammar: s, code: e.textContent,
      }; if (n.hooks.run("before-sanity-check", l), !l.code || !l.grammar) return l.code && (n.hooks.run("before-highlight", l), l.element.textContent = l.code, n.hooks.run("after-highlight", l)), void n.hooks.run("complete", l); if (n.hooks.run("before-highlight", l), r && _self.Worker) { const u = new Worker(n.filename); u.onmessage = function (t) { l.highlightedCode = t.data, n.hooks.run("before-insert", l), l.element.innerHTML = l.highlightedCode, i && i.call(l.element), n.hooks.run("after-highlight", l), n.hooks.run("complete", l); }, u.postMessage(JSON.stringify({ language: l.language, code: l.code, immediateClose: !0 })); } else l.highlightedCode = n.highlight(l.code, l.grammar, l.language), n.hooks.run("before-insert", l), l.element.innerHTML = l.highlightedCode, i && i.call(e), n.hooks.run("after-highlight", l), n.hooks.run("complete", l);
    },
    highlight(t, e, i) { const o = { code: t, grammar: e, language: i }; return n.hooks.run("before-tokenize", o), o.tokens = n.tokenize(o.code, o.grammar), n.hooks.run("after-tokenize", o), r.stringify(n.util.encode(o.tokens), o.language); },
    matchGrammar(t, e, r, i, o, s, a) { const l = n.Token; for (const u in r) if (r.hasOwnProperty(u) && r[u]) { if (u == a) return; let c = r[u]; c = n.util.type(c) === "Array" ? c : [c]; for (let d = 0; d < c.length; ++d) { let h = c[d]; const p = h.inside; const f = !!h.lookbehind; const m = !!h.greedy; let g = 0; const v = h.alias; if (m && !h.pattern.global) { const y = h.pattern.toString().match(/[imuy]*$/)[0]; h.pattern = RegExp(h.pattern.source, `${y}g`); }h = h.pattern || h; for (let _ = i, b = o; _ < e.length; b += e[_].length, ++_) { let w = e[_]; if (e.length > t.length) return; if (!(w instanceof l)) { if (m && _ != e.length - 1) { if (h.lastIndex = b, !(T = h.exec(t))) break; for (var x = T.index + (f ? T[1].length : 0), S = T.index + T[0].length, k = _, C = b, E = e.length; E > k && (S > C || !e[k].type && !e[k - 1].greedy); ++k)x >= (C += e[k].length) && (++_, b = C); if (e[_] instanceof l) continue; P = k - _, w = t.slice(b, C), T.index -= b; } else { h.lastIndex = 0; var T = h.exec(w); var P = 1; } if (T) { f && (g = T[1] ? T[1].length : 0); S = (x = T.index + g) + (T = T[0].slice(g)).length; const O = w.slice(0, x); const A = w.slice(S); const M = [_, P]; O && (++_, b += O.length, M.push(O)); const L = new l(u, p ? n.tokenize(T, p) : T, v, T, m); if (M.push(L), A && M.push(A), Array.prototype.splice.apply(e, M), P != 1 && n.matchGrammar(t, e, r, _, b, !0, u), s) break; } else if (s) break; } } } } },
    tokenize(t, e) { const r = [t]; const i = e.rest; if (i) { for (const o in i)e[o] = i[o]; delete e.rest; } return n.matchGrammar(t, r, e, 0, 0, !1), r; },
    hooks: { all: {}, add(t, e) { const r = n.hooks.all; r[t] = r[t] || [], r[t].push(e); }, run(t, e) { const r = n.hooks.all[t]; if (r && r.length) for (var i, o = 0; i = r[o++];)i(e); } },
  }; var r = n.Token = function (t, e, n, r, i) { this.type = t, this.content = e, this.alias = n, this.length = 0 | (r || "").length, this.greedy = !!i; }; if (r.stringify = function (t, e, i) {
    if (typeof t === "string") return t; if (n.util.type(t) === "Array") return t.map(((n) => r.stringify(n, e, t))).join(""); const o = {
      type: t.type, content: r.stringify(t.content, e, i), tag: "span", classes: ["token", t.type], attributes: {}, language: e, parent: i,
    }; if (t.alias) { const s = n.util.type(t.alias) === "Array" ? t.alias : [t.alias]; Array.prototype.push.apply(o.classes, s); }n.hooks.run("wrap", o); const a = Object.keys(o.attributes).map(((t) => `${t}="${(o.attributes[t] || "").replace(/"/g, "&quot;")}"`)).join(" "); return `<${o.tag} class="${o.classes.join(" ")}"${a ? ` ${a}` : ""}>${o.content}</${o.tag}>`;
  }, !_self.document) return _self.addEventListener ? (n.disableWorkerMessageHandler || _self.addEventListener("message", ((t) => { const e = JSON.parse(t.data); const r = e.language; const i = e.code; const o = e.immediateClose; _self.postMessage(n.highlight(i, n.languages[r], r)), o && _self.close(); }), !1), _self.Prism) : _self.Prism; const i = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop(); return i && (n.filename = i.src, n.manual || i.hasAttribute("data-manual") || (document.readyState !== "loading" ? window.requestAnimationFrame ? window.requestAnimationFrame(n.highlightAll) : window.setTimeout(n.highlightAll, 16) : document.addEventListener("DOMContentLoaded", n.highlightAll))), _self.Prism;
}()); void 0 !== module && module.exports && (module.exports = Prism), typeof global !== "undefined" && (global.Prism = Prism), Prism.languages.markup = {
  comment: /<!--[\s\S]*?-->/,
  prolog: /<\?[\s\S]+?\?>/,
  doctype: /<!DOCTYPE[\s\S]+?>/i,
  cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
  tag: {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
    greedy: !0,
    inside: {
      tag: { pattern: /^<\/?[^\s>\/]+/i, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "attr-value": { pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i, inside: { punctuation: [/^=/, { pattern: /(^|[^\\])["']/, lookbehind: !0 }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } },
    },
  },
  entity: /&#?[\da-z]{1,8};/i,
}, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.hooks.add("wrap", ((t) => { t.type === "entity" && (t.attributes.title = t.content.replace(/&amp;/, "&")); })), Prism.languages.xml = Prism.languages.markup, Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.css = {
  comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i, inside: { rule: /@[\w-]+/ } }, url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i, selector: /[^{}\s][^{};]*?(?=\s*\{)/, string: { pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i, important: /\B!important\b/i, function: /[-a-z0-9]+(?=\()/i, punctuation: /[(){};:]/,
}, Prism.languages.css.atrule.inside.rest = Prism.languages.css, Prism.languages.markup && (Prism.languages.insertBefore("markup", "tag", {
  style: {
    pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i, lookbehind: !0, inside: Prism.languages.css, alias: "language-css", greedy: !0,
  },
}), Prism.languages.insertBefore("inside", "attr-value", { "style-attr": { pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i, inside: { "attr-name": { pattern: /^\s*style/i, inside: Prism.languages.markup.tag.inside }, punctuation: /^\s*=\s*['"]|['"]\s*$/, "attr-value": { pattern: /.+/i, inside: Prism.languages.css } }, alias: "language-css" } }, Prism.languages.markup.tag)), Prism.languages.clike = {
  comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /[a-z0-9_]+(?=\()/i, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/,
}, Prism.languages.javascript = Prism.languages.extend("clike", {
  keyword: /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/, number: /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/, function: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/,
}), Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^\/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/, lookbehind: !0, greedy: !0 }, "function-variable": { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i, alias: "function" }, constant: /\b[A-Z][A-Z\d_]*\b/ }), Prism.languages.insertBefore("javascript", "string", { "template-string": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, greedy: !0, inside: { interpolation: { pattern: /\$\{[^}]+\}/, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } } }), Prism.languages.markup && Prism.languages.insertBefore("markup", "tag", {
  script: {
    pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i, lookbehind: !0, inside: Prism.languages.javascript, alias: "language-javascript", greedy: !0,
  },
}), Prism.languages.js = Prism.languages.javascript, Prism.languages.css.selector = {
  pattern: /[^{}\s][^{}]*(?=\s*\{)/,
  inside: {
    "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+(?:\(.*\))?/, class: /\.[-:.\w]+/, id: /#[-:.\w]+/, attribute: /\[[^\]]+\]/,
  },
}, Prism.languages.insertBefore("css", "function", { hexcode: /#[\da-f]{3,8}/i, entity: /\\[\da-f]{1,8}/i, number: /[\d%.]+/ }), Prism.languages.git = {
  comment: /^#.*/m, deleted: /^[-].*/m, inserted: /^\+.*/m, string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m, command: { pattern: /^.*\$ git .*$/m, inside: { parameter: /\s--?\w+/m } }, coord: /^@@.*@@$/m, commit_sha1: /^commit \w{40}$/m,
}, Prism.languages.icon = {
  comment: /#.*/, string: { pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/, greedy: !0 }, number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i, "builtin-keyword": { pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/, alias: "variable" }, directive: { pattern: /\$\w+/, alias: "builtin" }, keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/, function: /(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/, operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/, punctuation: /[\[\](){},;]/,
}, Prism.languages.json = {
  property: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i, string: { pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, greedy: !0 }, number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/, punctuation: /[{}[\]);,]/, operator: /:/g, boolean: /\b(?:true|false)\b/i, null: /\bnull\b/i,
}, Prism.languages.jsonp = Prism.languages.json, (function (t) {
  t.languages.sass = t.languages.extend("css", { comment: { pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m, lookbehind: !0 } }), t.languages.insertBefore("sass", "atrule", { "atrule-line": { pattern: /^(?:[ \t]*)[@+=].+/m, inside: { atrule: /(?:@[\w-]+|[+=])/m } } }), delete t.languages.sass.atrule; const e = /\$[-\w]+|#\{\$[-\w]+\}/; const n = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/, { pattern: /(\s+)-(?=\s)/, lookbehind: !0 }]; t.languages.insertBefore("sass", "property", {
    "variable-line": { pattern: /^[ \t]*\$.+/m, inside: { punctuation: /:/, variable: e, operator: n } },
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,
      inside: {
        property: [/[^:\s]+(?=\s*:)/, { pattern: /(:)[^:\s]+/, lookbehind: !0 }], punctuation: /:/, variable: e, operator: n, important: t.languages.sass.important,
      },
    },
  }), delete t.languages.sass.property, delete t.languages.sass.important, delete t.languages.sass.selector, t.languages.insertBefore("sass", "punctuation", { selector: { pattern: /([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/, lookbehind: !0 } });
}(Prism)), Prism.languages.scss = Prism.languages.extend("css", {
  comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/, lookbehind: !0 }, atrule: { pattern: /@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/, inside: { rule: /@[\w-]+/ } }, url: /(?:[-a-z]+-)*url(?=\()/i, selector: { pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()]|&|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m, inside: { parent: { pattern: /&/, alias: "important" }, placeholder: /%[-\w]+/, variable: /\$[-\w]+|#\{\$[-\w]+\}/ } },
}), Prism.languages.insertBefore("scss", "atrule", { keyword: [/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i, { pattern: /( +)(?:from|through)(?= )/, lookbehind: !0 }] }), Prism.languages.scss.property = { pattern: /(?:[\w-]|\$[-\w]+|#\{\$[-\w]+\})+(?=\s*:)/i, inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ } }, Prism.languages.insertBefore("scss", "important", { variable: /\$[-\w]+|#\{\$[-\w]+\}/ }), Prism.languages.insertBefore("scss", "function", {
  placeholder: { pattern: /%[-\w]+/, alias: "selector" }, statement: { pattern: /\B!(?:default|optional)\b/i, alias: "keyword" }, boolean: /\b(?:true|false)\b/, null: /\bnull\b/, operator: { pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/, lookbehind: !0 },
}), Prism.languages.scss.atrule.inside.rest = Prism.languages.scss, (function () { if (typeof self !== "undefined" && self.Prism && self.document) { let t = []; const e = {}; const n = function () {}; Prism.plugins.toolbar = {}; const r = Prism.plugins.toolbar.registerButton = function (n, r) { let i; i = typeof r === "function" ? r : function (t) { let e; return typeof r.onClick === "function" ? ((e = document.createElement("button")).type = "button", e.addEventListener("click", (function () { r.onClick.call(this, t); }))) : typeof r.url === "string" ? (e = document.createElement("a")).href = r.url : e = document.createElement("span"), e.textContent = r.text, e; }, t.push(e[n] = i); }; const i = Prism.plugins.toolbar.hook = function (r) { const i = r.element.parentNode; if (i && /pre/i.test(i.nodeName) && !i.parentNode.classList.contains("code-toolbar")) { const o = document.createElement("div"); o.classList.add("code-toolbar"), i.parentNode.insertBefore(o, i), o.appendChild(i); const s = document.createElement("div"); s.classList.add("toolbar"), document.body.hasAttribute("data-toolbar-order") && (t = document.body.getAttribute("data-toolbar-order").split(",").map(((t) => e[t] || n))), t.forEach(((t) => { const e = t(r); if (e) { const n = document.createElement("div"); n.classList.add("toolbar-item"), n.appendChild(e), s.appendChild(n); } })), o.appendChild(s); } }; r("label", ((t) => { const e = t.element.parentNode; if (e && /pre/i.test(e.nodeName) && e.hasAttribute("data-label")) { let n; let r; const i = e.getAttribute("data-label"); try { r = document.querySelector(`template#${i}`); } catch (t) {} return r ? n = r.content : (e.hasAttribute("data-url") ? (n = document.createElement("a")).href = e.getAttribute("data-url") : n = document.createElement("span"), n.textContent = i), n; } })), Prism.hooks.add("complete", i); } }()), (function () {
  function t(t) { this.defaults = { ...t }; } function e(t) { return t.replace(/-(\w)/g, ((t, e) => e.toUpperCase())); } function n(t) { for (var e = 0, n = 0; n < t.length; ++n)t.charCodeAt(n) == "\t".charCodeAt(0) && (e += 3); return t.length + e; } const r = Object.assign || function (t, e) { for (const n in e)e.hasOwnProperty(n) && (t[n] = e[n]); return t; }; t.prototype = {
    setDefaults(t) { this.defaults = r(this.defaults, t); }, normalize(t, n) { for (const i in n = r(this.defaults, n)) { const o = e(i); i !== "normalize" && o !== "setDefaults" && n[i] && this[o] && (t = this[o].call(this, t, n[i])); } return t; }, leftTrim(t) { return t.replace(/^\s+/, ""); }, rightTrim(t) { return t.replace(/\s+$/, ""); }, tabsToSpaces(t, e) { return e = 0 | e || 4, t.replace(/\t/g, new Array(++e).join(" ")); }, spacesToTabs(t, e) { return e = 0 | e || 4, t.replace(new RegExp(` {${e}}`, "g"), "\t"); }, removeTrailing(t) { return t.replace(/\s*?$/gm, ""); }, removeInitialLineFeed(t) { return t.replace(/^(?:\r?\n|\r)/, ""); }, removeIndent(t) { const e = t.match(/^[^\S\n\r]*(?=\S)/gm); return e && e[0].length ? (e.sort(((t, e) => t.length - e.length)), e[0].length ? t.replace(new RegExp(`^${e[0]}`, "gm"), "") : t) : t; }, indent(t, e) { return t.replace(/^[^\S\n\r]*(?=\S)/gm, `${new Array(++e).join("\t")}$&`); }, breakLines(t, e) { e = !0 === e ? 80 : 0 | e || 80; for (var r = t.split("\n"), i = 0; i < r.length; ++i) if (!(n(r[i]) <= e)) { for (var o = r[i].split(/(\s+)/g), s = 0, a = 0; a < o.length; ++a) { const l = n(o[a]); (s += l) > e && (o[a] = `\n${o[a]}`, s = l); }r[i] = o.join(""); } return r.join("\n"); },
  }, void 0 !== module && module.exports && (module.exports = t), void 0 !== Prism && (Prism.plugins.NormalizeWhitespace = new t({
    "remove-trailing": !0, "remove-indent": !0, "left-trim": !0, "right-trim": !0,
  }), Prism.hooks.add("before-sanity-check", ((t) => { const e = Prism.plugins.NormalizeWhitespace; if (!t.settings || !1 !== t.settings["whitespace-normalization"]) { if ((!t.element || !t.element.parentNode) && t.code) return void (t.code = e.normalize(t.code, t.settings)); const n = t.element.parentNode; const r = /\bno-whitespace-normalization\b/; if (t.code && n && n.nodeName.toLowerCase() === "pre" && !r.test(n.className) && !r.test(t.element.className)) { for (var i = n.childNodes, o = "", s = "", a = !1, l = 0; l < i.length; ++l) { const u = i[l]; u == t.element ? a = !0 : u.nodeName === "#text" && (a ? s += u.nodeValue : o += u.nodeValue, n.removeChild(u), --l); } if (t.element.children.length && Prism.plugins.KeepMarkup) { const c = o + t.element.innerHTML + s; t.element.innerHTML = e.normalize(c, t.settings), t.code = t.element.textContent; } else t.code = o + t.code + s, t.code = e.normalize(t.code, t.settings); } } })));
}()), (function () { if (typeof self !== "undefined" && self.Prism && self.document) { if (!Prism.plugins.toolbar) return void console.warn("Copy to Clipboard plugin loaded before Toolbar plugin."); let t = window.ClipboardJS || void 0; t || typeof require !== "function" || (t = require("clipboard")); const e = []; if (!t) { const n = document.createElement("script"); const r = document.querySelector("head"); n.onload = function () { if (t = window.ClipboardJS) for (;e.length;)e.pop()(); }, n.src = "https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js", r.appendChild(n); }Prism.plugins.toolbar.registerButton("copy-to-clipboard", ((n) => { function r() { const e = new t(o, { text() { return n.code; } }); e.on("success", (() => { o.textContent = "Copied!", i(); })), e.on("error", (() => { o.textContent = "Press Ctrl+C to copy", i(); })); } function i() { setTimeout((() => { o.textContent = "Copy"; }), 5e3); } var o = document.createElement("a"); return o.textContent = "Copy", t ? r() : e.push(r), o; })); } }()), (function (t) { typeof define === "function" && define.amd ? define([], t) : typeof exports === "object" ? module.exports = t() : window.wNumb = t(); }((() => {
  const t = ["decimals", "thousand", "mark", "prefix", "suffix", "encoder", "decoder", "negativeBefore", "negative", "edit", "undo"]; function e(t) { return t.split("").reverse().join(""); } function n(t, e) { return t.substring(0, e.length) === e; } function r(t, e, n) { if ((t[e] || t[n]) && t[e] === t[n]) throw new Error(e); } function i(t) { return typeof t === "number" && isFinite(t); } function o(t, n, r, o, s, a, l, u, c, d, h, p) { let f; let m; let g; const v = p; let y = ""; let _ = ""; return a && (p = a(p)), !!i(p) && (!1 !== t && parseFloat(p.toFixed(t)) === 0 && (p = 0), p < 0 && (f = !0, p = Math.abs(p)), !1 !== t && (p = (function (t, e) { return t = t.toString().split("e"), (+(`${(t = (t = Math.round(+(`${t[0]}e${t[1] ? +t[1] + e : e}`))).toString().split("e"))[0]}e${t[1] ? t[1] - e : -e}`)).toFixed(e); }(p, t))), (p = p.toString()).indexOf(".") !== -1 ? (g = (m = p.split("."))[0], r && (y = r + m[1])) : g = p, n && (g = e((g = e(g).match(/.{1,3}/g)).join(e(n)))), f && u && (_ += u), o && (_ += o), f && c && (_ += c), _ += g, _ += y, s && (_ += s), d && (_ = d(_, v)), _); } function s(t, e, r, o, s, a, l, u, c, d, h, p) { let f; let m = ""; return h && (p = h(p)), !(!p || typeof p !== "string") && (u && n(p, u) && (p = p.replace(u, ""), f = !0), o && n(p, o) && (p = p.replace(o, "")), c && n(p, c) && (p = p.replace(c, ""), f = !0), s && (function (t, e) { return t.slice(-1 * e.length) === e; }(p, s)) && (p = p.slice(0, -1 * s.length)), e && (p = p.split(e).join("")), r && (p = p.replace(r, ".")), f && (m += "-"), (m = (m += p).replace(/[^0-9\.\-.]/g, "")) !== "" && (m = Number(m), l && (m = l(m)), !!i(m) && m)); } function a(e, n, r) { let i; const o = []; for (i = 0; i < t.length; i += 1)o.push(e[t[i]]); return o.push(r), n.apply("", o); } return function e(n) { if (!(this instanceof e)) return new e(n); typeof n === "object" && (n = (function (e) { let n; let i; let o; const s = {}; for (void 0 === e.suffix && (e.suffix = e.postfix), n = 0; n < t.length; n += 1) if (void 0 === (o = e[i = t[n]]))i !== "negative" || s.negativeBefore ? i === "mark" && s.thousand !== "." ? s[i] = "." : s[i] = !1 : s[i] = "-"; else if (i === "decimals") { if (!(o >= 0 && o < 8)) throw new Error(i); s[i] = o; } else if (i === "encoder" || i === "decoder" || i === "edit" || i === "undo") { if (typeof o !== "function") throw new Error(i); s[i] = o; } else { if (typeof o !== "string") throw new Error(i); s[i] = o; } return r(s, "mark", "thousand"), r(s, "prefix", "negative"), r(s, "prefix", "negativeBefore"), s; }(n)), this.to = function (t) { return a(n, o, t); }, this.from = function (t) { return a(n, s, t); }); };
})));
